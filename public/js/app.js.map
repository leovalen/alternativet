{"version":3,"names":[],"mappings":"","sources":["app.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],2:[function(require,module,exports){\n/*\n * Copyright 2012-2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define, location) {\n\t'use strict';\n\n\tvar undef;\n\n\tdefine(function (require) {\n\n\t\tvar mixin, origin, urlRE, absoluteUrlRE, fullyQualifiedUrlRE;\n\n\t\tmixin = require('./util/mixin');\n\n\t\turlRE = /([a-z][a-z0-9\\+\\-\\.]*:)\\/\\/([^@]+@)?(([^:\\/]+)(:([0-9]+))?)?(\\/[^?#]*)?(\\?[^#]*)?(#\\S*)?/i;\n\t\tabsoluteUrlRE = /^([a-z][a-z0-9\\-\\+\\.]*:\\/\\/|\\/)/i;\n\t\tfullyQualifiedUrlRE = /([a-z][a-z0-9\\+\\-\\.]*:)\\/\\/([^@]+@)?(([^:\\/]+)(:([0-9]+))?)?\\//i;\n\n\t\t/**\n\t\t * Apply params to the template to create a URL.\n\t\t *\n\t\t * Parameters that are not applied directly to the template, are appended\n\t\t * to the URL as query string parameters.\n\t\t *\n\t\t * @param {string} template the URI template\n\t\t * @param {Object} params parameters to apply to the template\n\t\t * @return {string} the resulting URL\n\t\t */\n\t\tfunction buildUrl(template, params) {\n\t\t\t// internal builder to convert template with params.\n\t\t\tvar url, name, queryStringParams, re;\n\n\t\t\turl = template;\n\t\t\tqueryStringParams = {};\n\n\t\t\tif (params) {\n\t\t\t\tfor (name in params) {\n\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\tre = new RegExp('\\\\{' + name + '\\\\}');\n\t\t\t\t\tif (re.test(url)) {\n\t\t\t\t\t\turl = url.replace(re, encodeURIComponent(params[name]), 'g');\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tqueryStringParams[name] = params[name];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (name in queryStringParams) {\n\t\t\t\t\turl += url.indexOf('?') === -1 ? '?' : '&';\n\t\t\t\t\turl += encodeURIComponent(name);\n\t\t\t\t\tif (queryStringParams[name] !== null && queryStringParams[name] !== undefined) {\n\t\t\t\t\t\turl += '=';\n\t\t\t\t\t\turl += encodeURIComponent(queryStringParams[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn url;\n\t\t}\n\n\t\tfunction startsWith(str, test) {\n\t\t\treturn str.indexOf(test) === 0;\n\t\t}\n\n\t\t/**\n\t\t * Create a new URL Builder\n\t\t *\n\t\t * @param {string|UrlBuilder} template the base template to build from, may be another UrlBuilder\n\t\t * @param {Object} [params] base parameters\n\t\t * @constructor\n\t\t */\n\t\tfunction UrlBuilder(template, params) {\n\t\t\tif (!(this instanceof UrlBuilder)) {\n\t\t\t\t// invoke as a constructor\n\t\t\t\treturn new UrlBuilder(template, params);\n\t\t\t}\n\n\t\t\tif (template instanceof UrlBuilder) {\n\t\t\t\tthis._template = template.template;\n\t\t\t\tthis._params = mixin({}, this._params, params);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._template = (template || '').toString();\n\t\t\t\tthis._params = params || {};\n\t\t\t}\n\t\t}\n\n\t\tUrlBuilder.prototype = {\n\n\t\t\t/**\n\t\t\t * Create a new UrlBuilder instance that extends the current builder.\n\t\t\t * The current builder is unmodified.\n\t\t\t *\n\t\t\t * @param {string} [template] URL template to append to the current template\n\t\t\t * @param {Object} [params] params to combine with current params.  New params override existing params\n\t\t\t * @return {UrlBuilder} the new builder\n\t\t\t */\n\t\t\tappend: function (template,  params) {\n\t\t\t\t// TODO consider query strings and fragments\n\t\t\t\treturn new UrlBuilder(this._template + template, mixin({}, this._params, params));\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Create a new UrlBuilder with a fully qualified URL based on the\n\t\t\t * window's location or base href and the current templates relative URL.\n\t\t\t *\n\t\t\t * Path variables are preserved.\n\t\t\t *\n\t\t\t * *Browser only*\n\t\t\t *\n\t\t\t * @return {UrlBuilder} the fully qualified URL template\n\t\t\t */\n\t\t\tfullyQualify: function () {\n\t\t\t\tif (!location) { return this; }\n\t\t\t\tif (this.isFullyQualified()) { return this; }\n\n\t\t\t\tvar template = this._template;\n\n\t\t\t\tif (startsWith(template, '//')) {\n\t\t\t\t\ttemplate = origin.protocol + template;\n\t\t\t\t}\n\t\t\t\telse if (startsWith(template, '/')) {\n\t\t\t\t\ttemplate = origin.origin + template;\n\t\t\t\t}\n\t\t\t\telse if (!this.isAbsolute()) {\n\t\t\t\t\ttemplate = origin.origin + origin.pathname.substring(0, origin.pathname.lastIndexOf('/') + 1);\n\t\t\t\t}\n\n\t\t\t\tif (template.indexOf('/', 8) === -1) {\n\t\t\t\t\t// default the pathname to '/'\n\t\t\t\t\ttemplate = template + '/';\n\t\t\t\t}\n\n\t\t\t\treturn new UrlBuilder(template, this._params);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * True if the URL is absolute\n\t\t\t *\n\t\t\t * @return {boolean}\n\t\t\t */\n\t\t\tisAbsolute: function () {\n\t\t\t\treturn absoluteUrlRE.test(this.build());\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * True if the URL is fully qualified\n\t\t\t *\n\t\t\t * @return {boolean}\n\t\t\t */\n\t\t\tisFullyQualified: function () {\n\t\t\t\treturn fullyQualifiedUrlRE.test(this.build());\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * True if the URL is cross origin. The protocol, host and port must not be\n\t\t\t * the same in order to be cross origin,\n\t\t\t *\n\t\t\t * @return {boolean}\n\t\t\t */\n\t\t\tisCrossOrigin: function () {\n\t\t\t\tif (!origin) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar url = this.parts();\n\t\t\t\treturn url.protocol !== origin.protocol ||\n\t\t\t\t       url.hostname !== origin.hostname ||\n\t\t\t\t       url.port !== origin.port;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Split a URL into its consituent parts following the naming convention of\n\t\t\t * 'window.location'. One difference is that the port will contain the\n\t\t\t * protocol default if not specified.\n\t\t\t *\n\t\t\t * @see https://developer.mozilla.org/en-US/docs/DOM/window.location\n\t\t\t *\n\t\t\t * @returns {Object} a 'window.location'-like object\n\t\t\t */\n\t\t\tparts: function () {\n\t\t\t\t/*jshint maxcomplexity:20 */\n\t\t\t\tvar url, parts;\n\t\t\t\turl = this.fullyQualify().build().match(urlRE);\n\t\t\t\tparts = {\n\t\t\t\t\thref: url[0],\n\t\t\t\t\tprotocol: url[1],\n\t\t\t\t\thost: url[3] || '',\n\t\t\t\t\thostname: url[4] || '',\n\t\t\t\t\tport: url[6],\n\t\t\t\t\tpathname: url[7] || '',\n\t\t\t\t\tsearch: url[8] || '',\n\t\t\t\t\thash: url[9] || ''\n\t\t\t\t};\n\t\t\t\tparts.origin = parts.protocol + '//' + parts.host;\n\t\t\t\tparts.port = parts.port || (parts.protocol === 'https:' ? '443' : parts.protocol === 'http:' ? '80' : '');\n\t\t\t\treturn parts;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Expand the template replacing path variables with parameters\n\t\t\t *\n\t\t\t * @param {Object} [params] params to combine with current params.  New params override existing params\n\t\t\t * @return {string} the expanded URL\n\t\t\t */\n\t\t\tbuild: function (params) {\n\t\t\t\treturn buildUrl(this._template, mixin({}, this._params, params));\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @see build\n\t\t\t */\n\t\t\ttoString: function () {\n\t\t\t\treturn this.build();\n\t\t\t}\n\n\t\t};\n\n\t\torigin = location ? new UrlBuilder(location.href).parts() : undef;\n\n\t\treturn UrlBuilder;\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); },\n\ttypeof window !== 'undefined' ? window.location : void 0\n\t// Boilerplate for AMD and Node\n));\n\n},{\"./util/mixin\":22}],3:[function(require,module,exports){\n/*\n * Copyright 2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar rest = require('./client/default'),\n\t\t    browser = require('./client/xhr');\n\n\t\trest.setPlatformDefaultClient(browser);\n\n\t\treturn rest;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"./client/default\":5,\"./client/xhr\":6}],4:[function(require,module,exports){\n/*\n * Copyright 2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\t/**\n\t\t * Add common helper methods to a client impl\n\t\t *\n\t\t * @param {function} impl the client implementation\n\t\t * @param {Client} [target] target of this client, used when wrapping other clients\n\t\t * @returns {Client} the client impl with additional methods\n\t\t */\n\t\treturn function client(impl, target) {\n\n\t\t\tif (target) {\n\n\t\t\t\t/**\n\t\t\t\t * @returns {Client} the target client\n\t\t\t\t */\n\t\t\t\timpl.skip = function skip() {\n\t\t\t\t\treturn target;\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Allow a client to easily be wrapped by an interceptor\n\t\t\t *\n\t\t\t * @param {Interceptor} interceptor the interceptor to wrap this client with\n\t\t\t * @param [config] configuration for the interceptor\n\t\t\t * @returns {Client} the newly wrapped client\n\t\t\t */\n\t\t\timpl.wrap = function wrap(interceptor, config) {\n\t\t\t\treturn interceptor(impl, config);\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * @deprecated\n\t\t\t */\n\t\t\timpl.chain = function chain() {\n\t\t\t\tif (typeof console !== 'undefined') {\n\t\t\t\t\tconsole.log('rest.js: client.chain() is deprecated, use client.wrap() instead');\n\t\t\t\t}\n\n\t\t\t\treturn impl.wrap.apply(this, arguments);\n\t\t\t};\n\n\t\t\treturn impl;\n\n\t\t};\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],5:[function(require,module,exports){\n/*\n * Copyright 2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tvar undef;\n\n\tdefine(function (require) {\n\n\t\t/**\n\t\t * Plain JS Object containing properties that represent an HTTP request.\n\t\t *\n\t\t * Depending on the capabilities of the underlying client, a request\n\t\t * may be cancelable. If a request may be canceled, the client will add\n\t\t * a canceled flag and cancel function to the request object. Canceling\n\t\t * the request will put the response into an error state.\n\t\t *\n\t\t * @field {string} [method='GET'] HTTP method, commonly GET, POST, PUT, DELETE or HEAD\n\t\t * @field {string|UrlBuilder} [path=''] path template with optional path variables\n\t\t * @field {Object} [params] parameters for the path template and query string\n\t\t * @field {Object} [headers] custom HTTP headers to send, in addition to the clients default headers\n\t\t * @field [entity] the HTTP entity, common for POST or PUT requests\n\t\t * @field {boolean} [canceled] true if the request has been canceled, set by the client\n\t\t * @field {Function} [cancel] cancels the request if invoked, provided by the client\n\t\t * @field {Client} [originator] the client that first handled this request, provided by the interceptor\n\t\t *\n\t\t * @class Request\n\t\t */\n\n\t\t/**\n\t\t * Plain JS Object containing properties that represent an HTTP response\n\t\t *\n\t\t * @field {Object} [request] the request object as received by the root client\n\t\t * @field {Object} [raw] the underlying request object, like XmlHttpRequest in a browser\n\t\t * @field {number} [status.code] status code of the response (i.e. 200, 404)\n\t\t * @field {string} [status.text] status phrase of the response\n\t\t * @field {Object] [headers] response headers hash of normalized name, value pairs\n\t\t * @field [entity] the response body\n\t\t *\n\t\t * @class Response\n\t\t */\n\n\t\t/**\n\t\t * HTTP client particularly suited for RESTful operations.\n\t\t *\n\t\t * @field {function} wrap wraps this client with a new interceptor returning the wrapped client\n\t\t *\n\t\t * @param {Request} the HTTP request\n\t\t * @returns {ResponsePromise<Response>} a promise the resolves to the HTTP response\n\t\t *\n\t\t * @class Client\n\t\t */\n\n\t\t /**\n\t\t  * Extended when.js Promises/A+ promise with HTTP specific helpers\n\t\t  *q\n\t\t  * @method entity promise for the HTTP entity\n\t\t  * @method status promise for the HTTP status code\n\t\t  * @method headers promise for the HTTP response headers\n\t\t  * @method header promise for a specific HTTP response header\n\t\t  *\n\t\t  * @class ResponsePromise\n\t\t  * @extends Promise\n\t\t  */\n\n\t\tvar client, target, platformDefault;\n\n\t\tclient = require('../client');\n\n\t\t/**\n\t\t * Make a request with the default client\n\t\t * @param {Request} the HTTP request\n\t\t * @returns {Promise<Response>} a promise the resolves to the HTTP response\n\t\t */\n\t\tfunction defaultClient() {\n\t\t\treturn target.apply(undef, arguments);\n\t\t}\n\n\t\t/**\n\t\t * Change the default client\n\t\t * @param {Client} client the new default client\n\t\t */\n\t\tdefaultClient.setDefaultClient = function setDefaultClient(client) {\n\t\t\ttarget = client;\n\t\t};\n\n\t\t/**\n\t\t * Obtain a direct reference to the current default client\n\t\t * @returns {Client} the default client\n\t\t */\n\t\tdefaultClient.getDefaultClient = function getDefaultClient() {\n\t\t\treturn target;\n\t\t};\n\n\t\t/**\n\t\t * Reset the default client to the platform default\n\t\t */\n\t\tdefaultClient.resetDefaultClient = function resetDefaultClient() {\n\t\t\ttarget = platformDefault;\n\t\t};\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tdefaultClient.setPlatformDefaultClient = function setPlatformDefaultClient(client) {\n\t\t\tif (platformDefault) {\n\t\t\t\tthrow new Error('Unable to redefine platformDefaultClient');\n\t\t\t}\n\t\t\ttarget = platformDefault = client;\n\t\t};\n\n\t\treturn client(defaultClient);\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../client\":4}],6:[function(require,module,exports){\n/*\n * Copyright 2012-2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define, global) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar when, UrlBuilder, normalizeHeaderName, responsePromise, client, headerSplitRE;\n\n\t\twhen = require('when');\n\t\tUrlBuilder = require('../UrlBuilder');\n\t\tnormalizeHeaderName = require('../util/normalizeHeaderName');\n\t\tresponsePromise = require('../util/responsePromise');\n\t\tclient = require('../client');\n\n\t\t// according to the spec, the line break is '\\r\\n', but doesn't hold true in practice\n\t\theaderSplitRE = /[\\r|\\n]+/;\n\n\t\tfunction parseHeaders(raw) {\n\t\t\t// Note: Set-Cookie will be removed by the browser\n\t\t\tvar headers = {};\n\n\t\t\tif (!raw) { return headers; }\n\n\t\t\traw.trim().split(headerSplitRE).forEach(function (header) {\n\t\t\t\tvar boundary, name, value;\n\t\t\t\tboundary = header.indexOf(':');\n\t\t\t\tname = normalizeHeaderName(header.substring(0, boundary).trim());\n\t\t\t\tvalue = header.substring(boundary + 1).trim();\n\t\t\t\tif (headers[name]) {\n\t\t\t\t\tif (Array.isArray(headers[name])) {\n\t\t\t\t\t\t// add to an existing array\n\t\t\t\t\t\theaders[name].push(value);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// convert single value to array\n\t\t\t\t\t\theaders[name] = [headers[name], value];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// new, single value\n\t\t\t\t\theaders[name] = value;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn headers;\n\t\t}\n\n\t\tfunction safeMixin(target, source) {\n\t\t\tObject.keys(source || {}).forEach(function (prop) {\n\t\t\t\t// make sure the property already exists as\n\t\t\t\t// IE 6 will blow up if we add a new prop\n\t\t\t\tif (source.hasOwnProperty(prop) && prop in target) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttarget[prop] = source[prop];\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t// ignore, expected for some properties at some points in the request lifecycle\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn target;\n\t\t}\n\n\t\treturn client(function xhr(request) {\n\t\t\treturn responsePromise.promise(function (resolve, reject) {\n\t\t\t\t/*jshint maxcomplexity:20 */\n\n\t\t\t\tvar client, method, url, headers, entity, headerName, response, XMLHttpRequest;\n\n\t\t\t\trequest = typeof request === 'string' ? { path: request } : request || {};\n\t\t\t\tresponse = { request: request };\n\n\t\t\t\tif (request.canceled) {\n\t\t\t\t\tresponse.error = 'precanceled';\n\t\t\t\t\treject(response);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tXMLHttpRequest = request.engine || global.XMLHttpRequest;\n\t\t\t\tif (!XMLHttpRequest) {\n\t\t\t\t\treject({ request: request, error: 'xhr-not-available' });\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tentity = request.entity;\n\t\t\t\trequest.method = request.method || (entity ? 'POST' : 'GET');\n\t\t\t\tmethod = request.method;\n\t\t\t\turl = new UrlBuilder(request.path || '', request.params).build();\n\n\t\t\t\ttry {\n\t\t\t\t\tclient = response.raw = new XMLHttpRequest();\n\n\t\t\t\t\t// mixin extra request properties before and after opening the request as some properties require being set at different phases of the request\n\t\t\t\t\tsafeMixin(client, request.mixin);\n\t\t\t\t\tclient.open(method, url, true);\n\t\t\t\t\tsafeMixin(client, request.mixin);\n\n\t\t\t\t\theaders = request.headers;\n\t\t\t\t\tfor (headerName in headers) {\n\t\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\t\tif (headerName === 'Content-Type' && headers[headerName] === 'multipart/form-data') {\n\t\t\t\t\t\t\t// XMLHttpRequest generates its own Content-Type header with the\n\t\t\t\t\t\t\t// appropriate multipart boundary when sending multipart/form-data.\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclient.setRequestHeader(headerName, headers[headerName]);\n\t\t\t\t\t}\n\n\t\t\t\t\trequest.canceled = false;\n\t\t\t\t\trequest.cancel = function cancel() {\n\t\t\t\t\t\trequest.canceled = true;\n\t\t\t\t\t\tclient.abort();\n\t\t\t\t\t\treject(response);\n\t\t\t\t\t};\n\n\t\t\t\t\tclient.onreadystatechange = function (/* e */) {\n\t\t\t\t\t\tif (request.canceled) { return; }\n\t\t\t\t\t\tif (client.readyState === (XMLHttpRequest.DONE || 4)) {\n\t\t\t\t\t\t\tresponse.status = {\n\t\t\t\t\t\t\t\tcode: client.status,\n\t\t\t\t\t\t\t\ttext: client.statusText\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tresponse.headers = parseHeaders(client.getAllResponseHeaders());\n\t\t\t\t\t\t\tresponse.entity = client.responseText;\n\n\t\t\t\t\t\t\tif (response.status.code > 0) {\n\t\t\t\t\t\t\t\t// check status code as readystatechange fires before error event\n\t\t\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// give the error callback a chance to fire before resolving\n\t\t\t\t\t\t\t\t// requests for file:// URLs do not have a status code\n\t\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t\t\t\t}, 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tclient.onerror = function (/* e */) {\n\t\t\t\t\t\t\tresponse.error = 'loaderror';\n\t\t\t\t\t\t\treject(response);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t// IE 6 will not support error handling\n\t\t\t\t\t}\n\n\t\t\t\t\tclient.send(entity);\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tresponse.error = 'loaderror';\n\t\t\t\t\treject(response);\n\t\t\t\t}\n\n\t\t\t});\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); },\n\ttypeof window !== 'undefined' ? window : void 0\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../UrlBuilder\":2,\"../client\":4,\"../util/normalizeHeaderName\":23,\"../util/responsePromise\":24,\"when\":114}],7:[function(require,module,exports){\n/*\n * Copyright 2012-2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar defaultClient, mixin, responsePromise, client, when;\n\n\t\tdefaultClient = require('./client/default');\n\t\tmixin = require('./util/mixin');\n\t\tresponsePromise = require('./util/responsePromise');\n\t\tclient = require('./client');\n\t\twhen = require('when');\n\n\t\t/**\n\t\t * Interceptors have the ability to intercept the request and/org response\n\t\t * objects.  They may augment, prune, transform or replace the\n\t\t * request/response as needed.  Clients may be composed by wrapping\n\t\t * together multiple interceptors.\n\t\t *\n\t\t * Configured interceptors are functional in nature.  Wrapping a client in\n\t\t * an interceptor will not affect the client, merely the data that flows in\n\t\t * and out of that client.  A common configuration can be created once and\n\t\t * shared; specialization can be created by further wrapping that client\n\t\t * with custom interceptors.\n\t\t *\n\t\t * @param {Client} [target] client to wrap\n\t\t * @param {Object} [config] configuration for the interceptor, properties will be specific to the interceptor implementation\n\t\t * @returns {Client} A client wrapped with the interceptor\n\t\t *\n\t\t * @class Interceptor\n\t\t */\n\n\t\tfunction defaultInitHandler(config) {\n\t\t\treturn config;\n\t\t}\n\n\t\tfunction defaultRequestHandler(request /*, config, meta */) {\n\t\t\treturn request;\n\t\t}\n\n\t\tfunction defaultResponseHandler(response /*, config, meta */) {\n\t\t\treturn response;\n\t\t}\n\n\t\tfunction race(promisesOrValues) {\n\t\t\t// this function is different than when.any as the first to reject also wins\n\t\t\treturn when.promise(function (resolve, reject) {\n\t\t\t\tpromisesOrValues.forEach(function (promiseOrValue) {\n\t\t\t\t\twhen(promiseOrValue, resolve, reject);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Alternate return type for the request handler that allows for more complex interactions.\n\t\t *\n\t\t * @param properties.request the traditional request return object\n\t\t * @param {Promise} [properties.abort] promise that resolves if/when the request is aborted\n\t\t * @param {Client} [properties.client] override the defined client with an alternate client\n\t\t * @param [properties.response] response for the request, short circuit the request\n\t\t */\n\t\tfunction ComplexRequest(properties) {\n\t\t\tif (!(this instanceof ComplexRequest)) {\n\t\t\t\t// in case users forget the 'new' don't mix into the interceptor\n\t\t\t\treturn new ComplexRequest(properties);\n\t\t\t}\n\t\t\tmixin(this, properties);\n\t\t}\n\n\t\t/**\n\t\t * Create a new interceptor for the provided handlers.\n\t\t *\n\t\t * @param {Function} [handlers.init] one time intialization, must return the config object\n\t\t * @param {Function} [handlers.request] request handler\n\t\t * @param {Function} [handlers.response] response handler regardless of error state\n\t\t * @param {Function} [handlers.success] response handler when the request is not in error\n\t\t * @param {Function} [handlers.error] response handler when the request is in error, may be used to 'unreject' an error state\n\t\t * @param {Function} [handlers.client] the client to use if otherwise not specified, defaults to platform default client\n\t\t *\n\t\t * @returns {Interceptor}\n\t\t */\n\t\tfunction interceptor(handlers) {\n\n\t\t\tvar initHandler, requestHandler, successResponseHandler, errorResponseHandler;\n\n\t\t\thandlers = handlers || {};\n\n\t\t\tinitHandler            = handlers.init    || defaultInitHandler;\n\t\t\trequestHandler         = handlers.request || defaultRequestHandler;\n\t\t\tsuccessResponseHandler = handlers.success || handlers.response || defaultResponseHandler;\n\t\t\terrorResponseHandler   = handlers.error   || function () {\n\t\t\t\t// Propagate the rejection, with the result of the handler\n\t\t\t\treturn when((handlers.response || defaultResponseHandler).apply(this, arguments), when.reject, when.reject);\n\t\t\t};\n\n\t\t\treturn function (target, config) {\n\n\t\t\t\tif (typeof target === 'object') {\n\t\t\t\t\tconfig = target;\n\t\t\t\t}\n\t\t\t\tif (typeof target !== 'function') {\n\t\t\t\t\ttarget = handlers.client || defaultClient;\n\t\t\t\t}\n\n\t\t\t\tconfig = initHandler(config || {});\n\n\t\t\t\tfunction interceptedClient(request) {\n\t\t\t\t\tvar context, meta;\n\t\t\t\t\tcontext = {};\n\t\t\t\t\tmeta = { 'arguments': Array.prototype.slice.call(arguments), client: interceptedClient };\n\t\t\t\t\trequest = typeof request === 'string' ? { path: request } : request || {};\n\t\t\t\t\trequest.originator = request.originator || interceptedClient;\n\t\t\t\t\treturn responsePromise(\n\t\t\t\t\t\trequestHandler.call(context, request, config, meta),\n\t\t\t\t\t\tfunction (request) {\n\t\t\t\t\t\t\tvar response, abort, next;\n\t\t\t\t\t\t\tnext = target;\n\t\t\t\t\t\t\tif (request instanceof ComplexRequest) {\n\t\t\t\t\t\t\t\t// unpack request\n\t\t\t\t\t\t\t\tabort = request.abort;\n\t\t\t\t\t\t\t\tnext = request.client || next;\n\t\t\t\t\t\t\t\tresponse = request.response;\n\t\t\t\t\t\t\t\t// normalize request, must be last\n\t\t\t\t\t\t\t\trequest = request.request;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresponse = response || when(request, function (request) {\n\t\t\t\t\t\t\t\treturn when(\n\t\t\t\t\t\t\t\t\tnext(request),\n\t\t\t\t\t\t\t\t\tfunction (response) {\n\t\t\t\t\t\t\t\t\t\treturn successResponseHandler.call(context, response, config, meta);\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfunction (response) {\n\t\t\t\t\t\t\t\t\t\treturn errorResponseHandler.call(context, response, config, meta);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn abort ? race([response, abort]) : response;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (error) {\n\t\t\t\t\t\t\treturn when.reject({ request: request, error: error });\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn client(interceptedClient, target);\n\t\t\t};\n\t\t}\n\n\t\tinterceptor.ComplexRequest = ComplexRequest;\n\n\t\treturn interceptor;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"./client\":4,\"./client/default\":5,\"./util/mixin\":22,\"./util/responsePromise\":24,\"when\":114}],8:[function(require,module,exports){\n/*\n * Copyright 2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor, mixinUtil, defaulter;\n\n\t\tinterceptor = require('../interceptor');\n\t\tmixinUtil = require('../util/mixin');\n\n\t\tdefaulter = (function () {\n\n\t\t\tfunction mixin(prop, target, defaults) {\n\t\t\t\tif (prop in target || prop in defaults) {\n\t\t\t\t\ttarget[prop] = mixinUtil({}, defaults[prop], target[prop]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction copy(prop, target, defaults) {\n\t\t\t\tif (prop in defaults && !(prop in target)) {\n\t\t\t\t\ttarget[prop] = defaults[prop];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar mappings = {\n\t\t\t\tmethod: copy,\n\t\t\t\tpath: copy,\n\t\t\t\tparams: mixin,\n\t\t\t\theaders: mixin,\n\t\t\t\tentity: copy,\n\t\t\t\tmixin: mixin\n\t\t\t};\n\n\t\t\treturn function (target, defaults) {\n\t\t\t\tfor (var prop in mappings) {\n\t\t\t\t\t/*jshint forin: false */\n\t\t\t\t\tmappings[prop](prop, target, defaults);\n\t\t\t\t}\n\t\t\t\treturn target;\n\t\t\t};\n\n\t\t}());\n\n\t\t/**\n\t\t * Provide default values for a request. These values will be applied to the\n\t\t * request if the request object does not already contain an explicit value.\n\t\t *\n\t\t * For 'params', 'headers', and 'mixin', individual values are mixed in with the\n\t\t * request's values. The result is a new object representiing the combined\n\t\t * request and config values. Neither input object is mutated.\n\t\t *\n\t\t * @param {Client} [client] client to wrap\n\t\t * @param {string} [config.method] the default method\n\t\t * @param {string} [config.path] the default path\n\t\t * @param {Object} [config.params] the default params, mixed with the request's existing params\n\t\t * @param {Object} [config.headers] the default headers, mixed with the request's existing headers\n\t\t * @param {Object} [config.mixin] the default \"mixins\" (http/https options), mixed with the request's existing \"mixins\"\n\t\t *\n\t\t * @returns {Client}\n\t\t */\n\t\treturn interceptor({\n\t\t\trequest: function handleRequest(request, config) {\n\t\t\t\treturn defaulter(request, config);\n\t\t\t}\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../interceptor\":7,\"../util/mixin\":22}],9:[function(require,module,exports){\n/*\n * Copyright 2012-2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor, when;\n\n\t\tinterceptor = require('../interceptor');\n\t\twhen = require('when');\n\n\t\t/**\n\t\t * Rejects the response promise based on the status code.\n\t\t *\n\t\t * Codes greater than or equal to the provided value are rejected.  Default\n\t\t * value 400.\n\t\t *\n\t\t * @param {Client} [client] client to wrap\n\t\t * @param {number} [config.code=400] code to indicate a rejection\n\t\t *\n\t\t * @returns {Client}\n\t\t */\n\t\treturn interceptor({\n\t\t\tinit: function (config) {\n\t\t\t\tconfig.code = config.code || 400;\n\t\t\t\treturn config;\n\t\t\t},\n\t\t\tresponse: function (response, config) {\n\t\t\t\tif (response.status && response.status.code >= config.code) {\n\t\t\t\t\treturn when.reject(response);\n\t\t\t\t}\n\t\t\t\treturn response;\n\t\t\t}\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../interceptor\":7,\"when\":114}],10:[function(require,module,exports){\n/*\n * Copyright 2012-2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor, mime, registry, noopConverter, when;\n\n\t\tinterceptor = require('../interceptor');\n\t\tmime = require('../mime');\n\t\tregistry = require('../mime/registry');\n\t\twhen = require('when');\n\n\t\tnoopConverter = {\n\t\t\tread: function (obj) { return obj; },\n\t\t\twrite: function (obj) { return obj; }\n\t\t};\n\n\t\t/**\n\t\t * MIME type support for request and response entities.  Entities are\n\t\t * (de)serialized using the converter for the MIME type.\n\t\t *\n\t\t * Request entities are converted using the desired converter and the\n\t\t * 'Accept' request header prefers this MIME.\n\t\t *\n\t\t * Response entities are converted based on the Content-Type response header.\n\t\t *\n\t\t * @param {Client} [client] client to wrap\n\t\t * @param {string} [config.mime='text/plain'] MIME type to encode the request\n\t\t *   entity\n\t\t * @param {string} [config.accept] Accept header for the request\n\t\t * @param {Client} [config.client=<request.originator>] client passed to the\n\t\t *   converter, defaults to the client originating the request\n\t\t * @param {Registry} [config.registry] MIME registry, defaults to the root\n\t\t *   registry\n\t\t * @param {boolean} [config.permissive] Allow an unkown request MIME type\n\t\t *\n\t\t * @returns {Client}\n\t\t */\n\t\treturn interceptor({\n\t\t\tinit: function (config) {\n\t\t\t\tconfig.registry = config.registry || registry;\n\t\t\t\treturn config;\n\t\t\t},\n\t\t\trequest: function (request, config) {\n\t\t\t\tvar type, headers;\n\n\t\t\t\theaders = request.headers || (request.headers = {});\n\t\t\t\ttype = mime.parse(headers['Content-Type'] = headers['Content-Type'] || config.mime || 'text/plain');\n\t\t\t\theaders.Accept = headers.Accept || config.accept || type.raw + ', application/json;q=0.8, text/plain;q=0.5, */*;q=0.2';\n\n\t\t\t\tif (!('entity' in request)) {\n\t\t\t\t\treturn request;\n\t\t\t\t}\n\n\t\t\t\treturn config.registry.lookup(type).otherwise(function () {\n\t\t\t\t\t// failed to resolve converter\n\t\t\t\t\tif (config.permissive) {\n\t\t\t\t\t\treturn noopConverter;\n\t\t\t\t\t}\n\t\t\t\t\tthrow 'mime-unknown';\n\t\t\t\t}).then(function (converter) {\n\t\t\t\t\tvar client = config.client || request.originator;\n\n\t\t\t\t\treturn when.attempt(converter.write, request.entity, { client: client, request: request, mime: type, registry: config.registry })\n\t\t\t\t\t\t.otherwise(function() {\n\t\t\t\t\t\t\tthrow 'mime-serialization';\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(function(entity) {\n\t\t\t\t\t\t\trequest.entity = entity;\n\t\t\t\t\t\t\treturn request;\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\t\t\tresponse: function (response, config) {\n\t\t\t\tif (!(response.headers && response.headers['Content-Type'] && response.entity)) {\n\t\t\t\t\treturn response;\n\t\t\t\t}\n\n\t\t\t\tvar type = mime.parse(response.headers['Content-Type']);\n\n\t\t\t\treturn config.registry.lookup(type).otherwise(function () { return noopConverter; }).then(function (converter) {\n\t\t\t\t\tvar client = config.client || response.request && response.request.originator;\n\n\t\t\t\t\treturn when.attempt(converter.read, response.entity, { client: client, response: response, mime: type, registry: config.registry })\n\t\t\t\t\t\t.otherwise(function (e) {\n\t\t\t\t\t\t\tresponse.error = 'mime-deserialization';\n\t\t\t\t\t\t\tresponse.cause = e;\n\t\t\t\t\t\t\tthrow response;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(function (entity) {\n\t\t\t\t\t\t\tresponse.entity = entity;\n\t\t\t\t\t\t\treturn response;\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../interceptor\":7,\"../mime\":13,\"../mime/registry\":14,\"when\":114}],11:[function(require,module,exports){\n/*\n * Copyright 2012-2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor, UrlBuilder;\n\n\t\tinterceptor = require('../interceptor');\n\t\tUrlBuilder = require('../UrlBuilder');\n\n\t\tfunction startsWith(str, prefix) {\n\t\t\treturn str.indexOf(prefix) === 0;\n\t\t}\n\n\t\tfunction endsWith(str, suffix) {\n\t\t\treturn str.lastIndexOf(suffix) + suffix.length === str.length;\n\t\t}\n\n\t\t/**\n\t\t * Prefixes the request path with a common value.\n\t\t *\n\t\t * @param {Client} [client] client to wrap\n\t\t * @param {number} [config.prefix] path prefix\n\t\t *\n\t\t * @returns {Client}\n\t\t */\n\t\treturn interceptor({\n\t\t\trequest: function (request, config) {\n\t\t\t\tvar path;\n\n\t\t\t\tif (config.prefix && !(new UrlBuilder(request.path).isFullyQualified())) {\n\t\t\t\t\tpath = config.prefix;\n\t\t\t\t\tif (request.path) {\n\t\t\t\t\t\tif (!endsWith(path, '/') && !startsWith(request.path, '/')) {\n\t\t\t\t\t\t\t// add missing '/' between path sections\n\t\t\t\t\t\t\tpath += '/';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpath += request.path;\n\t\t\t\t\t}\n\t\t\t\t\trequest.path = path;\n\t\t\t\t}\n\n\t\t\t\treturn request;\n\t\t\t}\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../UrlBuilder\":2,\"../interceptor\":7}],12:[function(require,module,exports){\n/*\n * Copyright 2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor, uriTemplate, mixin;\n\n\t\tinterceptor = require('../interceptor');\n\t\turiTemplate = require('../util/uriTemplate');\n\t\tmixin = require('../util/mixin');\n\n\t\t/**\n\t\t * Applies request params to the path as a URI Template\n\t\t *\n\t\t * Params are removed from the request object, as they have been consumed.\n\t\t *\n\t\t * @param {Client} [client] client to wrap\n\t\t * @param {Object} [config.params] default param values\n\t\t * @param {string} [config.template] default template\n\t\t *\n\t\t * @returns {Client}\n\t\t */\n\t\treturn interceptor({\n\t\t\tinit: function (config) {\n\t\t\t\tconfig.params = config.params || {};\n\t\t\t\tconfig.template = config.template || '';\n\t\t\t\treturn config;\n\t\t\t},\n\t\t\trequest: function (request, config) {\n\t\t\t\tvar template, params;\n\n\t\t\t\ttemplate = request.path || config.template;\n\t\t\t\tparams = mixin({}, request.params, config.params);\n\n\t\t\t\trequest.path = uriTemplate.expand(template, params);\n\t\t\t\tdelete request.params;\n\n\t\t\t\treturn request;\n\t\t\t}\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../interceptor\":7,\"../util/mixin\":22,\"../util/uriTemplate\":26}],13:[function(require,module,exports){\n/*\n* Copyright 2014 the original author or authors\n* @license MIT, see LICENSE.txt for details\n*\n* @author Scott Andrews\n*/\n\n(function (define) {\n\t'use strict';\n\n\tvar undef;\n\n\tdefine(function (/* require */) {\n\n\t\t/**\n\t\t * Parse a MIME type into it's constituent parts\n\t\t *\n\t\t * @param {string} mime MIME type to parse\n\t\t * @return {{\n\t\t *   {string} raw the original MIME type\n\t\t *   {string} type the type and subtype\n\t\t *   {string} [suffix] mime suffix, including the plus, if any\n\t\t *   {Object} params key/value pair of attributes\n\t\t * }}\n\t\t */\n\t\tfunction parse(mime) {\n\t\t\tvar params, type;\n\n\t\t\tparams = mime.split(';');\n\t\t\ttype = params[0].trim().split('+');\n\n\t\t\treturn {\n\t\t\t\traw: mime,\n\t\t\t\ttype: type[0],\n\t\t\t\tsuffix: type[1] ? '+' + type[1] : '',\n\t\t\t\tparams: params.slice(1).reduce(function (params, pair) {\n\t\t\t\t\tpair = pair.split('=');\n\t\t\t\t\tparams[pair[0].trim()] = pair[1] ? pair[1].trim() : undef;\n\t\t\t\t\treturn params;\n\t\t\t\t}, {})\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tparse: parse\n\t\t};\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],14:[function(require,module,exports){\n/*\n * Copyright 2012-2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar mime, when, registry;\n\n\t\tmime = require('../mime');\n\t\twhen = require('when');\n\n\t\tfunction Registry(mimes) {\n\n\t\t\t/**\n\t\t\t * Lookup the converter for a MIME type\n\t\t\t *\n\t\t\t * @param {string} type the MIME type\n\t\t\t * @return a promise for the converter\n\t\t\t */\n\t\t\tthis.lookup = function lookup(type) {\n\t\t\t\tvar parsed;\n\n\t\t\t\tparsed = typeof type === 'string' ? mime.parse(type) : type;\n\n\t\t\t\tif (mimes[parsed.raw]) {\n\t\t\t\t\treturn mimes[parsed.raw];\n\t\t\t\t}\n\t\t\t\tif (mimes[parsed.type + parsed.suffix]) {\n\t\t\t\t\treturn mimes[parsed.type + parsed.suffix];\n\t\t\t\t}\n\t\t\t\tif (mimes[parsed.type]) {\n\t\t\t\t\treturn mimes[parsed.type];\n\t\t\t\t}\n\t\t\t\tif (mimes[parsed.suffix]) {\n\t\t\t\t\treturn mimes[parsed.suffix];\n\t\t\t\t}\n\n\t\t\t\treturn when.reject(new Error('Unable to locate converter for mime \"' + parsed.raw + '\"'));\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Create a late dispatched proxy to the target converter.\n\t\t\t *\n\t\t\t * Common when a converter is registered under multiple names and\n\t\t\t * should be kept in sync if updated.\n\t\t\t *\n\t\t\t * @param {string} type mime converter to dispatch to\n\t\t\t * @returns converter whose read/write methods target the desired mime converter\n\t\t\t */\n\t\t\tthis.delegate = function delegate(type) {\n\t\t\t\treturn {\n\t\t\t\t\tread: function () {\n\t\t\t\t\t\tvar args = arguments;\n\t\t\t\t\t\treturn this.lookup(type).then(function (converter) {\n\t\t\t\t\t\t\treturn converter.read.apply(this, args);\n\t\t\t\t\t\t}.bind(this));\n\t\t\t\t\t}.bind(this),\n\t\t\t\t\twrite: function () {\n\t\t\t\t\t\tvar args = arguments;\n\t\t\t\t\t\treturn this.lookup(type).then(function (converter) {\n\t\t\t\t\t\t\treturn converter.write.apply(this, args);\n\t\t\t\t\t\t}.bind(this));\n\t\t\t\t\t}.bind(this)\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Register a custom converter for a MIME type\n\t\t\t *\n\t\t\t * @param {string} type the MIME type\n\t\t\t * @param converter the converter for the MIME type\n\t\t\t * @return a promise for the converter\n\t\t\t */\n\t\t\tthis.register = function register(type, converter) {\n\t\t\t\tmimes[type] = when(converter);\n\t\t\t\treturn mimes[type];\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Create a child registry whoes registered converters remain local, while\n\t\t\t * able to lookup converters from its parent.\n\t\t\t *\n\t\t\t * @returns child MIME registry\n\t\t\t */\n\t\t\tthis.child = function child() {\n\t\t\t\treturn new Registry(Object.create(mimes));\n\t\t\t};\n\n\t\t}\n\n\t\tregistry = new Registry({});\n\n\t\t// include provided serializers\n\t\tregistry.register('application/hal', require('./type/application/hal'));\n\t\tregistry.register('application/json', require('./type/application/json'));\n\t\tregistry.register('application/x-www-form-urlencoded', require('./type/application/x-www-form-urlencoded'));\n\t\tregistry.register('multipart/form-data', require('./type/multipart/form-data'));\n\t\tregistry.register('text/plain', require('./type/text/plain'));\n\n\t\tregistry.register('+json', registry.delegate('application/json'));\n\n\t\treturn registry;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../mime\":13,\"./type/application/hal\":15,\"./type/application/json\":16,\"./type/application/x-www-form-urlencoded\":17,\"./type/multipart/form-data\":18,\"./type/text/plain\":19,\"when\":114}],15:[function(require,module,exports){\n/*\n * Copyright 2013-2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar pathPrefix, template, find, lazyPromise, responsePromise, when;\n\n\t\tpathPrefix = require('../../../interceptor/pathPrefix');\n\t\ttemplate = require('../../../interceptor/template');\n\t\tfind = require('../../../util/find');\n\t\tlazyPromise = require('../../../util/lazyPromise');\n\t\tresponsePromise = require('../../../util/responsePromise');\n\t\twhen = require('when');\n\n\t\tfunction defineProperty(obj, name, value) {\n\t\t\tObject.defineProperty(obj, name, {\n\t\t\t\tvalue: value,\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\twriteable: true\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Hypertext Application Language serializer\n\t\t *\n\t\t * Implemented to https://tools.ietf.org/html/draft-kelly-json-hal-06\n\t\t *\n\t\t * As the spec is still a draft, this implementation will be updated as the\n\t\t * spec evolves\n\t\t *\n\t\t * Objects are read as HAL indexing links and embedded objects on to the\n\t\t * resource. Objects are written as plain JSON.\n\t\t *\n\t\t * Embedded relationships are indexed onto the resource by the relationship\n\t\t * as a promise for the related resource.\n\t\t *\n\t\t * Links are indexed onto the resource as a lazy promise that will GET the\n\t\t * resource when a handler is first registered on the promise.\n\t\t *\n\t\t * A `requestFor` method is added to the entity to make a request for the\n\t\t * relationship.\n\t\t *\n\t\t * A `clientFor` method is added to the entity to get a full Client for a\n\t\t * relationship.\n\t\t *\n\t\t * The `_links` and `_embedded` properties on the resource are made\n\t\t * non-enumerable.\n\t\t */\n\t\treturn {\n\n\t\t\tread: function (str, opts) {\n\t\t\t\tvar client, console;\n\n\t\t\t\topts = opts || {};\n\t\t\t\tclient = opts.client;\n\t\t\t\tconsole = opts.console || console;\n\n\t\t\t\tfunction deprecationWarning(relationship, deprecation) {\n\t\t\t\t\tif (deprecation && console && console.warn || console.log) {\n\t\t\t\t\t\t(console.warn || console.log).call(console, 'Relationship \\'' + relationship + '\\' is deprecated, see ' + deprecation);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn opts.registry.lookup(opts.mime.suffix).then(function (converter) {\n\t\t\t\t\treturn when(converter.read(str, opts)).then(function (root) {\n\n\t\t\t\t\t\tfind.findProperties(root, '_embedded', function (embedded, resource, name) {\n\t\t\t\t\t\t\tObject.keys(embedded).forEach(function (relationship) {\n\t\t\t\t\t\t\t\tif (relationship in resource) { return; }\n\t\t\t\t\t\t\t\tvar related = responsePromise({\n\t\t\t\t\t\t\t\t\tentity: embedded[relationship]\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tdefineProperty(resource, relationship, related);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdefineProperty(resource, name, embedded);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfind.findProperties(root, '_links', function (links, resource, name) {\n\t\t\t\t\t\t\tObject.keys(links).forEach(function (relationship) {\n\t\t\t\t\t\t\t\tvar link = links[relationship];\n\t\t\t\t\t\t\t\tif (relationship in resource) { return; }\n\t\t\t\t\t\t\t\tdefineProperty(resource, relationship, responsePromise.make(lazyPromise(function () {\n\t\t\t\t\t\t\t\t\tif (link.deprecation) { deprecationWarning(relationship, link.deprecation); }\n\t\t\t\t\t\t\t\t\tif (link.templated === true) {\n\t\t\t\t\t\t\t\t\t\treturn template(client)({ path: link.href });\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn client({ path: link.href });\n\t\t\t\t\t\t\t\t})));\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdefineProperty(resource, name, links);\n\t\t\t\t\t\t\tdefineProperty(resource, 'clientFor', function (relationship, clientOverride) {\n\t\t\t\t\t\t\t\tvar link = links[relationship];\n\t\t\t\t\t\t\t\tif (!link) {\n\t\t\t\t\t\t\t\t\tthrow new Error('Unknown relationship: ' + relationship);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (link.deprecation) { deprecationWarning(relationship, link.deprecation); }\n\t\t\t\t\t\t\t\tif (link.templated === true) {\n\t\t\t\t\t\t\t\t\treturn template(\n\t\t\t\t\t\t\t\t\t\tclientOverride || client,\n\t\t\t\t\t\t\t\t\t\t{ template: link.href }\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn pathPrefix(\n\t\t\t\t\t\t\t\t\tclientOverride || client,\n\t\t\t\t\t\t\t\t\t{ prefix: link.href }\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdefineProperty(resource, 'requestFor', function (relationship, request, clientOverride) {\n\t\t\t\t\t\t\t\tvar client = this.clientFor(relationship, clientOverride);\n\t\t\t\t\t\t\t\treturn client(request);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn root;\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t},\n\n\t\t\twrite: function (obj, opts) {\n\t\t\t\treturn opts.registry.lookup(opts.mime.suffix).then(function (converter) {\n\t\t\t\t\treturn converter.write(obj, opts);\n\t\t\t\t});\n\t\t\t}\n\n\t\t};\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../../../interceptor/pathPrefix\":11,\"../../../interceptor/template\":12,\"../../../util/find\":20,\"../../../util/lazyPromise\":21,\"../../../util/responsePromise\":24,\"when\":114}],16:[function(require,module,exports){\n/*\n * Copyright 2012-2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\t/**\n\t\t * Create a new JSON converter with custom reviver/replacer.\n\t\t *\n\t\t * The extended converter must be published to a MIME registry in order\n\t\t * to be used. The existing converter will not be modified.\n\t\t *\n\t\t * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON\n\t\t *\n\t\t * @param {function} [reviver=undefined] custom JSON.parse reviver\n\t\t * @param {function|Array} [replacer=undefined] custom JSON.stringify replacer\n\t\t */\n\t\tfunction createConverter(reviver, replacer) {\n\t\t\treturn {\n\n\t\t\t\tread: function (str) {\n\t\t\t\t\treturn JSON.parse(str, reviver);\n\t\t\t\t},\n\n\t\t\t\twrite: function (obj) {\n\t\t\t\t\treturn JSON.stringify(obj, replacer);\n\t\t\t\t},\n\n\t\t\t\textend: createConverter\n\n\t\t\t};\n\t\t}\n\n\t\treturn createConverter();\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],17:[function(require,module,exports){\n/*\n * Copyright 2012 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\tvar encodedSpaceRE, urlEncodedSpaceRE;\n\n\t\tencodedSpaceRE = /%20/g;\n\t\turlEncodedSpaceRE = /\\+/g;\n\n\t\tfunction urlEncode(str) {\n\t\t\tstr = encodeURIComponent(str);\n\t\t\t// spec says space should be encoded as '+'\n\t\t\treturn str.replace(encodedSpaceRE, '+');\n\t\t}\n\n\t\tfunction urlDecode(str) {\n\t\t\t// spec says space should be encoded as '+'\n\t\t\tstr = str.replace(urlEncodedSpaceRE, ' ');\n\t\t\treturn decodeURIComponent(str);\n\t\t}\n\n\t\tfunction append(str, name, value) {\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalue.forEach(function (value) {\n\t\t\t\t\tstr = append(str, name, value);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (str.length > 0) {\n\t\t\t\t\tstr += '&';\n\t\t\t\t}\n\t\t\t\tstr += urlEncode(name);\n\t\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\t\tstr += '=' + urlEncode(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\treturn {\n\n\t\t\tread: function (str) {\n\t\t\t\tvar obj = {};\n\t\t\t\tstr.split('&').forEach(function (entry) {\n\t\t\t\t\tvar pair, name, value;\n\t\t\t\t\tpair = entry.split('=');\n\t\t\t\t\tname = urlDecode(pair[0]);\n\t\t\t\t\tif (pair.length === 2) {\n\t\t\t\t\t\tvalue = urlDecode(pair[1]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = null;\n\t\t\t\t\t}\n\t\t\t\t\tif (name in obj) {\n\t\t\t\t\t\tif (!Array.isArray(obj[name])) {\n\t\t\t\t\t\t\t// convert to an array, perserving currnent value\n\t\t\t\t\t\t\tobj[name] = [obj[name]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobj[name].push(value);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tobj[name] = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn obj;\n\t\t\t},\n\n\t\t\twrite: function (obj) {\n\t\t\t\tvar str = '';\n\t\t\t\tObject.keys(obj).forEach(function (name) {\n\t\t\t\t\tstr = append(str, name, obj[name]);\n\t\t\t\t});\n\t\t\t\treturn str;\n\t\t\t}\n\n\t\t};\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],18:[function(require,module,exports){\n/*\n * Copyright 2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Michael Jackson\n */\n\n/* global FormData, File, Blob */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\tfunction isFormElement(object) {\n\t\t\treturn object &&\n\t\t\t\tobject.nodeType === 1 && // Node.ELEMENT_NODE\n\t\t\t\tobject.tagName === 'FORM';\n\t\t}\n\n\t\tfunction createFormDataFromObject(object) {\n\t\t\tvar formData = new FormData();\n\n\t\t\tvar value;\n\t\t\tfor (var property in object) {\n\t\t\t\tif (object.hasOwnProperty(property)) {\n\t\t\t\t\tvalue = object[property];\n\n\t\t\t\t\tif (value instanceof File) {\n\t\t\t\t\t\tformData.append(property, value, value.name);\n\t\t\t\t\t} else if (value instanceof Blob) {\n\t\t\t\t\t\tformData.append(property, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tformData.append(property, String(value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn formData;\n\t\t}\n\n\t\treturn {\n\n\t\t\twrite: function (object) {\n\t\t\t\tif (typeof FormData === 'undefined') {\n\t\t\t\t\tthrow new Error('The multipart/form-data mime serializer requires FormData support');\n\t\t\t\t}\n\n\t\t\t\t// Support FormData directly.\n\t\t\t\tif (object instanceof FormData) {\n\t\t\t\t\treturn object;\n\t\t\t\t}\n\n\t\t\t\t// Support <form> elements.\n\t\t\t\tif (isFormElement(object)) {\n\t\t\t\t\treturn new FormData(object);\n\t\t\t\t}\n\n\t\t\t\t// Support plain objects, may contain File/Blob as value.\n\t\t\t\tif (typeof object === 'object' && object !== null) {\n\t\t\t\t\treturn createFormDataFromObject(object);\n\t\t\t\t}\n\n\t\t\t\tthrow new Error('Unable to create FormData from object ' + object);\n\t\t\t}\n\n\t\t};\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],19:[function(require,module,exports){\n/*\n * Copyright 2012 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\treturn {\n\n\t\t\tread: function (str) {\n\t\t\t\treturn str;\n\t\t\t},\n\n\t\t\twrite: function (obj) {\n\t\t\t\treturn obj.toString();\n\t\t\t}\n\n\t\t};\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],20:[function(require,module,exports){\n/*\n * Copyright 2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\treturn {\n\n\t\t\t/**\n\t\t\t * Find objects within a graph the contain a property of a certain name.\n\t\t\t *\n\t\t\t * NOTE: this method will not discover object graph cycles.\n\t\t\t *\n\t\t\t * @param {*} obj object to search on\n\t\t\t * @param {string} prop name of the property to search for\n\t\t\t * @param {Function} callback function to receive the found properties and their parent\n\t\t\t */\n\t\t\tfindProperties: function findProperties(obj, prop, callback) {\n\t\t\t\tif (typeof obj !== 'object' || obj === null) { return; }\n\t\t\t\tif (prop in obj) {\n\t\t\t\t\tcallback(obj[prop], obj, prop);\n\t\t\t\t}\n\t\t\t\tObject.keys(obj).forEach(function (key) {\n\t\t\t\t\tfindProperties(obj[key], prop, callback);\n\t\t\t\t});\n\t\t\t}\n\n\t\t};\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],21:[function(require,module,exports){\n/*\n * Copyright 2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar when;\n\n\t\twhen = require('when');\n\n\t\t/**\n\t\t * Create a promise whose work is started only when a handler is registered.\n\t\t *\n\t\t * The work function will be invoked at most once. Thrown values will result\n\t\t * in promise rejection.\n\t\t *\n\t\t * @param {Function} work function whose ouput is used to resolve the\n\t\t *   returned promise.\n\t\t * @returns {Promise} a lazy promise\n\t\t */\n\t\tfunction lazyPromise(work) {\n\t\t\tvar defer, started, resolver, promise, then;\n\n\t\t\tdefer = when.defer();\n\t\t\tstarted = false;\n\n\t\t\tresolver = defer.resolver;\n\t\t\tpromise = defer.promise;\n\t\t\tthen = promise.then;\n\n\t\t\tpromise.then = function () {\n\t\t\t\tif (!started) {\n\t\t\t\t\tstarted = true;\n\t\t\t\t\twhen.attempt(work).then(resolver.resolve, resolver.reject);\n\t\t\t\t}\n\t\t\t\treturn then.apply(promise, arguments);\n\t\t\t};\n\n\t\t\treturn promise;\n\t\t}\n\n\t\treturn lazyPromise;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"when\":114}],22:[function(require,module,exports){\n/*\n * Copyright 2012-2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\t// derived from dojo.mixin\n\tdefine(function (/* require */) {\n\n\t\tvar empty = {};\n\n\t\t/**\n\t\t * Mix the properties from the source object into the destination object.\n\t\t * When the same property occurs in more then one object, the right most\n\t\t * value wins.\n\t\t *\n\t\t * @param {Object} dest the object to copy properties to\n\t\t * @param {Object} sources the objects to copy properties from.  May be 1 to N arguments, but not an Array.\n\t\t * @return {Object} the destination object\n\t\t */\n\t\tfunction mixin(dest /*, sources... */) {\n\t\t\tvar i, l, source, name;\n\n\t\t\tif (!dest) { dest = {}; }\n\t\t\tfor (i = 1, l = arguments.length; i < l; i += 1) {\n\t\t\t\tsource = arguments[i];\n\t\t\t\tfor (name in source) {\n\t\t\t\t\tif (!(name in dest) || (dest[name] !== source[name] && (!(name in empty) || empty[name] !== source[name]))) {\n\t\t\t\t\t\tdest[name] = source[name];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn dest; // Object\n\t\t}\n\n\t\treturn mixin;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],23:[function(require,module,exports){\n/*\n * Copyright 2012 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\t/**\n\t\t * Normalize HTTP header names using the pseudo camel case.\n\t\t *\n\t\t * For example:\n\t\t *   content-type         -> Content-Type\n\t\t *   accepts              -> Accepts\n\t\t *   x-custom-header-name -> X-Custom-Header-Name\n\t\t *\n\t\t * @param {string} name the raw header name\n\t\t * @return {string} the normalized header name\n\t\t */\n\t\tfunction normalizeHeaderName(name) {\n\t\t\treturn name.toLowerCase()\n\t\t\t\t.split('-')\n\t\t\t\t.map(function (chunk) { return chunk.charAt(0).toUpperCase() + chunk.slice(1); })\n\t\t\t\t.join('-');\n\t\t}\n\n\t\treturn normalizeHeaderName;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],24:[function(require,module,exports){\n/*\n * Copyright 2014-2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar when = require('when'),\n\t\t\tnormalizeHeaderName = require('./normalizeHeaderName');\n\n\t\tfunction property(promise, name) {\n\t\t\treturn promise.then(\n\t\t\t\tfunction (value) {\n\t\t\t\t\treturn value && value[name];\n\t\t\t\t},\n\t\t\t\tfunction (value) {\n\t\t\t\t\treturn when.reject(value && value[name]);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * Obtain the response entity\n\t\t *\n\t\t * @returns {Promise} for the response entity\n\t\t */\n\t\tfunction entity() {\n\t\t\t/*jshint validthis:true */\n\t\t\treturn property(this, 'entity');\n\t\t}\n\n\t\t/**\n\t\t * Obtain the response status\n\t\t *\n\t\t * @returns {Promise} for the response status\n\t\t */\n\t\tfunction status() {\n\t\t\t/*jshint validthis:true */\n\t\t\treturn property(property(this, 'status'), 'code');\n\t\t}\n\n\t\t/**\n\t\t * Obtain the response headers map\n\t\t *\n\t\t * @returns {Promise} for the response headers map\n\t\t */\n\t\tfunction headers() {\n\t\t\t/*jshint validthis:true */\n\t\t\treturn property(this, 'headers');\n\t\t}\n\n\t\t/**\n\t\t * Obtain a specific response header\n\t\t *\n\t\t * @param {String} headerName the header to retrieve\n\t\t * @returns {Promise} for the response header's value\n\t\t */\n\t\tfunction header(headerName) {\n\t\t\t/*jshint validthis:true */\n\t\t\theaderName = normalizeHeaderName(headerName);\n\t\t\treturn property(this.headers(), headerName);\n\t\t}\n\n\t\t/**\n\t\t * Follow a related resource\n\t\t *\n\t\t * The relationship to follow may be define as a plain string, an object\n\t\t * with the rel and params, or an array containing one or more entries\n\t\t * with the previous forms.\n\t\t *\n\t\t * Examples:\n\t\t *   response.follow('next')\n\t\t *\n\t\t *   response.follow({ rel: 'next', params: { pageSize: 100 } })\n\t\t *\n\t\t *   response.follow([\n\t\t *       { rel: 'items', params: { projection: 'noImages' } },\n\t\t *       'search',\n\t\t *       { rel: 'findByGalleryIsNull', params: { projection: 'noImages' } },\n\t\t *       'items'\n\t\t *   ])\n\t\t *\n\t\t * @param {String|Object|Array} rels one, or more, relationships to follow\n\t\t * @returns ResponsePromise<Response> related resource\n\t\t */\n\t\tfunction follow(rels) {\n\t\t\t/*jshint validthis:true */\n\t\t\trels = [].concat(rels);\n\t\t\treturn make(when.reduce(rels, function (response, rel) {\n\t\t\t\tif (typeof rel === 'string') {\n\t\t\t\t\trel = { rel: rel };\n\t\t\t\t}\n\t\t\t\tif (typeof response.entity.clientFor !== 'function') {\n\t\t\t\t\tthrow new Error('Hypermedia response expected');\n\t\t\t\t}\n\t\t\t\tvar client = response.entity.clientFor(rel.rel);\n\t\t\t\treturn client({ params: rel.params });\n\t\t\t}, this));\n\t\t}\n\n\t\t/**\n\t\t * Wrap a Promise as an ResponsePromise\n\t\t *\n\t\t * @param {Promise<Response>} promise the promise for an HTTP Response\n\t\t * @returns {ResponsePromise<Response>} wrapped promise for Response with additional helper methods\n\t\t */\n\t\tfunction make(promise) {\n\t\t\tpromise.status = status;\n\t\t\tpromise.headers = headers;\n\t\t\tpromise.header = header;\n\t\t\tpromise.entity = entity;\n\t\t\tpromise.follow = follow;\n\t\t\treturn promise;\n\t\t}\n\n\t\tfunction responsePromise() {\n\t\t\treturn make(when.apply(when, arguments));\n\t\t}\n\n\t\tresponsePromise.make = make;\n\t\tresponsePromise.reject = function (val) {\n\t\t\treturn make(when.reject(val));\n\t\t};\n\t\tresponsePromise.promise = function (func) {\n\t\t\treturn make(when.promise(func));\n\t\t};\n\n\t\treturn responsePromise;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"./normalizeHeaderName\":23,\"when\":114}],25:[function(require,module,exports){\n/*\n * Copyright 2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\tvar charMap;\n\n\t\tcharMap = (function () {\n\t\t\tvar strings = {\n\t\t\t\talpha: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\t\t\t\tdigit: '0123456789'\n\t\t\t};\n\n\t\t\tstrings.genDelims = ':/?#[]@';\n\t\t\tstrings.subDelims = '!$&\\'()*+,;=';\n\t\t\tstrings.reserved = strings.genDelims + strings.subDelims;\n\t\t\tstrings.unreserved = strings.alpha + strings.digit + '-._~';\n\t\t\tstrings.url = strings.reserved + strings.unreserved;\n\t\t\tstrings.scheme = strings.alpha + strings.digit + '+-.';\n\t\t\tstrings.userinfo = strings.unreserved + strings.subDelims + ':';\n\t\t\tstrings.host = strings.unreserved + strings.subDelims;\n\t\t\tstrings.port = strings.digit;\n\t\t\tstrings.pchar = strings.unreserved + strings.subDelims + ':@';\n\t\t\tstrings.segment = strings.pchar;\n\t\t\tstrings.path = strings.segment + '/';\n\t\t\tstrings.query = strings.pchar + '/?';\n\t\t\tstrings.fragment = strings.pchar + '/?';\n\n\t\t\treturn Object.keys(strings).reduce(function (charMap, set) {\n\t\t\t\tcharMap[set] = strings[set].split('').reduce(function (chars, myChar) {\n\t\t\t\t\tchars[myChar] = true;\n\t\t\t\t\treturn chars;\n\t\t\t\t}, {});\n\t\t\t\treturn charMap;\n\t\t\t}, {});\n\t\t}());\n\n\t\tfunction encode(str, allowed) {\n\t\t\tif (typeof str !== 'string') {\n\t\t\t\tthrow new Error('String required for URL encoding');\n\t\t\t}\n\t\t\treturn str.split('').map(function (myChar) {\n\t\t\t\tif (allowed.hasOwnProperty(myChar)) {\n\t\t\t\t\treturn myChar;\n\t\t\t\t}\n\t\t\t\tvar code = myChar.charCodeAt(0);\n\t\t\t\tif (code <= 127) {\n\t\t\t\t\treturn '%' + code.toString(16).toUpperCase();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn encodeURIComponent(myChar).toUpperCase();\n\t\t\t\t}\n\t\t\t}).join('');\n\t\t}\n\n\t\tfunction makeEncoder(allowed) {\n\t\t\tallowed = allowed || charMap.unreserved;\n\t\t\treturn function (str) {\n\t\t\t\treturn encode(str, allowed);\n\t\t\t};\n\t\t}\n\n\t\tfunction decode(str) {\n\t\t\treturn decodeURIComponent(str);\n\t\t}\n\n\t\treturn {\n\n\t\t\t/*\n\t\t\t * Decode URL encoded strings\n\t\t\t *\n\t\t\t * @param {string} URL encoded string\n\t\t\t * @returns {string} URL decoded string\n\t\t\t */\n\t\t\tdecode: decode,\n\n\t\t\t/*\n\t\t\t * URL encode a string\n\t\t\t *\n\t\t\t * All but alpha-numerics and a very limited set of punctuation - . _ ~ are\n\t\t\t * encoded.\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencode: makeEncoder(),\n\n\t\t\t/*\n\t\t\t* URL encode a URL\n\t\t\t*\n\t\t\t* All character permitted anywhere in a URL are left unencoded even\n\t\t\t* if that character is not permitted in that portion of a URL.\n\t\t\t*\n\t\t\t* Note: This method is typically not what you want.\n\t\t\t*\n\t\t\t* @param {string} string to encode\n\t\t\t* @returns {string} URL encoded string\n\t\t\t*/\n\t\t\tencodeURL: makeEncoder(charMap.url),\n\n\t\t\t/*\n\t\t\t * URL encode the scheme portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodeScheme: makeEncoder(charMap.scheme),\n\n\t\t\t/*\n\t\t\t * URL encode the user info portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodeUserInfo: makeEncoder(charMap.userinfo),\n\n\t\t\t/*\n\t\t\t * URL encode the host portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodeHost: makeEncoder(charMap.host),\n\n\t\t\t/*\n\t\t\t * URL encode the port portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodePort: makeEncoder(charMap.port),\n\n\t\t\t/*\n\t\t\t * URL encode a path segment portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodePathSegment: makeEncoder(charMap.segment),\n\n\t\t\t/*\n\t\t\t * URL encode the path portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodePath: makeEncoder(charMap.path),\n\n\t\t\t/*\n\t\t\t * URL encode the query portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodeQuery: makeEncoder(charMap.query),\n\n\t\t\t/*\n\t\t\t * URL encode the fragment portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodeFragment: makeEncoder(charMap.fragment)\n\n\t\t};\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],26:[function(require,module,exports){\n/*\n * Copyright 2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tvar undef;\n\n\tdefine(function (require) {\n\n\t\tvar uriEncoder, operations, prefixRE;\n\n\t\turiEncoder = require('./uriEncoder');\n\n\t\tprefixRE = /^([^:]*):([0-9]+)$/;\n\t\toperations = {\n\t\t\t'':  { first: '',  separator: ',', named: false, empty: '',  encoder: uriEncoder.encode },\n\t\t\t'+': { first: '',  separator: ',', named: false, empty: '',  encoder: uriEncoder.encodeURL },\n\t\t\t'#': { first: '#', separator: ',', named: false, empty: '',  encoder: uriEncoder.encodeURL },\n\t\t\t'.': { first: '.', separator: '.', named: false, empty: '',  encoder: uriEncoder.encode },\n\t\t\t'/': { first: '/', separator: '/', named: false, empty: '',  encoder: uriEncoder.encode },\n\t\t\t';': { first: ';', separator: ';', named: true,  empty: '',  encoder: uriEncoder.encode },\n\t\t\t'?': { first: '?', separator: '&', named: true,  empty: '=', encoder: uriEncoder.encode },\n\t\t\t'&': { first: '&', separator: '&', named: true,  empty: '=', encoder: uriEncoder.encode },\n\t\t\t'=': { reserved: true },\n\t\t\t',': { reserved: true },\n\t\t\t'!': { reserved: true },\n\t\t\t'@': { reserved: true },\n\t\t\t'|': { reserved: true }\n\t\t};\n\n\t\tfunction apply(operation, expression, params) {\n\t\t\t/*jshint maxcomplexity:11 */\n\t\t\treturn expression.split(',').reduce(function (result, variable) {\n\t\t\t\tvar opts, value;\n\n\t\t\t\topts = {};\n\t\t\t\tif (variable.slice(-1) === '*') {\n\t\t\t\t\tvariable = variable.slice(0, -1);\n\t\t\t\t\topts.explode = true;\n\t\t\t\t}\n\t\t\t\tif (prefixRE.test(variable)) {\n\t\t\t\t\tvar prefix = prefixRE.exec(variable);\n\t\t\t\t\tvariable = prefix[1];\n\t\t\t\t\topts.maxLength = parseInt(prefix[2]);\n\t\t\t\t}\n\n\t\t\t\tvariable = uriEncoder.decode(variable);\n\t\t\t\tvalue = params[variable];\n\n\t\t\t\tif (value === undef || value === null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tresult += value.reduce(function (result, value) {\n\t\t\t\t\t\tif (result.length) {\n\t\t\t\t\t\t\tresult += opts.explode ? operation.separator : ',';\n\t\t\t\t\t\t\tif (operation.named && opts.explode) {\n\t\t\t\t\t\t\t\tresult += operation.encoder(variable);\n\t\t\t\t\t\t\t\tresult += value.length ? '=' : operation.empty;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresult += operation.first;\n\t\t\t\t\t\t\tif (operation.named) {\n\t\t\t\t\t\t\t\tresult += operation.encoder(variable);\n\t\t\t\t\t\t\t\tresult += value.length ? '=' : operation.empty;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult += operation.encoder(value);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}, '');\n\t\t\t\t}\n\t\t\t\telse if (typeof value === 'object') {\n\t\t\t\t\tresult += Object.keys(value).reduce(function (result, name) {\n\t\t\t\t\t\tif (result.length) {\n\t\t\t\t\t\t\tresult += opts.explode ? operation.separator : ',';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresult += operation.first;\n\t\t\t\t\t\t\tif (operation.named && !opts.explode) {\n\t\t\t\t\t\t\t\tresult += operation.encoder(variable);\n\t\t\t\t\t\t\t\tresult += value[name].length ? '=' : operation.empty;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult += operation.encoder(name);\n\t\t\t\t\t\tresult += opts.explode ? '=' : ',';\n\t\t\t\t\t\tresult += operation.encoder(value[name]);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}, '');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = String(value);\n\t\t\t\t\tif (opts.maxLength) {\n\t\t\t\t\t\tvalue = value.slice(0, opts.maxLength);\n\t\t\t\t\t}\n\t\t\t\t\tresult += result.length ? operation.separator : operation.first;\n\t\t\t\t\tif (operation.named) {\n\t\t\t\t\t\tresult += operation.encoder(variable);\n\t\t\t\t\t\tresult += value.length ? '=' : operation.empty;\n\t\t\t\t\t}\n\t\t\t\t\tresult += operation.encoder(value);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, '');\n\t\t}\n\n\t\tfunction expandExpression(expression, params) {\n\t\t\tvar operation;\n\n\t\t\toperation = operations[expression.slice(0,1)];\n\t\t\tif (operation) {\n\t\t\t\texpression = expression.slice(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\toperation = operations[''];\n\t\t\t}\n\n\t\t\tif (operation.reserved) {\n\t\t\t\tthrow new Error('Reserved expression operations are not supported');\n\t\t\t}\n\n\t\t\treturn apply(operation, expression, params);\n\t\t}\n\n\t\tfunction expandTemplate(template, params) {\n\t\t\tvar start, end, uri;\n\n\t\t\turi = '';\n\t\t\tend = 0;\n\t\t\twhile (true) {\n\t\t\t\tstart = template.indexOf('{', end);\n\t\t\t\tif (start === -1) {\n\t\t\t\t\t// no more expressions\n\t\t\t\t\turi += template.slice(end);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\turi += template.slice(end, start);\n\t\t\t\tend = template.indexOf('}', start) + 1;\n\t\t\t\turi += expandExpression(template.slice(start + 1, end - 1), params);\n\t\t\t}\n\n\t\t\treturn uri;\n\t\t}\n\n\t\treturn {\n\n\t\t\t/**\n\t\t\t * Expand a URI Template with parameters to form a URI.\n\t\t\t *\n\t\t\t * Full implementation (level 4) of rfc6570.\n\t\t\t * @see https://tools.ietf.org/html/rfc6570\n\t\t\t *\n\t\t\t * @param {string} template URI template\n\t\t\t * @param {Object} [params] params to apply to the template durring expantion\n\t\t\t * @returns {string} expanded URI\n\t\t\t */\n\t\t\texpand: expandTemplate\n\n\t\t};\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"./uriEncoder\":25}],27:[function(require,module,exports){\nvar Vue // late bind\nvar map = Object.create(null)\nvar shimmed = false\nvar isBrowserify = false\n\n/**\n * Determine compatibility and apply patch.\n *\n * @param {Function} vue\n * @param {Boolean} browserify\n */\n\nexports.install = function (vue, browserify) {\n  if (shimmed) return\n  shimmed = true\n\n  Vue = vue\n  isBrowserify = browserify\n\n  exports.compatible = !!Vue.internalDirectives\n  if (!exports.compatible) {\n    console.warn(\n      '[HMR] vue-loader hot reload is only compatible with ' +\n      'Vue.js 1.0.0+.'\n    )\n    return\n  }\n\n  // patch view directive\n  patchView(Vue.internalDirectives.component)\n  console.log('[HMR] Vue component hot reload shim applied.')\n  // shim router-view if present\n  var routerView = Vue.elementDirective('router-view')\n  if (routerView) {\n    patchView(routerView)\n    console.log('[HMR] vue-router <router-view> hot reload shim applied.')\n  }\n}\n\n/**\n * Shim the view directive (component or router-view).\n *\n * @param {Object} View\n */\n\nfunction patchView (View) {\n  var unbuild = View.unbuild\n  View.unbuild = function (defer) {\n    if (!this.hotUpdating) {\n      var prevComponent = this.childVM && this.childVM.constructor\n      removeView(prevComponent, this)\n      // defer = true means we are transitioning to a new\n      // Component. Register this new component to the list.\n      if (defer) {\n        addView(this.Component, this)\n      }\n    }\n    // call original\n    return unbuild.call(this, defer)\n  }\n}\n\n/**\n * Add a component view to a Component's hot list\n *\n * @param {Function} Component\n * @param {Directive} view - view directive instance\n */\n\nfunction addView (Component, view) {\n  var id = Component && Component.options.hotID\n  if (id) {\n    if (!map[id]) {\n      map[id] = {\n        Component: Component,\n        views: [],\n        instances: []\n      }\n    }\n    map[id].views.push(view)\n  }\n}\n\n/**\n * Remove a component view from a Component's hot list\n *\n * @param {Function} Component\n * @param {Directive} view - view directive instance\n */\n\nfunction removeView (Component, view) {\n  var id = Component && Component.options.hotID\n  if (id) {\n    map[id].views.$remove(view)\n  }\n}\n\n/**\n * Create a record for a hot module, which keeps track of its construcotr,\n * instnaces and views (component directives or router-views).\n *\n * @param {String} id\n * @param {Object} options\n */\n\nexports.createRecord = function (id, options) {\n  if (typeof options === 'function') {\n    options = options.options\n  }\n  if (typeof options.el !== 'string' && typeof options.data !== 'object') {\n    makeOptionsHot(id, options)\n    map[id] = {\n      Component: null,\n      views: [],\n      instances: []\n    }\n  }\n}\n\n/**\n * Make a Component options object hot.\n *\n * @param {String} id\n * @param {Object} options\n */\n\nfunction makeOptionsHot (id, options) {\n  options.hotID = id\n  injectHook(options, 'created', function () {\n    var record = map[id]\n    if (!record.Component) {\n      record.Component = this.constructor\n    }\n    record.instances.push(this)\n  })\n  injectHook(options, 'beforeDestroy', function () {\n    map[id].instances.$remove(this)\n  })\n}\n\n/**\n * Inject a hook to a hot reloadable component so that\n * we can keep track of it.\n *\n * @param {Object} options\n * @param {String} name\n * @param {Function} hook\n */\n\nfunction injectHook (options, name, hook) {\n  var existing = options[name]\n  options[name] = existing\n    ? Array.isArray(existing)\n      ? existing.concat(hook)\n      : [existing, hook]\n    : [hook]\n}\n\n/**\n * Update a hot component.\n *\n * @param {String} id\n * @param {Object|null} newOptions\n * @param {String|null} newTemplate\n */\n\nexports.update = function (id, newOptions, newTemplate) {\n  var record = map[id]\n  // force full-reload if an instance of the component is active but is not\n  // managed by a view\n  if (!record || (record.instances.length && !record.views.length)) {\n    console.log('[HMR] Root or manually-mounted instance modified. Full reload may be required.')\n    if (!isBrowserify) {\n      window.location.reload()\n    } else {\n      // browserify-hmr somehow sends incomplete bundle if we reload here\n      return\n    }\n  }\n  if (!isBrowserify) {\n    // browserify-hmr already logs this\n    console.log('[HMR] Updating component: ' + format(id))\n  }\n  var Component = record.Component\n  // update constructor\n  if (newOptions) {\n    // in case the user exports a constructor\n    Component = record.Component = typeof newOptions === 'function'\n      ? newOptions\n      : Vue.extend(newOptions)\n    makeOptionsHot(id, Component.options)\n  }\n  if (newTemplate) {\n    Component.options.template = newTemplate\n  }\n  // handle recursive lookup\n  if (Component.options.name) {\n    Component.options.components[Component.options.name] = Component\n  }\n  // reset constructor cached linker\n  Component.linker = null\n  // reload all views\n  record.views.forEach(function (view) {\n    updateView(view, Component)\n  })\n}\n\n/**\n * Update a component view instance\n *\n * @param {Directive} view\n * @param {Function} Component\n */\n\nfunction updateView (view, Component) {\n  if (!view._bound) {\n    return\n  }\n  view.Component = Component\n  view.hotUpdating = true\n  // disable transitions\n  view.vm._isCompiled = false\n  // save state\n  var state = view.childVM.$data\n  // remount, make sure to disable keep-alive\n  var keepAlive = view.keepAlive\n  view.keepAlive = false\n  view.mountComponent()\n  view.keepAlive = keepAlive\n  // restore state\n  view.childVM.$data = state\n  // re-eanble transitions\n  view.vm._isCompiled = true\n  view.hotUpdating = false\n}\n\nfunction format (id) {\n  return id.match(/[^\\/]+\\.vue$/)[0]\n}\n\n},{}],28:[function(require,module,exports){\n'use strict';\n\nvar babelHelpers = {};\n\nbabelHelpers.classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\nfunction Target(path, matcher, delegate) {\n  this.path = path;\n  this.matcher = matcher;\n  this.delegate = delegate;\n}\n\nTarget.prototype = {\n  to: function to(target, callback) {\n    var delegate = this.delegate;\n\n    if (delegate && delegate.willAddRoute) {\n      target = delegate.willAddRoute(this.matcher.target, target);\n    }\n\n    this.matcher.add(this.path, target);\n\n    if (callback) {\n      if (callback.length === 0) {\n        throw new Error(\"You must have an argument in the function passed to `to`\");\n      }\n      this.matcher.addChild(this.path, target, callback, this.delegate);\n    }\n    return this;\n  }\n};\n\nfunction Matcher(target) {\n  this.routes = {};\n  this.children = {};\n  this.target = target;\n}\n\nMatcher.prototype = {\n  add: function add(path, handler) {\n    this.routes[path] = handler;\n  },\n\n  addChild: function addChild(path, target, callback, delegate) {\n    var matcher = new Matcher(target);\n    this.children[path] = matcher;\n\n    var match = generateMatch(path, matcher, delegate);\n\n    if (delegate && delegate.contextEntered) {\n      delegate.contextEntered(target, match);\n    }\n\n    callback(match);\n  }\n};\n\nfunction generateMatch(startingPath, matcher, delegate) {\n  return function (path, nestedCallback) {\n    var fullPath = startingPath + path;\n\n    if (nestedCallback) {\n      nestedCallback(generateMatch(fullPath, matcher, delegate));\n    } else {\n      return new Target(startingPath + path, matcher, delegate);\n    }\n  };\n}\n\nfunction addRoute(routeArray, path, handler) {\n  var len = 0;\n  for (var i = 0, l = routeArray.length; i < l; i++) {\n    len += routeArray[i].path.length;\n  }\n\n  path = path.substr(len);\n  var route = { path: path, handler: handler };\n  routeArray.push(route);\n}\n\nfunction eachRoute(baseRoute, matcher, callback, binding) {\n  var routes = matcher.routes;\n\n  for (var path in routes) {\n    if (routes.hasOwnProperty(path)) {\n      var routeArray = baseRoute.slice();\n      addRoute(routeArray, path, routes[path]);\n\n      if (matcher.children[path]) {\n        eachRoute(routeArray, matcher.children[path], callback, binding);\n      } else {\n        callback.call(binding, routeArray);\n      }\n    }\n  }\n}\n\nfunction map (callback, addRouteCallback) {\n  var matcher = new Matcher();\n\n  callback(generateMatch(\"\", matcher, this.delegate));\n\n  eachRoute([], matcher, function (route) {\n    if (addRouteCallback) {\n      addRouteCallback(this, route);\n    } else {\n      this.add(route);\n    }\n  }, this);\n}\n\nvar specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\'];\n\nvar escapeRegex = new RegExp('(\\\\' + specials.join('|\\\\') + ')', 'g');\n\nfunction isArray(test) {\n  return Object.prototype.toString.call(test) === \"[object Array]\";\n}\n\n// A Segment represents a segment in the original route description.\n// Each Segment type provides an `eachChar` and `regex` method.\n//\n// The `eachChar` method invokes the callback with one or more character\n// specifications. A character specification consumes one or more input\n// characters.\n//\n// The `regex` method returns a regex fragment for the segment. If the\n// segment is a dynamic of star segment, the regex fragment also includes\n// a capture.\n//\n// A character specification contains:\n//\n// * `validChars`: a String with a list of all valid characters, or\n// * `invalidChars`: a String with a list of all invalid characters\n// * `repeat`: true if the character specification can repeat\n\nfunction StaticSegment(string) {\n  this.string = string;\n}\nStaticSegment.prototype = {\n  eachChar: function eachChar(callback) {\n    var string = this.string,\n        ch;\n\n    for (var i = 0, l = string.length; i < l; i++) {\n      ch = string.charAt(i);\n      callback({ validChars: ch });\n    }\n  },\n\n  regex: function regex() {\n    return this.string.replace(escapeRegex, '\\\\$1');\n  },\n\n  generate: function generate() {\n    return this.string;\n  }\n};\n\nfunction DynamicSegment(name) {\n  this.name = name;\n}\nDynamicSegment.prototype = {\n  eachChar: function eachChar(callback) {\n    callback({ invalidChars: \"/\", repeat: true });\n  },\n\n  regex: function regex() {\n    return \"([^/]+)\";\n  },\n\n  generate: function generate(params) {\n    return params[this.name];\n  }\n};\n\nfunction StarSegment(name) {\n  this.name = name;\n}\nStarSegment.prototype = {\n  eachChar: function eachChar(callback) {\n    callback({ invalidChars: \"\", repeat: true });\n  },\n\n  regex: function regex() {\n    return \"(.+)\";\n  },\n\n  generate: function generate(params) {\n    return params[this.name];\n  }\n};\n\nfunction EpsilonSegment() {}\nEpsilonSegment.prototype = {\n  eachChar: function eachChar() {},\n  regex: function regex() {\n    return \"\";\n  },\n  generate: function generate() {\n    return \"\";\n  }\n};\n\nfunction parse(route, names, specificity) {\n  // normalize route as not starting with a \"/\". Recognition will\n  // also normalize.\n  if (route.charAt(0) === \"/\") {\n    route = route.substr(1);\n  }\n\n  var segments = route.split(\"/\"),\n      results = [];\n\n  // A routes has specificity determined by the order that its different segments\n  // appear in. This system mirrors how the magnitude of numbers written as strings\n  // works.\n  // Consider a number written as: \"abc\". An example would be \"200\". Any other number written\n  // \"xyz\" will be smaller than \"abc\" so long as `a > z`. For instance, \"199\" is smaller\n  // then \"200\", even though \"y\" and \"z\" (which are both 9) are larger than \"0\" (the value\n  // of (`b` and `c`). This is because the leading symbol, \"2\", is larger than the other\n  // leading symbol, \"1\".\n  // The rule is that symbols to the left carry more weight than symbols to the right\n  // when a number is written out as a string. In the above strings, the leading digit\n  // represents how many 100's are in the number, and it carries more weight than the middle\n  // number which represents how many 10's are in the number.\n  // This system of number magnitude works well for route specificity, too. A route written as\n  // `a/b/c` will be more specific than `x/y/z` as long as `a` is more specific than\n  // `x`, irrespective of the other parts.\n  // Because of this similarity, we assign each type of segment a number value written as a\n  // string. We can find the specificity of compound routes by concatenating these strings\n  // together, from left to right. After we have looped through all of the segments,\n  // we convert the string to a number.\n  specificity.val = '';\n\n  for (var i = 0, l = segments.length; i < l; i++) {\n    var segment = segments[i],\n        match;\n\n    if (match = segment.match(/^:([^\\/]+)$/)) {\n      results.push(new DynamicSegment(match[1]));\n      names.push(match[1]);\n      specificity.val += '3';\n    } else if (match = segment.match(/^\\*([^\\/]+)$/)) {\n      results.push(new StarSegment(match[1]));\n      specificity.val += '2';\n      names.push(match[1]);\n    } else if (segment === \"\") {\n      results.push(new EpsilonSegment());\n      specificity.val += '1';\n    } else {\n      results.push(new StaticSegment(segment));\n      specificity.val += '4';\n    }\n  }\n\n  specificity.val = +specificity.val;\n\n  return results;\n}\n\n// A State has a character specification and (`charSpec`) and a list of possible\n// subsequent states (`nextStates`).\n//\n// If a State is an accepting state, it will also have several additional\n// properties:\n//\n// * `regex`: A regular expression that is used to extract parameters from paths\n//   that reached this accepting state.\n// * `handlers`: Information on how to convert the list of captures into calls\n//   to registered handlers with the specified parameters\n// * `types`: How many static, dynamic or star segments in this route. Used to\n//   decide which route to use if multiple registered routes match a path.\n//\n// Currently, State is implemented naively by looping over `nextStates` and\n// comparing a character specification against a character. A more efficient\n// implementation would use a hash of keys pointing at one or more next states.\n\nfunction State(charSpec) {\n  this.charSpec = charSpec;\n  this.nextStates = [];\n}\n\nState.prototype = {\n  get: function get(charSpec) {\n    var nextStates = this.nextStates;\n\n    for (var i = 0, l = nextStates.length; i < l; i++) {\n      var child = nextStates[i];\n\n      var isEqual = child.charSpec.validChars === charSpec.validChars;\n      isEqual = isEqual && child.charSpec.invalidChars === charSpec.invalidChars;\n\n      if (isEqual) {\n        return child;\n      }\n    }\n  },\n\n  put: function put(charSpec) {\n    var state;\n\n    // If the character specification already exists in a child of the current\n    // state, just return that state.\n    if (state = this.get(charSpec)) {\n      return state;\n    }\n\n    // Make a new state for the character spec\n    state = new State(charSpec);\n\n    // Insert the new state as a child of the current state\n    this.nextStates.push(state);\n\n    // If this character specification repeats, insert the new state as a child\n    // of itself. Note that this will not trigger an infinite loop because each\n    // transition during recognition consumes a character.\n    if (charSpec.repeat) {\n      state.nextStates.push(state);\n    }\n\n    // Return the new state\n    return state;\n  },\n\n  // Find a list of child states matching the next character\n  match: function match(ch) {\n    // DEBUG \"Processing `\" + ch + \"`:\"\n    var nextStates = this.nextStates,\n        child,\n        charSpec,\n        chars;\n\n    // DEBUG \"  \" + debugState(this)\n    var returned = [];\n\n    for (var i = 0, l = nextStates.length; i < l; i++) {\n      child = nextStates[i];\n\n      charSpec = child.charSpec;\n\n      if (typeof (chars = charSpec.validChars) !== 'undefined') {\n        if (chars.indexOf(ch) !== -1) {\n          returned.push(child);\n        }\n      } else if (typeof (chars = charSpec.invalidChars) !== 'undefined') {\n        if (chars.indexOf(ch) === -1) {\n          returned.push(child);\n        }\n      }\n    }\n\n    return returned;\n  }\n\n  /** IF DEBUG\n  , debug: function() {\n    var charSpec = this.charSpec,\n        debug = \"[\",\n        chars = charSpec.validChars || charSpec.invalidChars;\n     if (charSpec.invalidChars) { debug += \"^\"; }\n    debug += chars;\n    debug += \"]\";\n     if (charSpec.repeat) { debug += \"+\"; }\n     return debug;\n  }\n  END IF **/\n};\n\n/** IF DEBUG\nfunction debug(log) {\n  console.log(log);\n}\n\nfunction debugState(state) {\n  return state.nextStates.map(function(n) {\n    if (n.nextStates.length === 0) { return \"( \" + n.debug() + \" [accepting] )\"; }\n    return \"( \" + n.debug() + \" <then> \" + n.nextStates.map(function(s) { return s.debug() }).join(\" or \") + \" )\";\n  }).join(\", \")\n}\nEND IF **/\n\n// Sort the routes by specificity\nfunction sortSolutions(states) {\n  return states.sort(function (a, b) {\n    return b.specificity.val - a.specificity.val;\n  });\n}\n\nfunction recognizeChar(states, ch) {\n  var nextStates = [];\n\n  for (var i = 0, l = states.length; i < l; i++) {\n    var state = states[i];\n\n    nextStates = nextStates.concat(state.match(ch));\n  }\n\n  return nextStates;\n}\n\nvar oCreate = Object.create || function (proto) {\n  function F() {}\n  F.prototype = proto;\n  return new F();\n};\n\nfunction RecognizeResults(queryParams) {\n  this.queryParams = queryParams || {};\n}\nRecognizeResults.prototype = oCreate({\n  splice: Array.prototype.splice,\n  slice: Array.prototype.slice,\n  push: Array.prototype.push,\n  length: 0,\n  queryParams: null\n});\n\nfunction findHandler(state, path, queryParams) {\n  var handlers = state.handlers,\n      regex = state.regex;\n  var captures = path.match(regex),\n      currentCapture = 1;\n  var result = new RecognizeResults(queryParams);\n\n  for (var i = 0, l = handlers.length; i < l; i++) {\n    var handler = handlers[i],\n        names = handler.names,\n        params = {};\n\n    for (var j = 0, m = names.length; j < m; j++) {\n      params[names[j]] = captures[currentCapture++];\n    }\n\n    result.push({ handler: handler.handler, params: params, isDynamic: !!names.length });\n  }\n\n  return result;\n}\n\nfunction addSegment(currentState, segment) {\n  segment.eachChar(function (ch) {\n    var state;\n\n    currentState = currentState.put(ch);\n  });\n\n  return currentState;\n}\n\nfunction decodeQueryParamPart(part) {\n  // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1\n  part = part.replace(/\\+/gm, '%20');\n  return decodeURIComponent(part);\n}\n\n// The main interface\n\nvar RouteRecognizer = function RouteRecognizer() {\n  this.rootState = new State();\n  this.names = {};\n};\n\nRouteRecognizer.prototype = {\n  add: function add(routes, options) {\n    var currentState = this.rootState,\n        regex = \"^\",\n        specificity = {},\n        handlers = [],\n        allSegments = [],\n        name;\n\n    var isEmpty = true;\n\n    for (var i = 0, l = routes.length; i < l; i++) {\n      var route = routes[i],\n          names = [];\n\n      var segments = parse(route.path, names, specificity);\n\n      allSegments = allSegments.concat(segments);\n\n      for (var j = 0, m = segments.length; j < m; j++) {\n        var segment = segments[j];\n\n        if (segment instanceof EpsilonSegment) {\n          continue;\n        }\n\n        isEmpty = false;\n\n        // Add a \"/\" for the new segment\n        currentState = currentState.put({ validChars: \"/\" });\n        regex += \"/\";\n\n        // Add a representation of the segment to the NFA and regex\n        currentState = addSegment(currentState, segment);\n        regex += segment.regex();\n      }\n\n      var handler = { handler: route.handler, names: names };\n      handlers.push(handler);\n    }\n\n    if (isEmpty) {\n      currentState = currentState.put({ validChars: \"/\" });\n      regex += \"/\";\n    }\n\n    currentState.handlers = handlers;\n    currentState.regex = new RegExp(regex + \"$\");\n    currentState.specificity = specificity;\n\n    if (name = options && options.as) {\n      this.names[name] = {\n        segments: allSegments,\n        handlers: handlers\n      };\n    }\n  },\n\n  handlersFor: function handlersFor(name) {\n    var route = this.names[name],\n        result = [];\n    if (!route) {\n      throw new Error(\"There is no route named \" + name);\n    }\n\n    for (var i = 0, l = route.handlers.length; i < l; i++) {\n      result.push(route.handlers[i]);\n    }\n\n    return result;\n  },\n\n  hasRoute: function hasRoute(name) {\n    return !!this.names[name];\n  },\n\n  generate: function generate(name, params) {\n    var route = this.names[name],\n        output = \"\";\n    if (!route) {\n      throw new Error(\"There is no route named \" + name);\n    }\n\n    var segments = route.segments;\n\n    for (var i = 0, l = segments.length; i < l; i++) {\n      var segment = segments[i];\n\n      if (segment instanceof EpsilonSegment) {\n        continue;\n      }\n\n      output += \"/\";\n      output += segment.generate(params);\n    }\n\n    if (output.charAt(0) !== '/') {\n      output = '/' + output;\n    }\n\n    if (params && params.queryParams) {\n      output += this.generateQueryString(params.queryParams);\n    }\n\n    return output;\n  },\n\n  generateQueryString: function generateQueryString(params) {\n    var pairs = [];\n    var keys = [];\n    for (var key in params) {\n      if (params.hasOwnProperty(key)) {\n        keys.push(key);\n      }\n    }\n    keys.sort();\n    for (var i = 0, len = keys.length; i < len; i++) {\n      key = keys[i];\n      var value = params[key];\n      if (value == null) {\n        continue;\n      }\n      var pair = encodeURIComponent(key);\n      if (isArray(value)) {\n        for (var j = 0, l = value.length; j < l; j++) {\n          var arrayPair = key + '[]' + '=' + encodeURIComponent(value[j]);\n          pairs.push(arrayPair);\n        }\n      } else {\n        pair += \"=\" + encodeURIComponent(value);\n        pairs.push(pair);\n      }\n    }\n\n    if (pairs.length === 0) {\n      return '';\n    }\n\n    return \"?\" + pairs.join(\"&\");\n  },\n\n  parseQueryString: function parseQueryString(queryString) {\n    var pairs = queryString.split(\"&\"),\n        queryParams = {};\n    for (var i = 0; i < pairs.length; i++) {\n      var pair = pairs[i].split('='),\n          key = decodeQueryParamPart(pair[0]),\n          keyLength = key.length,\n          isArray = false,\n          value;\n      if (pair.length === 1) {\n        value = 'true';\n      } else {\n        //Handle arrays\n        if (keyLength > 2 && key.slice(keyLength - 2) === '[]') {\n          isArray = true;\n          key = key.slice(0, keyLength - 2);\n          if (!queryParams[key]) {\n            queryParams[key] = [];\n          }\n        }\n        value = pair[1] ? decodeQueryParamPart(pair[1]) : '';\n      }\n      if (isArray) {\n        queryParams[key].push(value);\n      } else {\n        queryParams[key] = value;\n      }\n    }\n    return queryParams;\n  },\n\n  recognize: function recognize(path) {\n    var states = [this.rootState],\n        pathLen,\n        i,\n        l,\n        queryStart,\n        queryParams = {},\n        isSlashDropped = false;\n\n    queryStart = path.indexOf('?');\n    if (queryStart !== -1) {\n      var queryString = path.substr(queryStart + 1, path.length);\n      path = path.substr(0, queryStart);\n      queryParams = this.parseQueryString(queryString);\n    }\n\n    path = decodeURI(path);\n\n    // DEBUG GROUP path\n\n    if (path.charAt(0) !== \"/\") {\n      path = \"/\" + path;\n    }\n\n    pathLen = path.length;\n    if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n      path = path.substr(0, pathLen - 1);\n      isSlashDropped = true;\n    }\n\n    for (i = 0, l = path.length; i < l; i++) {\n      states = recognizeChar(states, path.charAt(i));\n      if (!states.length) {\n        break;\n      }\n    }\n\n    // END DEBUG GROUP\n\n    var solutions = [];\n    for (i = 0, l = states.length; i < l; i++) {\n      if (states[i].handlers) {\n        solutions.push(states[i]);\n      }\n    }\n\n    states = sortSolutions(solutions);\n\n    var state = solutions[0];\n\n    if (state && state.handlers) {\n      // if a trailing slash was dropped and a star segment is the last segment\n      // specified, put the trailing slash back\n      if (isSlashDropped && state.regex.source.slice(-5) === \"(.+)$\") {\n        path = path + \"/\";\n      }\n      return findHandler(state, path, queryParams);\n    }\n  }\n};\n\nRouteRecognizer.prototype.map = map;\n\nRouteRecognizer.VERSION = '0.1.9';\n\nvar genQuery = RouteRecognizer.prototype.generateQueryString;\n\n// export default for holding the Vue reference\nvar exports$1 = {};\n/**\n * Warn stuff.\n *\n * @param {String} msg\n */\n\nfunction warn(msg) {\n  /* istanbul ignore next */\n  if (window.console) {\n    console.warn('[vue-router] ' + msg);\n    /* istanbul ignore if */\n    if (!exports$1.Vue || exports$1.Vue.config.debug) {\n      console.warn(new Error('warning stack trace:').stack);\n    }\n  }\n}\n\n/**\n * Resolve a relative path.\n *\n * @param {String} base\n * @param {String} relative\n * @param {Boolean} append\n * @return {String}\n */\n\nfunction resolvePath(base, relative, append) {\n  var query = base.match(/(\\?.*)$/);\n  if (query) {\n    query = query[1];\n    base = base.slice(0, -query.length);\n  }\n  // a query!\n  if (relative.charAt(0) === '?') {\n    return base + relative;\n  }\n  var stack = base.split('/');\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  }\n  // resolve relative path\n  var segments = relative.replace(/^\\//, '').split('/');\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (segment === '.') {\n      continue;\n    } else if (segment === '..') {\n      stack.pop();\n    } else {\n      stack.push(segment);\n    }\n  }\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n  return stack.join('/');\n}\n\n/**\n * Forgiving check for a promise\n *\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction isPromise(p) {\n  return p && typeof p.then === 'function';\n}\n\n/**\n * Retrive a route config field from a component instance\n * OR a component contructor.\n *\n * @param {Function|Vue} component\n * @param {String} name\n * @return {*}\n */\n\nfunction getRouteConfig(component, name) {\n  var options = component && (component.$options || component.options);\n  return options && options.route && options.route[name];\n}\n\n/**\n * Resolve an async component factory. Have to do a dirty\n * mock here because of Vue core's internal API depends on\n * an ID check.\n *\n * @param {Object} handler\n * @param {Function} cb\n */\n\nvar resolver = undefined;\n\nfunction resolveAsyncComponent(handler, cb) {\n  if (!resolver) {\n    resolver = {\n      resolve: exports$1.Vue.prototype._resolveComponent,\n      $options: {\n        components: {\n          _: handler.component\n        }\n      }\n    };\n  } else {\n    resolver.$options.components._ = handler.component;\n  }\n  resolver.resolve('_', function (Component) {\n    handler.component = Component;\n    cb(Component);\n  });\n}\n\n/**\n * Map the dynamic segments in a path to params.\n *\n * @param {String} path\n * @param {Object} params\n * @param {Object} query\n */\n\nfunction mapParams(path, params, query) {\n  if (params === undefined) params = {};\n\n  path = path.replace(/:([^\\/]+)/g, function (_, key) {\n    var val = params[key];\n    if (!val) {\n      warn('param \"' + key + '\" not found when generating ' + 'path for \"' + path + '\" with params ' + JSON.stringify(params));\n    }\n    return val || '';\n  });\n  if (query) {\n    path += genQuery(query);\n  }\n  return path;\n}\n\nvar hashRE = /#.*$/;\n\nvar HTML5History = (function () {\n  function HTML5History(_ref) {\n    var root = _ref.root;\n    var onChange = _ref.onChange;\n    babelHelpers.classCallCheck(this, HTML5History);\n\n    if (root) {\n      // make sure there's the starting slash\n      if (root.charAt(0) !== '/') {\n        root = '/' + root;\n      }\n      // remove trailing slash\n      this.root = root.replace(/\\/$/, '');\n      this.rootRE = new RegExp('^\\\\' + this.root);\n    } else {\n      this.root = null;\n    }\n    this.onChange = onChange;\n    // check base tag\n    var baseEl = document.querySelector('base');\n    this.base = baseEl && baseEl.getAttribute('href');\n  }\n\n  HTML5History.prototype.start = function start() {\n    var _this = this;\n\n    this.listener = function (e) {\n      var url = decodeURI(location.pathname + location.search);\n      if (_this.root) {\n        url = url.replace(_this.rootRE, '');\n      }\n      _this.onChange(url, e && e.state, location.hash);\n    };\n    window.addEventListener('popstate', this.listener);\n    this.listener();\n  };\n\n  HTML5History.prototype.stop = function stop() {\n    window.removeEventListener('popstate', this.listener);\n  };\n\n  HTML5History.prototype.go = function go(path, replace, append) {\n    var url = this.formatPath(path, append);\n    if (replace) {\n      history.replaceState({}, '', url);\n    } else {\n      // record scroll position by replacing current state\n      history.replaceState({\n        pos: {\n          x: window.pageXOffset,\n          y: window.pageYOffset\n        }\n      }, '');\n      // then push new state\n      history.pushState({}, '', url);\n    }\n    var hashMatch = path.match(hashRE);\n    var hash = hashMatch && hashMatch[0];\n    path = url\n    // strip hash so it doesn't mess up params\n    .replace(hashRE, '')\n    // remove root before matching\n    .replace(this.rootRE, '');\n    this.onChange(path, null, hash);\n  };\n\n  HTML5History.prototype.formatPath = function formatPath(path, append) {\n    return path.charAt(0) === '/'\n    // absolute path\n    ? this.root ? this.root + '/' + path.replace(/^\\//, '') : path : resolvePath(this.base || location.pathname, path, append);\n  };\n\n  return HTML5History;\n})();\n\nvar HashHistory = (function () {\n  function HashHistory(_ref) {\n    var hashbang = _ref.hashbang;\n    var onChange = _ref.onChange;\n    babelHelpers.classCallCheck(this, HashHistory);\n\n    this.hashbang = hashbang;\n    this.onChange = onChange;\n  }\n\n  HashHistory.prototype.start = function start() {\n    var self = this;\n    this.listener = function () {\n      var path = location.hash;\n      var raw = path.replace(/^#!?/, '');\n      // always\n      if (raw.charAt(0) !== '/') {\n        raw = '/' + raw;\n      }\n      var formattedPath = self.formatPath(raw);\n      if (formattedPath !== path) {\n        location.replace(formattedPath);\n        return;\n      }\n      // determine query\n      // note it's possible to have queries in both the actual URL\n      // and the hash fragment itself.\n      var query = location.search && path.indexOf('?') > -1 ? '&' + location.search.slice(1) : location.search;\n      self.onChange(decodeURI(path.replace(/^#!?/, '') + query));\n    };\n    window.addEventListener('hashchange', this.listener);\n    this.listener();\n  };\n\n  HashHistory.prototype.stop = function stop() {\n    window.removeEventListener('hashchange', this.listener);\n  };\n\n  HashHistory.prototype.go = function go(path, replace, append) {\n    path = this.formatPath(path, append);\n    if (replace) {\n      location.replace(path);\n    } else {\n      location.hash = path;\n    }\n  };\n\n  HashHistory.prototype.formatPath = function formatPath(path, append) {\n    var isAbsoloute = path.charAt(0) === '/';\n    var prefix = '#' + (this.hashbang ? '!' : '');\n    return isAbsoloute ? prefix + path : prefix + resolvePath(location.hash.replace(/^#!?/, ''), path, append);\n  };\n\n  return HashHistory;\n})();\n\nvar AbstractHistory = (function () {\n  function AbstractHistory(_ref) {\n    var onChange = _ref.onChange;\n    babelHelpers.classCallCheck(this, AbstractHistory);\n\n    this.onChange = onChange;\n    this.currentPath = '/';\n  }\n\n  AbstractHistory.prototype.start = function start() {\n    this.onChange('/');\n  };\n\n  AbstractHistory.prototype.stop = function stop() {\n    // noop\n  };\n\n  AbstractHistory.prototype.go = function go(path, replace, append) {\n    path = this.currentPath = this.formatPath(path, append);\n    this.onChange(path);\n  };\n\n  AbstractHistory.prototype.formatPath = function formatPath(path, append) {\n    return path.charAt(0) === '/' ? path : resolvePath(this.currentPath, path, append);\n  };\n\n  return AbstractHistory;\n})();\n\n/**\n * Determine the reusability of an existing router view.\n *\n * @param {Directive} view\n * @param {Object} handler\n * @param {Transition} transition\n */\n\nfunction canReuse(view, handler, transition) {\n  var component = view.childVM;\n  if (!component || !handler) {\n    return false;\n  }\n  // important: check view.Component here because it may\n  // have been changed in activate hook\n  if (view.Component !== handler.component) {\n    return false;\n  }\n  var canReuseFn = getRouteConfig(component, 'canReuse');\n  return typeof canReuseFn === 'boolean' ? canReuseFn : canReuseFn ? canReuseFn.call(component, {\n    to: transition.to,\n    from: transition.from\n  }) : true; // defaults to true\n}\n\n/**\n * Check if a component can deactivate.\n *\n * @param {Directive} view\n * @param {Transition} transition\n * @param {Function} next\n */\n\nfunction canDeactivate(view, transition, next) {\n  var fromComponent = view.childVM;\n  var hook = getRouteConfig(fromComponent, 'canDeactivate');\n  if (!hook) {\n    next();\n  } else {\n    transition.callHook(hook, fromComponent, next, {\n      expectBoolean: true\n    });\n  }\n}\n\n/**\n * Check if a component can activate.\n *\n * @param {Object} handler\n * @param {Transition} transition\n * @param {Function} next\n */\n\nfunction canActivate(handler, transition, next) {\n  resolveAsyncComponent(handler, function (Component) {\n    // have to check due to async-ness\n    if (transition.aborted) {\n      return;\n    }\n    // determine if this component can be activated\n    var hook = getRouteConfig(Component, 'canActivate');\n    if (!hook) {\n      next();\n    } else {\n      transition.callHook(hook, null, next, {\n        expectBoolean: true\n      });\n    }\n  });\n}\n\n/**\n * Call deactivate hooks for existing router-views.\n *\n * @param {Directive} view\n * @param {Transition} transition\n * @param {Function} next\n */\n\nfunction deactivate(view, transition, next) {\n  var component = view.childVM;\n  var hook = getRouteConfig(component, 'deactivate');\n  if (!hook) {\n    next();\n  } else {\n    transition.callHooks(hook, component, next);\n  }\n}\n\n/**\n * Activate / switch component for a router-view.\n *\n * @param {Directive} view\n * @param {Transition} transition\n * @param {Number} depth\n * @param {Function} [cb]\n */\n\nfunction activate(view, transition, depth, cb, reuse) {\n  var handler = transition.activateQueue[depth];\n  if (!handler) {\n    // fix 1.0.0-alpha.3 compat\n    if (view._bound) {\n      view.setComponent(null);\n    }\n    cb && cb();\n    return;\n  }\n\n  var Component = view.Component = handler.component;\n  var activateHook = getRouteConfig(Component, 'activate');\n  var dataHook = getRouteConfig(Component, 'data');\n  var waitForData = getRouteConfig(Component, 'waitForData');\n\n  view.depth = depth;\n  view.activated = false;\n\n  var component = undefined;\n  var loading = !!(dataHook && !waitForData);\n\n  // \"reuse\" is a flag passed down when the parent view is\n  // either reused via keep-alive or as a child of a kept-alive view.\n  // of course we can only reuse if the current kept-alive instance\n  // is of the correct type.\n  reuse = reuse && view.childVM && view.childVM.constructor === Component;\n\n  if (reuse) {\n    // just reuse\n    component = view.childVM;\n    component.$loadingRouteData = loading;\n  } else {\n    // unbuild current component. this step also destroys\n    // and removes all nested child views.\n    view.unbuild(true);\n    // handle keep-alive.\n    // if the view has keep-alive, the child vm is not actually\n    // destroyed - its nested views will still be in router's\n    // view list. We need to removed these child views and\n    // cache them on the child vm.\n    if (view.keepAlive) {\n      var views = transition.router._views;\n      var i = views.indexOf(view);\n      if (i > 0) {\n        transition.router._views = views.slice(i);\n        if (view.childVM) {\n          view.childVM._routerViews = views.slice(0, i);\n        }\n      }\n    }\n\n    // build the new component. this will also create the\n    // direct child view of the current one. it will register\n    // itself as view.childView.\n    component = view.build({\n      _meta: {\n        $loadingRouteData: loading\n      }\n    });\n    // handle keep-alive.\n    // when a kept-alive child vm is restored, we need to\n    // add its cached child views into the router's view list,\n    // and also properly update current view's child view.\n    if (view.keepAlive) {\n      component.$loadingRouteData = loading;\n      var cachedViews = component._routerViews;\n      if (cachedViews) {\n        transition.router._views = cachedViews.concat(transition.router._views);\n        view.childView = cachedViews[cachedViews.length - 1];\n        component._routerViews = null;\n      }\n    }\n  }\n\n  // cleanup the component in case the transition is aborted\n  // before the component is ever inserted.\n  var cleanup = function cleanup() {\n    component.$destroy();\n  };\n\n  // actually insert the component and trigger transition\n  var insert = function insert() {\n    if (reuse) {\n      cb && cb();\n      return;\n    }\n    var router = transition.router;\n    if (router._rendered || router._transitionOnLoad) {\n      view.transition(component);\n    } else {\n      // no transition on first render, manual transition\n      /* istanbul ignore if */\n      if (view.setCurrent) {\n        // 0.12 compat\n        view.setCurrent(component);\n      } else {\n        // 1.0\n        view.childVM = component;\n      }\n      component.$before(view.anchor, null, false);\n    }\n    cb && cb();\n  };\n\n  // called after activation hook is resolved\n  var afterActivate = function afterActivate() {\n    view.activated = true;\n    // activate the child view\n    if (view.childView) {\n      activate(view.childView, transition, depth + 1, null, reuse || view.keepAlive);\n    }\n    if (dataHook && waitForData) {\n      // wait until data loaded to insert\n      loadData(component, transition, dataHook, insert, cleanup);\n    } else {\n      // load data and insert at the same time\n      if (dataHook) {\n        loadData(component, transition, dataHook);\n      }\n      insert();\n    }\n  };\n\n  if (activateHook) {\n    transition.callHooks(activateHook, component, afterActivate, {\n      cleanup: cleanup\n    });\n  } else {\n    afterActivate();\n  }\n}\n\n/**\n * Reuse a view, just reload data if necessary.\n *\n * @param {Directive} view\n * @param {Transition} transition\n */\n\nfunction reuse(view, transition) {\n  var component = view.childVM;\n  var dataHook = getRouteConfig(component, 'data');\n  if (dataHook) {\n    loadData(component, transition, dataHook);\n  }\n}\n\n/**\n * Asynchronously load and apply data to component.\n *\n * @param {Vue} component\n * @param {Transition} transition\n * @param {Function} hook\n * @param {Function} cb\n * @param {Function} cleanup\n */\n\nfunction loadData(component, transition, hook, cb, cleanup) {\n  component.$loadingRouteData = true;\n  transition.callHooks(hook, component, function (data, onError) {\n    // merge data from multiple data hooks\n    if (Array.isArray(data) && data._needMerge) {\n      data = data.reduce(function (res, obj) {\n        if (isPlainObject(obj)) {\n          Object.keys(obj).forEach(function (key) {\n            res[key] = obj[key];\n          });\n        }\n        return res;\n      }, Object.create(null));\n    }\n    // handle promise sugar syntax\n    var promises = [];\n    if (isPlainObject(data)) {\n      Object.keys(data).forEach(function (key) {\n        var val = data[key];\n        if (isPromise(val)) {\n          promises.push(val.then(function (resolvedVal) {\n            component.$set(key, resolvedVal);\n          }));\n        } else {\n          component.$set(key, val);\n        }\n      });\n    }\n    if (!promises.length) {\n      component.$loadingRouteData = false;\n      cb && cb();\n    } else {\n      promises[0].constructor.all(promises).then(function (_) {\n        component.$loadingRouteData = false;\n        cb && cb();\n      }, onError);\n    }\n  }, {\n    cleanup: cleanup,\n    expectData: true\n  });\n}\n\nfunction isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n\n/**\n * A RouteTransition object manages the pipeline of a\n * router-view switching process. This is also the object\n * passed into user route hooks.\n *\n * @param {Router} router\n * @param {Route} to\n * @param {Route} from\n */\n\nvar RouteTransition = (function () {\n  function RouteTransition(router, to, from) {\n    babelHelpers.classCallCheck(this, RouteTransition);\n\n    this.router = router;\n    this.to = to;\n    this.from = from;\n    this.next = null;\n    this.aborted = false;\n    this.done = false;\n\n    // start by determine the queues\n\n    // the deactivate queue is an array of router-view\n    // directive instances that need to be deactivated,\n    // deepest first.\n    this.deactivateQueue = router._views;\n\n    // check the default handler of the deepest match\n    var matched = to.matched ? Array.prototype.slice.call(to.matched) : [];\n\n    // the activate queue is an array of route handlers\n    // that need to be activated\n    this.activateQueue = matched.map(function (match) {\n      return match.handler;\n    });\n  }\n\n  /**\n   * Abort current transition and return to previous location.\n   */\n\n  RouteTransition.prototype.abort = function abort() {\n    if (!this.aborted) {\n      this.aborted = true;\n      // if the root path throws an error during validation\n      // on initial load, it gets caught in an infinite loop.\n      var abortingOnLoad = !this.from.path && this.to.path === '/';\n      if (!abortingOnLoad) {\n        this.router.replace(this.from.path || '/');\n      }\n    }\n  };\n\n  /**\n   * Abort current transition and redirect to a new location.\n   *\n   * @param {String} path\n   */\n\n  RouteTransition.prototype.redirect = function redirect(path) {\n    if (!this.aborted) {\n      this.aborted = true;\n      if (typeof path === 'string') {\n        path = mapParams(path, this.to.params, this.to.query);\n      } else {\n        path.params = path.params || this.to.params;\n        path.query = path.query || this.to.query;\n      }\n      this.router.replace(path);\n    }\n  };\n\n  /**\n   * A router view transition's pipeline can be described as\n   * follows, assuming we are transitioning from an existing\n   * <router-view> chain [Component A, Component B] to a new\n   * chain [Component A, Component C]:\n   *\n   *  A    A\n   *  | => |\n   *  B    C\n   *\n   * 1. Reusablity phase:\n   *   -> canReuse(A, A)\n   *   -> canReuse(B, C)\n   *   -> determine new queues:\n   *      - deactivation: [B]\n   *      - activation: [C]\n   *\n   * 2. Validation phase:\n   *   -> canDeactivate(B)\n   *   -> canActivate(C)\n   *\n   * 3. Activation phase:\n   *   -> deactivate(B)\n   *   -> activate(C)\n   *\n   * Each of these steps can be asynchronous, and any\n   * step can potentially abort the transition.\n   *\n   * @param {Function} cb\n   */\n\n  RouteTransition.prototype.start = function start(cb) {\n    var transition = this;\n    var daq = this.deactivateQueue;\n    var aq = this.activateQueue;\n    var rdaq = daq.slice().reverse();\n    var reuseQueue = undefined;\n\n    // 1. Reusability phase\n    var i = undefined;\n    for (i = 0; i < rdaq.length; i++) {\n      if (!canReuse(rdaq[i], aq[i], transition)) {\n        break;\n      }\n    }\n    if (i > 0) {\n      reuseQueue = rdaq.slice(0, i);\n      daq = rdaq.slice(i).reverse();\n      aq = aq.slice(i);\n    }\n\n    // 2. Validation phase\n    transition.runQueue(daq, canDeactivate, function () {\n      transition.runQueue(aq, canActivate, function () {\n        transition.runQueue(daq, deactivate, function () {\n          // 3. Activation phase\n\n          // Update router current route\n          transition.router._onTransitionValidated(transition);\n\n          // trigger reuse for all reused views\n          reuseQueue && reuseQueue.forEach(function (view) {\n            reuse(view, transition);\n          });\n\n          // the root of the chain that needs to be replaced\n          // is the top-most non-reusable view.\n          if (daq.length) {\n            var view = daq[daq.length - 1];\n            var depth = reuseQueue ? reuseQueue.length : 0;\n            activate(view, transition, depth, cb);\n          } else {\n            cb();\n          }\n        });\n      });\n    });\n  };\n\n  /**\n   * Asynchronously and sequentially apply a function to a\n   * queue.\n   *\n   * @param {Array} queue\n   * @param {Function} fn\n   * @param {Function} cb\n   */\n\n  RouteTransition.prototype.runQueue = function runQueue(queue, fn, cb) {\n    var transition = this;\n    step(0);\n    function step(index) {\n      if (index >= queue.length) {\n        cb();\n      } else {\n        fn(queue[index], transition, function () {\n          step(index + 1);\n        });\n      }\n    }\n  };\n\n  /**\n   * Call a user provided route transition hook and handle\n   * the response (e.g. if the user returns a promise).\n   *\n   * If the user neither expects an argument nor returns a\n   * promise, the hook is assumed to be synchronous.\n   *\n   * @param {Function} hook\n   * @param {*} [context]\n   * @param {Function} [cb]\n   * @param {Object} [options]\n   *                 - {Boolean} expectBoolean\n   *                 - {Boolean} expectData\n   *                 - {Function} cleanup\n   */\n\n  RouteTransition.prototype.callHook = function callHook(hook, context, cb) {\n    var _ref = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n    var _ref$expectBoolean = _ref.expectBoolean;\n    var expectBoolean = _ref$expectBoolean === undefined ? false : _ref$expectBoolean;\n    var _ref$expectData = _ref.expectData;\n    var expectData = _ref$expectData === undefined ? false : _ref$expectData;\n    var cleanup = _ref.cleanup;\n\n    var transition = this;\n    var nextCalled = false;\n\n    // abort the transition\n    var abort = function abort() {\n      cleanup && cleanup();\n      transition.abort();\n    };\n\n    // handle errors\n    var onError = function onError(err) {\n      // cleanup indicates an after-activation hook,\n      // so instead of aborting we just let the transition\n      // finish.\n      cleanup ? next() : abort();\n      if (err && !transition.router._suppress) {\n        warn('Uncaught error during transition: ');\n        throw err instanceof Error ? err : new Error(err);\n      }\n    };\n\n    // advance the transition to the next step\n    var next = function next(data) {\n      if (nextCalled) {\n        warn('transition.next() should be called only once.');\n        return;\n      }\n      nextCalled = true;\n      if (transition.aborted) {\n        cleanup && cleanup();\n        return;\n      }\n      cb && cb(data, onError);\n    };\n\n    // expose a clone of the transition object, so that each\n    // hook gets a clean copy and prevent the user from\n    // messing with the internals.\n    var exposed = {\n      to: transition.to,\n      from: transition.from,\n      abort: abort,\n      next: next,\n      redirect: function redirect() {\n        transition.redirect.apply(transition, arguments);\n      }\n    };\n\n    // actually call the hook\n    var res = undefined;\n    try {\n      res = hook.call(context, exposed);\n    } catch (err) {\n      return onError(err);\n    }\n\n    // handle boolean/promise return values\n    var resIsPromise = isPromise(res);\n    if (expectBoolean) {\n      if (typeof res === 'boolean') {\n        res ? next() : abort();\n      } else if (resIsPromise) {\n        res.then(function (ok) {\n          ok ? next() : abort();\n        }, onError);\n      } else if (!hook.length) {\n        next(res);\n      }\n    } else if (resIsPromise) {\n      res.then(next, onError);\n    } else if (expectData && isPlainOjbect(res) || !hook.length) {\n      next(res);\n    }\n  };\n\n  /**\n   * Call a single hook or an array of async hooks in series.\n   *\n   * @param {Array} hooks\n   * @param {*} context\n   * @param {Function} cb\n   * @param {Object} [options]\n   */\n\n  RouteTransition.prototype.callHooks = function callHooks(hooks, context, cb, options) {\n    var _this = this;\n\n    if (Array.isArray(hooks)) {\n      (function () {\n        var res = [];\n        res._needMerge = true;\n        var onError = undefined;\n        _this.runQueue(hooks, function (hook, _, next) {\n          if (!_this.aborted) {\n            _this.callHook(hook, context, function (r, onError) {\n              if (r) res.push(r);\n              onError = onError;\n              next();\n            }, options);\n          }\n        }, function () {\n          cb(res, onError);\n        });\n      })();\n    } else {\n      this.callHook(hooks, context, cb, options);\n    }\n  };\n\n  return RouteTransition;\n})();\n\nfunction isPlainOjbect(val) {\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n\nvar internalKeysRE = /^(component|subRoutes)$/;\n\n/**\n * Route Context Object\n *\n * @param {String} path\n * @param {Router} router\n */\n\nvar Route = function Route(path, router) {\n  var _this = this;\n\n  babelHelpers.classCallCheck(this, Route);\n\n  var matched = router._recognizer.recognize(path);\n  if (matched) {\n    // copy all custom fields from route configs\n    [].forEach.call(matched, function (match) {\n      for (var key in match.handler) {\n        if (!internalKeysRE.test(key)) {\n          _this[key] = match.handler[key];\n        }\n      }\n    });\n    // set query and params\n    this.query = matched.queryParams;\n    this.params = [].reduce.call(matched, function (prev, cur) {\n      if (cur.params) {\n        for (var key in cur.params) {\n          prev[key] = cur.params[key];\n        }\n      }\n      return prev;\n    }, {});\n  }\n  // expose path and router\n  this.path = path;\n  this.router = router;\n  // for internal use\n  this.matched = matched || router._notFoundHandler;\n  // Important: freeze self to prevent observation\n  Object.freeze(this);\n};\n\nfunction applyOverride (Vue) {\n\n  var _ = Vue.util;\n\n  // override Vue's init and destroy process to keep track of router instances\n  var init = Vue.prototype._init;\n  Vue.prototype._init = function (options) {\n    var root = options._parent || options.parent || this;\n    var route = root.$route;\n    if (route) {\n      route.router._children.push(this);\n      if (!this.$route) {\n        /* istanbul ignore if */\n        if (this._defineMeta) {\n          // 0.12\n          this._defineMeta('$route', route);\n        } else {\n          // 1.0\n          _.defineReactive(this, '$route', route);\n        }\n      }\n    }\n    init.call(this, options);\n  };\n\n  var destroy = Vue.prototype._destroy;\n  Vue.prototype._destroy = function () {\n    if (!this._isBeingDestroyed) {\n      var route = this.$root.$route;\n      if (route) {\n        route.router._children.$remove(this);\n      }\n      destroy.apply(this, arguments);\n    }\n  };\n\n  // 1.0 only: enable route mixins\n  var strats = Vue.config.optionMergeStrategies;\n  var hooksToMergeRE = /^(data|activate|deactivate)$/;\n\n  if (strats) {\n    strats.route = function (parentVal, childVal) {\n      if (!childVal) return parentVal;\n      if (!parentVal) return childVal;\n      var ret = {};\n      _.extend(ret, parentVal);\n      for (var key in childVal) {\n        var a = ret[key];\n        var b = childVal[key];\n        // for data, activate and deactivate, we need to merge them into\n        // arrays similar to lifecycle hooks.\n        if (a && hooksToMergeRE.test(key)) {\n          ret[key] = (_.isArray(a) ? a : [a]).concat(b);\n        } else {\n          ret[key] = b;\n        }\n      }\n      return ret;\n    };\n  }\n}\n\nfunction View (Vue) {\n\n  var _ = Vue.util;\n  var componentDef =\n  // 0.12\n  Vue.directive('_component') ||\n  // 1.0\n  Vue.internalDirectives.component;\n  // <router-view> extends the internal component directive\n  var viewDef = _.extend({}, componentDef);\n\n  // with some overrides\n  _.extend(viewDef, {\n\n    _isRouterView: true,\n\n    bind: function bind() {\n      var route = this.vm.$route;\n      /* istanbul ignore if */\n      if (!route) {\n        warn('<router-view> can only be used inside a ' + 'router-enabled app.');\n        return;\n      }\n      // force dynamic directive so v-component doesn't\n      // attempt to build right now\n      this._isDynamicLiteral = true;\n      // finally, init by delegating to v-component\n      componentDef.bind.call(this);\n\n      // all we need to do here is registering this view\n      // in the router. actual component switching will be\n      // managed by the pipeline.\n      var router = this.router = route.router;\n      router._views.unshift(this);\n\n      // note the views are in reverse order.\n      var parentView = router._views[1];\n      if (parentView) {\n        // register self as a child of the parent view,\n        // instead of activating now. This is so that the\n        // child's activate hook is called after the\n        // parent's has resolved.\n        parentView.childView = this;\n      }\n\n      // handle late-rendered view\n      // two possibilities:\n      // 1. root view rendered after transition has been\n      //    validated;\n      // 2. child view rendered after parent view has been\n      //    activated.\n      var transition = route.router._currentTransition;\n      if (!parentView && transition.done || parentView && parentView.activated) {\n        var depth = parentView ? parentView.depth + 1 : 0;\n        activate(this, transition, depth);\n      }\n    },\n\n    unbind: function unbind() {\n      this.router._views.$remove(this);\n      componentDef.unbind.call(this);\n    }\n  });\n\n  Vue.elementDirective('router-view', viewDef);\n}\n\nvar trailingSlashRE = /\\/$/;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\nvar queryStringRE = /\\?.*$/;\n\n// install v-link, which provides navigation support for\n// HTML5 history mode\nfunction Link (Vue) {\n\n  var _ = Vue.util;\n\n  Vue.directive('link', {\n\n    bind: function bind() {\n      var _this = this;\n\n      var vm = this.vm;\n      /* istanbul ignore if */\n      if (!vm.$route) {\n        warn('v-link can only be used inside a ' + 'router-enabled app.');\n        return;\n      }\n      // no need to handle click if link expects to be opened\n      // in a new window/tab.\n      /* istanbul ignore if */\n      if (this.el.tagName === 'A' && this.el.getAttribute('target') === '_blank') {\n        return;\n      }\n      // handle click\n      var router = vm.$route.router;\n      this.handler = function (e) {\n        // don't redirect with control keys\n        if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n        // don't redirect when preventDefault called\n        if (e.defaultPrevented) return;\n        // don't redirect on right click\n        if (e.button !== 0) return;\n\n        var target = _this.target;\n        var go = function go(target) {\n          e.preventDefault();\n          if (target != null) {\n            router.go(target);\n          }\n        };\n\n        if (_this.el.tagName === 'A' || e.target === _this.el) {\n          // v-link on <a v-link=\"'path'\">\n          go(target);\n        } else {\n          // v-link delegate on <div v-link>\n          var el = e.target;\n          while (el && el.tagName !== 'A' && el !== _this.el) {\n            el = el.parentNode;\n          }\n          if (!el) return;\n          if (el.tagName !== 'A' || !el.href) {\n            // allow not anchor\n            go(target);\n          } else if (sameOrigin(el)) {\n            go({\n              path: el.pathname,\n              replace: target && target.replace,\n              append: target && target.append\n            });\n          }\n        }\n      };\n      this.el.addEventListener('click', this.handler);\n      // manage active link class\n      this.unwatch = vm.$watch('$route.path', _.bind(this.updateClasses, this));\n    },\n\n    update: function update(path) {\n      var router = this.vm.$route.router;\n      var append = undefined;\n      this.target = path;\n      if (_.isObject(path)) {\n        append = path.append;\n        this.exact = path.exact;\n        this.prevActiveClass = this.activeClass;\n        this.activeClass = path.activeClass;\n      }\n      path = this.path = router._stringifyPath(path);\n      this.activeRE = path && !this.exact ? new RegExp('^' + path.replace(/\\/$/, '').replace(regexEscapeRE, '\\\\$&') + '(\\\\/|$)') : null;\n      this.updateClasses(this.vm.$route.path);\n      var isAbsolute = path.charAt(0) === '/';\n      // do not format non-hash relative paths\n      var href = path && (router.mode === 'hash' || isAbsolute) ? router.history.formatPath(path, append) : path;\n      if (this.el.tagName === 'A') {\n        if (href) {\n          this.el.href = href;\n        } else {\n          this.el.removeAttribute('href');\n        }\n      }\n    },\n\n    updateClasses: function updateClasses(path) {\n      var el = this.el;\n      var router = this.vm.$route.router;\n      var activeClass = this.activeClass || router._linkActiveClass;\n      // clear old class\n      if (this.prevActiveClass !== activeClass) {\n        _.removeClass(el, this.prevActiveClass);\n      }\n      // remove query string before matching\n      var dest = this.path.replace(queryStringRE, '');\n      path = path.replace(queryStringRE, '');\n      // add new class\n      if (this.exact) {\n        if (dest === path ||\n        // also allow additional trailing slash\n        dest.charAt(dest.length - 1) !== '/' && dest === path.replace(trailingSlashRE, '')) {\n          _.addClass(el, activeClass);\n        } else {\n          _.removeClass(el, activeClass);\n        }\n      } else {\n        if (this.activeRE && this.activeRE.test(path)) {\n          _.addClass(el, activeClass);\n        } else {\n          _.removeClass(el, activeClass);\n        }\n      }\n    },\n\n    unbind: function unbind() {\n      this.el.removeEventListener('click', this.handler);\n      this.unwatch && this.unwatch();\n    }\n  });\n\n  function sameOrigin(link) {\n    return link.protocol === location.protocol && link.hostname === location.hostname && link.port === location.port;\n  }\n}\n\nvar historyBackends = {\n  abstract: AbstractHistory,\n  hash: HashHistory,\n  html5: HTML5History\n};\n\n// late bind during install\nvar Vue = undefined;\n\n/**\n * Router constructor\n *\n * @param {Object} [options]\n */\n\nvar Router = (function () {\n  function Router() {\n    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    var _ref$hashbang = _ref.hashbang;\n    var hashbang = _ref$hashbang === undefined ? true : _ref$hashbang;\n    var _ref$abstract = _ref.abstract;\n    var abstract = _ref$abstract === undefined ? false : _ref$abstract;\n    var _ref$history = _ref.history;\n    var history = _ref$history === undefined ? false : _ref$history;\n    var _ref$saveScrollPosition = _ref.saveScrollPosition;\n    var saveScrollPosition = _ref$saveScrollPosition === undefined ? false : _ref$saveScrollPosition;\n    var _ref$transitionOnLoad = _ref.transitionOnLoad;\n    var transitionOnLoad = _ref$transitionOnLoad === undefined ? false : _ref$transitionOnLoad;\n    var _ref$suppressTransitionError = _ref.suppressTransitionError;\n    var suppressTransitionError = _ref$suppressTransitionError === undefined ? false : _ref$suppressTransitionError;\n    var _ref$root = _ref.root;\n    var root = _ref$root === undefined ? null : _ref$root;\n    var _ref$linkActiveClass = _ref.linkActiveClass;\n    var linkActiveClass = _ref$linkActiveClass === undefined ? 'v-link-active' : _ref$linkActiveClass;\n    babelHelpers.classCallCheck(this, Router);\n\n    /* istanbul ignore if */\n    if (!Router.installed) {\n      throw new Error('Please install the Router with Vue.use() before ' + 'creating an instance.');\n    }\n\n    // Vue instances\n    this.app = null;\n    this._views = [];\n    this._children = [];\n\n    // route recognizer\n    this._recognizer = new RouteRecognizer();\n    this._guardRecognizer = new RouteRecognizer();\n\n    // state\n    this._started = false;\n    this._startCb = null;\n    this._currentRoute = {};\n    this._currentTransition = null;\n    this._previousTransition = null;\n    this._notFoundHandler = null;\n    this._notFoundRedirect = null;\n    this._beforeEachHooks = [];\n    this._afterEachHooks = [];\n\n    // feature detection\n    this._hasPushState = typeof window !== 'undefined' && window.history && window.history.pushState;\n\n    // trigger transition on initial render?\n    this._rendered = false;\n    this._transitionOnLoad = transitionOnLoad;\n\n    // history mode\n    this._abstract = abstract;\n    this._hashbang = hashbang;\n    this._history = this._hasPushState && history;\n\n    // other options\n    this._saveScrollPosition = saveScrollPosition;\n    this._linkActiveClass = linkActiveClass;\n    this._suppress = suppressTransitionError;\n\n    // create history object\n    var inBrowser = Vue.util.inBrowser;\n    this.mode = !inBrowser || this._abstract ? 'abstract' : this._history ? 'html5' : 'hash';\n\n    var History = historyBackends[this.mode];\n    var self = this;\n    this.history = new History({\n      root: root,\n      hashbang: this._hashbang,\n      onChange: function onChange(path, state, anchor) {\n        self._match(path, state, anchor);\n      }\n    });\n  }\n\n  /**\n   * Allow directly passing components to a route\n   * definition.\n   *\n   * @param {String} path\n   * @param {Object} handler\n   */\n\n  // API ===================================================\n\n  /**\n  * Register a map of top-level paths.\n  *\n  * @param {Object} map\n  */\n\n  Router.prototype.map = function map(_map) {\n    for (var route in _map) {\n      this.on(route, _map[route]);\n    }\n  };\n\n  /**\n   * Register a single root-level path\n   *\n   * @param {String} rootPath\n   * @param {Object} handler\n   *                 - {String} component\n   *                 - {Object} [subRoutes]\n   *                 - {Boolean} [forceRefresh]\n   *                 - {Function} [before]\n   *                 - {Function} [after]\n   */\n\n  Router.prototype.on = function on(rootPath, handler) {\n    if (rootPath === '*') {\n      this._notFound(handler);\n    } else {\n      this._addRoute(rootPath, handler, []);\n    }\n  };\n\n  /**\n   * Set redirects.\n   *\n   * @param {Object} map\n   */\n\n  Router.prototype.redirect = function redirect(map) {\n    for (var path in map) {\n      this._addRedirect(path, map[path]);\n    }\n  };\n\n  /**\n   * Set aliases.\n   *\n   * @param {Object} map\n   */\n\n  Router.prototype.alias = function alias(map) {\n    for (var path in map) {\n      this._addAlias(path, map[path]);\n    }\n  };\n\n  /**\n   * Set global before hook.\n   *\n   * @param {Function} fn\n   */\n\n  Router.prototype.beforeEach = function beforeEach(fn) {\n    this._beforeEachHooks.push(fn);\n  };\n\n  /**\n   * Set global after hook.\n   *\n   * @param {Function} fn\n   */\n\n  Router.prototype.afterEach = function afterEach(fn) {\n    this._afterEachHooks.push(fn);\n  };\n\n  /**\n   * Navigate to a given path.\n   * The path can be an object describing a named path in\n   * the format of { name: '...', params: {}, query: {}}\n   * The path is assumed to be already decoded, and will\n   * be resolved against root (if provided)\n   *\n   * @param {String|Object} path\n   * @param {Boolean} [replace]\n   */\n\n  Router.prototype.go = function go(path) {\n    var replace = false;\n    var append = false;\n    if (Vue.util.isObject(path)) {\n      replace = path.replace;\n      append = path.append;\n    }\n    path = this._stringifyPath(path);\n    if (path) {\n      this.history.go(path, replace, append);\n    }\n  };\n\n  /**\n   * Short hand for replacing current path\n   *\n   * @param {String} path\n   */\n\n  Router.prototype.replace = function replace(path) {\n    if (typeof path === 'string') {\n      path = { path: path };\n    }\n    path.replace = true;\n    this.go(path);\n  };\n\n  /**\n   * Start the router.\n   *\n   * @param {VueConstructor} App\n   * @param {String|Element} container\n   * @param {Function} [cb]\n   */\n\n  Router.prototype.start = function start(App, container, cb) {\n    /* istanbul ignore if */\n    if (this._started) {\n      warn('already started.');\n      return;\n    }\n    this._started = true;\n    this._startCb = cb;\n    if (!this.app) {\n      /* istanbul ignore if */\n      if (!App || !container) {\n        throw new Error('Must start vue-router with a component and a ' + 'root container.');\n      }\n      this._appContainer = container;\n      var Ctor = this._appConstructor = typeof App === 'function' ? App : Vue.extend(App);\n      // give it a name for better debugging\n      Ctor.options.name = Ctor.options.name || 'RouterApp';\n    }\n    this.history.start();\n  };\n\n  /**\n   * Stop listening to route changes.\n   */\n\n  Router.prototype.stop = function stop() {\n    this.history.stop();\n    this._started = false;\n  };\n\n  // Internal methods ======================================\n\n  /**\n  * Add a route containing a list of segments to the internal\n  * route recognizer. Will be called recursively to add all\n  * possible sub-routes.\n  *\n  * @param {String} path\n  * @param {Object} handler\n  * @param {Array} segments\n  */\n\n  Router.prototype._addRoute = function _addRoute(path, handler, segments) {\n    guardComponent(path, handler);\n    handler.path = path;\n    handler.fullPath = (segments.reduce(function (path, segment) {\n      return path + segment.path;\n    }, '') + path).replace('//', '/');\n    segments.push({\n      path: path,\n      handler: handler\n    });\n    this._recognizer.add(segments, {\n      as: handler.name\n    });\n    // add sub routes\n    if (handler.subRoutes) {\n      for (var subPath in handler.subRoutes) {\n        // recursively walk all sub routes\n        this._addRoute(subPath, handler.subRoutes[subPath],\n        // pass a copy in recursion to avoid mutating\n        // across branches\n        segments.slice());\n      }\n    }\n  };\n\n  /**\n   * Set the notFound route handler.\n   *\n   * @param {Object} handler\n   */\n\n  Router.prototype._notFound = function _notFound(handler) {\n    guardComponent('*', handler);\n    this._notFoundHandler = [{ handler: handler }];\n  };\n\n  /**\n   * Add a redirect record.\n   *\n   * @param {String} path\n   * @param {String} redirectPath\n   */\n\n  Router.prototype._addRedirect = function _addRedirect(path, redirectPath) {\n    if (path === '*') {\n      this._notFoundRedirect = redirectPath;\n    } else {\n      this._addGuard(path, redirectPath, this.replace);\n    }\n  };\n\n  /**\n   * Add an alias record.\n   *\n   * @param {String} path\n   * @param {String} aliasPath\n   */\n\n  Router.prototype._addAlias = function _addAlias(path, aliasPath) {\n    this._addGuard(path, aliasPath, this._match);\n  };\n\n  /**\n   * Add a path guard.\n   *\n   * @param {String} path\n   * @param {String} mappedPath\n   * @param {Function} handler\n   */\n\n  Router.prototype._addGuard = function _addGuard(path, mappedPath, _handler) {\n    var _this = this;\n\n    this._guardRecognizer.add([{\n      path: path,\n      handler: function handler(match, query) {\n        var realPath = mapParams(mappedPath, match.params, query);\n        _handler.call(_this, realPath);\n      }\n    }]);\n  };\n\n  /**\n   * Check if a path matches any redirect records.\n   *\n   * @param {String} path\n   * @return {Boolean} - if true, will skip normal match.\n   */\n\n  Router.prototype._checkGuard = function _checkGuard(path) {\n    var matched = this._guardRecognizer.recognize(path);\n    if (matched) {\n      matched[0].handler(matched[0], matched.queryParams);\n      return true;\n    } else if (this._notFoundRedirect) {\n      matched = this._recognizer.recognize(path);\n      if (!matched) {\n        this.replace(this._notFoundRedirect);\n        return true;\n      }\n    }\n  };\n\n  /**\n   * Match a URL path and set the route context on vm,\n   * triggering view updates.\n   *\n   * @param {String} path\n   * @param {Object} [state]\n   * @param {String} [anchor]\n   */\n\n  Router.prototype._match = function _match(path, state, anchor) {\n    var _this2 = this;\n\n    if (this._checkGuard(path)) {\n      return;\n    }\n\n    var currentRoute = this._currentRoute;\n    var currentTransition = this._currentTransition;\n\n    if (currentTransition) {\n      if (currentTransition.to.path === path) {\n        // do nothing if we have an active transition going to the same path\n        return;\n      } else if (currentRoute.path === path) {\n        // We are going to the same path, but we also have an ongoing but\n        // not-yet-validated transition. Abort that transition and reset to\n        // prev transition.\n        currentTransition.aborted = true;\n        this._currentTransition = this._prevTransition;\n        return;\n      } else {\n        // going to a totally different path. abort ongoing transition.\n        currentTransition.aborted = true;\n      }\n    }\n\n    // construct new route and transition context\n    var route = new Route(path, this);\n    var transition = new RouteTransition(this, route, currentRoute);\n\n    // current transition is updated right now.\n    // however, current route will only be updated after the transition has\n    // been validated.\n    this._prevTransition = currentTransition;\n    this._currentTransition = transition;\n\n    if (!this.app) {\n      // initial render\n      this.app = new this._appConstructor({\n        el: this._appContainer,\n        _meta: {\n          $route: route\n        }\n      });\n    }\n\n    // check global before hook\n    var beforeHooks = this._beforeEachHooks;\n    var startTransition = function startTransition() {\n      transition.start(function () {\n        _this2._postTransition(route, state, anchor);\n      });\n    };\n\n    if (beforeHooks.length) {\n      transition.runQueue(beforeHooks, function (hook, _, next) {\n        if (transition === _this2._currentTransition) {\n          transition.callHook(hook, null, next, {\n            expectBoolean: true\n          });\n        }\n      }, startTransition);\n    } else {\n      startTransition();\n    }\n\n    if (!this._rendered && this._startCb) {\n      this._startCb.call(null);\n    }\n\n    // HACK:\n    // set rendered to true after the transition start, so\n    // that components that are acitvated synchronously know\n    // whether it is the initial render.\n    this._rendered = true;\n  };\n\n  /**\n   * Set current to the new transition.\n   * This is called by the transition object when the\n   * validation of a route has succeeded.\n   *\n   * @param {Transition} transition\n   */\n\n  Router.prototype._onTransitionValidated = function _onTransitionValidated(transition) {\n    // set current route\n    var route = this._currentRoute = transition.to;\n    // update route context for all children\n    if (this.app.$route !== route) {\n      this.app.$route = route;\n      this._children.forEach(function (child) {\n        child.$route = route;\n      });\n    }\n    // call global after hook\n    if (this._afterEachHooks.length) {\n      this._afterEachHooks.forEach(function (hook) {\n        return hook.call(null, {\n          to: transition.to,\n          from: transition.from\n        });\n      });\n    }\n    this._currentTransition.done = true;\n  };\n\n  /**\n   * Handle stuff after the transition.\n   *\n   * @param {Route} route\n   * @param {Object} [state]\n   * @param {String} [anchor]\n   */\n\n  Router.prototype._postTransition = function _postTransition(route, state, anchor) {\n    // handle scroll positions\n    // saved scroll positions take priority\n    // then we check if the path has an anchor\n    var pos = state && state.pos;\n    if (pos && this._saveScrollPosition) {\n      Vue.nextTick(function () {\n        window.scrollTo(pos.x, pos.y);\n      });\n    } else if (anchor) {\n      Vue.nextTick(function () {\n        var el = document.getElementById(anchor.slice(1));\n        if (el) {\n          window.scrollTo(window.scrollX, el.offsetTop);\n        }\n      });\n    }\n  };\n\n  /**\n   * Normalize named route object / string paths into\n   * a string.\n   *\n   * @param {Object|String|Number} path\n   * @return {String}\n   */\n\n  Router.prototype._stringifyPath = function _stringifyPath(path) {\n    if (path && typeof path === 'object') {\n      if (path.name) {\n        var params = path.params || {};\n        if (path.query) {\n          params.queryParams = path.query;\n        }\n        return this._recognizer.generate(path.name, params);\n      } else if (path.path) {\n        var fullPath = path.path;\n        if (path.query) {\n          var query = this._recognizer.generateQueryString(path.query);\n          if (fullPath.indexOf('?') > -1) {\n            fullPath += '&' + query.slice(1);\n          } else {\n            fullPath += query;\n          }\n        }\n        return fullPath;\n      } else {\n        return '';\n      }\n    } else {\n      return path ? path + '' : '';\n    }\n  };\n\n  return Router;\n})();\n\nfunction guardComponent(path, handler) {\n  var comp = handler.component;\n  if (Vue.util.isPlainObject(comp)) {\n    comp = handler.component = Vue.extend(comp);\n  }\n  /* istanbul ignore if */\n  if (typeof comp !== 'function') {\n    handler.component = null;\n    warn('invalid component for route \"' + path + '\".');\n  }\n}\n\n/* Installation */\n\nRouter.installed = false;\n\n/**\n * Installation interface.\n * Install the necessary directives.\n */\n\nRouter.install = function (externalVue) {\n  /* istanbul ignore if */\n  if (Router.installed) {\n    warn('already installed.');\n    return;\n  }\n  Vue = externalVue;\n  applyOverride(Vue);\n  View(Vue);\n  Link(Vue);\n  exports$1.Vue = Vue;\n  Router.installed = true;\n};\n\n// auto install\n/* istanbul ignore if */\nif (typeof window !== 'undefined' && window.Vue) {\n  window.Vue.use(Router);\n}\n\nmodule.exports = Router;\n},{}],29:[function(require,module,exports){\nvar _ = require('../util')\nvar Watcher = require('../watcher')\nvar Path = require('../parsers/path')\nvar textParser = require('../parsers/text')\nvar dirParser = require('../parsers/directive')\nvar expParser = require('../parsers/expression')\nvar filterRE = /[^|]\\|[^|]/\n\n/**\n * Get the value from an expression on this vm.\n *\n * @param {String} exp\n * @param {Boolean} [asStatement]\n * @return {*}\n */\n\nexports.$get = function (exp, asStatement) {\n  var res = expParser.parse(exp)\n  if (res) {\n    if (asStatement && !expParser.isSimplePath(exp)) {\n      var self = this\n      return function statementHandler () {\n        res.get.call(self, self)\n      }\n    } else {\n      try {\n        return res.get.call(this, this)\n      } catch (e) {}\n    }\n  }\n}\n\n/**\n * Set the value from an expression on this vm.\n * The expression must be a valid left-hand\n * expression in an assignment.\n *\n * @param {String} exp\n * @param {*} val\n */\n\nexports.$set = function (exp, val) {\n  var res = expParser.parse(exp, true)\n  if (res && res.set) {\n    res.set.call(this, this, val)\n  }\n}\n\n/**\n * Delete a property on the VM\n *\n * @param {String} key\n */\n\nexports.$delete = function (key) {\n  _.delete(this._data, key)\n}\n\n/**\n * Watch an expression, trigger callback when its\n * value changes.\n *\n * @param {String|Function} expOrFn\n * @param {Function} cb\n * @param {Object} [options]\n *                 - {Boolean} deep\n *                 - {Boolean} immediate\n * @return {Function} - unwatchFn\n */\n\nexports.$watch = function (expOrFn, cb, options) {\n  var vm = this\n  var parsed\n  if (typeof expOrFn === 'string') {\n    parsed = dirParser.parse(expOrFn)\n    expOrFn = parsed.expression\n  }\n  var watcher = new Watcher(vm, expOrFn, cb, {\n    deep: options && options.deep,\n    filters: parsed && parsed.filters\n  })\n  if (options && options.immediate) {\n    cb.call(vm, watcher.value)\n  }\n  return function unwatchFn () {\n    watcher.teardown()\n  }\n}\n\n/**\n * Evaluate a text directive, including filters.\n *\n * @param {String} text\n * @param {Boolean} [asStatement]\n * @return {String}\n */\n\nexports.$eval = function (text, asStatement) {\n  // check for filters.\n  if (filterRE.test(text)) {\n    var dir = dirParser.parse(text)\n    // the filter regex check might give false positive\n    // for pipes inside strings, so it's possible that\n    // we don't get any filters here\n    var val = this.$get(dir.expression, asStatement)\n    return dir.filters\n      ? this._applyFilters(val, null, dir.filters)\n      : val\n  } else {\n    // no filter\n    return this.$get(text, asStatement)\n  }\n}\n\n/**\n * Interpolate a piece of template text.\n *\n * @param {String} text\n * @return {String}\n */\n\nexports.$interpolate = function (text) {\n  var tokens = textParser.parse(text)\n  var vm = this\n  if (tokens) {\n    if (tokens.length === 1) {\n      return vm.$eval(tokens[0].value) + ''\n    } else {\n      return tokens.map(function (token) {\n        return token.tag\n          ? vm.$eval(token.value)\n          : token.value\n      }).join('')\n    }\n  } else {\n    return text\n  }\n}\n\n/**\n * Log instance data as a plain JS object\n * so that it is easier to inspect in console.\n * This method assumes console is available.\n *\n * @param {String} [path]\n */\n\nexports.$log = function (path) {\n  var data = path\n    ? Path.get(this._data, path)\n    : this._data\n  if (data) {\n    data = clean(data)\n  }\n  // include computed fields\n  if (!path) {\n    for (var key in this.$options.computed) {\n      data[key] = clean(this[key])\n    }\n  }\n  console.log(data)\n}\n\n/**\n * \"clean\" a getter/setter converted object into a plain\n * object copy.\n *\n * @param {Object} - obj\n * @return {Object}\n */\n\nfunction clean (obj) {\n  return JSON.parse(JSON.stringify(obj))\n}\n\n},{\"../parsers/directive\":79,\"../parsers/expression\":80,\"../parsers/path\":81,\"../parsers/text\":83,\"../util\":91,\"../watcher\":95}],30:[function(require,module,exports){\nvar _ = require('../util')\nvar transition = require('../transition')\n\n/**\n * Convenience on-instance nextTick. The callback is\n * auto-bound to the instance, and this avoids component\n * modules having to rely on the global Vue.\n *\n * @param {Function} fn\n */\n\nexports.$nextTick = function (fn) {\n  _.nextTick(fn, this)\n}\n\n/**\n * Append instance to target\n *\n * @param {Node} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$appendTo = function (target, cb, withTransition) {\n  return insert(\n    this, target, cb, withTransition,\n    append, transition.append\n  )\n}\n\n/**\n * Prepend instance to target\n *\n * @param {Node} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$prependTo = function (target, cb, withTransition) {\n  target = query(target)\n  if (target.hasChildNodes()) {\n    this.$before(target.firstChild, cb, withTransition)\n  } else {\n    this.$appendTo(target, cb, withTransition)\n  }\n  return this\n}\n\n/**\n * Insert instance before target\n *\n * @param {Node} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$before = function (target, cb, withTransition) {\n  return insert(\n    this, target, cb, withTransition,\n    before, transition.before\n  )\n}\n\n/**\n * Insert instance after target\n *\n * @param {Node} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$after = function (target, cb, withTransition) {\n  target = query(target)\n  if (target.nextSibling) {\n    this.$before(target.nextSibling, cb, withTransition)\n  } else {\n    this.$appendTo(target.parentNode, cb, withTransition)\n  }\n  return this\n}\n\n/**\n * Remove instance from DOM\n *\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$remove = function (cb, withTransition) {\n  if (!this.$el.parentNode) {\n    return cb && cb()\n  }\n  var inDoc = this._isAttached && _.inDoc(this.$el)\n  // if we are not in document, no need to check\n  // for transitions\n  if (!inDoc) withTransition = false\n  var self = this\n  var realCb = function () {\n    if (inDoc) self._callHook('detached')\n    if (cb) cb()\n  }\n  if (this._isFragment) {\n    _.removeNodeRange(\n      this._fragmentStart,\n      this._fragmentEnd,\n      this, this._fragment, realCb\n    )\n  } else {\n    var op = withTransition === false\n      ? remove\n      : transition.remove\n    op(this.$el, this, realCb)\n  }\n  return this\n}\n\n/**\n * Shared DOM insertion function.\n *\n * @param {Vue} vm\n * @param {Element} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition]\n * @param {Function} op1 - op for non-transition insert\n * @param {Function} op2 - op for transition insert\n * @return vm\n */\n\nfunction insert (vm, target, cb, withTransition, op1, op2) {\n  target = query(target)\n  var targetIsDetached = !_.inDoc(target)\n  var op = withTransition === false || targetIsDetached\n      ? op1\n      : op2\n  var shouldCallHook =\n    !targetIsDetached &&\n    !vm._isAttached &&\n    !_.inDoc(vm.$el)\n  if (vm._isFragment) {\n    _.mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {\n      op(node, target, vm)\n    })\n    cb && cb()\n  } else {\n    op(vm.$el, target, vm, cb)\n  }\n  if (shouldCallHook) {\n    vm._callHook('attached')\n  }\n  return vm\n}\n\n/**\n * Check for selectors\n *\n * @param {String|Element} el\n */\n\nfunction query (el) {\n  return typeof el === 'string'\n    ? document.querySelector(el)\n    : el\n}\n\n/**\n * Append operation that takes a callback.\n *\n * @param {Node} el\n * @param {Node} target\n * @param {Vue} vm - unused\n * @param {Function} [cb]\n */\n\nfunction append (el, target, vm, cb) {\n  target.appendChild(el)\n  if (cb) cb()\n}\n\n/**\n * InsertBefore operation that takes a callback.\n *\n * @param {Node} el\n * @param {Node} target\n * @param {Vue} vm - unused\n * @param {Function} [cb]\n */\n\nfunction before (el, target, vm, cb) {\n  _.before(el, target)\n  if (cb) cb()\n}\n\n/**\n * Remove operation that takes a callback.\n *\n * @param {Node} el\n * @param {Vue} vm - unused\n * @param {Function} [cb]\n */\n\nfunction remove (el, vm, cb) {\n  _.remove(el)\n  if (cb) cb()\n}\n\n},{\"../transition\":84,\"../util\":91}],31:[function(require,module,exports){\nvar _ = require('../util')\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n */\n\nexports.$on = function (event, fn) {\n  (this._events[event] || (this._events[event] = []))\n    .push(fn)\n  modifyListenerCount(this, event, 1)\n  return this\n}\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n */\n\nexports.$once = function (event, fn) {\n  var self = this\n  function on () {\n    self.$off(event, on)\n    fn.apply(this, arguments)\n  }\n  on.fn = fn\n  this.$on(event, on)\n  return this\n}\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n */\n\nexports.$off = function (event, fn) {\n  var cbs\n  // all\n  if (!arguments.length) {\n    if (this.$parent) {\n      for (event in this._events) {\n        cbs = this._events[event]\n        if (cbs) {\n          modifyListenerCount(this, event, -cbs.length)\n        }\n      }\n    }\n    this._events = {}\n    return this\n  }\n  // specific event\n  cbs = this._events[event]\n  if (!cbs) {\n    return this\n  }\n  if (arguments.length === 1) {\n    modifyListenerCount(this, event, -cbs.length)\n    this._events[event] = null\n    return this\n  }\n  // specific handler\n  var cb\n  var i = cbs.length\n  while (i--) {\n    cb = cbs[i]\n    if (cb === fn || cb.fn === fn) {\n      modifyListenerCount(this, event, -1)\n      cbs.splice(i, 1)\n      break\n    }\n  }\n  return this\n}\n\n/**\n * Trigger an event on self.\n *\n * @param {String} event\n */\n\nexports.$emit = function (event) {\n  var cbs = this._events[event]\n  this._shouldPropagate = !cbs\n  if (cbs) {\n    cbs = cbs.length > 1\n      ? _.toArray(cbs)\n      : cbs\n    var args = _.toArray(arguments, 1)\n    for (var i = 0, l = cbs.length; i < l; i++) {\n      var res = cbs[i].apply(this, args)\n      if (res === true) {\n        this._shouldPropagate = true\n      }\n    }\n  }\n  return this\n}\n\n/**\n * Recursively broadcast an event to all children instances.\n *\n * @param {String} event\n * @param {...*} additional arguments\n */\n\nexports.$broadcast = function (event) {\n  // if no child has registered for this event,\n  // then there's no need to broadcast.\n  if (!this._eventsCount[event]) return\n  var children = this.$children\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i]\n    child.$emit.apply(child, arguments)\n    if (child._shouldPropagate) {\n      child.$broadcast.apply(child, arguments)\n    }\n  }\n  return this\n}\n\n/**\n * Recursively propagate an event up the parent chain.\n *\n * @param {String} event\n * @param {...*} additional arguments\n */\n\nexports.$dispatch = function () {\n  this.$emit.apply(this, arguments)\n  var parent = this.$parent\n  while (parent) {\n    parent.$emit.apply(parent, arguments)\n    parent = parent._shouldPropagate\n      ? parent.$parent\n      : null\n  }\n  return this\n}\n\n/**\n * Modify the listener counts on all parents.\n * This bookkeeping allows $broadcast to return early when\n * no child has listened to a certain event.\n *\n * @param {Vue} vm\n * @param {String} event\n * @param {Number} count\n */\n\nvar hookRE = /^hook:/\nfunction modifyListenerCount (vm, event, count) {\n  var parent = vm.$parent\n  // hooks do not get broadcasted so no need\n  // to do bookkeeping for them\n  if (!parent || !count || hookRE.test(event)) return\n  while (parent) {\n    parent._eventsCount[event] =\n      (parent._eventsCount[event] || 0) + count\n    parent = parent.$parent\n  }\n}\n\n},{\"../util\":91}],32:[function(require,module,exports){\nvar _ = require('../util')\nvar config = require('../config')\n\n/**\n * Expose useful internals\n */\n\nexports.util = _\nexports.config = config\nexports.set = _.set\nexports.delete = _.delete\nexports.nextTick = _.nextTick\n\n/**\n * The following are exposed for advanced usage / plugins\n */\n\nexports.compiler = require('../compiler')\nexports.FragmentFactory = require('../fragment/factory')\nexports.internalDirectives = require('../directives/internal')\nexports.parsers = {\n  path: require('../parsers/path'),\n  text: require('../parsers/text'),\n  template: require('../parsers/template'),\n  directive: require('../parsers/directive'),\n  expression: require('../parsers/expression')\n}\n\n/**\n * Each instance constructor, including Vue, has a unique\n * cid. This enables us to create wrapped \"child\n * constructors\" for prototypal inheritance and cache them.\n */\n\nexports.cid = 0\nvar cid = 1\n\n/**\n * Class inheritance\n *\n * @param {Object} extendOptions\n */\n\nexports.extend = function (extendOptions) {\n  extendOptions = extendOptions || {}\n  var Super = this\n  var isFirstExtend = Super.cid === 0\n  if (isFirstExtend && extendOptions._Ctor) {\n    return extendOptions._Ctor\n  }\n  var name = extendOptions.name || Super.options.name\n  var Sub = createClass(name || 'VueComponent')\n  Sub.prototype = Object.create(Super.prototype)\n  Sub.prototype.constructor = Sub\n  Sub.cid = cid++\n  Sub.options = _.mergeOptions(\n    Super.options,\n    extendOptions\n  )\n  Sub['super'] = Super\n  // allow further extension\n  Sub.extend = Super.extend\n  // create asset registers, so extended classes\n  // can have their private assets too.\n  config._assetTypes.forEach(function (type) {\n    Sub[type] = Super[type]\n  })\n  // enable recursive self-lookup\n  if (name) {\n    Sub.options.components[name] = Sub\n  }\n  // cache constructor\n  if (isFirstExtend) {\n    extendOptions._Ctor = Sub\n  }\n  return Sub\n}\n\n/**\n * A function that returns a sub-class constructor with the\n * given name. This gives us much nicer output when\n * logging instances in the console.\n *\n * @param {String} name\n * @return {Function}\n */\n\nfunction createClass (name) {\n  return new Function(\n    'return function ' + _.classify(name) +\n    ' (options) { this._init(options) }'\n  )()\n}\n\n/**\n * Plugin system\n *\n * @param {Object} plugin\n */\n\nexports.use = function (plugin) {\n  /* istanbul ignore if */\n  if (plugin.installed) {\n    return\n  }\n  // additional parameters\n  var args = _.toArray(arguments, 1)\n  args.unshift(this)\n  if (typeof plugin.install === 'function') {\n    plugin.install.apply(plugin, args)\n  } else {\n    plugin.apply(null, args)\n  }\n  plugin.installed = true\n  return this\n}\n\n/**\n * Apply a global mixin by merging it into the default\n * options.\n */\n\nexports.mixin = function (mixin) {\n  var Vue = _.Vue\n  Vue.options = _.mergeOptions(Vue.options, mixin)\n}\n\n/**\n * Create asset registration methods with the following\n * signature:\n *\n * @param {String} id\n * @param {*} definition\n */\n\nconfig._assetTypes.forEach(function (type) {\n  exports[type] = function (id, definition) {\n    if (!definition) {\n      return this.options[type + 's'][id]\n    } else {\n      if (\n        type === 'component' &&\n        _.isPlainObject(definition)\n      ) {\n        definition.name = id\n        definition = _.Vue.extend(definition)\n      }\n      this.options[type + 's'][id] = definition\n      return definition\n    }\n  }\n})\n\n},{\"../compiler\":38,\"../config\":40,\"../directives/internal\":47,\"../fragment/factory\":69,\"../parsers/directive\":79,\"../parsers/expression\":80,\"../parsers/path\":81,\"../parsers/template\":82,\"../parsers/text\":83,\"../util\":91}],33:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar compiler = require('../compiler')\n\n/**\n * Set instance target element and kick off the compilation\n * process. The passed in `el` can be a selector string, an\n * existing Element, or a DocumentFragment (for block\n * instances).\n *\n * @param {Element|DocumentFragment|string} el\n * @public\n */\n\nexports.$mount = function (el) {\n  if (this._isCompiled) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      '$mount() should be called only once.'\n    )\n    return\n  }\n  el = _.query(el)\n  if (!el) {\n    el = document.createElement('div')\n  }\n  this._compile(el)\n  this._initDOMHooks()\n  if (_.inDoc(this.$el)) {\n    this._callHook('attached')\n    ready.call(this)\n  } else {\n    this.$once('hook:attached', ready)\n  }\n  return this\n}\n\n/**\n * Mark an instance as ready.\n */\n\nfunction ready () {\n  this._isAttached = true\n  this._isReady = true\n  this._callHook('ready')\n}\n\n/**\n * Teardown the instance, simply delegate to the internal\n * _destroy.\n */\n\nexports.$destroy = function (remove, deferCleanup) {\n  this._destroy(remove, deferCleanup)\n}\n\n/**\n * Partially compile a piece of DOM and return a\n * decompile function.\n *\n * @param {Element|DocumentFragment} el\n * @param {Vue} [host]\n * @return {Function}\n */\n\nexports.$compile = function (el, host, scope, frag) {\n  return compiler.compile(el, this.$options, true)(\n    this, el, host, scope, frag\n  )\n}\n\n}).call(this,require('_process'))\n\n},{\"../compiler\":38,\"../util\":91,\"_process\":1}],34:[function(require,module,exports){\n(function (process){\nvar _ = require('./util')\nvar config = require('./config')\n\n// we have two separate queues: one for directive updates\n// and one for user watcher registered via $watch().\n// we want to guarantee directive updates to be called\n// before user watchers so that when user watchers are\n// triggered, the DOM would have already been in updated\n// state.\nvar queue = []\nvar userQueue = []\nvar has = {}\nvar circular = {}\nvar waiting = false\nvar internalQueueDepleted = false\n\n/**\n * Reset the batcher's state.\n */\n\nfunction resetBatcherState () {\n  queue = []\n  userQueue = []\n  has = {}\n  circular = {}\n  waiting = internalQueueDepleted = false\n}\n\n/**\n * Flush both queues and run the watchers.\n */\n\nfunction flushBatcherQueue () {\n  runBatcherQueue(queue)\n  internalQueueDepleted = true\n  runBatcherQueue(userQueue)\n  // dev tool hook\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production') {\n    if (_.inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {\n      window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('flush')\n    }\n  }\n  resetBatcherState()\n}\n\n/**\n * Run the watchers in a single queue.\n *\n * @param {Array} queue\n */\n\nfunction runBatcherQueue (queue) {\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (var i = 0; i < queue.length; i++) {\n    var watcher = queue[i]\n    var id = watcher.id\n    has[id] = null\n    watcher.run()\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1\n      if (circular[id] > config._maxUpdateCount) {\n        queue.splice(has[id], 1)\n        _.warn(\n          'You may have an infinite update loop for watcher ' +\n          'with expression: ' + watcher.expression\n        )\n      }\n    }\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n *\n * @param {Watcher} watcher\n *   properties:\n *   - {Number} id\n *   - {Function} run\n */\n\nexports.push = function (watcher) {\n  var id = watcher.id\n  if (has[id] == null) {\n    // if an internal watcher is pushed, but the internal\n    // queue is already depleted, we run it immediately.\n    if (internalQueueDepleted && !watcher.user) {\n      watcher.run()\n      return\n    }\n    // push watcher into appropriate queue\n    var q = watcher.user ? userQueue : queue\n    has[id] = q.length\n    q.push(watcher)\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n      _.nextTick(flushBatcherQueue)\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"./config\":40,\"./util\":91,\"_process\":1}],35:[function(require,module,exports){\n/**\n * A doubly linked list-based Least Recently Used (LRU)\n * cache. Will keep most recently used items while\n * discarding least recently used items when its limit is\n * reached. This is a bare-bone version of\n * Rasmus Andersson's js-lru:\n *\n *   https://github.com/rsms/js-lru\n *\n * @param {Number} limit\n * @constructor\n */\n\nfunction Cache (limit) {\n  this.size = 0\n  this.limit = limit\n  this.head = this.tail = undefined\n  this._keymap = Object.create(null)\n}\n\nvar p = Cache.prototype\n\n/**\n * Put <value> into the cache associated with <key>.\n * Returns the entry which was removed to make room for\n * the new entry. Otherwise undefined is returned.\n * (i.e. if there was enough room already).\n *\n * @param {String} key\n * @param {*} value\n * @return {Entry|undefined}\n */\n\np.put = function (key, value) {\n  var entry = {\n    key: key,\n    value: value\n  }\n  this._keymap[key] = entry\n  if (this.tail) {\n    this.tail.newer = entry\n    entry.older = this.tail\n  } else {\n    this.head = entry\n  }\n  this.tail = entry\n  if (this.size === this.limit) {\n    return this.shift()\n  } else {\n    this.size++\n  }\n}\n\n/**\n * Purge the least recently used (oldest) entry from the\n * cache. Returns the removed entry or undefined if the\n * cache was empty.\n */\n\np.shift = function () {\n  var entry = this.head\n  if (entry) {\n    this.head = this.head.newer\n    this.head.older = undefined\n    entry.newer = entry.older = undefined\n    this._keymap[entry.key] = undefined\n  }\n  return entry\n}\n\n/**\n * Get and register recent use of <key>. Returns the value\n * associated with <key> or undefined if not in cache.\n *\n * @param {String} key\n * @param {Boolean} returnEntry\n * @return {Entry|*}\n */\n\np.get = function (key, returnEntry) {\n  var entry = this._keymap[key]\n  if (entry === undefined) return\n  if (entry === this.tail) {\n    return returnEntry\n      ? entry\n      : entry.value\n  }\n  // HEAD--------------TAIL\n  //   <.older   .newer>\n  //  <--- add direction --\n  //   A  B  C  <D>  E\n  if (entry.newer) {\n    if (entry === this.head) {\n      this.head = entry.newer\n    }\n    entry.newer.older = entry.older // C <-- E.\n  }\n  if (entry.older) {\n    entry.older.newer = entry.newer // C. --> E\n  }\n  entry.newer = undefined // D --x\n  entry.older = this.tail // D. --> E\n  if (this.tail) {\n    this.tail.newer = entry // E. <-- D\n  }\n  this.tail = entry\n  return returnEntry\n    ? entry\n    : entry.value\n}\n\nmodule.exports = Cache\n\n},{}],36:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar dirParser = require('../parsers/directive')\nvar propDef = require('../directives/internal/prop')\nvar propBindingModes = require('../config')._propBindingModes\nvar empty = {}\n\n// regexes\nvar identRE = require('../parsers/path').identRE\nvar settablePathRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\[[^\\[\\]]+\\])*$/\n\n/**\n * Compile props on a root element and return\n * a props link function.\n *\n * @param {Element|DocumentFragment} el\n * @param {Array} propOptions\n * @return {Function} propsLinkFn\n */\n\nmodule.exports = function compileProps (el, propOptions) {\n  var props = []\n  var names = Object.keys(propOptions)\n  var i = names.length\n  var options, name, attr, value, path, parsed, prop, isTitleBinding\n  while (i--) {\n    name = names[i]\n    options = propOptions[name] || empty\n\n    if (process.env.NODE_ENV !== 'production' && name === '$data') {\n      _.warn('Do not use $data as prop.')\n      continue\n    }\n\n    // props could contain dashes, which will be\n    // interpreted as minus calculations by the parser\n    // so we need to camelize the path here\n    path = _.camelize(name)\n    if (!identRE.test(path)) {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'Invalid prop key: \"' + name + '\". Prop keys ' +\n        'must be valid identifiers.'\n      )\n      continue\n    }\n\n    prop = {\n      name: name,\n      path: path,\n      options: options,\n      mode: propBindingModes.ONE_WAY\n    }\n\n    // IE title issues\n    isTitleBinding = false\n    if (name === 'title' && (el.getAttribute(':title') || el.getAttribute('v-bind:title'))) {\n      isTitleBinding = true\n    }\n\n    // first check literal version\n    attr = _.hyphenate(name)\n    value = prop.raw = _.attr(el, attr)\n    if (value === null || isTitleBinding) {\n      // then check dynamic version\n      if ((value = _.getBindAttr(el, attr)) === null) {\n        if ((value = _.getBindAttr(el, attr + '.sync')) !== null) {\n          prop.mode = propBindingModes.TWO_WAY\n        } else if ((value = _.getBindAttr(el, attr + '.once')) !== null) {\n          prop.mode = propBindingModes.ONE_TIME\n        }\n      }\n      prop.raw = value\n      if (value !== null) {\n        parsed = dirParser.parse(value)\n        value = parsed.expression\n        prop.filters = parsed.filters\n        // check binding type\n        if (_.isLiteral(value)) {\n          // for expressions containing literal numbers and\n          // booleans, there's no need to setup a prop binding,\n          // so we can optimize them as a one-time set.\n          prop.optimizedLiteral = true\n        } else {\n          prop.dynamic = true\n          // check non-settable path for two-way bindings\n          if (process.env.NODE_ENV !== 'production' &&\n              prop.mode === propBindingModes.TWO_WAY &&\n              !settablePathRE.test(value)) {\n            prop.mode = propBindingModes.ONE_WAY\n            _.warn(\n              'Cannot bind two-way prop with non-settable ' +\n              'parent path: ' + value\n            )\n          }\n        }\n        prop.parentPath = value\n\n        // warn required two-way\n        if (\n          process.env.NODE_ENV !== 'production' &&\n          options.twoWay &&\n          prop.mode !== propBindingModes.TWO_WAY\n        ) {\n          _.warn(\n            'Prop \"' + name + '\" expects a two-way binding type.'\n          )\n        }\n\n      } else if (options.required) {\n        // warn missing required\n        process.env.NODE_ENV !== 'production' && _.warn(\n          'Missing required prop: ' + name\n        )\n      }\n    }\n\n    // push prop\n    props.push(prop)\n  }\n  return makePropsLinkFn(props)\n}\n\n/**\n * Build a function that applies props to a vm.\n *\n * @param {Array} props\n * @return {Function} propsLinkFn\n */\n\nfunction makePropsLinkFn (props) {\n  return function propsLinkFn (vm, scope) {\n    // store resolved props info\n    vm._props = {}\n    var i = props.length\n    var prop, path, options, value, raw\n    while (i--) {\n      prop = props[i]\n      raw = prop.raw\n      path = prop.path\n      options = prop.options\n      vm._props[path] = prop\n      if (raw === null) {\n        // initialize absent prop\n        _.initProp(vm, prop, getDefault(vm, options))\n      } else if (prop.dynamic) {\n        // dynamic prop\n        if (vm._context) {\n          if (prop.mode === propBindingModes.ONE_TIME) {\n            // one time binding\n            value = (scope || vm._context).$get(prop.parentPath)\n            _.initProp(vm, prop, value)\n          } else {\n            // dynamic binding\n            vm._bindDir({\n              name: 'prop',\n              def: propDef,\n              prop: prop\n            }, null, null, scope) // el, host, scope\n          }\n        } else {\n          process.env.NODE_ENV !== 'production' && _.warn(\n            'Cannot bind dynamic prop on a root instance' +\n            ' with no parent: ' + prop.name + '=\"' +\n            raw + '\"'\n          )\n        }\n      } else if (prop.optimizedLiteral) {\n        // optimized literal, cast it and just set once\n        raw = _.stripQuotes(raw)\n        value = _.toBoolean(_.toNumber(raw))\n        _.initProp(vm, prop, value)\n      } else {\n        // string literal, but we need to cater for\n        // Boolean props with no value\n        value = options.type === Boolean && raw === ''\n          ? true\n          : raw\n        _.initProp(vm, prop, value)\n      }\n    }\n  }\n}\n\n/**\n * Get the default value of a prop.\n *\n * @param {Vue} vm\n * @param {Object} options\n * @return {*}\n */\n\nfunction getDefault (vm, options) {\n  // no default, return undefined\n  if (!options.hasOwnProperty('default')) {\n    // absent boolean value defaults to false\n    return options.type === Boolean\n      ? false\n      : undefined\n  }\n  var def = options.default\n  // warn against non-factory defaults for Object & Array\n  if (_.isObject(def)) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Object/Array as default prop values will be shared ' +\n      'across multiple instances. Use a factory function ' +\n      'to return the default value instead.'\n    )\n  }\n  // call factory function for non-Function types\n  return typeof def === 'function' && options.type !== Function\n    ? def.call(vm)\n    : def\n}\n\n}).call(this,require('_process'))\n\n},{\"../config\":40,\"../directives/internal/prop\":48,\"../parsers/directive\":79,\"../parsers/path\":81,\"../util\":91,\"_process\":1}],37:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar publicDirectives = require('../directives/public')\nvar internalDirectives = require('../directives/internal')\nvar compileProps = require('./compile-props')\nvar textParser = require('../parsers/text')\nvar dirParser = require('../parsers/directive')\nvar templateParser = require('../parsers/template')\nvar resolveAsset = _.resolveAsset\n\n// special binding prefixes\nvar bindRE = /^v-bind:|^:/\nvar onRE = /^v-on:|^@/\nvar argRE = /:(.*)$/\nvar modifierRE = /\\.[^\\.]+/g\nvar transitionRE = /^(v-bind:|:)?transition$/\n\n// terminal directives\nvar terminalDirectives = [\n  'for',\n  'if'\n]\n\n// default directive priority\nvar DEFAULT_PRIORITY = 1000\n\n/**\n * Compile a template and return a reusable composite link\n * function, which recursively contains more link functions\n * inside. This top level compile function would normally\n * be called on instance root nodes, but can also be used\n * for partial compilation if the partial argument is true.\n *\n * The returned composite link function, when called, will\n * return an unlink function that tearsdown all directives\n * created during the linking phase.\n *\n * @param {Element|DocumentFragment} el\n * @param {Object} options\n * @param {Boolean} partial\n * @return {Function}\n */\n\nexports.compile = function (el, options, partial) {\n  // link function for the node itself.\n  var nodeLinkFn = partial || !options._asComponent\n    ? compileNode(el, options)\n    : null\n  // link function for the childNodes\n  var childLinkFn =\n    !(nodeLinkFn && nodeLinkFn.terminal) &&\n    el.tagName !== 'SCRIPT' &&\n    el.hasChildNodes()\n      ? compileNodeList(el.childNodes, options)\n      : null\n\n  /**\n   * A composite linker function to be called on a already\n   * compiled piece of DOM, which instantiates all directive\n   * instances.\n   *\n   * @param {Vue} vm\n   * @param {Element|DocumentFragment} el\n   * @param {Vue} [host] - host vm of transcluded content\n   * @param {Object} [scope] - v-for scope\n   * @param {Fragment} [frag] - link context fragment\n   * @return {Function|undefined}\n   */\n\n  return function compositeLinkFn (vm, el, host, scope, frag) {\n    // cache childNodes before linking parent, fix #657\n    var childNodes = _.toArray(el.childNodes)\n    // link\n    var dirs = linkAndCapture(function compositeLinkCapturer () {\n      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag)\n      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag)\n    }, vm)\n    return makeUnlinkFn(vm, dirs)\n  }\n}\n\n/**\n * Apply a linker to a vm/element pair and capture the\n * directives created during the process.\n *\n * @param {Function} linker\n * @param {Vue} vm\n */\n\nfunction linkAndCapture (linker, vm) {\n  var originalDirCount = vm._directives.length\n  linker()\n  var dirs = vm._directives.slice(originalDirCount)\n  dirs.sort(directiveComparator)\n  for (var i = 0, l = dirs.length; i < l; i++) {\n    dirs[i]._bind()\n  }\n  return dirs\n}\n\n/**\n * Directive priority sort comparator\n *\n * @param {Object} a\n * @param {Object} b\n */\n\nfunction directiveComparator (a, b) {\n  a = a.descriptor.def.priority || DEFAULT_PRIORITY\n  b = b.descriptor.def.priority || DEFAULT_PRIORITY\n  return a > b ? -1 : a === b ? 0 : 1\n}\n\n/**\n * Linker functions return an unlink function that\n * tearsdown all directives instances generated during\n * the process.\n *\n * We create unlink functions with only the necessary\n * information to avoid retaining additional closures.\n *\n * @param {Vue} vm\n * @param {Array} dirs\n * @param {Vue} [context]\n * @param {Array} [contextDirs]\n * @return {Function}\n */\n\nfunction makeUnlinkFn (vm, dirs, context, contextDirs) {\n  return function unlink (destroying) {\n    teardownDirs(vm, dirs, destroying)\n    if (context && contextDirs) {\n      teardownDirs(context, contextDirs)\n    }\n  }\n}\n\n/**\n * Teardown partial linked directives.\n *\n * @param {Vue} vm\n * @param {Array} dirs\n * @param {Boolean} destroying\n */\n\nfunction teardownDirs (vm, dirs, destroying) {\n  var i = dirs.length\n  while (i--) {\n    dirs[i]._teardown()\n    if (!destroying) {\n      vm._directives.$remove(dirs[i])\n    }\n  }\n}\n\n/**\n * Compile link props on an instance.\n *\n * @param {Vue} vm\n * @param {Element} el\n * @param {Object} props\n * @param {Object} [scope]\n * @return {Function}\n */\n\nexports.compileAndLinkProps = function (vm, el, props, scope) {\n  var propsLinkFn = compileProps(el, props)\n  var propDirs = linkAndCapture(function () {\n    propsLinkFn(vm, scope)\n  }, vm)\n  return makeUnlinkFn(vm, propDirs)\n}\n\n/**\n * Compile the root element of an instance.\n *\n * 1. attrs on context container (context scope)\n * 2. attrs on the component template root node, if\n *    replace:true (child scope)\n *\n * If this is a fragment instance, we only need to compile 1.\n *\n * @param {Vue} vm\n * @param {Element} el\n * @param {Object} options\n * @param {Object} contextOptions\n * @return {Function}\n */\n\nexports.compileRoot = function (el, options, contextOptions) {\n  var containerAttrs = options._containerAttrs\n  var replacerAttrs = options._replacerAttrs\n  var contextLinkFn, replacerLinkFn\n\n  // only need to compile other attributes for\n  // non-fragment instances\n  if (el.nodeType !== 11) {\n    // for components, container and replacer need to be\n    // compiled separately and linked in different scopes.\n    if (options._asComponent) {\n      // 2. container attributes\n      if (containerAttrs && contextOptions) {\n        contextLinkFn = compileDirectives(containerAttrs, contextOptions)\n      }\n      if (replacerAttrs) {\n        // 3. replacer attributes\n        replacerLinkFn = compileDirectives(replacerAttrs, options)\n      }\n    } else {\n      // non-component, just compile as a normal element.\n      replacerLinkFn = compileDirectives(el.attributes, options)\n    }\n  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {\n    // warn container directives for fragment instances\n    var names = containerAttrs.map(function (attr) {\n      return '\"' + attr.name + '\"'\n    }).join(', ')\n    var plural = containerAttrs.length > 1\n    _.warn(\n      'Attribute' + (plural ? 's ' : ' ') + names +\n      (plural ? ' are' : ' is') + ' ignored on component ' +\n      '<' + options.el.tagName.toLowerCase() + '> because ' +\n      'the component is a fragment instance: ' +\n      'http://vuejs.org/guide/components.html#Fragment_Instance'\n    )\n  }\n\n  return function rootLinkFn (vm, el, scope) {\n    // link context scope dirs\n    var context = vm._context\n    var contextDirs\n    if (context && contextLinkFn) {\n      contextDirs = linkAndCapture(function () {\n        contextLinkFn(context, el, null, scope)\n      }, context)\n    }\n\n    // link self\n    var selfDirs = linkAndCapture(function () {\n      if (replacerLinkFn) replacerLinkFn(vm, el)\n    }, vm)\n\n    // return the unlink function that tearsdown context\n    // container directives.\n    return makeUnlinkFn(vm, selfDirs, context, contextDirs)\n  }\n}\n\n/**\n * Compile a node and return a nodeLinkFn based on the\n * node type.\n *\n * @param {Node} node\n * @param {Object} options\n * @return {Function|null}\n */\n\nfunction compileNode (node, options) {\n  var type = node.nodeType\n  if (type === 1 && node.tagName !== 'SCRIPT') {\n    return compileElement(node, options)\n  } else if (type === 3 && node.data.trim()) {\n    return compileTextNode(node, options)\n  } else {\n    return null\n  }\n}\n\n/**\n * Compile an element and return a nodeLinkFn.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function|null}\n */\n\nfunction compileElement (el, options) {\n  // preprocess textareas.\n  // textarea treats its text content as the initial value.\n  // just bind it as an attr directive for value.\n  if (el.tagName === 'TEXTAREA') {\n    var tokens = textParser.parse(el.value)\n    if (tokens) {\n      el.setAttribute(':value', textParser.tokensToExp(tokens))\n      el.value = ''\n    }\n  }\n  var linkFn\n  var hasAttrs = el.hasAttributes()\n  // check terminal directives (for & if)\n  if (hasAttrs) {\n    linkFn = checkTerminalDirectives(el, options)\n  }\n  // check element directives\n  if (!linkFn) {\n    linkFn = checkElementDirectives(el, options)\n  }\n  // check component\n  if (!linkFn) {\n    linkFn = checkComponent(el, options)\n  }\n  // normal directives\n  if (!linkFn && hasAttrs) {\n    linkFn = compileDirectives(el.attributes, options)\n  }\n  return linkFn\n}\n\n/**\n * Compile a textNode and return a nodeLinkFn.\n *\n * @param {TextNode} node\n * @param {Object} options\n * @return {Function|null} textNodeLinkFn\n */\n\nfunction compileTextNode (node, options) {\n  var tokens = textParser.parse(node.data)\n  if (!tokens) {\n    return null\n  }\n  var frag = document.createDocumentFragment()\n  var el, token\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i]\n    el = token.tag\n      ? processTextToken(token, options)\n      : document.createTextNode(token.value)\n    frag.appendChild(el)\n  }\n  return makeTextNodeLinkFn(tokens, frag, options)\n}\n\n/**\n * Process a single text token.\n *\n * @param {Object} token\n * @param {Object} options\n * @return {Node}\n */\n\nfunction processTextToken (token, options) {\n  var el\n  if (token.oneTime) {\n    el = document.createTextNode(token.value)\n  } else {\n    if (token.html) {\n      el = document.createComment('v-html')\n      setTokenType('html')\n    } else {\n      // IE will clean up empty textNodes during\n      // frag.cloneNode(true), so we have to give it\n      // something here...\n      el = document.createTextNode(' ')\n      setTokenType('text')\n    }\n  }\n  function setTokenType (type) {\n    if (token.descriptor) return\n    var parsed = dirParser.parse(token.value)\n    token.descriptor = {\n      name: type,\n      def: publicDirectives[type],\n      expression: parsed.expression,\n      filters: parsed.filters\n    }\n  }\n  return el\n}\n\n/**\n * Build a function that processes a textNode.\n *\n * @param {Array<Object>} tokens\n * @param {DocumentFragment} frag\n */\n\nfunction makeTextNodeLinkFn (tokens, frag) {\n  return function textNodeLinkFn (vm, el, host, scope) {\n    var fragClone = frag.cloneNode(true)\n    var childNodes = _.toArray(fragClone.childNodes)\n    var token, value, node\n    for (var i = 0, l = tokens.length; i < l; i++) {\n      token = tokens[i]\n      value = token.value\n      if (token.tag) {\n        node = childNodes[i]\n        if (token.oneTime) {\n          value = (scope || vm).$eval(value)\n          if (token.html) {\n            _.replace(node, templateParser.parse(value, true))\n          } else {\n            node.data = value\n          }\n        } else {\n          vm._bindDir(token.descriptor, node, host, scope)\n        }\n      }\n    }\n    _.replace(el, fragClone)\n  }\n}\n\n/**\n * Compile a node list and return a childLinkFn.\n *\n * @param {NodeList} nodeList\n * @param {Object} options\n * @return {Function|undefined}\n */\n\nfunction compileNodeList (nodeList, options) {\n  var linkFns = []\n  var nodeLinkFn, childLinkFn, node\n  for (var i = 0, l = nodeList.length; i < l; i++) {\n    node = nodeList[i]\n    nodeLinkFn = compileNode(node, options)\n    childLinkFn =\n      !(nodeLinkFn && nodeLinkFn.terminal) &&\n      node.tagName !== 'SCRIPT' &&\n      node.hasChildNodes()\n        ? compileNodeList(node.childNodes, options)\n        : null\n    linkFns.push(nodeLinkFn, childLinkFn)\n  }\n  return linkFns.length\n    ? makeChildLinkFn(linkFns)\n    : null\n}\n\n/**\n * Make a child link function for a node's childNodes.\n *\n * @param {Array<Function>} linkFns\n * @return {Function} childLinkFn\n */\n\nfunction makeChildLinkFn (linkFns) {\n  return function childLinkFn (vm, nodes, host, scope, frag) {\n    var node, nodeLinkFn, childrenLinkFn\n    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n      node = nodes[n]\n      nodeLinkFn = linkFns[i++]\n      childrenLinkFn = linkFns[i++]\n      // cache childNodes before linking parent, fix #657\n      var childNodes = _.toArray(node.childNodes)\n      if (nodeLinkFn) {\n        nodeLinkFn(vm, node, host, scope, frag)\n      }\n      if (childrenLinkFn) {\n        childrenLinkFn(vm, childNodes, host, scope, frag)\n      }\n    }\n  }\n}\n\n/**\n * Check for element directives (custom elements that should\n * be resovled as terminal directives).\n *\n * @param {Element} el\n * @param {Object} options\n */\n\nfunction checkElementDirectives (el, options) {\n  var tag = el.tagName.toLowerCase()\n  if (_.commonTagRE.test(tag)) return\n  var def = resolveAsset(options, 'elementDirectives', tag)\n  if (def) {\n    return makeTerminalNodeLinkFn(el, tag, '', options, def)\n  }\n}\n\n/**\n * Check if an element is a component. If yes, return\n * a component link function.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function|undefined}\n */\n\nfunction checkComponent (el, options) {\n  var component = _.checkComponent(el, options)\n  if (component) {\n    var descriptor = {\n      name: 'component',\n      expression: component.id,\n      def: internalDirectives.component,\n      modifiers: {\n        literal: !component.dynamic\n      }\n    }\n    var componentLinkFn = function (vm, el, host, scope, frag) {\n      vm._bindDir(descriptor, el, host, scope, frag)\n    }\n    componentLinkFn.terminal = true\n    return componentLinkFn\n  }\n}\n\n/**\n * Check an element for terminal directives in fixed order.\n * If it finds one, return a terminal link function.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function} terminalLinkFn\n */\n\nfunction checkTerminalDirectives (el, options) {\n  // skip v-pre\n  if (_.attr(el, 'v-pre') !== null) {\n    return skip\n  }\n  // skip v-else block, but only if following v-if\n  if (el.hasAttribute('v-else')) {\n    var prev = el.previousElementSibling\n    if (prev && prev.hasAttribute('v-if')) {\n      return skip\n    }\n  }\n  var value, dirName\n  for (var i = 0, l = terminalDirectives.length; i < l; i++) {\n    dirName = terminalDirectives[i]\n    /* eslint-disable no-cond-assign */\n    if (value = el.getAttribute('v-' + dirName)) {\n      return makeTerminalNodeLinkFn(el, dirName, value, options)\n    }\n    /* eslint-enable no-cond-assign */\n  }\n}\n\nfunction skip () {}\nskip.terminal = true\n\n/**\n * Build a node link function for a terminal directive.\n * A terminal link function terminates the current\n * compilation recursion and handles compilation of the\n * subtree in the directive.\n *\n * @param {Element} el\n * @param {String} dirName\n * @param {String} value\n * @param {Object} options\n * @param {Object} [def]\n * @return {Function} terminalLinkFn\n */\n\nfunction makeTerminalNodeLinkFn (el, dirName, value, options, def) {\n  var parsed = dirParser.parse(value)\n  var descriptor = {\n    name: dirName,\n    expression: parsed.expression,\n    filters: parsed.filters,\n    raw: value,\n    // either an element directive, or if/for\n    def: def || publicDirectives[dirName]\n  }\n  var fn = function terminalNodeLinkFn (vm, el, host, scope, frag) {\n    vm._bindDir(descriptor, el, host, scope, frag)\n  }\n  fn.terminal = true\n  return fn\n}\n\n/**\n * Compile the directives on an element and return a linker.\n *\n * @param {Array|NamedNodeMap} attrs\n * @param {Object} options\n * @return {Function}\n */\n\nfunction compileDirectives (attrs, options) {\n  var i = attrs.length\n  var dirs = []\n  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens\n  while (i--) {\n    attr = attrs[i]\n    name = rawName = attr.name\n    value = rawValue = attr.value\n    tokens = textParser.parse(value)\n    // reset arg\n    arg = null\n    // check modifiers\n    modifiers = parseModifiers(name)\n    name = name.replace(modifierRE, '')\n\n    // attribute interpolations\n    if (tokens) {\n      value = textParser.tokensToExp(tokens)\n      arg = name\n      pushDir('bind', publicDirectives.bind, true)\n    } else\n\n    // special attribute: transition\n    if (transitionRE.test(name)) {\n      modifiers.literal = !bindRE.test(name)\n      pushDir('transition', internalDirectives.transition)\n    } else\n\n    // event handlers\n    if (onRE.test(name)) {\n      arg = name.replace(onRE, '')\n      pushDir('on', publicDirectives.on)\n    } else\n\n    // attribute bindings\n    if (bindRE.test(name)) {\n      dirName = name.replace(bindRE, '')\n      if (dirName === 'style' || dirName === 'class') {\n        pushDir(dirName, internalDirectives[dirName])\n      } else {\n        arg = dirName\n        pushDir('bind', publicDirectives.bind)\n      }\n    } else\n\n    // normal directives\n    if (name.indexOf('v-') === 0) {\n      // check arg\n      arg = (arg = name.match(argRE)) && arg[1]\n      if (arg) {\n        name = name.replace(argRE, '')\n      }\n      // extract directive name\n      dirName = name.slice(2)\n\n      // skip v-else (when used with v-show)\n      if (dirName === 'else') {\n        continue\n      }\n\n      dirDef = resolveAsset(options, 'directives', dirName)\n\n      if (process.env.NODE_ENV !== 'production') {\n        _.assertAsset(dirDef, 'directive', dirName)\n      }\n\n      if (dirDef) {\n        if (_.isLiteral(value)) {\n          value = _.stripQuotes(value)\n          modifiers.literal = true\n        }\n        pushDir(dirName, dirDef)\n      }\n    }\n  }\n\n  /**\n   * Push a directive.\n   *\n   * @param {String} dirName\n   * @param {Object|Function} def\n   * @param {Boolean} [interp]\n   */\n\n  function pushDir (dirName, def, interp) {\n    var parsed = dirParser.parse(value)\n    dirs.push({\n      name: dirName,\n      attr: rawName,\n      raw: rawValue,\n      def: def,\n      arg: arg,\n      modifiers: modifiers,\n      expression: parsed.expression,\n      filters: parsed.filters,\n      interp: interp\n    })\n  }\n\n  if (dirs.length) {\n    return makeNodeLinkFn(dirs)\n  }\n}\n\n/**\n * Parse modifiers from directive attribute name.\n *\n * @param {String} name\n * @return {Object}\n */\n\nfunction parseModifiers (name) {\n  var res = Object.create(null)\n  var match = name.match(modifierRE)\n  if (match) {\n    var i = match.length\n    while (i--) {\n      res[match[i].slice(1)] = true\n    }\n  }\n  return res\n}\n\n/**\n * Build a link function for all directives on a single node.\n *\n * @param {Array} directives\n * @return {Function} directivesLinkFn\n */\n\nfunction makeNodeLinkFn (directives) {\n  return function nodeLinkFn (vm, el, host, scope, frag) {\n    // reverse apply because it's sorted low to high\n    var i = directives.length\n    while (i--) {\n      vm._bindDir(directives[i], el, host, scope, frag)\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../directives/internal\":47,\"../directives/public\":57,\"../parsers/directive\":79,\"../parsers/template\":82,\"../parsers/text\":83,\"../util\":91,\"./compile-props\":36,\"_process\":1}],38:[function(require,module,exports){\nvar _ = require('../util')\n\n_.extend(exports, require('./compile'))\n_.extend(exports, require('./transclude'))\n\n},{\"../util\":91,\"./compile\":37,\"./transclude\":39}],39:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar templateParser = require('../parsers/template')\nvar specialCharRE = /[^\\w\\-:\\.]/\n\n/**\n * Process an element or a DocumentFragment based on a\n * instance option object. This allows us to transclude\n * a template node/fragment before the instance is created,\n * so the processed fragment can then be cloned and reused\n * in v-for.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Element|DocumentFragment}\n */\n\nexports.transclude = function (el, options) {\n  // extract container attributes to pass them down\n  // to compiler, because they need to be compiled in\n  // parent scope. we are mutating the options object here\n  // assuming the same object will be used for compile\n  // right after this.\n  if (options) {\n    options._containerAttrs = extractAttrs(el)\n  }\n  // for template tags, what we want is its content as\n  // a documentFragment (for fragment instances)\n  if (_.isTemplate(el)) {\n    el = templateParser.parse(el)\n  }\n  if (options) {\n    if (options._asComponent && !options.template) {\n      options.template = '<slot></slot>'\n    }\n    if (options.template) {\n      options._content = _.extractContent(el)\n      el = transcludeTemplate(el, options)\n    }\n  }\n  if (el instanceof DocumentFragment) {\n    // anchors for fragment instance\n    // passing in `persist: true` to avoid them being\n    // discarded by IE during template cloning\n    _.prepend(_.createAnchor('v-start', true), el)\n    el.appendChild(_.createAnchor('v-end', true))\n  }\n  return el\n}\n\n/**\n * Process the template option.\n * If the replace option is true this will swap the $el.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Element|DocumentFragment}\n */\n\nfunction transcludeTemplate (el, options) {\n  var template = options.template\n  var frag = templateParser.parse(template, true)\n  if (frag) {\n    var replacer = frag.firstChild\n    var tag = replacer.tagName && replacer.tagName.toLowerCase()\n    if (options.replace) {\n      /* istanbul ignore if */\n      if (el === document.body) {\n        process.env.NODE_ENV !== 'production' && _.warn(\n          'You are mounting an instance with a template to ' +\n          '<body>. This will replace <body> entirely. You ' +\n          'should probably use `replace: false` here.'\n        )\n      }\n      // there are many cases where the instance must\n      // become a fragment instance: basically anything that\n      // can create more than 1 root nodes.\n      if (\n        // multi-children template\n        frag.childNodes.length > 1 ||\n        // non-element template\n        replacer.nodeType !== 1 ||\n        // single nested component\n        tag === 'component' ||\n        _.resolveAsset(options, 'components', tag) ||\n        replacer.hasAttribute('is') ||\n        replacer.hasAttribute(':is') ||\n        replacer.hasAttribute('v-bind:is') ||\n        // element directive\n        _.resolveAsset(options, 'elementDirectives', tag) ||\n        // for block\n        replacer.hasAttribute('v-for') ||\n        // if block\n        replacer.hasAttribute('v-if')\n      ) {\n        return frag\n      } else {\n        options._replacerAttrs = extractAttrs(replacer)\n        mergeAttrs(el, replacer)\n        return replacer\n      }\n    } else {\n      el.appendChild(frag)\n      return el\n    }\n  } else {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Invalid template option: ' + template\n    )\n  }\n}\n\n/**\n * Helper to extract a component container's attributes\n * into a plain object array.\n *\n * @param {Element} el\n * @return {Array}\n */\n\nfunction extractAttrs (el) {\n  if (el.nodeType === 1 && el.hasAttributes()) {\n    return _.toArray(el.attributes)\n  }\n}\n\n/**\n * Merge the attributes of two elements, and make sure\n * the class names are merged properly.\n *\n * @param {Element} from\n * @param {Element} to\n */\n\nfunction mergeAttrs (from, to) {\n  var attrs = from.attributes\n  var i = attrs.length\n  var name, value\n  while (i--) {\n    name = attrs[i].name\n    value = attrs[i].value\n    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {\n      to.setAttribute(name, value)\n    } else if (name === 'class') {\n      value = to.getAttribute(name) + ' ' + value\n      to.setAttribute(name, value)\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../parsers/template\":82,\"../util\":91,\"_process\":1}],40:[function(require,module,exports){\nmodule.exports = {\n\n  /**\n   * Whether to print debug messages.\n   * Also enables stack trace for warnings.\n   *\n   * @type {Boolean}\n   */\n\n  debug: false,\n\n  /**\n   * Whether to suppress warnings.\n   *\n   * @type {Boolean}\n   */\n\n  silent: false,\n\n  /**\n   * Whether to use async rendering.\n   */\n\n  async: true,\n\n  /**\n   * Whether to warn against errors caught when evaluating\n   * expressions.\n   */\n\n  warnExpressionErrors: true,\n\n  /**\n   * Internal flag to indicate the delimiters have been\n   * changed.\n   *\n   * @type {Boolean}\n   */\n\n  _delimitersChanged: true,\n\n  /**\n   * List of asset types that a component can own.\n   *\n   * @type {Array}\n   */\n\n  _assetTypes: [\n    'component',\n    'directive',\n    'elementDirective',\n    'filter',\n    'transition',\n    'partial'\n  ],\n\n  /**\n   * prop binding modes\n   */\n\n  _propBindingModes: {\n    ONE_WAY: 0,\n    TWO_WAY: 1,\n    ONE_TIME: 2\n  },\n\n  /**\n   * Max circular updates allowed in a batcher flush cycle.\n   */\n\n  _maxUpdateCount: 100\n\n}\n\n/**\n * Interpolation delimiters. Changing these would trigger\n * the text parser to re-compile the regular expressions.\n *\n * @type {Array<String>}\n */\n\nvar delimiters = ['{{', '}}']\nvar unsafeDelimiters = ['{{{', '}}}']\nvar textParser = require('./parsers/text')\n\nObject.defineProperty(module.exports, 'delimiters', {\n  get: function () {\n    return delimiters\n  },\n  set: function (val) {\n    delimiters = val\n    textParser.compileRegex()\n  }\n})\n\nObject.defineProperty(module.exports, 'unsafeDelimiters', {\n  get: function () {\n    return unsafeDelimiters\n  },\n  set: function (val) {\n    unsafeDelimiters = val\n    textParser.compileRegex()\n  }\n})\n\n},{\"./parsers/text\":83}],41:[function(require,module,exports){\n(function (process){\nvar _ = require('./util')\nvar Watcher = require('./watcher')\nvar expParser = require('./parsers/expression')\nfunction noop () {}\n\n/**\n * A directive links a DOM element with a piece of data,\n * which is the result of evaluating an expression.\n * It registers a watcher with the expression and calls\n * the DOM update function when a change is triggered.\n *\n * @param {String} name\n * @param {Node} el\n * @param {Vue} vm\n * @param {Object} descriptor\n *                 - {String} name\n *                 - {Object} def\n *                 - {String} expression\n *                 - {Array<Object>} [filters]\n *                 - {Boolean} literal\n *                 - {String} attr\n *                 - {String} raw\n * @param {Object} def - directive definition object\n * @param {Vue} [host] - transclusion host component\n * @param {Object} [scope] - v-for scope\n * @param {Fragment} [frag] - owner fragment\n * @constructor\n */\n\nfunction Directive (descriptor, vm, el, host, scope, frag) {\n  this.vm = vm\n  this.el = el\n  // copy descriptor properties\n  this.descriptor = descriptor\n  this.name = descriptor.name\n  this.expression = descriptor.expression\n  this.arg = descriptor.arg\n  this.modifiers = descriptor.modifiers\n  this.filters = descriptor.filters\n  this.literal = this.modifiers && this.modifiers.literal\n  // private\n  this._locked = false\n  this._bound = false\n  this._listeners = null\n  // link context\n  this._host = host\n  this._scope = scope\n  this._frag = frag\n  // store directives on node in dev mode\n  if (process.env.NODE_ENV !== 'production' && this.el) {\n    this.el._vue_directives = this.el._vue_directives || []\n    this.el._vue_directives.push(this)\n  }\n}\n\n/**\n * Initialize the directive, mixin definition properties,\n * setup the watcher, call definition bind() and update()\n * if present.\n *\n * @param {Object} def\n */\n\nDirective.prototype._bind = function () {\n  var name = this.name\n  var descriptor = this.descriptor\n\n  // remove attribute\n  if (\n    (name !== 'cloak' || this.vm._isCompiled) &&\n    this.el && this.el.removeAttribute\n  ) {\n    var attr = descriptor.attr || ('v-' + name)\n    this.el.removeAttribute(attr)\n  }\n\n  // copy def properties\n  var def = descriptor.def\n  if (typeof def === 'function') {\n    this.update = def\n  } else {\n    _.extend(this, def)\n  }\n\n  // setup directive params\n  this._setupParams()\n\n  // initial bind\n  if (this.bind) {\n    this.bind()\n  }\n\n  if (this.literal) {\n    this.update && this.update(descriptor.raw)\n  } else if (\n    (this.expression || this.modifiers) &&\n    (this.update || this.twoWay) &&\n    !this._checkStatement()\n  ) {\n    // wrapped updater for context\n    var dir = this\n    if (this.update) {\n      this._update = function (val, oldVal) {\n        if (!dir._locked) {\n          dir.update(val, oldVal)\n        }\n      }\n    } else {\n      this._update = noop\n    }\n    var preProcess = this._preProcess\n      ? _.bind(this._preProcess, this)\n      : null\n    var postProcess = this._postProcess\n      ? _.bind(this._postProcess, this)\n      : null\n    var watcher = this._watcher = new Watcher(\n      this.vm,\n      this.expression,\n      this._update, // callback\n      {\n        filters: this.filters,\n        twoWay: this.twoWay,\n        deep: this.deep,\n        preProcess: preProcess,\n        postProcess: postProcess,\n        scope: this._scope\n      }\n    )\n    // v-model with inital inline value need to sync back to\n    // model instead of update to DOM on init. They would\n    // set the afterBind hook to indicate that.\n    if (this.afterBind) {\n      this.afterBind()\n    } else if (this.update) {\n      this.update(watcher.value)\n    }\n  }\n  this._bound = true\n}\n\n/**\n * Setup all param attributes, e.g. track-by,\n * transition-mode, etc...\n */\n\nDirective.prototype._setupParams = function () {\n  if (!this.params) {\n    return\n  }\n  var params = this.params\n  // swap the params array with a fresh object.\n  this.params = Object.create(null)\n  var i = params.length\n  var key, val, mappedKey\n  while (i--) {\n    key = params[i]\n    mappedKey = _.camelize(key)\n    val = _.getBindAttr(this.el, key)\n    if (val != null) {\n      // dynamic\n      this._setupParamWatcher(mappedKey, val)\n    } else {\n      // static\n      val = _.attr(this.el, key)\n      if (val != null) {\n        this.params[mappedKey] = val === '' ? true : val\n      }\n    }\n  }\n}\n\n/**\n * Setup a watcher for a dynamic param.\n *\n * @param {String} key\n * @param {String} expression\n */\n\nDirective.prototype._setupParamWatcher = function (key, expression) {\n  var self = this\n  var called = false\n  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {\n    self.params[key] = val\n    // since we are in immediate mode,\n    // only call the param change callbacks if this is not the first update.\n    if (called) {\n      var cb = self.paramWatchers && self.paramWatchers[key]\n      if (cb) {\n        cb.call(self, val, oldVal)\n      }\n    } else {\n      called = true\n    }\n  }, {\n    immediate: true\n  })\n  ;(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch)\n}\n\n/**\n * Check if the directive is a function caller\n * and if the expression is a callable one. If both true,\n * we wrap up the expression and use it as the event\n * handler.\n *\n * e.g. on-click=\"a++\"\n *\n * @return {Boolean}\n */\n\nDirective.prototype._checkStatement = function () {\n  var expression = this.expression\n  if (\n    expression && this.acceptStatement &&\n    !expParser.isSimplePath(expression)\n  ) {\n    var fn = expParser.parse(expression).get\n    var scope = this._scope || this.vm\n    var handler = function () {\n      fn.call(scope, scope)\n    }\n    if (this.filters) {\n      handler = scope._applyFilters(handler, null, this.filters)\n    }\n    this.update(handler)\n    return true\n  }\n}\n\n/**\n * Set the corresponding value with the setter.\n * This should only be used in two-way directives\n * e.g. v-model.\n *\n * @param {*} value\n * @public\n */\n\nDirective.prototype.set = function (value) {\n  /* istanbul ignore else */\n  if (this.twoWay) {\n    this._withLock(function () {\n      this._watcher.set(value)\n    })\n  } else if (process.env.NODE_ENV !== 'production') {\n    _.warn(\n      'Directive.set() can only be used inside twoWay' +\n      'directives.'\n    )\n  }\n}\n\n/**\n * Execute a function while preventing that function from\n * triggering updates on this directive instance.\n *\n * @param {Function} fn\n */\n\nDirective.prototype._withLock = function (fn) {\n  var self = this\n  self._locked = true\n  fn.call(self)\n  _.nextTick(function () {\n    self._locked = false\n  })\n}\n\n/**\n * Convenience method that attaches a DOM event listener\n * to the directive element and autometically tears it down\n * during unbind.\n *\n * @param {String} event\n * @param {Function} handler\n */\n\nDirective.prototype.on = function (event, handler) {\n  _.on(this.el, event, handler)\n  ;(this._listeners || (this._listeners = []))\n    .push([event, handler])\n}\n\n/**\n * Teardown the watcher and call unbind.\n */\n\nDirective.prototype._teardown = function () {\n  if (this._bound) {\n    this._bound = false\n    if (this.unbind) {\n      this.unbind()\n    }\n    if (this._watcher) {\n      this._watcher.teardown()\n    }\n    var listeners = this._listeners\n    var i\n    if (listeners) {\n      i = listeners.length\n      while (i--) {\n        _.off(this.el, listeners[i][0], listeners[i][1])\n      }\n    }\n    var unwatchFns = this._paramUnwatchFns\n    if (unwatchFns) {\n      i = unwatchFns.length\n      while (i--) {\n        unwatchFns[i]()\n      }\n    }\n    if (process.env.NODE_ENV !== 'production' && this.el) {\n      this.el._vue_directives.$remove(this)\n    }\n    this.vm = this.el = this._watcher = this._listeners = null\n  }\n}\n\nmodule.exports = Directive\n\n}).call(this,require('_process'))\n\n},{\"./parsers/expression\":80,\"./util\":91,\"./watcher\":95,\"_process\":1}],42:[function(require,module,exports){\nexports.slot = require('./slot')\nexports.partial = require('./partial')\n\n},{\"./partial\":43,\"./slot\":44}],43:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\nvar vIf = require('../public/if')\nvar FragmentFactory = require('../../fragment/factory')\n\nmodule.exports = {\n\n  priority: 1750,\n\n  params: ['name'],\n\n  // watch changes to name for dynamic partials\n  paramWatchers: {\n    name: function (value) {\n      vIf.remove.call(this)\n      if (value) {\n        this.insert(value)\n      }\n    }\n  },\n\n  bind: function () {\n    this.anchor = _.createAnchor('v-partial')\n    _.replace(this.el, this.anchor)\n    this.insert(this.params.name)\n  },\n\n  insert: function (id) {\n    var partial = _.resolveAsset(this.vm.$options, 'partials', id)\n    if (process.env.NODE_ENV !== 'production') {\n      _.assertAsset(partial, 'partial', id)\n    }\n    if (partial) {\n      this.factory = new FragmentFactory(this.vm, partial)\n      vIf.insert.call(this)\n    }\n  },\n\n  unbind: function () {\n    if (this.frag) {\n      this.frag.destroy()\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../fragment/factory\":69,\"../../util\":91,\"../public/if\":56,\"_process\":1}],44:[function(require,module,exports){\nvar _ = require('../../util')\nvar templateParser = require('../../parsers/template')\n\n// This is the elementDirective that handles <content>\n// transclusions. It relies on the raw content of an\n// instance being stored as `$options._content` during\n// the transclude phase.\n\nmodule.exports = {\n\n  priority: 1750,\n\n  params: ['name'],\n\n  bind: function () {\n    var host = this.vm\n    var raw = host.$options._content\n    var content\n    if (!raw) {\n      this.fallback()\n      return\n    }\n    var context = host._context\n    var slotName = this.params.name\n    if (!slotName) {\n      // Default content\n      var self = this\n      var compileDefaultContent = function () {\n        self.compile(\n          extractFragment(raw.childNodes, raw, true),\n          context,\n          host\n        )\n      }\n      if (!host._isCompiled) {\n        // defer until the end of instance compilation,\n        // because the default outlet must wait until all\n        // other possible outlets with selectors have picked\n        // out their contents.\n        host.$once('hook:compiled', compileDefaultContent)\n      } else {\n        compileDefaultContent()\n      }\n    } else {\n      var selector = '[slot=\"' + slotName + '\"]'\n      var nodes = raw.querySelectorAll(selector)\n      if (nodes.length) {\n        content = extractFragment(nodes, raw)\n        if (content.hasChildNodes()) {\n          this.compile(content, context, host)\n        } else {\n          this.fallback()\n        }\n      } else {\n        this.fallback()\n      }\n    }\n  },\n\n  fallback: function () {\n    this.compile(_.extractContent(this.el, true), this.vm)\n  },\n\n  compile: function (content, context, host) {\n    if (content && context) {\n      var scope = host\n        ? host._scope\n        : this._scope\n      this.unlink = context.$compile(\n        content, host, scope, this._frag\n      )\n    }\n    if (content) {\n      _.replace(this.el, content)\n    } else {\n      _.remove(this.el)\n    }\n  },\n\n  unbind: function () {\n    if (this.unlink) {\n      this.unlink()\n    }\n  }\n}\n\n/**\n * Extract qualified content nodes from a node list.\n *\n * @param {NodeList} nodes\n * @param {Element} parent\n * @param {Boolean} main\n * @return {DocumentFragment}\n */\n\nfunction extractFragment (nodes, parent, main) {\n  var frag = document.createDocumentFragment()\n  for (var i = 0, l = nodes.length; i < l; i++) {\n    var node = nodes[i]\n    // if this is the main outlet, we want to skip all\n    // previously selected nodes;\n    // otherwise, we want to mark the node as selected.\n    // clone the node so the original raw content remains\n    // intact. this ensures proper re-compilation in cases\n    // where the outlet is inside a conditional block\n    if (main && !node.__v_selected) {\n      append(node)\n    } else if (!main && node.parentNode === parent) {\n      node.__v_selected = true\n      append(node)\n    }\n  }\n  return frag\n\n  function append (node) {\n    if (_.isTemplate(node) &&\n        !node.hasAttribute('v-if') &&\n        !node.hasAttribute('v-for')) {\n      node = templateParser.parse(node)\n    }\n    node = templateParser.clone(node)\n    frag.appendChild(node)\n  }\n}\n\n},{\"../../parsers/template\":82,\"../../util\":91}],45:[function(require,module,exports){\nvar _ = require('../../util')\nvar addClass = _.addClass\nvar removeClass = _.removeClass\n\nmodule.exports = {\n\n  deep: true,\n\n  update: function (value) {\n    if (value && typeof value === 'string') {\n      this.handleObject(stringToObject(value))\n    } else if (_.isPlainObject(value)) {\n      this.handleObject(value)\n    } else if (_.isArray(value)) {\n      this.handleArray(value)\n    } else {\n      this.cleanup()\n    }\n  },\n\n  handleObject: function (value) {\n    this.cleanup(value)\n    var keys = this.prevKeys = Object.keys(value)\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i]\n      if (value[key]) {\n        addClass(this.el, key)\n      } else {\n        removeClass(this.el, key)\n      }\n    }\n  },\n\n  handleArray: function (value) {\n    this.cleanup(value)\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        addClass(this.el, value[i])\n      }\n    }\n    this.prevKeys = value.slice()\n  },\n\n  cleanup: function (value) {\n    if (this.prevKeys) {\n      var i = this.prevKeys.length\n      while (i--) {\n        var key = this.prevKeys[i]\n        if (key && (!value || !contains(value, key))) {\n          removeClass(this.el, key)\n        }\n      }\n    }\n  }\n}\n\nfunction stringToObject (value) {\n  var res = {}\n  var keys = value.trim().split(/\\s+/)\n  var i = keys.length\n  while (i--) {\n    res[keys[i]] = true\n  }\n  return res\n}\n\nfunction contains (value, key) {\n  return _.isArray(value)\n    ? value.indexOf(key) > -1\n    : value.hasOwnProperty(key)\n}\n\n},{\"../../util\":91}],46:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\nvar templateParser = require('../../parsers/template')\n\nmodule.exports = {\n\n  priority: 1500,\n\n  params: [\n    'keep-alive',\n    'transition-mode',\n    'inline-template'\n  ],\n\n  /**\n   * Setup. Two possible usages:\n   *\n   * - static:\n   *   <comp> or <div v-component=\"comp\">\n   *\n   * - dynamic:\n   *   <component :is=\"view\">\n   */\n\n  bind: function () {\n    if (!this.el.__vue__) {\n      // check ref\n      this.ref = _.findRef(this.el)\n      var refs = (this._scope || this.vm).$refs\n      if (this.ref && !refs.hasOwnProperty(this.ref)) {\n        _.defineReactive(refs, this.ref, null)\n      }\n      // keep-alive cache\n      this.keepAlive = this.params.keepAlive\n      if (this.keepAlive) {\n        this.cache = {}\n      }\n      // check inline-template\n      if (this.params.inlineTemplate) {\n        // extract inline template as a DocumentFragment\n        this.inlineTemplate = _.extractContent(this.el, true)\n      }\n      // component resolution related state\n      this.pendingComponentCb =\n      this.Component = null\n      // transition related state\n      this.pendingRemovals = 0\n      this.pendingRemovalCb = null\n      // check dynamic component params\n        // create a ref anchor\n      this.anchor = _.createAnchor('v-component')\n      _.replace(this.el, this.anchor)\n      // if static, build right now.\n      if (this.literal) {\n        this.setComponent(this.expression)\n      }\n    } else {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'cannot mount component \"' + this.expression + '\" ' +\n        'on already mounted element: ' + this.el\n      )\n    }\n  },\n\n  /**\n   * Public update, called by the watcher in the dynamic\n   * literal scenario, e.g. <component :is=\"view\">\n   */\n\n  update: function (value) {\n    if (!this.literal) {\n      this.setComponent(value)\n    }\n  },\n\n  /**\n   * Switch dynamic components. May resolve the component\n   * asynchronously, and perform transition based on\n   * specified transition mode. Accepts a few additional\n   * arguments specifically for vue-router.\n   *\n   * The callback is called when the full transition is\n   * finished.\n   *\n   * @param {String} value\n   * @param {Function} [cb]\n   */\n\n  setComponent: function (value, cb) {\n    this.invalidatePending()\n    if (!value) {\n      // just remove current\n      this.unbuild(true)\n      this.remove(this.childVM, cb)\n      this.childVM = null\n    } else {\n      var self = this\n      this.resolveComponent(value, function () {\n        self.mountComponent(cb)\n      })\n    }\n  },\n\n  /**\n   * Resolve the component constructor to use when creating\n   * the child vm.\n   */\n\n  resolveComponent: function (id, cb) {\n    var self = this\n    this.pendingComponentCb = _.cancellable(function (Component) {\n      self.ComponentName = Component.options.name || id\n      self.Component = Component\n      cb()\n    })\n    this.vm._resolveComponent(id, this.pendingComponentCb)\n  },\n\n  /**\n   * Create a new instance using the current constructor and\n   * replace the existing instance. This method doesn't care\n   * whether the new component and the old one are actually\n   * the same.\n   *\n   * @param {Function} [cb]\n   */\n\n  mountComponent: function (cb) {\n    // actual mount\n    this.unbuild(true)\n    var self = this\n    var activateHook = this.Component.options.activate\n    var cached = this.getCached()\n    var newComponent = this.build()\n    if (activateHook && !cached) {\n      this.waitingFor = newComponent\n      activateHook.call(newComponent, function () {\n        self.waitingFor = null\n        self.transition(newComponent, cb)\n      })\n    } else {\n      this.transition(newComponent, cb)\n    }\n  },\n\n  /**\n   * When the component changes or unbinds before an async\n   * constructor is resolved, we need to invalidate its\n   * pending callback.\n   */\n\n  invalidatePending: function () {\n    if (this.pendingComponentCb) {\n      this.pendingComponentCb.cancel()\n      this.pendingComponentCb = null\n    }\n  },\n\n  /**\n   * Instantiate/insert a new child vm.\n   * If keep alive and has cached instance, insert that\n   * instance; otherwise build a new one and cache it.\n   *\n   * @param {Object} [extraOptions]\n   * @return {Vue} - the created instance\n   */\n\n  build: function (extraOptions) {\n    var cached = this.getCached()\n    if (cached) {\n      return cached\n    }\n    if (this.Component) {\n      // default options\n      var options = {\n        name: this.ComponentName,\n        el: templateParser.clone(this.el),\n        template: this.inlineTemplate,\n        // make sure to add the child with correct parent\n        // if this is a transcluded component, its parent\n        // should be the transclusion host.\n        parent: this._host || this.vm,\n        // if no inline-template, then the compiled\n        // linker can be cached for better performance.\n        _linkerCachable: !this.inlineTemplate,\n        _ref: this.ref,\n        _asComponent: true,\n        _isRouterView: this._isRouterView,\n        // if this is a transcluded component, context\n        // will be the common parent vm of this instance\n        // and its host.\n        _context: this.vm,\n        // if this is inside an inline v-for, the scope\n        // will be the intermediate scope created for this\n        // repeat fragment. this is used for linking props\n        // and container directives.\n        _scope: this._scope,\n        // pass in the owner fragment of this component.\n        // this is necessary so that the fragment can keep\n        // track of its contained components in order to\n        // call attach/detach hooks for them.\n        _frag: this._frag\n      }\n      // extra options\n      // in 1.0.0 this is used by vue-router only\n      /* istanbul ignore if */\n      if (extraOptions) {\n        _.extend(options, extraOptions)\n      }\n      var child = new this.Component(options)\n      if (this.keepAlive) {\n        this.cache[this.Component.cid] = child\n      }\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' &&\n          this.el.hasAttribute('transition') &&\n          child._isFragment) {\n        _.warn(\n          'Transitions will not work on a fragment instance. ' +\n          'Template: ' + child.$options.template\n        )\n      }\n      return child\n    }\n  },\n\n  /**\n   * Try to get a cached instance of the current component.\n   *\n   * @return {Vue|undefined}\n   */\n\n  getCached: function () {\n    return this.keepAlive && this.cache[this.Component.cid]\n  },\n\n  /**\n   * Teardown the current child, but defers cleanup so\n   * that we can separate the destroy and removal steps.\n   *\n   * @param {Boolean} defer\n   */\n\n  unbuild: function (defer) {\n    if (this.waitingFor) {\n      this.waitingFor.$destroy()\n      this.waitingFor = null\n    }\n    var child = this.childVM\n    if (!child || this.keepAlive) {\n      return\n    }\n    // the sole purpose of `deferCleanup` is so that we can\n    // \"deactivate\" the vm right now and perform DOM removal\n    // later.\n    child.$destroy(false, defer)\n  },\n\n  /**\n   * Remove current destroyed child and manually do\n   * the cleanup after removal.\n   *\n   * @param {Function} cb\n   */\n\n  remove: function (child, cb) {\n    var keepAlive = this.keepAlive\n    if (child) {\n      // we may have a component switch when a previous\n      // component is still being transitioned out.\n      // we want to trigger only one lastest insertion cb\n      // when the existing transition finishes. (#1119)\n      this.pendingRemovals++\n      this.pendingRemovalCb = cb\n      var self = this\n      child.$remove(function () {\n        self.pendingRemovals--\n        if (!keepAlive) child._cleanup()\n        if (!self.pendingRemovals && self.pendingRemovalCb) {\n          self.pendingRemovalCb()\n          self.pendingRemovalCb = null\n        }\n      })\n    } else if (cb) {\n      cb()\n    }\n  },\n\n  /**\n   * Actually swap the components, depending on the\n   * transition mode. Defaults to simultaneous.\n   *\n   * @param {Vue} target\n   * @param {Function} [cb]\n   */\n\n  transition: function (target, cb) {\n    var self = this\n    var current = this.childVM\n    // for devtool inspection\n    if (process.env.NODE_ENV !== 'production') {\n      if (current) current._inactive = true\n      target._inactive = false\n    }\n    this.childVM = target\n    switch (self.params.transitionMode) {\n      case 'in-out':\n        target.$before(self.anchor, function () {\n          self.remove(current, cb)\n        })\n        break\n      case 'out-in':\n        self.remove(current, function () {\n          target.$before(self.anchor, cb)\n        })\n        break\n      default:\n        self.remove(current)\n        target.$before(self.anchor, cb)\n    }\n  },\n\n  /**\n   * Unbind.\n   */\n\n  unbind: function () {\n    this.invalidatePending()\n    // Do not defer cleanup when unbinding\n    this.unbuild()\n    // destroy all keep-alive cached instances\n    if (this.cache) {\n      for (var key in this.cache) {\n        this.cache[key].$destroy()\n      }\n      this.cache = null\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../parsers/template\":82,\"../../util\":91,\"_process\":1}],47:[function(require,module,exports){\nexports.style = require('./style')\nexports['class'] = require('./class')\nexports.component = require('./component')\nexports.prop = require('./prop')\nexports.transition = require('./transition')\n\n},{\"./class\":45,\"./component\":46,\"./prop\":48,\"./style\":49,\"./transition\":50}],48:[function(require,module,exports){\n// NOTE: the prop internal directive is compiled and linked\n// during _initScope(), before the created hook is called.\n// The purpose is to make the initial prop values available\n// inside `created` hooks and `data` functions.\n\nvar _ = require('../../util')\nvar Watcher = require('../../watcher')\nvar bindingModes = require('../../config')._propBindingModes\n\nmodule.exports = {\n\n  bind: function () {\n\n    var child = this.vm\n    var parent = child._context\n    // passed in from compiler directly\n    var prop = this.descriptor.prop\n    var childKey = prop.path\n    var parentKey = prop.parentPath\n    var twoWay = prop.mode === bindingModes.TWO_WAY\n\n    var parentWatcher = this.parentWatcher = new Watcher(\n      parent,\n      parentKey,\n      function (val) {\n        if (_.assertProp(prop, val)) {\n          child[childKey] = val\n        }\n      }, {\n        twoWay: twoWay,\n        filters: prop.filters,\n        // important: props need to be observed on the\n        // v-for scope if present\n        scope: this._scope\n      }\n    )\n\n    // set the child initial value.\n    _.initProp(child, prop, parentWatcher.value)\n\n    // setup two-way binding\n    if (twoWay) {\n      // important: defer the child watcher creation until\n      // the created hook (after data observation)\n      var self = this\n      child.$once('hook:created', function () {\n        self.childWatcher = new Watcher(\n          child,\n          childKey,\n          function (val) {\n            parentWatcher.set(val)\n          }\n        )\n      })\n    }\n  },\n\n  unbind: function () {\n    this.parentWatcher.teardown()\n    if (this.childWatcher) {\n      this.childWatcher.teardown()\n    }\n  }\n}\n\n},{\"../../config\":40,\"../../util\":91,\"../../watcher\":95}],49:[function(require,module,exports){\nvar _ = require('../../util')\nvar prefixes = ['-webkit-', '-moz-', '-ms-']\nvar camelPrefixes = ['Webkit', 'Moz', 'ms']\nvar importantRE = /!important;?$/\nvar testEl = null\nvar propCache = {}\n\nmodule.exports = {\n\n  deep: true,\n\n  update: function (value) {\n    if (typeof value === 'string') {\n      this.el.style.cssText = value\n    } else if (_.isArray(value)) {\n      this.handleObject(value.reduce(_.extend, {}))\n    } else {\n      this.handleObject(value || {})\n    }\n  },\n\n  handleObject: function (value) {\n    // cache object styles so that only changed props\n    // are actually updated.\n    var cache = this.cache || (this.cache = {})\n    var name, val\n    for (name in cache) {\n      if (!(name in value)) {\n        this.handleSingle(name, null)\n        delete cache[name]\n      }\n    }\n    for (name in value) {\n      val = value[name]\n      if (val !== cache[name]) {\n        cache[name] = val\n        this.handleSingle(name, val)\n      }\n    }\n  },\n\n  handleSingle: function (prop, value) {\n    prop = normalize(prop)\n    if (!prop) return // unsupported prop\n    // cast possible numbers/booleans into strings\n    if (value != null) value += ''\n    if (value) {\n      var isImportant = importantRE.test(value)\n        ? 'important'\n        : ''\n      if (isImportant) {\n        value = value.replace(importantRE, '').trim()\n      }\n      this.el.style.setProperty(prop, value, isImportant)\n    } else {\n      this.el.style.removeProperty(prop)\n    }\n  }\n\n}\n\n/**\n * Normalize a CSS property name.\n * - cache result\n * - auto prefix\n * - camelCase -> dash-case\n *\n * @param {String} prop\n * @return {String}\n */\n\nfunction normalize (prop) {\n  if (propCache[prop]) {\n    return propCache[prop]\n  }\n  var res = prefix(prop)\n  propCache[prop] = propCache[res] = res\n  return res\n}\n\n/**\n * Auto detect the appropriate prefix for a CSS property.\n * https://gist.github.com/paulirish/523692\n *\n * @param {String} prop\n * @return {String}\n */\n\nfunction prefix (prop) {\n  prop = _.hyphenate(prop)\n  var camel = _.camelize(prop)\n  var upper = camel.charAt(0).toUpperCase() + camel.slice(1)\n  if (!testEl) {\n    testEl = document.createElement('div')\n  }\n  if (camel in testEl.style) {\n    return prop\n  }\n  var i = prefixes.length\n  var prefixed\n  while (i--) {\n    prefixed = camelPrefixes[i] + upper\n    if (prefixed in testEl.style) {\n      return prefixes[i] + prop\n    }\n  }\n}\n\n},{\"../../util\":91}],50:[function(require,module,exports){\nvar _ = require('../../util')\nvar Transition = require('../../transition/transition')\n\nmodule.exports = {\n\n  priority: 1000,\n\n  update: function (id, oldId) {\n    var el = this.el\n    // resolve on owner vm\n    var hooks = _.resolveAsset(this.vm.$options, 'transitions', id)\n    id = id || 'v'\n    // apply on closest vm\n    el.__v_trans = new Transition(el, id, hooks, this.el.__vue__ || this.vm)\n    if (oldId) {\n      _.removeClass(el, oldId + '-transition')\n    }\n    _.addClass(el, id + '-transition')\n  }\n}\n\n},{\"../../transition/transition\":86,\"../../util\":91}],51:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\n\n// xlink\nvar xlinkNS = 'http://www.w3.org/1999/xlink'\nvar xlinkRE = /^xlink:/\n\n// these input element attributes should also set their\n// corresponding properties\nvar inputProps = {\n  value: 1,\n  checked: 1,\n  selected: 1\n}\n\n// these attributes should set a hidden property for\n// binding v-model to object values\nvar modelProps = {\n  value: '_value',\n  'true-value': '_trueValue',\n  'false-value': '_falseValue'\n}\n\n// check for attributes that prohibit interpolations\nvar disallowedInterpAttrRE = /^v-|^:|^@|^(is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/\n\nmodule.exports = {\n\n  priority: 850,\n\n  bind: function () {\n    var attr = this.arg\n    var tag = this.el.tagName\n    // should be deep watch on object mode\n    if (!attr) {\n      this.deep = true\n    }\n    // handle interpolation bindings\n    if (this.descriptor.interp) {\n      // only allow binding on native attributes\n      if (\n        disallowedInterpAttrRE.test(attr) ||\n        (attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT'))\n      ) {\n        process.env.NODE_ENV !== 'production' && _.warn(\n          attr + '=\"' + this.descriptor.raw + '\": ' +\n          'attribute interpolation is not allowed in Vue.js ' +\n          'directives and special attributes.'\n        )\n        this.el.removeAttribute(attr)\n        this.invalid = true\n      }\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production') {\n        var raw = attr + '=\"' + this.descriptor.raw + '\": '\n        // warn src\n        if (attr === 'src') {\n          _.warn(\n            raw + 'interpolation in \"src\" attribute will cause ' +\n            'a 404 request. Use v-bind:src instead.'\n          )\n        }\n\n        // warn style\n        if (attr === 'style') {\n          _.warn(\n            raw + 'interpolation in \"style\" attribute will cause ' +\n            'the attribute to be discarded in Internet Explorer. ' +\n            'Use v-bind:style instead.'\n          )\n        }\n      }\n    }\n  },\n\n  update: function (value) {\n    if (this.invalid) {\n      return\n    }\n    var attr = this.arg\n    if (this.arg) {\n      this.handleSingle(attr, value)\n    } else {\n      this.handleObject(value || {})\n    }\n  },\n\n  // share object handler with v-bind:class\n  handleObject: require('../internal/style').handleObject,\n\n  handleSingle: function (attr, value) {\n    if (inputProps[attr] && attr in this.el) {\n      this.el[attr] = attr === 'value'\n        ? (value || '') // IE9 will set input.value to \"null\" for null...\n        : value\n    }\n    // set model props\n    var modelProp = modelProps[attr]\n    if (modelProp) {\n      this.el[modelProp] = value\n      // update v-model if present\n      var model = this.el.__v_model\n      if (model) {\n        model.listener()\n      }\n    }\n    // do not set value attribute for textarea\n    if (attr === 'value' && this.el.tagName === 'TEXTAREA') {\n      this.el.removeAttribute(attr)\n      return\n    }\n    // update attribute\n    if (value != null && value !== false) {\n      if (xlinkRE.test(attr)) {\n        this.el.setAttributeNS(xlinkNS, attr, value)\n      } else {\n        this.el.setAttribute(attr, value)\n      }\n    } else {\n      this.el.removeAttribute(attr)\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../util\":91,\"../internal/style\":49,\"_process\":1}],52:[function(require,module,exports){\nmodule.exports = {\n  bind: function () {\n    var el = this.el\n    this.vm.$once('hook:compiled', function () {\n      el.removeAttribute('v-cloak')\n    })\n  }\n}\n\n},{}],53:[function(require,module,exports){\nvar _ = require('../../util')\n\nmodule.exports = {\n\n  priority: 1500,\n\n  bind: function () {\n    /* istanbul ignore if */\n    if (!this.arg) {\n      return\n    }\n    var id = this.id = _.camelize(this.arg)\n    var refs = (this._scope || this.vm).$els\n    if (refs.hasOwnProperty(id)) {\n      refs[id] = this.el\n    } else {\n      _.defineReactive(refs, id, this.el)\n    }\n  },\n\n  unbind: function () {\n    var refs = (this._scope || this.vm).$els\n    if (refs[this.id] === this.el) {\n      refs[this.id] = null\n    }\n  }\n}\n\n},{\"../../util\":91}],54:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\nvar FragmentFactory = require('../../fragment/factory')\nvar isObject = _.isObject\nvar uid = 0\n\nmodule.exports = {\n\n  priority: 2000,\n\n  params: [\n    'track-by',\n    'stagger',\n    'enter-stagger',\n    'leave-stagger'\n  ],\n\n  bind: function () {\n    // support \"item in items\" syntax\n    var inMatch = this.expression.match(/(.*) in (.*)/)\n    if (inMatch) {\n      var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/)\n      if (itMatch) {\n        this.iterator = itMatch[1].trim()\n        this.alias = itMatch[2].trim()\n      } else {\n        this.alias = inMatch[1].trim()\n      }\n      this.expression = inMatch[2]\n    }\n\n    if (!this.alias) {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'Alias is required in v-for.'\n      )\n      return\n    }\n\n    // uid as a cache identifier\n    this.id = '__v-for__' + (++uid)\n\n    // check if this is an option list,\n    // so that we know if we need to update the <select>'s\n    // v-model when the option list has changed.\n    // because v-model has a lower priority than v-for,\n    // the v-model is not bound here yet, so we have to\n    // retrive it in the actual updateModel() function.\n    var tag = this.el.tagName\n    this.isOption =\n      (tag === 'OPTION' || tag === 'OPTGROUP') &&\n      this.el.parentNode.tagName === 'SELECT'\n\n    // setup anchor nodes\n    this.start = _.createAnchor('v-for-start')\n    this.end = _.createAnchor('v-for-end')\n    _.replace(this.el, this.end)\n    _.before(this.start, this.end)\n\n    // check ref\n    this.ref = _.findRef(this.el)\n\n    // cache\n    this.cache = Object.create(null)\n\n    // fragment factory\n    this.factory = new FragmentFactory(this.vm, this.el)\n  },\n\n  update: function (data) {\n    this.diff(data)\n    this.updateRef()\n    this.updateModel()\n  },\n\n  /**\n   * Diff, based on new data and old data, determine the\n   * minimum amount of DOM manipulations needed to make the\n   * DOM reflect the new data Array.\n   *\n   * The algorithm diffs the new data Array by storing a\n   * hidden reference to an owner vm instance on previously\n   * seen data. This allows us to achieve O(n) which is\n   * better than a levenshtein distance based algorithm,\n   * which is O(m * n).\n   *\n   * @param {Array} data\n   */\n\n  diff: function (data) {\n    // check if the Array was converted from an Object\n    var item = data[0]\n    var convertedFromObject = this.fromObject =\n      isObject(item) &&\n      item.hasOwnProperty('$key') &&\n      item.hasOwnProperty('$value')\n\n    var trackByKey = this.params.trackBy\n    var oldFrags = this.frags\n    var frags = this.frags = new Array(data.length)\n    var alias = this.alias\n    var iterator = this.iterator\n    var start = this.start\n    var end = this.end\n    var inDoc = _.inDoc(start)\n    var init = !oldFrags\n    var i, l, frag, key, value, primitive\n\n    // First pass, go through the new Array and fill up\n    // the new frags array. If a piece of data has a cached\n    // instance for it, we reuse it. Otherwise build a new\n    // instance.\n    for (i = 0, l = data.length; i < l; i++) {\n      item = data[i]\n      key = convertedFromObject ? item.$key : null\n      value = convertedFromObject ? item.$value : item\n      primitive = !isObject(value)\n      frag = !init && this.getCachedFrag(value, i, key)\n      if (frag) { // reusable fragment\n        frag.reused = true\n        // update $index\n        frag.scope.$index = i\n        // update $key\n        if (key) {\n          frag.scope.$key = key\n        }\n        // update iterator\n        if (iterator) {\n          frag.scope[iterator] = key !== null ? key : i\n        }\n        // update data for track-by, object repeat &\n        // primitive values.\n        if (trackByKey || convertedFromObject || primitive) {\n          frag.scope[alias] = value\n        }\n      } else { // new isntance\n        frag = this.create(value, alias, i, key)\n        frag.fresh = !init\n      }\n      frags[i] = frag\n      if (init) {\n        frag.before(end)\n      }\n    }\n\n    // we're done for the initial render.\n    if (init) {\n      return\n    }\n\n    // Second pass, go through the old fragments and\n    // destroy those who are not reused (and remove them\n    // from cache)\n    var removalIndex = 0\n    var totalRemoved = oldFrags.length - frags.length\n    for (i = 0, l = oldFrags.length; i < l; i++) {\n      frag = oldFrags[i]\n      if (!frag.reused) {\n        this.deleteCachedFrag(frag)\n        this.remove(frag, removalIndex++, totalRemoved, inDoc)\n      }\n    }\n\n    // Final pass, move/insert new fragments into the\n    // right place.\n    var targetPrev, prevEl, currentPrev\n    var insertionIndex = 0\n    for (i = 0, l = frags.length; i < l; i++) {\n      frag = frags[i]\n      // this is the frag that we should be after\n      targetPrev = frags[i - 1]\n      prevEl = targetPrev\n        ? targetPrev.staggerCb\n          ? targetPrev.staggerAnchor\n          : targetPrev.end || targetPrev.node\n        : start\n      if (frag.reused && !frag.staggerCb) {\n        currentPrev = findPrevFrag(frag, start, this.id)\n        if (currentPrev !== targetPrev) {\n          this.move(frag, prevEl)\n        }\n      } else {\n        // new instance, or still in stagger.\n        // insert with updated stagger index.\n        this.insert(frag, insertionIndex++, prevEl, inDoc)\n      }\n      frag.reused = frag.fresh = false\n    }\n  },\n\n  /**\n   * Create a new fragment instance.\n   *\n   * @param {*} value\n   * @param {String} alias\n   * @param {Number} index\n   * @param {String} [key]\n   * @return {Fragment}\n   */\n\n  create: function (value, alias, index, key) {\n    var host = this._host\n    // create iteration scope\n    var parentScope = this._scope || this.vm\n    var scope = Object.create(parentScope)\n    // ref holder for the scope\n    scope.$refs = Object.create(parentScope.$refs)\n    scope.$els = Object.create(parentScope.$els)\n    // make sure point $parent to parent scope\n    scope.$parent = parentScope\n    // for two-way binding on alias\n    scope.$forContext = this\n    // define scope properties\n    _.defineReactive(scope, alias, value)\n    _.defineReactive(scope, '$index', index)\n    if (key) {\n      _.defineReactive(scope, '$key', key)\n    } else if (scope.$key) {\n      // avoid accidental fallback\n      _.define(scope, '$key', null)\n    }\n    if (this.iterator) {\n      _.defineReactive(scope, this.iterator, key !== null ? key : index)\n    }\n    var frag = this.factory.create(host, scope, this._frag)\n    frag.forId = this.id\n    this.cacheFrag(value, frag, index, key)\n    return frag\n  },\n\n  /**\n   * Update the v-ref on owner vm.\n   */\n\n  updateRef: function () {\n    var ref = this.ref\n    if (!ref) return\n    var hash = (this._scope || this.vm).$refs\n    var refs\n    if (!this.fromObject) {\n      refs = this.frags.map(findVmFromFrag)\n    } else {\n      refs = {}\n      this.frags.forEach(function (frag) {\n        refs[frag.scope.$key] = findVmFromFrag(frag)\n      })\n    }\n    if (!hash.hasOwnProperty(ref)) {\n      _.defineReactive(hash, ref, refs)\n    } else {\n      hash[ref] = refs\n    }\n  },\n\n  /**\n   * For option lists, update the containing v-model on\n   * parent <select>.\n   */\n\n  updateModel: function () {\n    if (this.isOption) {\n      var parent = this.start.parentNode\n      var model = parent && parent.__v_model\n      if (model) {\n        model.forceUpdate()\n      }\n    }\n  },\n\n  /**\n   * Insert a fragment. Handles staggering.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Node} prevEl\n   * @param {Boolean} inDoc\n   */\n\n  insert: function (frag, index, prevEl, inDoc) {\n    if (frag.staggerCb) {\n      frag.staggerCb.cancel()\n      frag.staggerCb = null\n    }\n    var staggerAmount = this.getStagger(frag, index, null, 'enter')\n    if (inDoc && staggerAmount) {\n      // create an anchor and insert it synchronously,\n      // so that we can resolve the correct order without\n      // worrying about some elements not inserted yet\n      var anchor = frag.staggerAnchor\n      if (!anchor) {\n        anchor = frag.staggerAnchor = _.createAnchor('stagger-anchor')\n        anchor.__vfrag__ = frag\n      }\n      _.after(anchor, prevEl)\n      var op = frag.staggerCb = _.cancellable(function () {\n        frag.staggerCb = null\n        frag.before(anchor)\n        _.remove(anchor)\n      })\n      setTimeout(op, staggerAmount)\n    } else {\n      frag.before(prevEl.nextSibling)\n    }\n  },\n\n  /**\n   * Remove a fragment. Handles staggering.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Number} total\n   * @param {Boolean} inDoc\n   */\n\n  remove: function (frag, index, total, inDoc) {\n    if (frag.staggerCb) {\n      frag.staggerCb.cancel()\n      frag.staggerCb = null\n      // it's not possible for the same frag to be removed\n      // twice, so if we have a pending stagger callback,\n      // it means this frag is queued for enter but removed\n      // before its transition started. Since it is already\n      // destroyed, we can just leave it in detached state.\n      return\n    }\n    var staggerAmount = this.getStagger(frag, index, total, 'leave')\n    if (inDoc && staggerAmount) {\n      var op = frag.staggerCb = _.cancellable(function () {\n        frag.staggerCb = null\n        frag.remove(true)\n      })\n      setTimeout(op, staggerAmount)\n    } else {\n      frag.remove(true)\n    }\n  },\n\n  /**\n   * Move a fragment to a new position.\n   * Force no transition.\n   *\n   * @param {Fragment} frag\n   * @param {Node} prevEl\n   */\n\n  move: function (frag, prevEl) {\n    frag.before(prevEl.nextSibling, false)\n  },\n\n  /**\n   * Cache a fragment using track-by or the object key.\n   *\n   * @param {*} value\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {String} [key]\n   */\n\n  cacheFrag: function (value, frag, index, key) {\n    var trackByKey = this.params.trackBy\n    var cache = this.cache\n    var primitive = !isObject(value)\n    var id\n    if (key || trackByKey || primitive) {\n      id = trackByKey\n        ? trackByKey === '$index'\n          ? index\n          : value[trackByKey]\n        : (key || value)\n      if (!cache[id]) {\n        cache[id] = frag\n      } else if (trackByKey !== '$index') {\n        process.env.NODE_ENV !== 'production' &&\n        this.warnDuplicate(value)\n      }\n    } else {\n      id = this.id\n      if (value.hasOwnProperty(id)) {\n        if (value[id] === null) {\n          value[id] = frag\n        } else {\n          process.env.NODE_ENV !== 'production' &&\n          this.warnDuplicate(value)\n        }\n      } else {\n        _.define(value, id, frag)\n      }\n    }\n    frag.raw = value\n  },\n\n  /**\n   * Get a cached fragment from the value/index/key\n   *\n   * @param {*} value\n   * @param {Number} index\n   * @param {String} key\n   * @return {Fragment}\n   */\n\n  getCachedFrag: function (value, index, key) {\n    var trackByKey = this.params.trackBy\n    var primitive = !isObject(value)\n    var frag\n    if (key || trackByKey || primitive) {\n      var id = trackByKey\n        ? trackByKey === '$index'\n          ? index\n          : value[trackByKey]\n        : (key || value)\n      frag = this.cache[id]\n    } else {\n      frag = value[this.id]\n    }\n    if (frag && (frag.reused || frag.fresh)) {\n      process.env.NODE_ENV !== 'production' &&\n      this.warnDuplicate(value)\n    }\n    return frag\n  },\n\n  /**\n   * Delete a fragment from cache.\n   *\n   * @param {Fragment} frag\n   */\n\n  deleteCachedFrag: function (frag) {\n    var value = frag.raw\n    var trackByKey = this.params.trackBy\n    var scope = frag.scope\n    var index = scope.$index\n    // fix #948: avoid accidentally fall through to\n    // a parent repeater which happens to have $key.\n    var key = scope.hasOwnProperty('$key') && scope.$key\n    var primitive = !isObject(value)\n    if (trackByKey || key || primitive) {\n      var id = trackByKey\n        ? trackByKey === '$index'\n          ? index\n          : value[trackByKey]\n        : (key || value)\n      this.cache[id] = null\n    } else {\n      value[this.id] = null\n      frag.raw = null\n    }\n  },\n\n  /**\n   * Get the stagger amount for an insertion/removal.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Number} total\n   * @param {String} type\n   */\n\n  getStagger: function (frag, index, total, type) {\n    type = type + 'Stagger'\n    var trans = frag.node.__v_trans\n    var hooks = trans && trans.hooks\n    var hook = hooks && (hooks[type] || hooks.stagger)\n    return hook\n      ? hook.call(frag, index, total)\n      : index * parseInt(this.params[type] || this.params.stagger, 10)\n  },\n\n  /**\n   * Pre-process the value before piping it through the\n   * filters. This is passed to and called by the watcher.\n   */\n\n  _preProcess: function (value) {\n    // regardless of type, store the un-filtered raw value.\n    this.rawValue = value\n    return value\n  },\n\n  /**\n   * Post-process the value after it has been piped through\n   * the filters. This is passed to and called by the watcher.\n   *\n   * It is necessary for this to be called during the\n   * wathcer's dependency collection phase because we want\n   * the v-for to update when the source Object is mutated.\n   */\n\n  _postProcess: function (value) {\n    if (_.isArray(value)) {\n      return value\n    } else if (_.isPlainObject(value)) {\n      // convert plain object to array.\n      var keys = Object.keys(value)\n      var i = keys.length\n      var res = new Array(i)\n      var key\n      while (i--) {\n        key = keys[i]\n        res[i] = {\n          $key: key,\n          $value: value[key]\n        }\n      }\n      return res\n    } else {\n      var type = typeof value\n      if (type === 'number') {\n        value = range(value)\n      } else if (type === 'string') {\n        value = _.toArray(value)\n      }\n      return value || []\n    }\n  },\n\n  unbind: function () {\n    if (this.ref) {\n      (this._scope || this.vm).$refs[this.ref] = null\n    }\n    if (this.frags) {\n      var i = this.frags.length\n      var frag\n      while (i--) {\n        frag = this.frags[i]\n        this.deleteCachedFrag(frag)\n        frag.destroy()\n      }\n    }\n  }\n}\n\n/**\n * Helper to find the previous element that is a fragment\n * anchor. This is necessary because a destroyed frag's\n * element could still be lingering in the DOM before its\n * leaving transition finishes, but its inserted flag\n * should have been set to false so we can skip them.\n *\n * If this is a block repeat, we want to make sure we only\n * return frag that is bound to this v-for. (see #929)\n *\n * @param {Fragment} frag\n * @param {Comment|Text} anchor\n * @param {String} id\n * @return {Fragment}\n */\n\nfunction findPrevFrag (frag, anchor, id) {\n  var el = frag.node.previousSibling\n  /* istanbul ignore if */\n  if (!el) return\n  frag = el.__vfrag__\n  while (\n    (!frag || frag.forId !== id || !frag.inserted) &&\n    el !== anchor\n  ) {\n    el = el.previousSibling\n    /* istanbul ignore if */\n    if (!el) return\n    frag = el.__vfrag__\n  }\n  return frag\n}\n\n/**\n * Find a vm from a fragment.\n *\n * @param {Fragment} frag\n * @return {Vue|undefined}\n */\n\nfunction findVmFromFrag (frag) {\n  return frag.node.__vue__ || frag.node.nextSibling.__vue__\n}\n\n/**\n * Create a range array from given number.\n *\n * @param {Number} n\n * @return {Array}\n */\n\nfunction range (n) {\n  var i = -1\n  var ret = new Array(n)\n  while (++i < n) {\n    ret[i] = i\n  }\n  return ret\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  module.exports.warnDuplicate = function (value) {\n    _.warn(\n      'Duplicate value found in v-for=\"' + this.descriptor.raw + '\": ' +\n      JSON.stringify(value) + '. Use track-by=\"$index\" if ' +\n      'you are expecting duplicate values.'\n    )\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../fragment/factory\":69,\"../../util\":91,\"_process\":1}],55:[function(require,module,exports){\nvar _ = require('../../util')\nvar templateParser = require('../../parsers/template')\n\nmodule.exports = {\n\n  bind: function () {\n    // a comment node means this is a binding for\n    // {{{ inline unescaped html }}}\n    if (this.el.nodeType === 8) {\n      // hold nodes\n      this.nodes = []\n      // replace the placeholder with proper anchor\n      this.anchor = _.createAnchor('v-html')\n      _.replace(this.el, this.anchor)\n    }\n  },\n\n  update: function (value) {\n    value = _.toString(value)\n    if (this.nodes) {\n      this.swap(value)\n    } else {\n      this.el.innerHTML = value\n    }\n  },\n\n  swap: function (value) {\n    // remove old nodes\n    var i = this.nodes.length\n    while (i--) {\n      _.remove(this.nodes[i])\n    }\n    // convert new value to a fragment\n    // do not attempt to retrieve from id selector\n    var frag = templateParser.parse(value, true, true)\n    // save a reference to these nodes so we can remove later\n    this.nodes = _.toArray(frag.childNodes)\n    _.before(frag, this.anchor)\n  }\n}\n\n},{\"../../parsers/template\":82,\"../../util\":91}],56:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\nvar FragmentFactory = require('../../fragment/factory')\n\nmodule.exports = {\n\n  priority: 2000,\n\n  bind: function () {\n    var el = this.el\n    if (!el.__vue__) {\n      // check else block\n      var next = el.nextElementSibling\n      if (next && _.attr(next, 'v-else') !== null) {\n        _.remove(next)\n        this.elseFactory = new FragmentFactory(this.vm, next)\n      }\n      // check main block\n      this.anchor = _.createAnchor('v-if')\n      _.replace(el, this.anchor)\n      this.factory = new FragmentFactory(this.vm, el)\n    } else {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'v-if=\"' + this.expression + '\" cannot be ' +\n        'used on an instance root element.'\n      )\n      this.invalid = true\n    }\n  },\n\n  update: function (value) {\n    if (this.invalid) return\n    if (value) {\n      if (!this.frag) {\n        this.insert()\n      }\n    } else {\n      this.remove()\n    }\n  },\n\n  insert: function () {\n    if (this.elseFrag) {\n      this.elseFrag.remove(true)\n      this.elseFrag = null\n    }\n    this.frag = this.factory.create(this._host, this._scope, this._frag)\n    this.frag.before(this.anchor)\n  },\n\n  remove: function () {\n    if (this.frag) {\n      this.frag.remove(true)\n      this.frag = null\n    }\n    if (this.elseFactory) {\n      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag)\n      this.elseFrag.before(this.anchor)\n    }\n  },\n\n  unbind: function () {\n    if (this.frag) {\n      this.frag.destroy()\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../fragment/factory\":69,\"../../util\":91,\"_process\":1}],57:[function(require,module,exports){\n// text & html\nexports.text = require('./text')\nexports.html = require('./html')\n\n// logic control\nexports['for'] = require('./for')\nexports['if'] = require('./if')\nexports.show = require('./show')\n\n// two-way binding\nexports.model = require('./model')\n\n// event handling\nexports.on = require('./on')\n\n// attributes\nexports.bind = require('./bind')\n\n// ref & el\nexports.el = require('./el')\nexports.ref = require('./ref')\n\n// cloak\nexports.cloak = require('./cloak')\n\n},{\"./bind\":51,\"./cloak\":52,\"./el\":53,\"./for\":54,\"./html\":55,\"./if\":56,\"./model\":59,\"./on\":63,\"./ref\":64,\"./show\":65,\"./text\":66}],58:[function(require,module,exports){\nvar _ = require('../../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    var self = this\n    var el = this.el\n\n    this.getValue = function () {\n      return el.hasOwnProperty('_value')\n        ? el._value\n        : self.params.number\n          ? _.toNumber(el.value)\n          : el.value\n    }\n\n    function getBooleanValue () {\n      var val = el.checked\n      if (val && el.hasOwnProperty('_trueValue')) {\n        return el._trueValue\n      }\n      if (!val && el.hasOwnProperty('_falseValue')) {\n        return el._falseValue\n      }\n      return val\n    }\n\n    this.listener = function () {\n      var model = self._watcher.value\n      if (_.isArray(model)) {\n        var val = self.getValue()\n        if (el.checked) {\n          if (_.indexOf(model, val) < 0) {\n            model.push(val)\n          }\n        } else {\n          model.$remove(val)\n        }\n      } else {\n        self.set(getBooleanValue())\n      }\n    }\n\n    this.on('change', this.listener)\n    if (el.checked) {\n      this.afterBind = this.listener\n    }\n  },\n\n  update: function (value) {\n    var el = this.el\n    if (_.isArray(value)) {\n      el.checked = _.indexOf(value, this.getValue()) > -1\n    } else {\n      if (el.hasOwnProperty('_trueValue')) {\n        el.checked = _.looseEqual(value, el._trueValue)\n      } else {\n        el.checked = !!value\n      }\n    }\n  }\n}\n\n},{\"../../../util\":91}],59:[function(require,module,exports){\n(function (process){\nvar _ = require('../../../util')\n\nvar handlers = {\n  text: require('./text'),\n  radio: require('./radio'),\n  select: require('./select'),\n  checkbox: require('./checkbox')\n}\n\nmodule.exports = {\n\n  priority: 800,\n  twoWay: true,\n  handlers: handlers,\n  params: ['lazy', 'number', 'debounce'],\n\n  /**\n   * Possible elements:\n   *   <select>\n   *   <textarea>\n   *   <input type=\"*\">\n   *     - text\n   *     - checkbox\n   *     - radio\n   *     - number\n   */\n\n  bind: function () {\n    // friendly warning...\n    this.checkFilters()\n    if (this.hasRead && !this.hasWrite) {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'It seems you are using a read-only filter with ' +\n        'v-model. You might want to use a two-way filter ' +\n        'to ensure correct behavior.'\n      )\n    }\n    var el = this.el\n    var tag = el.tagName\n    var handler\n    if (tag === 'INPUT') {\n      handler = handlers[el.type] || handlers.text\n    } else if (tag === 'SELECT') {\n      handler = handlers.select\n    } else if (tag === 'TEXTAREA') {\n      handler = handlers.text\n    } else {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'v-model does not support element type: ' + tag\n      )\n      return\n    }\n    el.__v_model = this\n    handler.bind.call(this)\n    this.update = handler.update\n    this._unbind = handler.unbind\n  },\n\n  /**\n   * Check read/write filter stats.\n   */\n\n  checkFilters: function () {\n    var filters = this.filters\n    if (!filters) return\n    var i = filters.length\n    while (i--) {\n      var filter = _.resolveAsset(this.vm.$options, 'filters', filters[i].name)\n      if (typeof filter === 'function' || filter.read) {\n        this.hasRead = true\n      }\n      if (filter.write) {\n        this.hasWrite = true\n      }\n    }\n  },\n\n  unbind: function () {\n    this.el.__v_model = null\n    this._unbind && this._unbind()\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../../util\":91,\"./checkbox\":58,\"./radio\":60,\"./select\":61,\"./text\":62,\"_process\":1}],60:[function(require,module,exports){\nvar _ = require('../../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    var self = this\n    var el = this.el\n\n    this.getValue = function () {\n      // value overwrite via v-bind:value\n      if (el.hasOwnProperty('_value')) {\n        return el._value\n      }\n      var val = el.value\n      if (self.params.number) {\n        val = _.toNumber(val)\n      }\n      return val\n    }\n\n    this.listener = function () {\n      self.set(self.getValue())\n    }\n    this.on('change', this.listener)\n\n    if (el.checked) {\n      this.afterBind = this.listener\n    }\n  },\n\n  update: function (value) {\n    this.el.checked = _.looseEqual(value, this.getValue())\n  }\n}\n\n},{\"../../../util\":91}],61:[function(require,module,exports){\nvar _ = require('../../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    var self = this\n    var el = this.el\n\n    // method to force update DOM using latest value.\n    this.forceUpdate = function () {\n      if (self._watcher) {\n        self.update(self._watcher.get())\n      }\n    }\n\n    // check if this is a multiple select\n    var multiple = this.multiple = el.hasAttribute('multiple')\n\n    // attach listener\n    this.listener = function () {\n      var value = getValue(el, multiple)\n      value = self.params.number\n        ? _.isArray(value)\n          ? value.map(_.toNumber)\n          : _.toNumber(value)\n        : value\n      self.set(value)\n    }\n    this.on('change', this.listener)\n\n    // if has initial value, set afterBind\n    var initValue = getValue(el, multiple, true)\n    if ((multiple && initValue.length) ||\n        (!multiple && initValue !== null)) {\n      this.afterBind = this.listener\n    }\n\n    // All major browsers except Firefox resets\n    // selectedIndex with value -1 to 0 when the element\n    // is appended to a new parent, therefore we have to\n    // force a DOM update whenever that happens...\n    this.vm.$on('hook:attached', this.forceUpdate)\n  },\n\n  update: function (value) {\n    var el = this.el\n    el.selectedIndex = -1\n    var multi = this.multiple && _.isArray(value)\n    var options = el.options\n    var i = options.length\n    var op, val\n    while (i--) {\n      op = options[i]\n      val = op.hasOwnProperty('_value')\n        ? op._value\n        : op.value\n      /* eslint-disable eqeqeq */\n      op.selected = multi\n        ? indexOf(value, val) > -1\n        : _.looseEqual(value, val)\n      /* eslint-enable eqeqeq */\n    }\n  },\n\n  unbind: function () {\n    /* istanbul ignore next */\n    this.vm.$off('hook:attached', this.forceUpdate)\n  }\n}\n\n/**\n * Get select value\n *\n * @param {SelectElement} el\n * @param {Boolean} multi\n * @param {Boolean} init\n * @return {Array|*}\n */\n\nfunction getValue (el, multi, init) {\n  var res = multi ? [] : null\n  var op, val, selected\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    op = el.options[i]\n    selected = init\n      ? op.hasAttribute('selected')\n      : op.selected\n    if (selected) {\n      val = op.hasOwnProperty('_value')\n        ? op._value\n        : op.value\n      if (multi) {\n        res.push(val)\n      } else {\n        return val\n      }\n    }\n  }\n  return res\n}\n\n/**\n * Native Array.indexOf uses strict equal, but in this\n * case we need to match string/numbers with custom equal.\n *\n * @param {Array} arr\n * @param {*} val\n */\n\nfunction indexOf (arr, val) {\n  var i = arr.length\n  while (i--) {\n    if (_.looseEqual(arr[i], val)) {\n      return i\n    }\n  }\n  return -1\n}\n\n},{\"../../../util\":91}],62:[function(require,module,exports){\nvar _ = require('../../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    var self = this\n    var el = this.el\n    var isRange = el.type === 'range'\n    var lazy = this.params.lazy\n    var number = this.params.number\n    var debounce = this.params.debounce\n\n    // handle composition events.\n    //   http://blog.evanyou.me/2014/01/03/composition-event/\n    // skip this for Android because it handles composition\n    // events quite differently. Android doesn't trigger\n    // composition events for language input methods e.g.\n    // Chinese, but instead triggers them for spelling\n    // suggestions... (see Discussion/#162)\n    var composing = false\n    if (!_.isAndroid && !isRange) {\n      this.on('compositionstart', function () {\n        composing = true\n      })\n      this.on('compositionend', function () {\n        composing = false\n        // in IE11 the \"compositionend\" event fires AFTER\n        // the \"input\" event, so the input handler is blocked\n        // at the end... have to call it here.\n        //\n        // #1327: in lazy mode this is unecessary.\n        if (!lazy) {\n          self.listener()\n        }\n      })\n    }\n\n    // prevent messing with the input when user is typing,\n    // and force update on blur.\n    this.focused = false\n    if (!isRange) {\n      this.on('focus', function () {\n        self.focused = true\n      })\n      this.on('blur', function () {\n        self.focused = false\n        self.listener()\n      })\n    }\n\n    // Now attach the main listener\n    this.listener = function () {\n      if (composing) return\n      var val = number || isRange\n        ? _.toNumber(el.value)\n        : el.value\n      self.set(val)\n      // force update on next tick to avoid lock & same value\n      // also only update when user is not typing\n      _.nextTick(function () {\n        if (self._bound && !self.focused) {\n          self.update(self._watcher.value)\n        }\n      })\n    }\n\n    // apply debounce\n    if (debounce) {\n      this.listener = _.debounce(this.listener, debounce)\n    }\n\n    // Support jQuery events, since jQuery.trigger() doesn't\n    // trigger native events in some cases and some plugins\n    // rely on $.trigger()\n    //\n    // We want to make sure if a listener is attached using\n    // jQuery, it is also removed with jQuery, that's why\n    // we do the check for each directive instance and\n    // store that check result on itself. This also allows\n    // easier test coverage control by unsetting the global\n    // jQuery variable in tests.\n    this.hasjQuery = typeof jQuery === 'function'\n    if (this.hasjQuery) {\n      jQuery(el).on('change', this.listener)\n      if (!lazy) {\n        jQuery(el).on('input', this.listener)\n      }\n    } else {\n      this.on('change', this.listener)\n      if (!lazy) {\n        this.on('input', this.listener)\n      }\n    }\n\n    // IE9 doesn't fire input event on backspace/del/cut\n    if (!lazy && _.isIE9) {\n      this.on('cut', function () {\n        _.nextTick(self.listener)\n      })\n      this.on('keyup', function (e) {\n        if (e.keyCode === 46 || e.keyCode === 8) {\n          self.listener()\n        }\n      })\n    }\n\n    // set initial value if present\n    if (\n      el.hasAttribute('value') ||\n      (el.tagName === 'TEXTAREA' && el.value.trim())\n    ) {\n      this.afterBind = this.listener\n    }\n  },\n\n  update: function (value) {\n    this.el.value = _.toString(value)\n  },\n\n  unbind: function () {\n    var el = this.el\n    if (this.hasjQuery) {\n      jQuery(el).off('change', this.listener)\n      jQuery(el).off('input', this.listener)\n    }\n  }\n}\n\n},{\"../../../util\":91}],63:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  'delete': 46,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40\n}\n\nfunction keyFilter (handler, keys) {\n  var codes = keys.map(function (key) {\n    var code = keyCodes[key]\n    if (!code) {\n      code = parseInt(key, 10)\n    }\n    return code\n  })\n  return function keyHandler (e) {\n    if (codes.indexOf(e.keyCode) > -1) {\n      return handler.call(this, e)\n    }\n  }\n}\n\nfunction stopFilter (handler) {\n  return function stopHandler (e) {\n    e.stopPropagation()\n    return handler.call(this, e)\n  }\n}\n\nfunction preventFilter (handler) {\n  return function preventHandler (e) {\n    e.preventDefault()\n    return handler.call(this, e)\n  }\n}\n\nmodule.exports = {\n\n  acceptStatement: true,\n  priority: 700,\n\n  bind: function () {\n    // deal with iframes\n    if (\n      this.el.tagName === 'IFRAME' &&\n      this.arg !== 'load'\n    ) {\n      var self = this\n      this.iframeBind = function () {\n        _.on(self.el.contentWindow, self.arg, self.handler)\n      }\n      this.on('load', this.iframeBind)\n    }\n  },\n\n  update: function (handler) {\n    // stub a noop for v-on with no value,\n    // e.g. @mousedown.prevent\n    if (!this.descriptor.raw) {\n      handler = function () {}\n    }\n\n    if (typeof handler !== 'function') {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'v-on:' + this.arg + '=\"' +\n        this.expression + '\" expects a function value, ' +\n        'got ' + handler\n      )\n      return\n    }\n\n    // apply modifiers\n    if (this.modifiers.stop) {\n      handler = stopFilter(handler)\n    }\n    if (this.modifiers.prevent) {\n      handler = preventFilter(handler)\n    }\n    // key filter\n    var keys = Object.keys(this.modifiers)\n      .filter(function (key) {\n        return key !== 'stop' && key !== 'prevent'\n      })\n    if (keys.length) {\n      handler = keyFilter(handler, keys)\n    }\n\n    this.reset()\n    var scope = this._scope || this.vm\n    this.handler = function (e) {\n      scope.$event = e\n      var res = handler(e)\n      scope.$event = null\n      return res\n    }\n    if (this.iframeBind) {\n      this.iframeBind()\n    } else {\n      _.on(this.el, this.arg, this.handler)\n    }\n  },\n\n  reset: function () {\n    var el = this.iframeBind\n      ? this.el.contentWindow\n      : this.el\n    if (this.handler) {\n      _.off(el, this.arg, this.handler)\n    }\n  },\n\n  unbind: function () {\n    this.reset()\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../util\":91,\"_process\":1}],64:[function(require,module,exports){\n(function (process){\nif (process.env.NODE_ENV !== 'production') {\n  module.exports = {\n    bind: function () {\n      require('../../util').warn(\n        'v-ref:' + this.arg + ' must be used on a child ' +\n        'component. Found on <' + this.el.tagName.toLowerCase() + '>.'\n      )\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../util\":91,\"_process\":1}],65:[function(require,module,exports){\nvar _ = require('../../util')\nvar transition = require('../../transition')\n\nmodule.exports = {\n\n  bind: function () {\n    // check else block\n    var next = this.el.nextElementSibling\n    if (next && _.attr(next, 'v-else') !== null) {\n      this.elseEl = next\n    }\n  },\n\n  update: function (value) {\n    var el = this.el\n    transition.apply(el, value ? 1 : -1, function () {\n      el.style.display = value ? '' : 'none'\n    }, this.vm)\n    var elseEl = this.elseEl\n    if (elseEl) {\n      transition.apply(elseEl, value ? -1 : 1, function () {\n        elseEl.style.display = value ? 'none' : ''\n      }, this.vm)\n    }\n  }\n}\n\n},{\"../../transition\":84,\"../../util\":91}],66:[function(require,module,exports){\nvar _ = require('../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    this.attr = this.el.nodeType === 3\n      ? 'data'\n      : 'textContent'\n  },\n\n  update: function (value) {\n    this.el[this.attr] = _.toString(value)\n  }\n}\n\n},{\"../../util\":91}],67:[function(require,module,exports){\nvar _ = require('../util')\nvar Path = require('../parsers/path')\nvar toArray = require('../directives/public/for')._postProcess\n\n/**\n * Limit filter for arrays\n *\n * @param {Number} n\n */\n\nexports.limitBy = function (arr, n) {\n  return typeof n === 'number'\n    ? arr.slice(0, n)\n    : arr\n}\n\n/**\n * Filter filter for arrays\n *\n * @param {String} searchKey\n * @param {String} [delimiter]\n * @param {String} dataKey\n */\n\nexports.filterBy = function (arr, search, delimiter /* ...dataKeys */) {\n  arr = toArray(arr)\n  if (search == null) {\n    return arr\n  }\n  if (typeof search === 'function') {\n    return arr.filter(search)\n  }\n  // cast to lowercase string\n  search = ('' + search).toLowerCase()\n  // allow optional `in` delimiter\n  // because why not\n  var n = delimiter === 'in' ? 3 : 2\n  // extract and flatten keys\n  var keys = _.toArray(arguments, n).reduce(function (prev, cur) {\n    return prev.concat(cur)\n  }, [])\n  var res = []\n  var item, key, val, j\n  for (var i = 0, l = arr.length; i < l; i++) {\n    item = arr[i]\n    val = (item && item.$value) || item\n    j = keys.length\n    if (j) {\n      while (j--) {\n        key = keys[j]\n        if ((key === '$key' && contains(item.$key, search)) ||\n            contains(Path.get(val, key), search)) {\n          res.push(item)\n          break\n        }\n      }\n    } else if (contains(item, search)) {\n      res.push(item)\n    }\n  }\n  return res\n}\n\n/**\n * Filter filter for arrays\n *\n * @param {String} sortKey\n * @param {String} reverse\n */\n\nexports.orderBy = function (arr, sortKey, reverse) {\n  arr = toArray(arr)\n  if (!sortKey) {\n    return arr\n  }\n  var order = (reverse && reverse < 0) ? -1 : 1\n  // sort on a copy to avoid mutating original array\n  return arr.slice().sort(function (a, b) {\n    if (sortKey !== '$key') {\n      if (_.isObject(a) && '$value' in a) a = a.$value\n      if (_.isObject(b) && '$value' in b) b = b.$value\n    }\n    a = _.isObject(a) ? Path.get(a, sortKey) : a\n    b = _.isObject(b) ? Path.get(b, sortKey) : b\n    return a === b ? 0 : a > b ? order : -order\n  })\n}\n\n/**\n * String contain helper\n *\n * @param {*} val\n * @param {String} search\n */\n\nfunction contains (val, search) {\n  var i\n  if (_.isPlainObject(val)) {\n    var keys = Object.keys(val)\n    i = keys.length\n    while (i--) {\n      if (contains(val[keys[i]], search)) {\n        return true\n      }\n    }\n  } else if (_.isArray(val)) {\n    i = val.length\n    while (i--) {\n      if (contains(val[i], search)) {\n        return true\n      }\n    }\n  } else if (val != null) {\n    return val.toString().toLowerCase().indexOf(search) > -1\n  }\n}\n\n},{\"../directives/public/for\":54,\"../parsers/path\":81,\"../util\":91}],68:[function(require,module,exports){\nvar _ = require('../util')\n\n/**\n * Stringify value.\n *\n * @param {Number} indent\n */\n\nexports.json = {\n  read: function (value, indent) {\n    return typeof value === 'string'\n      ? value\n      : JSON.stringify(value, null, Number(indent) || 2)\n  },\n  write: function (value) {\n    try {\n      return JSON.parse(value)\n    } catch (e) {\n      return value\n    }\n  }\n}\n\n/**\n * 'abc' => 'Abc'\n */\n\nexports.capitalize = function (value) {\n  if (!value && value !== 0) return ''\n  value = value.toString()\n  return value.charAt(0).toUpperCase() + value.slice(1)\n}\n\n/**\n * 'abc' => 'ABC'\n */\n\nexports.uppercase = function (value) {\n  return (value || value === 0)\n    ? value.toString().toUpperCase()\n    : ''\n}\n\n/**\n * 'AbC' => 'abc'\n */\n\nexports.lowercase = function (value) {\n  return (value || value === 0)\n    ? value.toString().toLowerCase()\n    : ''\n}\n\n/**\n * 12345 => $12,345.00\n *\n * @param {String} sign\n */\n\nvar digitsRE = /(\\d{3})(?=\\d)/g\nexports.currency = function (value, currency) {\n  value = parseFloat(value)\n  if (!isFinite(value) || (!value && value !== 0)) return ''\n  currency = currency != null ? currency : '$'\n  var stringified = Math.abs(value).toFixed(2)\n  var _int = stringified.slice(0, -3)\n  var i = _int.length % 3\n  var head = i > 0\n    ? (_int.slice(0, i) + (_int.length > 3 ? ',' : ''))\n    : ''\n  var _float = stringified.slice(-3)\n  var sign = value < 0 ? '-' : ''\n  return currency + sign + head +\n    _int.slice(i).replace(digitsRE, '$1,') +\n    _float\n}\n\n/**\n * 'item' => 'items'\n *\n * @params\n *  an array of strings corresponding to\n *  the single, double, triple ... forms of the word to\n *  be pluralized. When the number to be pluralized\n *  exceeds the length of the args, it will use the last\n *  entry in the array.\n *\n *  e.g. ['single', 'double', 'triple', 'multiple']\n */\n\nexports.pluralize = function (value) {\n  var args = _.toArray(arguments, 1)\n  return args.length > 1\n    ? (args[value % 10 - 1] || args[args.length - 1])\n    : (args[0] + (value === 1 ? '' : 's'))\n}\n\n/**\n * Debounce a handler function.\n *\n * @param {Function} handler\n * @param {Number} delay = 300\n * @return {Function}\n */\n\nexports.debounce = function (handler, delay) {\n  if (!handler) return\n  if (!delay) {\n    delay = 300\n  }\n  return _.debounce(handler, delay)\n}\n\n/**\n * Install special array filters\n */\n\n_.extend(exports, require('./array-filters'))\n\n},{\"../util\":91,\"./array-filters\":67}],69:[function(require,module,exports){\nvar _ = require('../util')\nvar compiler = require('../compiler')\nvar templateParser = require('../parsers/template')\nvar Fragment = require('./fragment')\nvar Cache = require('../cache')\nvar linkerCache = new Cache(5000)\n\n/**\n * A factory that can be used to create instances of a\n * fragment. Caches the compiled linker if possible.\n *\n * @param {Vue} vm\n * @param {Element|String} el\n */\n\nfunction FragmentFactory (vm, el) {\n  this.vm = vm\n  var template\n  var isString = typeof el === 'string'\n  if (isString || _.isTemplate(el)) {\n    template = templateParser.parse(el, true)\n  } else {\n    template = document.createDocumentFragment()\n    template.appendChild(el)\n  }\n  this.template = template\n  // linker can be cached, but only for components\n  var linker\n  var cid = vm.constructor.cid\n  if (cid > 0) {\n    var cacheId = cid + (isString ? el : el.outerHTML)\n    linker = linkerCache.get(cacheId)\n    if (!linker) {\n      linker = compiler.compile(template, vm.$options, true)\n      linkerCache.put(cacheId, linker)\n    }\n  } else {\n    linker = compiler.compile(template, vm.$options, true)\n  }\n  this.linker = linker\n}\n\n/**\n * Create a fragment instance with given host and scope.\n *\n * @param {Vue} host\n * @param {Object} scope\n * @param {Fragment} parentFrag\n */\n\nFragmentFactory.prototype.create = function (host, scope, parentFrag) {\n  var frag = templateParser.clone(this.template)\n  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag)\n}\n\nmodule.exports = FragmentFactory\n\n},{\"../cache\":35,\"../compiler\":38,\"../parsers/template\":82,\"../util\":91,\"./fragment\":70}],70:[function(require,module,exports){\nvar _ = require('../util')\nvar transition = require('../transition')\n\n/**\n * Abstraction for a partially-compiled fragment.\n * Can optionally compile content with a child scope.\n *\n * @param {Function} linker\n * @param {Vue} vm\n * @param {DocumentFragment} frag\n * @param {Vue} [host]\n * @param {Object} [scope]\n */\n\nfunction Fragment (linker, vm, frag, host, scope, parentFrag) {\n  this.children = []\n  this.childFrags = []\n  this.vm = vm\n  this.scope = scope\n  this.inserted = false\n  this.parentFrag = parentFrag\n  if (parentFrag) {\n    parentFrag.childFrags.push(this)\n  }\n  this.unlink = linker(vm, frag, host, scope, this)\n  var single = this.single = frag.childNodes.length === 1\n  if (single) {\n    this.node = frag.childNodes[0]\n    this.before = singleBefore\n    this.remove = singleRemove\n  } else {\n    this.node = _.createAnchor('fragment-start')\n    this.end = _.createAnchor('fragment-end')\n    this.frag = frag\n    _.prepend(this.node, frag)\n    frag.appendChild(this.end)\n    this.before = multiBefore\n    this.remove = multiRemove\n  }\n  this.node.__vfrag__ = this\n}\n\n/**\n * Call attach/detach for all components contained within\n * this fragment. Also do so recursively for all child\n * fragments.\n *\n * @param {Function} hook\n */\n\nFragment.prototype.callHook = function (hook) {\n  var i, l\n  for (i = 0, l = this.children.length; i < l; i++) {\n    hook(this.children[i])\n  }\n  for (i = 0, l = this.childFrags.length; i < l; i++) {\n    this.childFrags[i].callHook(hook)\n  }\n}\n\n/**\n * Destroy the fragment.\n */\n\nFragment.prototype.destroy = function () {\n  if (this.parentFrag) {\n    this.parentFrag.childFrags.$remove(this)\n  }\n  this.unlink()\n}\n\n/**\n * Insert fragment before target, single node version\n *\n * @param {Node} target\n * @param {Boolean} withTransition\n */\n\nfunction singleBefore (target, withTransition) {\n  this.inserted = true\n  var method = withTransition !== false\n    ? transition.before\n    : _.before\n  method(this.node, target, this.vm)\n  if (_.inDoc(this.node)) {\n    this.callHook(attach)\n  }\n}\n\n/**\n * Remove fragment, single node version\n *\n * @param {Boolean} [destroy]\n */\n\nfunction singleRemove (destroy) {\n  this.inserted = false\n  var shouldCallRemove = _.inDoc(this.node)\n  var self = this\n  transition.remove(this.node, this.vm, function () {\n    if (shouldCallRemove) {\n      self.callHook(detach)\n    }\n    if (destroy) {\n      self.destroy()\n    }\n  })\n}\n\n/**\n * Insert fragment before target, multi-nodes version\n *\n * @param {Node} target\n * @param {Boolean} withTransition\n */\n\nfunction multiBefore (target, withTransition) {\n  this.inserted = true\n  var vm = this.vm\n  var method = withTransition !== false\n    ? transition.before\n    : _.before\n  _.mapNodeRange(this.node, this.end, function (node) {\n    method(node, target, vm)\n  })\n  if (_.inDoc(this.node)) {\n    this.callHook(attach)\n  }\n}\n\n/**\n * Remove fragment, multi-nodes version\n *\n * @param {Boolean} [destroy]\n */\n\nfunction multiRemove (destroy) {\n  this.inserted = false\n  var self = this\n  var shouldCallRemove = _.inDoc(this.node)\n  _.removeNodeRange(this.node, this.end, this.vm, this.frag, function () {\n    if (shouldCallRemove) {\n      self.callHook(detach)\n    }\n    if (destroy) {\n      self.destroy()\n    }\n  })\n}\n\n/**\n * Call attach hook for a Vue instance.\n *\n * @param {Vue} child\n */\n\nfunction attach (child) {\n  if (!child._isAttached) {\n    child._callHook('attached')\n  }\n}\n\n/**\n * Call detach hook for a Vue instance.\n *\n * @param {Vue} child\n */\n\nfunction detach (child) {\n  if (child._isAttached) {\n    child._callHook('detached')\n  }\n}\n\nmodule.exports = Fragment\n\n},{\"../transition\":84,\"../util\":91}],71:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar inDoc = _.inDoc\nvar eventRE = /^v-on:|^@/\n\n/**\n * Setup the instance's option events & watchers.\n * If the value is a string, we pull it from the\n * instance's methods by name.\n */\n\nexports._initEvents = function () {\n  var options = this.$options\n  if (options._asComponent) {\n    registerComponentEvents(this, options.el)\n  }\n  registerCallbacks(this, '$on', options.events)\n  registerCallbacks(this, '$watch', options.watch)\n}\n\n/**\n * Register v-on events on a child component\n *\n * @param {Vue} vm\n * @param {Element} el\n */\n\nfunction registerComponentEvents (vm, el) {\n  var attrs = el.attributes\n  var name, handler\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    name = attrs[i].name\n    if (eventRE.test(name)) {\n      name = name.replace(eventRE, '')\n      handler = (vm._scope || vm._context).$eval(attrs[i].value, true)\n      vm.$on(name.replace(eventRE), handler)\n    }\n  }\n}\n\n/**\n * Register callbacks for option events and watchers.\n *\n * @param {Vue} vm\n * @param {String} action\n * @param {Object} hash\n */\n\nfunction registerCallbacks (vm, action, hash) {\n  if (!hash) return\n  var handlers, key, i, j\n  for (key in hash) {\n    handlers = hash[key]\n    if (_.isArray(handlers)) {\n      for (i = 0, j = handlers.length; i < j; i++) {\n        register(vm, action, key, handlers[i])\n      }\n    } else {\n      register(vm, action, key, handlers)\n    }\n  }\n}\n\n/**\n * Helper to register an event/watch callback.\n *\n * @param {Vue} vm\n * @param {String} action\n * @param {String} key\n * @param {Function|String|Object} handler\n * @param {Object} [options]\n */\n\nfunction register (vm, action, key, handler, options) {\n  var type = typeof handler\n  if (type === 'function') {\n    vm[action](key, handler, options)\n  } else if (type === 'string') {\n    var methods = vm.$options.methods\n    var method = methods && methods[handler]\n    if (method) {\n      vm[action](key, method, options)\n    } else {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'Unknown method: \"' + handler + '\" when ' +\n        'registering callback for ' + action +\n        ': \"' + key + '\".'\n      )\n    }\n  } else if (handler && type === 'object') {\n    register(vm, action, key, handler.handler, handler)\n  }\n}\n\n/**\n * Setup recursive attached/detached calls\n */\n\nexports._initDOMHooks = function () {\n  this.$on('hook:attached', onAttached)\n  this.$on('hook:detached', onDetached)\n}\n\n/**\n * Callback to recursively call attached hook on children\n */\n\nfunction onAttached () {\n  if (!this._isAttached) {\n    this._isAttached = true\n    this.$children.forEach(callAttach)\n  }\n}\n\n/**\n * Iterator to call attached hook\n *\n * @param {Vue} child\n */\n\nfunction callAttach (child) {\n  if (!child._isAttached && inDoc(child.$el)) {\n    child._callHook('attached')\n  }\n}\n\n/**\n * Callback to recursively call detached hook on children\n */\n\nfunction onDetached () {\n  if (this._isAttached) {\n    this._isAttached = false\n    this.$children.forEach(callDetach)\n  }\n}\n\n/**\n * Iterator to call detached hook\n *\n * @param {Vue} child\n */\n\nfunction callDetach (child) {\n  if (child._isAttached && !inDoc(child.$el)) {\n    child._callHook('detached')\n  }\n}\n\n/**\n * Trigger all handlers for a hook\n *\n * @param {String} hook\n */\n\nexports._callHook = function (hook) {\n  var handlers = this.$options[hook]\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      handlers[i].call(this)\n    }\n  }\n  this.$emit('hook:' + hook)\n}\n\n}).call(this,require('_process'))\n\n},{\"../util\":91,\"_process\":1}],72:[function(require,module,exports){\nvar mergeOptions = require('../util').mergeOptions\nvar uid = 0\n\n/**\n * The main init sequence. This is called for every\n * instance, including ones that are created from extended\n * constructors.\n *\n * @param {Object} options - this options object should be\n *                           the result of merging class\n *                           options and the options passed\n *                           in to the constructor.\n */\n\nexports._init = function (options) {\n\n  options = options || {}\n\n  this.$el = null\n  this.$parent = options.parent\n  this.$root = this.$parent\n    ? this.$parent.$root\n    : this\n  this.$children = []\n  this.$refs = {}       // child vm references\n  this.$els = {}        // element references\n  this._watchers = []   // all watchers as an array\n  this._directives = [] // all directives\n\n  // a uid\n  this._uid = uid++\n\n  // a flag to avoid this being observed\n  this._isVue = true\n\n  // events bookkeeping\n  this._events = {}            // registered callbacks\n  this._eventsCount = {}       // for $broadcast optimization\n  this._shouldPropagate = false // for event propagation\n\n  // fragment instance properties\n  this._isFragment = false\n  this._fragment =         // @type {DocumentFragment}\n  this._fragmentStart =    // @type {Text|Comment}\n  this._fragmentEnd = null // @type {Text|Comment}\n\n  // lifecycle state\n  this._isCompiled =\n  this._isDestroyed =\n  this._isReady =\n  this._isAttached =\n  this._isBeingDestroyed = false\n  this._unlinkFn = null\n\n  // context:\n  // if this is a transcluded component, context\n  // will be the common parent vm of this instance\n  // and its host.\n  this._context = options._context || this.$parent\n\n  // scope:\n  // if this is inside an inline v-for, the scope\n  // will be the intermediate scope created for this\n  // repeat fragment. this is used for linking props\n  // and container directives.\n  this._scope = options._scope\n\n  // fragment:\n  // if this instance is compiled inside a Fragment, it\n  // needs to reigster itself as a child of that fragment\n  // for attach/detach to work properly.\n  this._frag = options._frag\n  if (this._frag) {\n    this._frag.children.push(this)\n  }\n\n  // push self into parent / transclusion host\n  if (this.$parent) {\n    this.$parent.$children.push(this)\n  }\n\n  // set ref\n  if (options._ref) {\n    (this._scope || this._context).$refs[options._ref] = this\n  }\n\n  // merge options.\n  options = this.$options = mergeOptions(\n    this.constructor.options,\n    options,\n    this\n  )\n\n  // initialize data as empty object.\n  // it will be filled up in _initScope().\n  this._data = {}\n\n  // call init hook\n  this._callHook('init')\n\n  // initialize data observation and scope inheritance.\n  this._initState()\n\n  // setup event system and option events.\n  this._initEvents()\n\n  // call created hook\n  this._callHook('created')\n\n  // if `el` option is passed, start compilation.\n  if (options.el) {\n    this.$mount(options.el)\n  }\n}\n\n},{\"../util\":91}],73:[function(require,module,exports){\nvar _ = require('../util')\nvar Directive = require('../directive')\nvar compiler = require('../compiler')\n\n/**\n * Transclude, compile and link element.\n *\n * If a pre-compiled linker is available, that means the\n * passed in element will be pre-transcluded and compiled\n * as well - all we need to do is to call the linker.\n *\n * Otherwise we need to call transclude/compile/link here.\n *\n * @param {Element} el\n * @return {Element}\n */\n\nexports._compile = function (el) {\n  var options = this.$options\n\n  // transclude and init element\n  // transclude can potentially replace original\n  // so we need to keep reference; this step also injects\n  // the template and caches the original attributes\n  // on the container node and replacer node.\n  var original = el\n  el = compiler.transclude(el, options)\n  this._initElement(el)\n\n  // root is always compiled per-instance, because\n  // container attrs and props can be different every time.\n  var contextOptions = this._context && this._context.$options\n  var rootLinker = compiler.compileRoot(el, options, contextOptions)\n\n  // compile and link the rest\n  var contentLinkFn\n  var ctor = this.constructor\n  // component compilation can be cached\n  // as long as it's not using inline-template\n  if (options._linkerCachable) {\n    contentLinkFn = ctor.linker\n    if (!contentLinkFn) {\n      contentLinkFn = ctor.linker = compiler.compile(el, options)\n    }\n  }\n\n  // link phase\n  // make sure to link root with prop scope!\n  var rootUnlinkFn = rootLinker(this, el, this._scope)\n  var contentUnlinkFn = contentLinkFn\n    ? contentLinkFn(this, el)\n    : compiler.compile(el, options)(this, el)\n\n  // register composite unlink function\n  // to be called during instance destruction\n  this._unlinkFn = function () {\n    rootUnlinkFn()\n    // passing destroying: true to avoid searching and\n    // splicing the directives\n    contentUnlinkFn(true)\n  }\n\n  // finally replace original\n  if (options.replace) {\n    _.replace(original, el)\n  }\n\n  this._isCompiled = true\n  this._callHook('compiled')\n  return el\n}\n\n/**\n * Initialize instance element. Called in the public\n * $mount() method.\n *\n * @param {Element} el\n */\n\nexports._initElement = function (el) {\n  if (el instanceof DocumentFragment) {\n    this._isFragment = true\n    this.$el = this._fragmentStart = el.firstChild\n    this._fragmentEnd = el.lastChild\n    // set persisted text anchors to empty\n    if (this._fragmentStart.nodeType === 3) {\n      this._fragmentStart.data = this._fragmentEnd.data = ''\n    }\n    this._fragment = el\n  } else {\n    this.$el = el\n  }\n  this.$el.__vue__ = this\n  this._callHook('beforeCompile')\n}\n\n/**\n * Create and bind a directive to an element.\n *\n * @param {String} name - directive name\n * @param {Node} node   - target node\n * @param {Object} desc - parsed directive descriptor\n * @param {Object} def  - directive definition object\n * @param {Vue} [host] - transclusion host component\n * @param {Object} [scope] - v-for scope\n * @param {Fragment} [frag] - owner fragment\n */\n\nexports._bindDir = function (descriptor, node, host, scope, frag) {\n  this._directives.push(\n    new Directive(descriptor, this, node, host, scope, frag)\n  )\n}\n\n/**\n * Teardown an instance, unobserves the data, unbind all the\n * directives, turn off all the event listeners, etc.\n *\n * @param {Boolean} remove - whether to remove the DOM node.\n * @param {Boolean} deferCleanup - if true, defer cleanup to\n *                                 be called later\n */\n\nexports._destroy = function (remove, deferCleanup) {\n  if (this._isBeingDestroyed) {\n    return\n  }\n  this._callHook('beforeDestroy')\n  this._isBeingDestroyed = true\n  var i\n  // remove self from parent. only necessary\n  // if parent is not being destroyed as well.\n  var parent = this.$parent\n  if (parent && !parent._isBeingDestroyed) {\n    parent.$children.$remove(this)\n    // unregister ref\n    var ref = this.$options._ref\n    if (ref) {\n      var scope = this._scope || this._context\n      if (scope.$refs[ref] === this) {\n        scope.$refs[ref] = null\n      }\n    }\n  }\n  // remove self from owner fragment\n  if (this._frag) {\n    this._frag.children.$remove(this)\n  }\n  // destroy all children.\n  i = this.$children.length\n  while (i--) {\n    this.$children[i].$destroy()\n  }\n  // teardown props\n  if (this._propsUnlinkFn) {\n    this._propsUnlinkFn()\n  }\n  // teardown all directives. this also tearsdown all\n  // directive-owned watchers.\n  if (this._unlinkFn) {\n    this._unlinkFn()\n  }\n  i = this._watchers.length\n  while (i--) {\n    this._watchers[i].teardown()\n  }\n  // remove reference to self on $el\n  if (this.$el) {\n    this.$el.__vue__ = null\n  }\n  // remove DOM element\n  var self = this\n  if (remove && this.$el) {\n    this.$remove(function () {\n      self._cleanup()\n    })\n  } else if (!deferCleanup) {\n    this._cleanup()\n  }\n}\n\n/**\n * Clean up to ensure garbage collection.\n * This is called after the leave transition if there\n * is any.\n */\n\nexports._cleanup = function () {\n  // remove reference from data ob\n  // frozen object may not have observer.\n  if (this._data.__ob__) {\n    this._data.__ob__.removeVm(this)\n  }\n  // Clean up references to private properties and other\n  // instances. preserve reference to _data so that proxy\n  // accessors still work. The only potential side effect\n  // here is that mutating the instance after it's destroyed\n  // may affect the state of other components that are still\n  // observing the same object, but that seems to be a\n  // reasonable responsibility for the user rather than\n  // always throwing an error on them.\n  this.$el =\n  this.$parent =\n  this.$root =\n  this.$children =\n  this._watchers =\n  this._context =\n  this._scope =\n  this._directives = null\n  // call the last hook...\n  this._isDestroyed = true\n  this._callHook('destroyed')\n  // turn off all instance listeners.\n  this.$off()\n}\n\n},{\"../compiler\":38,\"../directive\":41,\"../util\":91}],74:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\n\n/**\n * Apply a list of filter (descriptors) to a value.\n * Using plain for loops here because this will be called in\n * the getter of any watcher with filters so it is very\n * performance sensitive.\n *\n * @param {*} value\n * @param {*} [oldValue]\n * @param {Array} filters\n * @param {Boolean} write\n * @return {*}\n */\n\nexports._applyFilters = function (value, oldValue, filters, write) {\n  var filter, fn, args, arg, offset, i, l, j, k\n  for (i = 0, l = filters.length; i < l; i++) {\n    filter = filters[i]\n    fn = _.resolveAsset(this.$options, 'filters', filter.name)\n    if (process.env.NODE_ENV !== 'production') {\n      _.assertAsset(fn, 'filter', filter.name)\n    }\n    if (!fn) continue\n    fn = write ? fn.write : (fn.read || fn)\n    if (typeof fn !== 'function') continue\n    args = write ? [value, oldValue] : [value]\n    offset = write ? 2 : 1\n    if (filter.args) {\n      for (j = 0, k = filter.args.length; j < k; j++) {\n        arg = filter.args[j]\n        args[j + offset] = arg.dynamic\n          ? this.$get(arg.value)\n          : arg.value\n      }\n    }\n    value = fn.apply(this, args)\n  }\n  return value\n}\n\n/**\n * Resolve a component, depending on whether the component\n * is defined normally or using an async factory function.\n * Resolves synchronously if already resolved, otherwise\n * resolves asynchronously and caches the resolved\n * constructor on the factory.\n *\n * @param {String} id\n * @param {Function} cb\n */\n\nexports._resolveComponent = function (id, cb) {\n  var factory = _.resolveAsset(this.$options, 'components', id)\n  if (process.env.NODE_ENV !== 'production') {\n    _.assertAsset(factory, 'component', id)\n  }\n  if (!factory) {\n    return\n  }\n  // async component factory\n  if (!factory.options) {\n    if (factory.resolved) {\n      // cached\n      cb(factory.resolved)\n    } else if (factory.requested) {\n      // pool callbacks\n      factory.pendingCallbacks.push(cb)\n    } else {\n      factory.requested = true\n      var cbs = factory.pendingCallbacks = [cb]\n      factory(function resolve (res) {\n        if (_.isPlainObject(res)) {\n          res = _.Vue.extend(res)\n        }\n        // cache resolved\n        factory.resolved = res\n        // invoke callbacks\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res)\n        }\n      }, function reject (reason) {\n        process.env.NODE_ENV !== 'production' && _.warn(\n          'Failed to resolve async component: ' + id + '. ' +\n          (reason ? '\\nReason: ' + reason : '')\n        )\n      })\n    }\n  } else {\n    // normal component\n    cb(factory)\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../util\":91,\"_process\":1}],75:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar compiler = require('../compiler')\nvar Observer = require('../observer')\nvar Dep = require('../observer/dep')\nvar Watcher = require('../watcher')\n\n/**\n * Setup the scope of an instance, which contains:\n * - observed data\n * - computed properties\n * - user methods\n * - meta properties\n */\n\nexports._initState = function () {\n  this._initProps()\n  this._initMeta()\n  this._initMethods()\n  this._initData()\n  this._initComputed()\n}\n\n/**\n * Initialize props.\n */\n\nexports._initProps = function () {\n  var options = this.$options\n  var el = options.el\n  var props = options.props\n  if (props && !el) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Props will not be compiled if no `el` option is ' +\n      'provided at instantiation.'\n    )\n  }\n  // make sure to convert string selectors into element now\n  el = options.el = _.query(el)\n  this._propsUnlinkFn = el && el.nodeType === 1 && props\n    // props must be linked in proper scope if inside v-for\n    ? compiler.compileAndLinkProps(this, el, props, this._scope)\n    : null\n}\n\n/**\n * Initialize the data.\n */\n\nexports._initData = function () {\n  var propsData = this._data\n  var optionsDataFn = this.$options.data\n  var optionsData = optionsDataFn && optionsDataFn()\n  if (optionsData) {\n    this._data = optionsData\n    for (var prop in propsData) {\n      if (process.env.NODE_ENV !== 'production' &&\n          optionsData.hasOwnProperty(prop)) {\n        _.warn(\n          'Data field \"' + prop + '\" is already defined ' +\n          'as a prop. Use prop default value instead.'\n        )\n      }\n      if (this._props[prop].raw !== null ||\n          !optionsData.hasOwnProperty(prop)) {\n        _.set(optionsData, prop, propsData[prop])\n      }\n    }\n  }\n  var data = this._data\n  // proxy data on instance\n  var keys = Object.keys(data)\n  var i, key\n  i = keys.length\n  while (i--) {\n    key = keys[i]\n    this._proxy(key)\n  }\n  // observe data\n  Observer.create(data, this)\n}\n\n/**\n * Swap the isntance's $data. Called in $data's setter.\n *\n * @param {Object} newData\n */\n\nexports._setData = function (newData) {\n  newData = newData || {}\n  var oldData = this._data\n  this._data = newData\n  var keys, key, i\n  // unproxy keys not present in new data\n  keys = Object.keys(oldData)\n  i = keys.length\n  while (i--) {\n    key = keys[i]\n    if (!(key in newData)) {\n      this._unproxy(key)\n    }\n  }\n  // proxy keys not already proxied,\n  // and trigger change for changed values\n  keys = Object.keys(newData)\n  i = keys.length\n  while (i--) {\n    key = keys[i]\n    if (!this.hasOwnProperty(key)) {\n      // new property\n      this._proxy(key)\n    }\n  }\n  oldData.__ob__.removeVm(this)\n  Observer.create(newData, this)\n  this._digest()\n}\n\n/**\n * Proxy a property, so that\n * vm.prop === vm._data.prop\n *\n * @param {String} key\n */\n\nexports._proxy = function (key) {\n  if (!_.isReserved(key)) {\n    // need to store ref to self here\n    // because these getter/setters might\n    // be called by child scopes via\n    // prototype inheritance.\n    var self = this\n    Object.defineProperty(self, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return self._data[key]\n      },\n      set: function proxySetter (val) {\n        self._data[key] = val\n      }\n    })\n  }\n}\n\n/**\n * Unproxy a property.\n *\n * @param {String} key\n */\n\nexports._unproxy = function (key) {\n  if (!_.isReserved(key)) {\n    delete this[key]\n  }\n}\n\n/**\n * Force update on every watcher in scope.\n */\n\nexports._digest = function () {\n  for (var i = 0, l = this._watchers.length; i < l; i++) {\n    this._watchers[i].update(true) // shallow updates\n  }\n}\n\n/**\n * Setup computed properties. They are essentially\n * special getter/setters\n */\n\nfunction noop () {}\nexports._initComputed = function () {\n  var computed = this.$options.computed\n  if (computed) {\n    for (var key in computed) {\n      var userDef = computed[key]\n      var def = {\n        enumerable: true,\n        configurable: true\n      }\n      if (typeof userDef === 'function') {\n        def.get = makeComputedGetter(userDef, this)\n        def.set = noop\n      } else {\n        def.get = userDef.get\n          ? userDef.cache !== false\n            ? makeComputedGetter(userDef.get, this)\n            : _.bind(userDef.get, this)\n          : noop\n        def.set = userDef.set\n          ? _.bind(userDef.set, this)\n          : noop\n      }\n      Object.defineProperty(this, key, def)\n    }\n  }\n}\n\nfunction makeComputedGetter (getter, owner) {\n  var watcher = new Watcher(owner, getter, null, {\n    lazy: true\n  })\n  return function computedGetter () {\n    if (watcher.dirty) {\n      watcher.evaluate()\n    }\n    if (Dep.target) {\n      watcher.depend()\n    }\n    return watcher.value\n  }\n}\n\n/**\n * Setup instance methods. Methods must be bound to the\n * instance since they might be passed down as a prop to\n * child components.\n */\n\nexports._initMethods = function () {\n  var methods = this.$options.methods\n  if (methods) {\n    for (var key in methods) {\n      this[key] = _.bind(methods[key], this)\n    }\n  }\n}\n\n/**\n * Initialize meta information like $index, $key & $value.\n */\n\nexports._initMeta = function () {\n  var metas = this.$options._meta\n  if (metas) {\n    for (var key in metas) {\n      _.defineReactive(this, key, metas[key])\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../compiler\":38,\"../observer\":78,\"../observer/dep\":77,\"../util\":91,\"../watcher\":95,\"_process\":1}],76:[function(require,module,exports){\nvar _ = require('../util')\nvar arrayProto = Array.prototype\nvar arrayMethods = Object.create(arrayProto)\n\n/**\n * Intercept mutating methods and emit events\n */\n\n;[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method]\n  _.define(arrayMethods, method, function mutator () {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length\n    var args = new Array(i)\n    while (i--) {\n      args[i] = arguments[i]\n    }\n    var result = original.apply(this, args)\n    var ob = this.__ob__\n    var inserted\n    switch (method) {\n      case 'push':\n        inserted = args\n        break\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n    // notify change\n    ob.dep.notify()\n    return result\n  })\n})\n\n/**\n * Swap the element at the given index with a new value\n * and emits corresponding event.\n *\n * @param {Number} index\n * @param {*} val\n * @return {*} - replaced element\n */\n\n_.define(\n  arrayProto,\n  '$set',\n  function $set (index, val) {\n    if (index >= this.length) {\n      this.length = index + 1\n    }\n    return this.splice(index, 1, val)[0]\n  }\n)\n\n/**\n * Convenience method to remove the element at given index.\n *\n * @param {Number} index\n * @param {*} val\n */\n\n_.define(\n  arrayProto,\n  '$remove',\n  function $remove (item) {\n    /* istanbul ignore if */\n    if (!this.length) return\n    var index = _.indexOf(this, item)\n    if (index > -1) {\n      return this.splice(index, 1)\n    }\n  }\n)\n\nmodule.exports = arrayMethods\n\n},{\"../util\":91}],77:[function(require,module,exports){\nvar _ = require('../util')\nvar uid = 0\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\n * @constructor\n */\n\nfunction Dep () {\n  this.id = uid++\n  this.subs = []\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null\n\n/**\n * Add a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.addSub = function (sub) {\n  this.subs.push(sub)\n}\n\n/**\n * Remove a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.removeSub = function (sub) {\n  this.subs.$remove(sub)\n}\n\n/**\n * Add self as a dependency to the target watcher.\n */\n\nDep.prototype.depend = function () {\n  Dep.target.addDep(this)\n}\n\n/**\n * Notify all subscribers of a new value.\n */\n\nDep.prototype.notify = function () {\n  // stablize the subscriber list first\n  var subs = _.toArray(this.subs)\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update()\n  }\n}\n\nmodule.exports = Dep\n\n},{\"../util\":91}],78:[function(require,module,exports){\nvar _ = require('../util')\nvar Dep = require('./dep')\nvar arrayMethods = require('./array')\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods)\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n *\n * @param {Array|Object} value\n * @constructor\n */\n\nfunction Observer (value) {\n  this.value = value\n  this.dep = new Dep()\n  _.define(value, '__ob__', this)\n  if (_.isArray(value)) {\n    var augment = _.hasProto\n      ? protoAugment\n      : copyAugment\n    augment(value, arrayMethods, arrayKeys)\n    this.observeArray(value)\n  } else {\n    this.walk(value)\n  }\n}\n\n// Static methods\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\n * @param {*} value\n * @param {Vue} [vm]\n * @return {Observer|undefined}\n * @static\n */\n\nObserver.create = function (value, vm) {\n  if (!value || typeof value !== 'object') {\n    return\n  }\n  var ob\n  if (\n    value.hasOwnProperty('__ob__') &&\n    value.__ob__ instanceof Observer\n  ) {\n    ob = value.__ob__\n  } else if (\n    (_.isArray(value) || _.isPlainObject(value)) &&\n    !Object.isFrozen(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value)\n  }\n  if (ob && vm) {\n    ob.addVm(vm)\n  }\n  return ob\n}\n\n// Instance methods\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n *\n * @param {Object} obj\n */\n\nObserver.prototype.walk = function (obj) {\n  var keys = Object.keys(obj)\n  var i = keys.length\n  while (i--) {\n    this.convert(keys[i], obj[keys[i]])\n  }\n}\n\n/**\n * Observe a list of Array items.\n *\n * @param {Array} items\n */\n\nObserver.prototype.observeArray = function (items) {\n  var i = items.length\n  while (i--) {\n    Observer.create(items[i])\n  }\n}\n\n/**\n * Convert a property into getter/setter so we can emit\n * the events when the property is accessed/changed.\n *\n * @param {String} key\n * @param {*} val\n */\n\nObserver.prototype.convert = function (key, val) {\n  defineReactive(this.value, key, val)\n}\n\n/**\n * Add an owner vm, so that when $set/$delete mutations\n * happen we can notify owner vms to proxy the keys and\n * digest the watchers. This is only called when the object\n * is observed as an instance's root $data.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.addVm = function (vm) {\n  (this.vms || (this.vms = [])).push(vm)\n}\n\n/**\n * Remove an owner vm. This is called when the object is\n * swapped out as an instance's $data object.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.removeVm = function (vm) {\n  this.vms.$remove(vm)\n}\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n *\n * @param {Object|Array} target\n * @param {Object} proto\n */\n\nfunction protoAugment (target, src) {\n  target.__proto__ = src\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n *\n * @param {Object|Array} target\n * @param {Object} proto\n */\n\nfunction copyAugment (target, src, keys) {\n  var i = keys.length\n  var key\n  while (i--) {\n    key = keys[i]\n    _.define(target, key, src[key])\n  }\n}\n\n/**\n * Define a reactive property on an Object.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n */\n\nfunction defineReactive (obj, key, val) {\n  var dep = new Dep()\n  var childOb = Observer.create(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function metaGetter () {\n      if (Dep.target) {\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n        }\n        if (_.isArray(val)) {\n          for (var e, i = 0, l = val.length; i < l; i++) {\n            e = val[i]\n            e && e.__ob__ && e.__ob__.dep.depend()\n          }\n        }\n      }\n      return val\n    },\n    set: function metaSetter (newVal) {\n      if (newVal === val) return\n      val = newVal\n      childOb = Observer.create(newVal)\n      dep.notify()\n    }\n  })\n}\n\n// Attach to the util object so it can be used elsewhere.\n_.defineReactive = defineReactive\n\nmodule.exports = Observer\n\n},{\"../util\":91,\"./array\":76,\"./dep\":77}],79:[function(require,module,exports){\nvar _ = require('../util')\nvar Cache = require('../cache')\nvar cache = new Cache(1000)\nvar filterTokenRE = /[^\\s'\"]+|'[^']*'|\"[^\"]*\"/g\nvar reservedArgRE = /^in$|^-?\\d+/\n\n/**\n * Parser state\n */\n\nvar str, dir\nvar c, i, l, lastFilterIndex\nvar inSingle, inDouble, curly, square, paren\n\n/**\n * Push a filter to the current directive object\n */\n\nfunction pushFilter () {\n  var exp = str.slice(lastFilterIndex, i).trim()\n  var filter\n  if (exp) {\n    filter = {}\n    var tokens = exp.match(filterTokenRE)\n    filter.name = tokens[0]\n    if (tokens.length > 1) {\n      filter.args = tokens.slice(1).map(processFilterArg)\n    }\n  }\n  if (filter) {\n    (dir.filters = dir.filters || []).push(filter)\n  }\n  lastFilterIndex = i + 1\n}\n\n/**\n * Check if an argument is dynamic and strip quotes.\n *\n * @param {String} arg\n * @return {Object}\n */\n\nfunction processFilterArg (arg) {\n  if (reservedArgRE.test(arg)) {\n    return {\n      value: _.toNumber(arg),\n      dynamic: false\n    }\n  } else {\n    var stripped = _.stripQuotes(arg)\n    var dynamic = stripped === arg\n    return {\n      value: dynamic ? arg : stripped,\n      dynamic: dynamic\n    }\n  }\n}\n\n/**\n * Parse a directive value and extract the expression\n * and its filters into a descriptor.\n *\n * Example:\n *\n * \"a + 1 | uppercase\" will yield:\n * {\n *   expression: 'a + 1',\n *   filters: [\n *     { name: 'uppercase', args: null }\n *   ]\n * }\n *\n * @param {String} str\n * @return {Object}\n */\n\nexports.parse = function (s) {\n\n  var hit = cache.get(s)\n  if (hit) {\n    return hit\n  }\n\n  // reset parser state\n  str = s\n  inSingle = inDouble = false\n  curly = square = paren = 0\n  lastFilterIndex = 0\n  dir = {}\n\n  for (i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i)\n    if (inSingle) {\n      // check single quote\n      if (c === 0x27) inSingle = !inSingle\n    } else if (inDouble) {\n      // check double quote\n      if (c === 0x22) inDouble = !inDouble\n    } else if (\n      c === 0x7C && // pipe\n      str.charCodeAt(i + 1) !== 0x7C &&\n      str.charCodeAt(i - 1) !== 0x7C\n    ) {\n      if (dir.expression == null) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1\n        dir.expression = str.slice(0, i).trim()\n      } else {\n        // already has filter\n        pushFilter()\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break // \"\n        case 0x27: inSingle = true; break // '\n        case 0x28: paren++; break         // (\n        case 0x29: paren--; break         // )\n        case 0x5B: square++; break        // [\n        case 0x5D: square--; break        // ]\n        case 0x7B: curly++; break         // {\n        case 0x7D: curly--; break         // }\n      }\n    }\n  }\n\n  if (dir.expression == null) {\n    dir.expression = str.slice(0, i).trim()\n  } else if (lastFilterIndex !== 0) {\n    pushFilter()\n  }\n\n  cache.put(s, dir)\n  return dir\n}\n\n},{\"../cache\":35,\"../util\":91}],80:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar Path = require('./path')\nvar Cache = require('../cache')\nvar expressionCache = new Cache(1000)\n\nvar allowedKeywords =\n  'Math,Date,this,true,false,null,undefined,Infinity,NaN,' +\n  'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' +\n  'encodeURIComponent,parseInt,parseFloat'\nvar allowedKeywordsRE =\n  new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)')\n\n// keywords that don't make sense inside expressions\nvar improperKeywords =\n  'break,case,class,catch,const,continue,debugger,default,' +\n  'delete,do,else,export,extends,finally,for,function,if,' +\n  'import,in,instanceof,let,return,super,switch,throw,try,' +\n  'var,while,with,yield,enum,await,implements,package,' +\n  'proctected,static,interface,private,public'\nvar improperKeywordsRE =\n  new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)')\n\nvar wsRE = /\\s/g\nvar newlineRE = /\\n/g\nvar saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('[^']*'|\"[^\"]*\")|new |typeof |void /g\nvar restoreRE = /\"(\\d+)\"/g\nvar pathTestRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/\nvar pathReplaceRE = /[^\\w$\\.]([A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\])*)/g\nvar booleanLiteralRE = /^(true|false)$/\n\n/**\n * Save / Rewrite / Restore\n *\n * When rewriting paths found in an expression, it is\n * possible for the same letter sequences to be found in\n * strings and Object literal property keys. Therefore we\n * remove and store these parts in a temporary array, and\n * restore them after the path rewrite.\n */\n\nvar saved = []\n\n/**\n * Save replacer\n *\n * The save regex can match two possible cases:\n * 1. An opening object literal\n * 2. A string\n * If matched as a plain string, we need to escape its\n * newlines, since the string needs to be preserved when\n * generating the function body.\n *\n * @param {String} str\n * @param {String} isString - str if matched as a string\n * @return {String} - placeholder with index\n */\n\nfunction save (str, isString) {\n  var i = saved.length\n  saved[i] = isString\n    ? str.replace(newlineRE, '\\\\n')\n    : str\n  return '\"' + i + '\"'\n}\n\n/**\n * Path rewrite replacer\n *\n * @param {String} raw\n * @return {String}\n */\n\nfunction rewrite (raw) {\n  var c = raw.charAt(0)\n  var path = raw.slice(1)\n  if (allowedKeywordsRE.test(path)) {\n    return raw\n  } else {\n    path = path.indexOf('\"') > -1\n      ? path.replace(restoreRE, restore)\n      : path\n    return c + 'scope.' + path\n  }\n}\n\n/**\n * Restore replacer\n *\n * @param {String} str\n * @param {String} i - matched save index\n * @return {String}\n */\n\nfunction restore (str, i) {\n  return saved[i]\n}\n\n/**\n * Rewrite an expression, prefixing all path accessors with\n * `scope.` and generate getter/setter functions.\n *\n * @param {String} exp\n * @param {Boolean} needSet\n * @return {Function}\n */\n\nfunction compileExpFns (exp, needSet) {\n  if (improperKeywordsRE.test(exp)) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Avoid using reserved keywords in expression: ' + exp\n    )\n  }\n  // reset state\n  saved.length = 0\n  // save strings and object literal keys\n  var body = exp\n    .replace(saveRE, save)\n    .replace(wsRE, '')\n  // rewrite all paths\n  // pad 1 space here becaue the regex matches 1 extra char\n  body = (' ' + body)\n    .replace(pathReplaceRE, rewrite)\n    .replace(restoreRE, restore)\n  var getter = makeGetter(body)\n  if (getter) {\n    return {\n      get: getter,\n      body: body,\n      set: needSet\n        ? makeSetter(body)\n        : null\n    }\n  }\n}\n\n/**\n * Compile getter setters for a simple path.\n *\n * @param {String} exp\n * @return {Function}\n */\n\nfunction compilePathFns (exp) {\n  var getter, path\n  if (exp.indexOf('[') < 0) {\n    // really simple path\n    path = exp.split('.')\n    path.raw = exp\n    getter = Path.compileGetter(path)\n  } else {\n    // do the real parsing\n    path = Path.parse(exp)\n    getter = path.get\n  }\n  return {\n    get: getter,\n    // always generate setter for simple paths\n    set: function (obj, val) {\n      Path.set(obj, path, val)\n    }\n  }\n}\n\n/**\n * Build a getter function. Requires eval.\n *\n * We isolate the try/catch so it doesn't affect the\n * optimization of the parse function when it is not called.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeGetter (body) {\n  try {\n    return new Function('scope', 'return ' + body + ';')\n  } catch (e) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Invalid expression. ' +\n      'Generated function body: ' + body\n    )\n  }\n}\n\n/**\n * Build a setter function.\n *\n * This is only needed in rare situations like \"a[b]\" where\n * a settable path requires dynamic evaluation.\n *\n * This setter function may throw error when called if the\n * expression body is not a valid left-hand expression in\n * assignment.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeSetter (body) {\n  try {\n    return new Function('scope', 'value', body + '=value;')\n  } catch (e) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Invalid setter function body: ' + body\n    )\n  }\n}\n\n/**\n * Check for setter existence on a cache hit.\n *\n * @param {Function} hit\n */\n\nfunction checkSetter (hit) {\n  if (!hit.set) {\n    hit.set = makeSetter(hit.body)\n  }\n}\n\n/**\n * Parse an expression into re-written getter/setters.\n *\n * @param {String} exp\n * @param {Boolean} needSet\n * @return {Function}\n */\n\nexports.parse = function (exp, needSet) {\n  exp = exp.trim()\n  // try cache\n  var hit = expressionCache.get(exp)\n  if (hit) {\n    if (needSet) {\n      checkSetter(hit)\n    }\n    return hit\n  }\n  // we do a simple path check to optimize for them.\n  // the check fails valid paths with unusal whitespaces,\n  // but that's too rare and we don't care.\n  // also skip boolean literals and paths that start with\n  // global \"Math\"\n  var res = exports.isSimplePath(exp)\n    ? compilePathFns(exp)\n    : compileExpFns(exp, needSet)\n  expressionCache.put(exp, res)\n  return res\n}\n\n/**\n * Check if an expression is a simple path.\n *\n * @param {String} exp\n * @return {Boolean}\n */\n\nexports.isSimplePath = function (exp) {\n  return pathTestRE.test(exp) &&\n    // don't treat true/false as paths\n    !booleanLiteralRE.test(exp) &&\n    // Math constants e.g. Math.PI, Math.E etc.\n    exp.slice(0, 5) !== 'Math.'\n}\n\n}).call(this,require('_process'))\n\n},{\"../cache\":35,\"../util\":91,\"./path\":81,\"_process\":1}],81:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar Cache = require('../cache')\nvar pathCache = new Cache(1000)\nvar identRE = exports.identRE = /^[$_a-zA-Z]+[\\w$]*$/\n\n// actions\nvar APPEND = 0\nvar PUSH = 1\n\n// states\nvar BEFORE_PATH = 0\nvar IN_PATH = 1\nvar BEFORE_IDENT = 2\nvar IN_IDENT = 3\nvar BEFORE_ELEMENT = 4\nvar AFTER_ZERO = 5\nvar IN_INDEX = 6\nvar IN_SINGLE_QUOTE = 7\nvar IN_DOUBLE_QUOTE = 8\nvar IN_SUB_PATH = 9\nvar AFTER_ELEMENT = 10\nvar AFTER_PATH = 11\nvar ERROR = 12\n\nvar pathStateMachine = []\n\npathStateMachine[BEFORE_PATH] = {\n  'ws': [BEFORE_PATH],\n  'ident': [IN_IDENT, APPEND],\n  '[': [BEFORE_ELEMENT],\n  'eof': [AFTER_PATH]\n}\n\npathStateMachine[IN_PATH] = {\n  'ws': [IN_PATH],\n  '.': [BEFORE_IDENT],\n  '[': [BEFORE_ELEMENT],\n  'eof': [AFTER_PATH]\n}\n\npathStateMachine[BEFORE_IDENT] = {\n  'ws': [BEFORE_IDENT],\n  'ident': [IN_IDENT, APPEND]\n}\n\npathStateMachine[IN_IDENT] = {\n  'ident': [IN_IDENT, APPEND],\n  '0': [IN_IDENT, APPEND],\n  'number': [IN_IDENT, APPEND],\n  'ws': [IN_PATH, PUSH],\n  '.': [BEFORE_IDENT, PUSH],\n  '[': [BEFORE_ELEMENT, PUSH],\n  'eof': [AFTER_PATH, PUSH]\n}\n\npathStateMachine[BEFORE_ELEMENT] = {\n  'ws': [BEFORE_ELEMENT],\n  '0': [AFTER_ZERO, APPEND],\n  'number': [IN_INDEX, APPEND],\n  \"'\": [IN_SINGLE_QUOTE, APPEND, ''],\n  '\"': [IN_DOUBLE_QUOTE, APPEND, ''],\n  'ident': [IN_SUB_PATH, APPEND, '*']\n}\n\npathStateMachine[AFTER_ZERO] = {\n  'ws': [AFTER_ELEMENT, PUSH],\n  ']': [IN_PATH, PUSH]\n}\n\npathStateMachine[IN_INDEX] = {\n  '0': [IN_INDEX, APPEND],\n  'number': [IN_INDEX, APPEND],\n  'ws': [AFTER_ELEMENT],\n  ']': [IN_PATH, PUSH]\n}\n\npathStateMachine[IN_SINGLE_QUOTE] = {\n  \"'\": [AFTER_ELEMENT],\n  'eof': ERROR,\n  'else': [IN_SINGLE_QUOTE, APPEND]\n}\n\npathStateMachine[IN_DOUBLE_QUOTE] = {\n  '\"': [AFTER_ELEMENT],\n  'eof': ERROR,\n  'else': [IN_DOUBLE_QUOTE, APPEND]\n}\n\npathStateMachine[IN_SUB_PATH] = {\n  'ident': [IN_SUB_PATH, APPEND],\n  '0': [IN_SUB_PATH, APPEND],\n  'number': [IN_SUB_PATH, APPEND],\n  'ws': [AFTER_ELEMENT],\n  ']': [IN_PATH, PUSH]\n}\n\npathStateMachine[AFTER_ELEMENT] = {\n  'ws': [AFTER_ELEMENT],\n  ']': [IN_PATH, PUSH]\n}\n\n/**\n * Determine the type of a character in a keypath.\n *\n * @param {Char} ch\n * @return {String} type\n */\n\nfunction getPathCharType (ch) {\n  if (ch === undefined) {\n    return 'eof'\n  }\n\n  var code = ch.charCodeAt(0)\n\n  switch (code) {\n    case 0x5B: // [\n    case 0x5D: // ]\n    case 0x2E: // .\n    case 0x22: // \"\n    case 0x27: // '\n    case 0x30: // 0\n      return ch\n\n    case 0x5F: // _\n    case 0x24: // $\n      return 'ident'\n\n    case 0x20: // Space\n    case 0x09: // Tab\n    case 0x0A: // Newline\n    case 0x0D: // Return\n    case 0xA0:  // No-break space\n    case 0xFEFF:  // Byte Order Mark\n    case 0x2028:  // Line Separator\n    case 0x2029:  // Paragraph Separator\n      return 'ws'\n  }\n\n  // a-z, A-Z\n  if (\n    (code >= 0x61 && code <= 0x7A) ||\n    (code >= 0x41 && code <= 0x5A)\n  ) {\n    return 'ident'\n  }\n\n  // 1-9\n  if (code >= 0x31 && code <= 0x39) {\n    return 'number'\n  }\n\n  return 'else'\n}\n\n/**\n * Parse a string path into an array of segments\n *\n * @param {String} path\n * @return {Array|undefined}\n */\n\nfunction parsePath (path) {\n  var keys = []\n  var index = -1\n  var mode = BEFORE_PATH\n  var c, newChar, key, type, transition, action, typeMap\n\n  var actions = []\n  actions[PUSH] = function () {\n    if (key === undefined) {\n      return\n    }\n    keys.push(key)\n    key = undefined\n  }\n  actions[APPEND] = function () {\n    if (key === undefined) {\n      key = newChar\n    } else {\n      key += newChar\n    }\n  }\n\n  function maybeUnescapeQuote () {\n    var nextChar = path[index + 1]\n    if ((mode === IN_SINGLE_QUOTE && nextChar === \"'\") ||\n        (mode === IN_DOUBLE_QUOTE && nextChar === '\"')) {\n      index++\n      newChar = nextChar\n      actions[APPEND]()\n      return true\n    }\n  }\n\n  while (mode != null) {\n    index++\n    c = path[index]\n\n    if (c === '\\\\' && maybeUnescapeQuote()) {\n      continue\n    }\n\n    type = getPathCharType(c)\n    typeMap = pathStateMachine[mode]\n    transition = typeMap[type] || typeMap['else'] || ERROR\n\n    if (transition === ERROR) {\n      return // parse error\n    }\n\n    mode = transition[0]\n    action = actions[transition[1]]\n    if (action) {\n      newChar = transition[2]\n      newChar = newChar === undefined\n        ? c\n        : newChar === '*'\n          ? newChar + c\n          : newChar\n      action()\n    }\n\n    if (mode === AFTER_PATH) {\n      keys.raw = path\n      return keys\n    }\n  }\n}\n\n/**\n * Format a accessor segment based on its type.\n *\n * @param {String} key\n * @return {Boolean}\n */\n\nfunction formatAccessor (key) {\n  if (identRE.test(key)) { // identifier\n    return '.' + key\n  } else if (+key === key >>> 0) { // bracket index\n    return '[' + key + ']'\n  } else if (key.charAt(0) === '*') {\n    return '[o' + formatAccessor(key.slice(1)) + ']'\n  } else { // bracket string\n    return '[\"' + key.replace(/\"/g, '\\\\\"') + '\"]'\n  }\n}\n\n/**\n * Compiles a getter function with a fixed path.\n * The fixed path getter supresses errors.\n *\n * @param {Array} path\n * @return {Function}\n */\n\nexports.compileGetter = function (path) {\n  var body = 'return o' + path.map(formatAccessor).join('')\n  return new Function('o', body)\n}\n\n/**\n * External parse that check for a cache hit first\n *\n * @param {String} path\n * @return {Array|undefined}\n */\n\nexports.parse = function (path) {\n  var hit = pathCache.get(path)\n  if (!hit) {\n    hit = parsePath(path)\n    if (hit) {\n      hit.get = exports.compileGetter(hit)\n      pathCache.put(path, hit)\n    }\n  }\n  return hit\n}\n\n/**\n * Get from an object from a path string\n *\n * @param {Object} obj\n * @param {String} path\n */\n\nexports.get = function (obj, path) {\n  path = exports.parse(path)\n  if (path) {\n    return path.get(obj)\n  }\n}\n\n/**\n * Warn against setting non-existent root path on a vm.\n */\n\nvar warnNonExistent\nif (process.env.NODE_ENV !== 'production') {\n  warnNonExistent = function (path) {\n    _.warn(\n      'You are setting a non-existent path \"' + path.raw + '\" ' +\n      'on a vm instance. Consider pre-initializing the property ' +\n      'with the \"data\" option for more reliable reactivity ' +\n      'and better performance.'\n    )\n  }\n}\n\n/**\n * Set on an object from a path\n *\n * @param {Object} obj\n * @param {String | Array} path\n * @param {*} val\n */\n\nexports.set = function (obj, path, val) {\n  var original = obj\n  if (typeof path === 'string') {\n    path = exports.parse(path)\n  }\n  if (!path || !_.isObject(obj)) {\n    return false\n  }\n  var last, key\n  for (var i = 0, l = path.length; i < l; i++) {\n    last = obj\n    key = path[i]\n    if (key.charAt(0) === '*') {\n      key = original[key.slice(1)]\n    }\n    if (i < l - 1) {\n      obj = obj[key]\n      if (!_.isObject(obj)) {\n        obj = {}\n        if (process.env.NODE_ENV !== 'production' && last._isVue) {\n          warnNonExistent(path)\n        }\n        _.set(last, key, obj)\n      }\n    } else {\n      if (_.isArray(obj)) {\n        obj.$set(key, val)\n      } else if (key in obj) {\n        obj[key] = val\n      } else {\n        if (process.env.NODE_ENV !== 'production' && obj._isVue) {\n          warnNonExistent(path)\n        }\n        _.set(obj, key, val)\n      }\n    }\n  }\n  return true\n}\n\n}).call(this,require('_process'))\n\n},{\"../cache\":35,\"../util\":91,\"_process\":1}],82:[function(require,module,exports){\nvar _ = require('../util')\nvar Cache = require('../cache')\nvar templateCache = new Cache(1000)\nvar idSelectorCache = new Cache(1000)\n\nvar map = {\n  _default: [0, '', ''],\n  legend: [1, '<fieldset>', '</fieldset>'],\n  tr: [2, '<table><tbody>', '</tbody></table>'],\n  col: [\n    2,\n    '<table><tbody></tbody><colgroup>',\n    '</colgroup></table>'\n  ]\n}\n\nmap.td =\nmap.th = [\n  3,\n  '<table><tbody><tr>',\n  '</tr></tbody></table>'\n]\n\nmap.option =\nmap.optgroup = [\n  1,\n  '<select multiple=\"multiple\">',\n  '</select>'\n]\n\nmap.thead =\nmap.tbody =\nmap.colgroup =\nmap.caption =\nmap.tfoot = [1, '<table>', '</table>']\n\nmap.g =\nmap.defs =\nmap.symbol =\nmap.use =\nmap.image =\nmap.text =\nmap.circle =\nmap.ellipse =\nmap.line =\nmap.path =\nmap.polygon =\nmap.polyline =\nmap.rect = [\n  1,\n  '<svg ' +\n    'xmlns=\"http://www.w3.org/2000/svg\" ' +\n    'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' +\n    'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' +\n    'version=\"1.1\">',\n  '</svg>'\n]\n\n/**\n * Check if a node is a supported template node with a\n * DocumentFragment content.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nfunction isRealTemplate (node) {\n  return _.isTemplate(node) &&\n    node.content instanceof DocumentFragment\n}\n\nvar tagRE = /<([\\w:]+)/\nvar entityRE = /&\\w+;|&#\\d+;|&#x[\\dA-F]+;/\n\n/**\n * Convert a string template to a DocumentFragment.\n * Determines correct wrapping by tag types. Wrapping\n * strategy found in jQuery & component/domify.\n *\n * @param {String} templateString\n * @return {DocumentFragment}\n */\n\nfunction stringToFragment (templateString) {\n  // try a cache hit first\n  var hit = templateCache.get(templateString)\n  if (hit) {\n    return hit\n  }\n\n  var frag = document.createDocumentFragment()\n  var tagMatch = templateString.match(tagRE)\n  var entityMatch = entityRE.test(templateString)\n\n  if (!tagMatch && !entityMatch) {\n    // text only, return a single text node.\n    frag.appendChild(\n      document.createTextNode(templateString)\n    )\n  } else {\n\n    var tag = tagMatch && tagMatch[1]\n    var wrap = map[tag] || map._default\n    var depth = wrap[0]\n    var prefix = wrap[1]\n    var suffix = wrap[2]\n    var node = document.createElement('div')\n\n    node.innerHTML = prefix + templateString.trim() + suffix\n    while (depth--) {\n      node = node.lastChild\n    }\n\n    var child\n    /* eslint-disable no-cond-assign */\n    while (child = node.firstChild) {\n    /* eslint-enable no-cond-assign */\n      frag.appendChild(child)\n    }\n  }\n\n  templateCache.put(templateString, frag)\n  return frag\n}\n\n/**\n * Convert a template node to a DocumentFragment.\n *\n * @param {Node} node\n * @return {DocumentFragment}\n */\n\nfunction nodeToFragment (node) {\n  // if its a template tag and the browser supports it,\n  // its content is already a document fragment.\n  if (isRealTemplate(node)) {\n    _.trimNode(node.content)\n    return node.content\n  }\n  // script template\n  if (node.tagName === 'SCRIPT') {\n    return stringToFragment(node.textContent)\n  }\n  // normal node, clone it to avoid mutating the original\n  var clone = exports.clone(node)\n  var frag = document.createDocumentFragment()\n  var child\n  /* eslint-disable no-cond-assign */\n  while (child = clone.firstChild) {\n  /* eslint-enable no-cond-assign */\n    frag.appendChild(child)\n  }\n  _.trimNode(frag)\n  return frag\n}\n\n// Test for the presence of the Safari template cloning bug\n// https://bugs.webkit.org/show_bug.cgi?id=137755\nvar hasBrokenTemplate = (function () {\n  /* istanbul ignore else */\n  if (_.inBrowser) {\n    var a = document.createElement('div')\n    a.innerHTML = '<template>1</template>'\n    return !a.cloneNode(true).firstChild.innerHTML\n  } else {\n    return false\n  }\n})()\n\n// Test for IE10/11 textarea placeholder clone bug\nvar hasTextareaCloneBug = (function () {\n  /* istanbul ignore else */\n  if (_.inBrowser) {\n    var t = document.createElement('textarea')\n    t.placeholder = 't'\n    return t.cloneNode(true).value === 't'\n  } else {\n    return false\n  }\n})()\n\n/**\n * 1. Deal with Safari cloning nested <template> bug by\n *    manually cloning all template instances.\n * 2. Deal with IE10/11 textarea placeholder bug by setting\n *    the correct value after cloning.\n *\n * @param {Element|DocumentFragment} node\n * @return {Element|DocumentFragment}\n */\n\nexports.clone = function (node) {\n  if (!node.querySelectorAll) {\n    return node.cloneNode()\n  }\n  var res = node.cloneNode(true)\n  var i, original, cloned\n  /* istanbul ignore if */\n  if (hasBrokenTemplate) {\n    var clone = res\n    if (isRealTemplate(node)) {\n      node = node.content\n      clone = res.content\n    }\n    original = node.querySelectorAll('template')\n    if (original.length) {\n      cloned = clone.querySelectorAll('template')\n      i = cloned.length\n      while (i--) {\n        cloned[i].parentNode.replaceChild(\n          exports.clone(original[i]),\n          cloned[i]\n        )\n      }\n    }\n  }\n  /* istanbul ignore if */\n  if (hasTextareaCloneBug) {\n    if (node.tagName === 'TEXTAREA') {\n      res.value = node.value\n    } else {\n      original = node.querySelectorAll('textarea')\n      if (original.length) {\n        cloned = res.querySelectorAll('textarea')\n        i = cloned.length\n        while (i--) {\n          cloned[i].value = original[i].value\n        }\n      }\n    }\n  }\n  return res\n}\n\n/**\n * Process the template option and normalizes it into a\n * a DocumentFragment that can be used as a partial or a\n * instance template.\n *\n * @param {*} template\n *    Possible values include:\n *    - DocumentFragment object\n *    - Node object of type Template\n *    - id selector: '#some-template-id'\n *    - template string: '<div><span>{{msg}}</span></div>'\n * @param {Boolean} clone\n * @param {Boolean} noSelector\n * @return {DocumentFragment|undefined}\n */\n\nexports.parse = function (template, clone, noSelector) {\n  var node, frag\n\n  // if the template is already a document fragment,\n  // do nothing\n  if (template instanceof DocumentFragment) {\n    _.trimNode(template)\n    return clone\n      ? exports.clone(template)\n      : template\n  }\n\n  if (typeof template === 'string') {\n    // id selector\n    if (!noSelector && template.charAt(0) === '#') {\n      // id selector can be cached too\n      frag = idSelectorCache.get(template)\n      if (!frag) {\n        node = document.getElementById(template.slice(1))\n        if (node) {\n          frag = nodeToFragment(node)\n          // save selector to cache\n          idSelectorCache.put(template, frag)\n        }\n      }\n    } else {\n      // normal string template\n      frag = stringToFragment(template)\n    }\n  } else if (template.nodeType) {\n    // a direct node\n    frag = nodeToFragment(template)\n  }\n\n  return frag && clone\n    ? exports.clone(frag)\n    : frag\n}\n\n},{\"../cache\":35,\"../util\":91}],83:[function(require,module,exports){\nvar Cache = require('../cache')\nvar config = require('../config')\nvar dirParser = require('./directive')\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g\nvar cache, tagRE, htmlRE\n\n/**\n * Escape a string so it can be used in a RegExp\n * constructor.\n *\n * @param {String} str\n */\n\nfunction escapeRegex (str) {\n  return str.replace(regexEscapeRE, '\\\\$&')\n}\n\nexports.compileRegex = function () {\n  var open = escapeRegex(config.delimiters[0])\n  var close = escapeRegex(config.delimiters[1])\n  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0])\n  var unsafeClose = escapeRegex(config.unsafeDelimiters[1])\n  tagRE = new RegExp(\n    unsafeOpen + '(.+?)' + unsafeClose + '|' +\n    open + '(.+?)' + close,\n    'g'\n  )\n  htmlRE = new RegExp(\n    '^' + unsafeOpen + '.*' + unsafeClose + '$'\n  )\n  // reset cache\n  cache = new Cache(1000)\n}\n\n/**\n * Parse a template text string into an array of tokens.\n *\n * @param {String} text\n * @return {Array<Object> | null}\n *               - {String} type\n *               - {String} value\n *               - {Boolean} [html]\n *               - {Boolean} [oneTime]\n */\n\nexports.parse = function (text) {\n  if (!cache) {\n    exports.compileRegex()\n  }\n  var hit = cache.get(text)\n  if (hit) {\n    return hit\n  }\n  text = text.replace(/\\n/g, '')\n  if (!tagRE.test(text)) {\n    return null\n  }\n  var tokens = []\n  var lastIndex = tagRE.lastIndex = 0\n  var match, index, html, value, first, oneTime\n  /* eslint-disable no-cond-assign */\n  while (match = tagRE.exec(text)) {\n  /* eslint-enable no-cond-assign */\n    index = match.index\n    // push text token\n    if (index > lastIndex) {\n      tokens.push({\n        value: text.slice(lastIndex, index)\n      })\n    }\n    // tag token\n    html = htmlRE.test(match[0])\n    value = html ? match[1] : match[2]\n    first = value.charCodeAt(0)\n    oneTime = first === 42 // *\n    value = oneTime\n      ? value.slice(1)\n      : value\n    tokens.push({\n      tag: true,\n      value: value.trim(),\n      html: html,\n      oneTime: oneTime\n    })\n    lastIndex = index + match[0].length\n  }\n  if (lastIndex < text.length) {\n    tokens.push({\n      value: text.slice(lastIndex)\n    })\n  }\n  cache.put(text, tokens)\n  return tokens\n}\n\n/**\n * Format a list of tokens into an expression.\n * e.g. tokens parsed from 'a {{b}} c' can be serialized\n * into one single expression as '\"a \" + b + \" c\"'.\n *\n * @param {Array} tokens\n * @return {String}\n */\n\nexports.tokensToExp = function (tokens) {\n  if (tokens.length > 1) {\n    return tokens.map(function (token) {\n      return formatToken(token)\n    }).join('+')\n  } else {\n    return formatToken(tokens[0], true)\n  }\n}\n\n/**\n * Format a single token.\n *\n * @param {Object} token\n * @param {Boolean} single\n * @return {String}\n */\n\nfunction formatToken (token, single) {\n  return token.tag\n    ? inlineFilters(token.value, single)\n    : '\"' + token.value + '\"'\n}\n\n/**\n * For an attribute with multiple interpolation tags,\n * e.g. attr=\"some-{{thing | filter}}\", in order to combine\n * the whole thing into a single watchable expression, we\n * have to inline those filters. This function does exactly\n * that. This is a bit hacky but it avoids heavy changes\n * to directive parser and watcher mechanism.\n *\n * @param {String} exp\n * @param {Boolean} single\n * @return {String}\n */\n\nvar filterRE = /[^|]\\|[^|]/\nfunction inlineFilters (exp, single) {\n  if (!filterRE.test(exp)) {\n    return single\n      ? exp\n      : '(' + exp + ')'\n  } else {\n    var dir = dirParser.parse(exp)\n    if (!dir.filters) {\n      return '(' + exp + ')'\n    } else {\n      return 'this._applyFilters(' +\n        dir.expression + // value\n        ',null,' +       // oldValue (null for read)\n        JSON.stringify(dir.filters) + // filter descriptors\n        ',false)'        // write?\n    }\n  }\n}\n\n},{\"../cache\":35,\"../config\":40,\"./directive\":79}],84:[function(require,module,exports){\nvar _ = require('../util')\n\n/**\n * Append with transition.\n *\n * @param {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nexports.append = function (el, target, vm, cb) {\n  apply(el, 1, function () {\n    target.appendChild(el)\n  }, vm, cb)\n}\n\n/**\n * InsertBefore with transition.\n *\n * @param {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nexports.before = function (el, target, vm, cb) {\n  apply(el, 1, function () {\n    _.before(el, target)\n  }, vm, cb)\n}\n\n/**\n * Remove with transition.\n *\n * @param {Element} el\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nexports.remove = function (el, vm, cb) {\n  apply(el, -1, function () {\n    _.remove(el)\n  }, vm, cb)\n}\n\n/**\n * Apply transitions with an operation callback.\n *\n * @param {Element} el\n * @param {Number} direction\n *                  1: enter\n *                 -1: leave\n * @param {Function} op - the actual DOM operation\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nvar apply = exports.apply = function (el, direction, op, vm, cb) {\n  var transition = el.__v_trans\n  if (\n    !transition ||\n    // skip if there are no js hooks and CSS transition is\n    // not supported\n    (!transition.hooks && !_.transitionEndEvent) ||\n    // skip transitions for initial compile\n    !vm._isCompiled ||\n    // if the vm is being manipulated by a parent directive\n    // during the parent's compilation phase, skip the\n    // animation.\n    (vm.$parent && !vm.$parent._isCompiled)\n  ) {\n    op()\n    if (cb) cb()\n    return\n  }\n  var action = direction > 0 ? 'enter' : 'leave'\n  transition[action](op, cb)\n}\n\n},{\"../util\":91}],85:[function(require,module,exports){\nvar _ = require('../util')\nvar queue = []\nvar queued = false\n\n/**\n * Push a job into the queue.\n *\n * @param {Function} job\n */\n\nexports.push = function (job) {\n  queue.push(job)\n  if (!queued) {\n    queued = true\n    _.nextTick(flush)\n  }\n}\n\n/**\n * Flush the queue, and do one forced reflow before\n * triggering transitions.\n */\n\nfunction flush () {\n  // Force layout\n  var f = document.documentElement.offsetHeight\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]()\n  }\n  queue = []\n  queued = false\n  // dummy return, so js linters don't complain about\n  // unused variable f\n  return f\n}\n\n},{\"../util\":91}],86:[function(require,module,exports){\nvar _ = require('../util')\nvar queue = require('./queue')\nvar addClass = _.addClass\nvar removeClass = _.removeClass\nvar transitionEndEvent = _.transitionEndEvent\nvar animationEndEvent = _.animationEndEvent\nvar transDurationProp = _.transitionProp + 'Duration'\nvar animDurationProp = _.animationProp + 'Duration'\n\nvar TYPE_TRANSITION = 1\nvar TYPE_ANIMATION = 2\n\n/**\n * A Transition object that encapsulates the state and logic\n * of the transition.\n *\n * @param {Element} el\n * @param {String} id\n * @param {Object} hooks\n * @param {Vue} vm\n */\n\nfunction Transition (el, id, hooks, vm) {\n  this.id = id\n  this.el = el\n  this.enterClass = id + '-enter'\n  this.leaveClass = id + '-leave'\n  this.hooks = hooks\n  this.vm = vm\n  // async state\n  this.pendingCssEvent =\n  this.pendingCssCb =\n  this.cancel =\n  this.pendingJsCb =\n  this.op =\n  this.cb = null\n  this.justEntered = false\n  this.entered = this.left = false\n  this.typeCache = {}\n  // bind\n  var self = this\n  ;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone']\n    .forEach(function (m) {\n      self[m] = _.bind(self[m], self)\n    })\n}\n\nvar p = Transition.prototype\n\n/**\n * Start an entering transition.\n *\n * 1. enter transition triggered\n * 2. call beforeEnter hook\n * 3. add enter class\n * 4. insert/show element\n * 5. call enter hook (with possible explicit js callback)\n * 6. reflow\n * 7. based on transition type:\n *    - transition:\n *        remove class now, wait for transitionend,\n *        then done if there's no explicit js callback.\n *    - animation:\n *        wait for animationend, remove class,\n *        then done if there's no explicit js callback.\n *    - no css transition:\n *        done now if there's no explicit js callback.\n * 8. wait for either done or js callback, then call\n *    afterEnter hook.\n *\n * @param {Function} op - insert/show the element\n * @param {Function} [cb]\n */\n\np.enter = function (op, cb) {\n  this.cancelPending()\n  this.callHook('beforeEnter')\n  this.cb = cb\n  addClass(this.el, this.enterClass)\n  op()\n  this.entered = false\n  this.callHookWithCb('enter')\n  if (this.entered) {\n    return // user called done synchronously.\n  }\n  this.cancel = this.hooks && this.hooks.enterCancelled\n  queue.push(this.enterNextTick)\n}\n\n/**\n * The \"nextTick\" phase of an entering transition, which is\n * to be pushed into a queue and executed after a reflow so\n * that removing the class can trigger a CSS transition.\n */\n\np.enterNextTick = function () {\n\n  // Important hack:\n  // in Chrome, if a just-entered element is applied the\n  // leave class while its interpolated property still has\n  // a very small value (within one frame), Chrome will\n  // skip the leave transition entirely and not firing the\n  // transtionend event. Therefore we need to protected\n  // against such cases using a one-frame timeout.\n  this.justEntered = true\n  var self = this\n  setTimeout(function () {\n    self.justEntered = false\n  }, 17)\n\n  var enterDone = this.enterDone\n  var type = this.getCssTransitionType(this.enterClass)\n  if (!this.pendingJsCb) {\n    if (type === TYPE_TRANSITION) {\n      // trigger transition by removing enter class now\n      removeClass(this.el, this.enterClass)\n      this.setupCssCb(transitionEndEvent, enterDone)\n    } else if (type === TYPE_ANIMATION) {\n      this.setupCssCb(animationEndEvent, enterDone)\n    } else {\n      enterDone()\n    }\n  } else if (type === TYPE_TRANSITION) {\n    removeClass(this.el, this.enterClass)\n  }\n}\n\n/**\n * The \"cleanup\" phase of an entering transition.\n */\n\np.enterDone = function () {\n  this.entered = true\n  this.cancel = this.pendingJsCb = null\n  removeClass(this.el, this.enterClass)\n  this.callHook('afterEnter')\n  if (this.cb) this.cb()\n}\n\n/**\n * Start a leaving transition.\n *\n * 1. leave transition triggered.\n * 2. call beforeLeave hook\n * 3. add leave class (trigger css transition)\n * 4. call leave hook (with possible explicit js callback)\n * 5. reflow if no explicit js callback is provided\n * 6. based on transition type:\n *    - transition or animation:\n *        wait for end event, remove class, then done if\n *        there's no explicit js callback.\n *    - no css transition:\n *        done if there's no explicit js callback.\n * 7. wait for either done or js callback, then call\n *    afterLeave hook.\n *\n * @param {Function} op - remove/hide the element\n * @param {Function} [cb]\n */\n\np.leave = function (op, cb) {\n  this.cancelPending()\n  this.callHook('beforeLeave')\n  this.op = op\n  this.cb = cb\n  addClass(this.el, this.leaveClass)\n  this.left = false\n  this.callHookWithCb('leave')\n  if (this.left) {\n    return // user called done synchronously.\n  }\n  this.cancel = this.hooks && this.hooks.leaveCancelled\n  // only need to handle leaveDone if\n  // 1. the transition is already done (synchronously called\n  //    by the user, which causes this.op set to null)\n  // 2. there's no explicit js callback\n  if (this.op && !this.pendingJsCb) {\n    // if a CSS transition leaves immediately after enter,\n    // the transitionend event never fires. therefore we\n    // detect such cases and end the leave immediately.\n    if (this.justEntered) {\n      this.leaveDone()\n    } else {\n      queue.push(this.leaveNextTick)\n    }\n  }\n}\n\n/**\n * The \"nextTick\" phase of a leaving transition.\n */\n\np.leaveNextTick = function () {\n  var type = this.getCssTransitionType(this.leaveClass)\n  if (type) {\n    var event = type === TYPE_TRANSITION\n      ? transitionEndEvent\n      : animationEndEvent\n    this.setupCssCb(event, this.leaveDone)\n  } else {\n    this.leaveDone()\n  }\n}\n\n/**\n * The \"cleanup\" phase of a leaving transition.\n */\n\np.leaveDone = function () {\n  this.left = true\n  this.cancel = this.pendingJsCb = null\n  this.op()\n  removeClass(this.el, this.leaveClass)\n  this.callHook('afterLeave')\n  if (this.cb) this.cb()\n  this.op = null\n}\n\n/**\n * Cancel any pending callbacks from a previously running\n * but not finished transition.\n */\n\np.cancelPending = function () {\n  this.op = this.cb = null\n  var hasPending = false\n  if (this.pendingCssCb) {\n    hasPending = true\n    _.off(this.el, this.pendingCssEvent, this.pendingCssCb)\n    this.pendingCssEvent = this.pendingCssCb = null\n  }\n  if (this.pendingJsCb) {\n    hasPending = true\n    this.pendingJsCb.cancel()\n    this.pendingJsCb = null\n  }\n  if (hasPending) {\n    removeClass(this.el, this.enterClass)\n    removeClass(this.el, this.leaveClass)\n  }\n  if (this.cancel) {\n    this.cancel.call(this.vm, this.el)\n    this.cancel = null\n  }\n}\n\n/**\n * Call a user-provided synchronous hook function.\n *\n * @param {String} type\n */\n\np.callHook = function (type) {\n  if (this.hooks && this.hooks[type]) {\n    this.hooks[type].call(this.vm, this.el)\n  }\n}\n\n/**\n * Call a user-provided, potentially-async hook function.\n * We check for the length of arguments to see if the hook\n * expects a `done` callback. If true, the transition's end\n * will be determined by when the user calls that callback;\n * otherwise, the end is determined by the CSS transition or\n * animation.\n *\n * @param {String} type\n */\n\np.callHookWithCb = function (type) {\n  var hook = this.hooks && this.hooks[type]\n  if (hook) {\n    if (hook.length > 1) {\n      this.pendingJsCb = _.cancellable(this[type + 'Done'])\n    }\n    hook.call(this.vm, this.el, this.pendingJsCb)\n  }\n}\n\n/**\n * Get an element's transition type based on the\n * calculated styles.\n *\n * @param {String} className\n * @return {Number}\n */\n\np.getCssTransitionType = function (className) {\n  /* istanbul ignore if */\n  if (\n    !transitionEndEvent ||\n    // skip CSS transitions if page is not visible -\n    // this solves the issue of transitionend events not\n    // firing until the page is visible again.\n    // pageVisibility API is supported in IE10+, same as\n    // CSS transitions.\n    document.hidden ||\n    // explicit js-only transition\n    (this.hooks && this.hooks.css === false) ||\n    // element is hidden\n    isHidden(this.el)\n  ) {\n    return\n  }\n  var type = this.typeCache[className]\n  if (type) return type\n  var inlineStyles = this.el.style\n  var computedStyles = window.getComputedStyle(this.el)\n  var transDuration =\n    inlineStyles[transDurationProp] ||\n    computedStyles[transDurationProp]\n  if (transDuration && transDuration !== '0s') {\n    type = TYPE_TRANSITION\n  } else {\n    var animDuration =\n      inlineStyles[animDurationProp] ||\n      computedStyles[animDurationProp]\n    if (animDuration && animDuration !== '0s') {\n      type = TYPE_ANIMATION\n    }\n  }\n  if (type) {\n    this.typeCache[className] = type\n  }\n  return type\n}\n\n/**\n * Setup a CSS transitionend/animationend callback.\n *\n * @param {String} event\n * @param {Function} cb\n */\n\np.setupCssCb = function (event, cb) {\n  this.pendingCssEvent = event\n  var self = this\n  var el = this.el\n  var onEnd = this.pendingCssCb = function (e) {\n    if (e.target === el) {\n      _.off(el, event, onEnd)\n      self.pendingCssEvent = self.pendingCssCb = null\n      if (!self.pendingJsCb && cb) {\n        cb()\n      }\n    }\n  }\n  _.on(el, event, onEnd)\n}\n\n/**\n * Check if an element is hidden - in that case we can just\n * skip the transition alltogether.\n *\n * @param {Element} el\n * @return {Boolean}\n */\n\nfunction isHidden (el) {\n  return !(\n    el.offsetWidth &&\n    el.offsetHeight &&\n    el.getClientRects().length\n  )\n}\n\nmodule.exports = Transition\n\n},{\"../util\":91,\"./queue\":85}],87:[function(require,module,exports){\n(function (process){\nvar _ = require('./index')\n\n/**\n * Check if an element is a component, if yes return its\n * component id.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Object|undefined}\n */\n\nexports.commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/\nexports.checkComponent = function (el, options) {\n  var tag = el.tagName.toLowerCase()\n  var hasAttrs = el.hasAttributes()\n  if (!exports.commonTagRE.test(tag) && tag !== 'component') {\n    if (_.resolveAsset(options, 'components', tag)) {\n      return { id: tag }\n    } else {\n      var is = hasAttrs && getIsBinding(el)\n      if (is) {\n        return is\n      } else if (process.env.NODE_ENV !== 'production') {\n        if (\n          tag.indexOf('-') > -1 ||\n          (\n            /HTMLUnknownElement/.test(el.toString()) &&\n            // Chrome returns unknown for several HTML5 elements.\n            // https://code.google.com/p/chromium/issues/detail?id=540526\n            !/^(data|time|rtc|rb)$/.test(tag)\n          )\n        ) {\n          _.warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly?'\n          )\n        }\n      }\n    }\n  } else if (hasAttrs) {\n    return getIsBinding(el)\n  }\n}\n\n/**\n * Get \"is\" binding from an element.\n *\n * @param {Element} el\n * @return {Object|undefined}\n */\n\nfunction getIsBinding (el) {\n  // dynamic syntax\n  var exp = _.attr(el, 'is')\n  if (exp != null) {\n    return { id: exp }\n  } else {\n    exp = _.getBindAttr(el, 'is')\n    if (exp != null) {\n      return { id: exp, dynamic: true }\n    }\n  }\n}\n\n/**\n * Set a prop's initial value on a vm and its data object.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @param {*} value\n */\n\nexports.initProp = function (vm, prop, value) {\n  if (exports.assertProp(prop, value)) {\n    var key = prop.path\n    vm[key] = vm._data[key] = value\n  }\n}\n\n/**\n * Assert whether a prop is valid.\n *\n * @param {Object} prop\n * @param {*} value\n */\n\nexports.assertProp = function (prop, value) {\n  // if a prop is not provided and is not required,\n  // skip the check.\n  if (prop.raw === null && !prop.required) {\n    return true\n  }\n  var options = prop.options\n  var type = options.type\n  var valid = true\n  var expectedType\n  if (type) {\n    if (type === String) {\n      expectedType = 'string'\n      valid = typeof value === expectedType\n    } else if (type === Number) {\n      expectedType = 'number'\n      valid = typeof value === 'number'\n    } else if (type === Boolean) {\n      expectedType = 'boolean'\n      valid = typeof value === 'boolean'\n    } else if (type === Function) {\n      expectedType = 'function'\n      valid = typeof value === 'function'\n    } else if (type === Object) {\n      expectedType = 'object'\n      valid = _.isPlainObject(value)\n    } else if (type === Array) {\n      expectedType = 'array'\n      valid = _.isArray(value)\n    } else {\n      valid = value instanceof type\n    }\n  }\n  if (!valid) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Invalid prop: type check failed for ' +\n      prop.path + '=\"' + prop.raw + '\".' +\n      ' Expected ' + formatType(expectedType) +\n      ', got ' + formatValue(value) + '.'\n    )\n    return false\n  }\n  var validator = options.validator\n  if (validator) {\n    if (!validator.call(null, value)) {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'Invalid prop: custom validator check failed for ' +\n        prop.path + '=\"' + prop.raw + '\"'\n      )\n      return false\n    }\n  }\n  return true\n}\n\nfunction formatType (val) {\n  return val\n    ? val.charAt(0).toUpperCase() + val.slice(1)\n    : 'custom type'\n}\n\nfunction formatValue (val) {\n  return Object.prototype.toString.call(val).slice(8, -1)\n}\n\n}).call(this,require('_process'))\n\n},{\"./index\":91,\"_process\":1}],88:[function(require,module,exports){\n(function (process){\n/**\n * Enable debug utilities.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n\n  var config = require('../config')\n  var hasConsole = typeof console !== 'undefined'\n\n  /**\n   * Log a message.\n   *\n   * @param {String} msg\n   */\n\n  exports.log = function (msg) {\n    if (hasConsole && config.debug) {\n      console.log('[Vue info]: ' + msg)\n    }\n  }\n\n  /**\n   * We've got a problem here.\n   *\n   * @param {String} msg\n   */\n\n  exports.warn = function (msg, e) {\n    if (hasConsole && (!config.silent || config.debug)) {\n      console.warn('[Vue warn]: ' + msg)\n      /* istanbul ignore if */\n      if (config.debug) {\n        console.warn((e || new Error('Warning Stack Trace')).stack)\n      }\n    }\n  }\n\n  /**\n   * Assert asset exists\n   */\n\n  exports.assertAsset = function (val, type, id) {\n    if (!val) {\n      exports.warn('Failed to resolve ' + type + ': ' + id)\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../config\":40,\"_process\":1}],89:[function(require,module,exports){\n(function (process){\nvar _ = require('./index')\nvar config = require('../config')\nvar transition = require('../transition')\n\n/**\n * Query an element selector if it's not an element already.\n *\n * @param {String|Element} el\n * @return {Element}\n */\n\nexports.query = function (el) {\n  if (typeof el === 'string') {\n    var selector = el\n    el = document.querySelector(el)\n    if (!el) {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'Cannot find element: ' + selector\n      )\n    }\n  }\n  return el\n}\n\n/**\n * Check if a node is in the document.\n * Note: document.documentElement.contains should work here\n * but always returns false for comment nodes in phantomjs,\n * making unit tests difficult. This is fixed by doing the\n * contains() check on the node's parentNode instead of\n * the node itself.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nexports.inDoc = function (node) {\n  var doc = document.documentElement\n  var parent = node && node.parentNode\n  return doc === node ||\n    doc === parent ||\n    !!(parent && parent.nodeType === 1 && (doc.contains(parent)))\n}\n\n/**\n * Get and remove an attribute from a node.\n *\n * @param {Node} node\n * @param {String} attr\n */\n\nexports.attr = function (node, attr) {\n  var val = node.getAttribute(attr)\n  if (val !== null) {\n    node.removeAttribute(attr)\n  }\n  return val\n}\n\n/**\n * Get an attribute with colon or v-bind: prefix.\n *\n * @param {Node} node\n * @param {String} name\n * @return {String|null}\n */\n\nexports.getBindAttr = function (node, name) {\n  var val = exports.attr(node, ':' + name)\n  if (val === null) {\n    val = exports.attr(node, 'v-bind:' + name)\n  }\n  return val\n}\n\n/**\n * Insert el before target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nexports.before = function (el, target) {\n  target.parentNode.insertBefore(el, target)\n}\n\n/**\n * Insert el after target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nexports.after = function (el, target) {\n  if (target.nextSibling) {\n    exports.before(el, target.nextSibling)\n  } else {\n    target.parentNode.appendChild(el)\n  }\n}\n\n/**\n * Remove el from DOM\n *\n * @param {Element} el\n */\n\nexports.remove = function (el) {\n  el.parentNode.removeChild(el)\n}\n\n/**\n * Prepend el to target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nexports.prepend = function (el, target) {\n  if (target.firstChild) {\n    exports.before(el, target.firstChild)\n  } else {\n    target.appendChild(el)\n  }\n}\n\n/**\n * Replace target with el\n *\n * @param {Element} target\n * @param {Element} el\n */\n\nexports.replace = function (target, el) {\n  var parent = target.parentNode\n  if (parent) {\n    parent.replaceChild(el, target)\n  }\n}\n\n/**\n * Add event listener shorthand.\n *\n * @param {Element} el\n * @param {String} event\n * @param {Function} cb\n */\n\nexports.on = function (el, event, cb) {\n  el.addEventListener(event, cb)\n}\n\n/**\n * Remove event listener shorthand.\n *\n * @param {Element} el\n * @param {String} event\n * @param {Function} cb\n */\n\nexports.off = function (el, event, cb) {\n  el.removeEventListener(event, cb)\n}\n\n/**\n * Add class with compatibility for IE & SVG\n *\n * @param {Element} el\n * @param {Strong} cls\n */\n\nexports.addClass = function (el, cls) {\n  if (el.classList) {\n    el.classList.add(cls)\n  } else {\n    var cur = ' ' + (el.getAttribute('class') || '') + ' '\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim())\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for IE & SVG\n *\n * @param {Element} el\n * @param {Strong} cls\n */\n\nexports.removeClass = function (el, cls) {\n  if (el.classList) {\n    el.classList.remove(cls)\n  } else {\n    var cur = ' ' + (el.getAttribute('class') || '') + ' '\n    var tar = ' ' + cls + ' '\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ')\n    }\n    el.setAttribute('class', cur.trim())\n  }\n  if (!el.className) {\n    el.removeAttribute('class')\n  }\n}\n\n/**\n * Extract raw content inside an element into a temporary\n * container div\n *\n * @param {Element} el\n * @param {Boolean} asFragment\n * @return {Element}\n */\n\nexports.extractContent = function (el, asFragment) {\n  var child\n  var rawContent\n  /* istanbul ignore if */\n  if (\n    exports.isTemplate(el) &&\n    el.content instanceof DocumentFragment\n  ) {\n    el = el.content\n  }\n  if (el.hasChildNodes()) {\n    exports.trimNode(el)\n    rawContent = asFragment\n      ? document.createDocumentFragment()\n      : document.createElement('div')\n    /* eslint-disable no-cond-assign */\n    while (child = el.firstChild) {\n    /* eslint-enable no-cond-assign */\n      rawContent.appendChild(child)\n    }\n  }\n  return rawContent\n}\n\n/**\n * Trim possible empty head/tail textNodes inside a parent.\n *\n * @param {Node} node\n */\n\nexports.trimNode = function (node) {\n  trim(node, node.firstChild)\n  trim(node, node.lastChild)\n}\n\nfunction trim (parent, node) {\n  if (node && node.nodeType === 3 && !node.data.trim()) {\n    parent.removeChild(node)\n  }\n}\n\n/**\n * Check if an element is a template tag.\n * Note if the template appears inside an SVG its tagName\n * will be in lowercase.\n *\n * @param {Element} el\n */\n\nexports.isTemplate = function (el) {\n  return el.tagName &&\n    el.tagName.toLowerCase() === 'template'\n}\n\n/**\n * Create an \"anchor\" for performing dom insertion/removals.\n * This is used in a number of scenarios:\n * - fragment instance\n * - v-html\n * - v-if\n * - v-for\n * - component\n *\n * @param {String} content\n * @param {Boolean} persist - IE trashes empty textNodes on\n *                            cloneNode(true), so in certain\n *                            cases the anchor needs to be\n *                            non-empty to be persisted in\n *                            templates.\n * @return {Comment|Text}\n */\n\nexports.createAnchor = function (content, persist) {\n  return config.debug\n    ? document.createComment(content)\n    : document.createTextNode(persist ? ' ' : '')\n}\n\n/**\n * Find a component ref attribute that starts with $.\n *\n * @param {Element} node\n * @return {String|undefined}\n */\n\nvar refRE = /^v-ref:/\nexports.findRef = function (node) {\n  if (node.hasAttributes()) {\n    var attrs = node.attributes\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      var name = attrs[i].name\n      if (refRE.test(name)) {\n        node.removeAttribute(name)\n        return _.camelize(name.replace(refRE, ''))\n      }\n    }\n  }\n}\n\n/**\n * Map a function to a range of nodes .\n *\n * @param {Node} node\n * @param {Node} end\n * @param {Function} op\n */\n\nexports.mapNodeRange = function (node, end, op) {\n  var next\n  while (node !== end) {\n    next = node.nextSibling\n    op(node)\n    node = next\n  }\n  op(end)\n}\n\n/**\n * Remove a range of nodes with transition, store\n * the nodes in a fragment with correct ordering,\n * and call callback when done.\n *\n * @param {Node} start\n * @param {Node} end\n * @param {Vue} vm\n * @param {DocumentFragment} frag\n * @param {Function} cb\n */\n\nexports.removeNodeRange = function (start, end, vm, frag, cb) {\n  var done = false\n  var removed = 0\n  var nodes = []\n  exports.mapNodeRange(start, end, function (node) {\n    if (node === end) done = true\n    nodes.push(node)\n    transition.remove(node, vm, onRemoved)\n  })\n  function onRemoved () {\n    removed++\n    if (done && removed >= nodes.length) {\n      for (var i = 0; i < nodes.length; i++) {\n        frag.appendChild(nodes[i])\n      }\n      cb && cb()\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../config\":40,\"../transition\":84,\"./index\":91,\"_process\":1}],90:[function(require,module,exports){\n// can we use __proto__?\nexports.hasProto = '__proto__' in {}\n\n// Browser environment sniffing\nvar inBrowser = exports.inBrowser =\n  typeof window !== 'undefined' &&\n  Object.prototype.toString.call(window) !== '[object Object]'\n\nexports.isIE9 =\n  inBrowser &&\n  navigator.userAgent.toLowerCase().indexOf('msie 9.0') > 0\n\nexports.isAndroid =\n  inBrowser &&\n  navigator.userAgent.toLowerCase().indexOf('android') > 0\n\n// Transition property/event sniffing\nif (inBrowser && !exports.isIE9) {\n  var isWebkitTrans =\n    window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  var isWebkitAnim =\n    window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  exports.transitionProp = isWebkitTrans\n    ? 'WebkitTransition'\n    : 'transition'\n  exports.transitionEndEvent = isWebkitTrans\n    ? 'webkitTransitionEnd'\n    : 'transitionend'\n  exports.animationProp = isWebkitAnim\n    ? 'WebkitAnimation'\n    : 'animation'\n  exports.animationEndEvent = isWebkitAnim\n    ? 'webkitAnimationEnd'\n    : 'animationend'\n}\n\n/**\n * Defer a task to execute it asynchronously. Ideally this\n * should be executed as a microtask, so we leverage\n * MutationObserver if it's available, and fallback to\n * setTimeout(0).\n *\n * @param {Function} cb\n * @param {Object} ctx\n */\n\nexports.nextTick = (function () {\n  var callbacks = []\n  var pending = false\n  var timerFunc\n  function nextTickHandler () {\n    pending = false\n    var copies = callbacks.slice(0)\n    callbacks = []\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]()\n    }\n  }\n  /* istanbul ignore if */\n  if (typeof MutationObserver !== 'undefined') {\n    var counter = 1\n    var observer = new MutationObserver(nextTickHandler)\n    var textNode = document.createTextNode(counter)\n    observer.observe(textNode, {\n      characterData: true\n    })\n    timerFunc = function () {\n      counter = (counter + 1) % 2\n      textNode.data = counter\n    }\n  } else {\n    timerFunc = setTimeout\n  }\n  return function (cb, ctx) {\n    var func = ctx\n      ? function () { cb.call(ctx) }\n      : cb\n    callbacks.push(func)\n    if (pending) return\n    pending = true\n    timerFunc(nextTickHandler, 0)\n  }\n})()\n\n},{}],91:[function(require,module,exports){\nvar lang = require('./lang')\nvar extend = lang.extend\n\nextend(exports, lang)\nextend(exports, require('./env'))\nextend(exports, require('./dom'))\nextend(exports, require('./options'))\nextend(exports, require('./component'))\nextend(exports, require('./debug'))\n\n},{\"./component\":87,\"./debug\":88,\"./dom\":89,\"./env\":90,\"./lang\":92,\"./options\":93}],92:[function(require,module,exports){\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n * @public\n */\n\nexports.set = function set (obj, key, val) {\n  if (obj.hasOwnProperty(key)) {\n    obj[key] = val\n    return\n  }\n  if (obj._isVue) {\n    set(obj._data, key, val)\n    return\n  }\n  var ob = obj.__ob__\n  if (!ob) {\n    obj[key] = val\n    return\n  }\n  ob.convert(key, val)\n  ob.dep.notify()\n  if (ob.vms) {\n    var i = ob.vms.length\n    while (i--) {\n      var vm = ob.vms[i]\n      vm._proxy(key)\n      vm._digest()\n    }\n  }\n}\n\n/**\n * Delete a property and trigger change if necessary.\n *\n * @param {Object} obj\n * @param {String} key\n */\n\nexports.delete = function (obj, key) {\n  if (!obj.hasOwnProperty(key)) {\n    return\n  }\n  delete obj[key]\n  var ob = obj.__ob__\n  if (!ob) {\n    return\n  }\n  ob.dep.notify()\n  if (ob.vms) {\n    var i = ob.vms.length\n    while (i--) {\n      var vm = ob.vms[i]\n      vm._unproxy(key)\n      vm._digest()\n    }\n  }\n}\n\n/**\n * Check if an expression is a literal value.\n *\n * @param {String} exp\n * @return {Boolean}\n */\n\nvar literalValueRE = /^\\s?(true|false|[\\d\\.]+|'[^']*'|\"[^\"]*\")\\s?$/\nexports.isLiteral = function (exp) {\n  return literalValueRE.test(exp)\n}\n\n/**\n * Check if a string starts with $ or _\n *\n * @param {String} str\n * @return {Boolean}\n */\n\nexports.isReserved = function (str) {\n  var c = (str + '').charCodeAt(0)\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Guard text output, make sure undefined outputs\n * empty string\n *\n * @param {*} value\n * @return {String}\n */\n\nexports.toString = function (value) {\n  return value == null\n    ? ''\n    : value.toString()\n}\n\n/**\n * Check and convert possible numeric strings to numbers\n * before setting back to data\n *\n * @param {*} value\n * @return {*|Number}\n */\n\nexports.toNumber = function (value) {\n  if (typeof value !== 'string') {\n    return value\n  } else {\n    var parsed = Number(value)\n    return isNaN(parsed)\n      ? value\n      : parsed\n  }\n}\n\n/**\n * Convert string boolean literals into real booleans.\n *\n * @param {*} value\n * @return {*|Boolean}\n */\n\nexports.toBoolean = function (value) {\n  return value === 'true'\n    ? true\n    : value === 'false'\n      ? false\n      : value\n}\n\n/**\n * Strip quotes from a string\n *\n * @param {String} str\n * @return {String | false}\n */\n\nexports.stripQuotes = function (str) {\n  var a = str.charCodeAt(0)\n  var b = str.charCodeAt(str.length - 1)\n  return a === b && (a === 0x22 || a === 0x27)\n    ? str.slice(1, -1)\n    : str\n}\n\n/**\n * Camelize a hyphen-delmited string.\n *\n * @param {String} str\n * @return {String}\n */\n\nvar camelizeRE = /-(\\w)/g\nexports.camelize = function (str) {\n  return str.replace(camelizeRE, toUpper)\n}\n\nfunction toUpper (_, c) {\n  return c ? c.toUpperCase() : ''\n}\n\n/**\n * Hyphenate a camelCase string.\n *\n * @param {String} str\n * @return {String}\n */\n\nvar hyphenateRE = /([a-z\\d])([A-Z])/g\nexports.hyphenate = function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n}\n\n/**\n * Converts hyphen/underscore/slash delimitered names into\n * camelized classNames.\n *\n * e.g. my-component => MyComponent\n *      some_else    => SomeElse\n *      some/comp    => SomeComp\n *\n * @param {String} str\n * @return {String}\n */\n\nvar classifyRE = /(?:^|[-_\\/])(\\w)/g\nexports.classify = function (str) {\n  return str.replace(classifyRE, toUpper)\n}\n\n/**\n * Simple bind, faster than native\n *\n * @param {Function} fn\n * @param {Object} ctx\n * @return {Function}\n */\n\nexports.bind = function (fn, ctx) {\n  return function (a) {\n    var l = arguments.length\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n}\n\n/**\n * Convert an Array-like object to a real Array.\n *\n * @param {Array-like} list\n * @param {Number} [start] - start index\n * @return {Array}\n */\n\nexports.toArray = function (list, start) {\n  start = start || 0\n  var i = list.length - start\n  var ret = new Array(i)\n  while (i--) {\n    ret[i] = list[i + start]\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n *\n * @param {Object} to\n * @param {Object} from\n */\n\nexports.extend = function (to, from) {\n  var keys = Object.keys(from)\n  var i = keys.length\n  while (i--) {\n    to[keys[i]] = from[keys[i]]\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nexports.isObject = function (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nvar toString = Object.prototype.toString\nvar OBJECT_STRING = '[object Object]'\nexports.isPlainObject = function (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Array type check.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nexports.isArray = Array.isArray\n\n/**\n * Define a non-enumerable property\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n * @param {Boolean} [enumerable]\n */\n\nexports.define = function (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  })\n}\n\n/**\n * Debounce a function so it only gets called after the\n * input stops arriving after the given wait period.\n *\n * @param {Function} func\n * @param {Number} wait\n * @return {Function} - the debounced function\n */\n\nexports.debounce = function (func, wait) {\n  var timeout, args, context, timestamp, result\n  var later = function () {\n    var last = Date.now() - timestamp\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last)\n    } else {\n      timeout = null\n      result = func.apply(context, args)\n      if (!timeout) context = args = null\n    }\n  }\n  return function () {\n    context = this\n    args = arguments\n    timestamp = Date.now()\n    if (!timeout) {\n      timeout = setTimeout(later, wait)\n    }\n    return result\n  }\n}\n\n/**\n * Manual indexOf because it's slightly faster than\n * native.\n *\n * @param {Array} arr\n * @param {*} obj\n */\n\nexports.indexOf = function (arr, obj) {\n  var i = arr.length\n  while (i--) {\n    if (arr[i] === obj) return i\n  }\n  return -1\n}\n\n/**\n * Make a cancellable version of an async callback.\n *\n * @param {Function} fn\n * @return {Function}\n */\n\nexports.cancellable = function (fn) {\n  var cb = function () {\n    if (!cb.cancelled) {\n      return fn.apply(this, arguments)\n    }\n  }\n  cb.cancel = function () {\n    cb.cancelled = true\n  }\n  return cb\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n *\n * @param {*} a\n * @param {*} b\n * @return {Boolean}\n */\n\nexports.looseEqual = function (a, b) {\n  /* eslint-disable eqeqeq */\n  return a == b || (\n    exports.isObject(a) && exports.isObject(b)\n      ? JSON.stringify(a) === JSON.stringify(b)\n      : false\n  )\n  /* eslint-enable eqeqeq */\n}\n\n},{}],93:[function(require,module,exports){\n(function (process){\nvar _ = require('./index')\nvar config = require('../config')\nvar extend = _.extend\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n *\n * All strategy functions follow the same signature:\n *\n * @param {*} parentVal\n * @param {*} childVal\n * @param {Vue} [vm]\n */\n\nvar strats = config.optionMergeStrategies = Object.create(null)\n\n/**\n * Helper that recursively merges two data objects together.\n */\n\nfunction mergeData (to, from) {\n  var key, toVal, fromVal\n  for (key in from) {\n    toVal = to[key]\n    fromVal = from[key]\n    if (!to.hasOwnProperty(key)) {\n      _.set(to, key, fromVal)\n    } else if (_.isObject(toVal) && _.isObject(fromVal)) {\n      mergeData(toVal, fromVal)\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\n\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.'\n      )\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\n/**\n * El\n */\n\nstrats.el = function (parentVal, childVal, vm) {\n  if (!vm && childVal && typeof childVal !== 'function') {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'The \"el\" option should be a function ' +\n      'that returns a per-instance value in component ' +\n      'definitions.'\n    )\n    return\n  }\n  var ret = childVal || parentVal\n  // invoke the element factory if this is instance merge\n  return vm && typeof ret === 'function'\n    ? ret.call(vm)\n    : ret\n}\n\n/**\n * Hooks and param attributes are merged as arrays.\n */\n\nstrats.init =\nstrats.created =\nstrats.ready =\nstrats.attached =\nstrats.detached =\nstrats.beforeCompile =\nstrats.compiled =\nstrats.beforeDestroy =\nstrats.destroyed = function (parentVal, childVal) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : _.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\n/**\n * 0.11 deprecation warning\n */\n\nstrats.paramAttributes = function () {\n  /* istanbul ignore next */\n  process.env.NODE_ENV !== 'production' && _.warn(\n    '\"paramAttributes\" option has been deprecated in 0.12. ' +\n    'Use \"props\" instead.'\n  )\n}\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\n\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal)\n  return childVal\n    ? extend(res, guardArrayAssets(childVal))\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets\n})\n\n/**\n * Events & Watchers.\n *\n * Events & watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\n\nstrats.watch =\nstrats.events = function (parentVal, childVal) {\n  if (!childVal) return parentVal\n  if (!parentVal) return childVal\n  var ret = {}\n  extend(ret, parentVal)\n  for (var key in childVal) {\n    var parent = ret[key]\n    var child = childVal[key]\n    if (parent && !_.isArray(parent)) {\n      parent = [parent]\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child]\n  }\n  return ret\n}\n\n/**\n * Other object hashes.\n */\n\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) return parentVal\n  if (!parentVal) return childVal\n  var ret = Object.create(null)\n  extend(ret, parentVal)\n  extend(ret, childVal)\n  return ret\n}\n\n/**\n * Default strategy.\n */\n\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n}\n\n/**\n * Make sure component options get converted to actual\n * constructors.\n *\n * @param {Object} options\n */\n\nfunction guardComponents (options) {\n  if (options.components) {\n    var components = options.components =\n      guardArrayAssets(options.components)\n    var def\n    var ids = Object.keys(components)\n    for (var i = 0, l = ids.length; i < l; i++) {\n      var key = ids[i]\n      if (_.commonTagRE.test(key)) {\n        process.env.NODE_ENV !== 'production' && _.warn(\n          'Do not use built-in HTML elements as component ' +\n          'id: ' + key\n        )\n        continue\n      }\n      def = components[key]\n      if (_.isPlainObject(def)) {\n        components[key] = _.Vue.extend(def)\n      }\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n *\n * @param {Object} options\n */\n\nfunction guardProps (options) {\n  var props = options.props\n  var i\n  if (_.isArray(props)) {\n    options.props = {}\n    i = props.length\n    while (i--) {\n      options.props[props[i]] = null\n    }\n  } else if (_.isPlainObject(props)) {\n    var keys = Object.keys(props)\n    i = keys.length\n    while (i--) {\n      var val = props[keys[i]]\n      if (typeof val === 'function') {\n        props[keys[i]] = { type: val }\n      }\n    }\n  }\n}\n\n/**\n * Guard an Array-format assets option and converted it\n * into the key-value Object format.\n *\n * @param {Object|Array} assets\n * @return {Object}\n */\n\nfunction guardArrayAssets (assets) {\n  if (_.isArray(assets)) {\n    var res = {}\n    var i = assets.length\n    var asset\n    while (i--) {\n      asset = assets[i]\n      var id = typeof asset === 'function'\n        ? ((asset.options && asset.options.name) || asset.id)\n        : (asset.name || asset.id)\n      if (!id) {\n        process.env.NODE_ENV !== 'production' && _.warn(\n          'Array-syntax assets must provide a \"name\" or \"id\" field.'\n        )\n      } else {\n        res[id] = asset\n      }\n    }\n    return res\n  }\n  return assets\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n *\n * @param {Object} parent\n * @param {Object} child\n * @param {Vue} [vm] - if vm is present, indicates this is\n *                     an instantiation merge.\n */\n\nexports.mergeOptions = function merge (parent, child, vm) {\n  guardComponents(child)\n  guardProps(child)\n  var options = {}\n  var key\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = merge(parent, child.mixins[i], vm)\n    }\n  }\n  for (key in parent) {\n    mergeField(key)\n  }\n  for (key in child) {\n    if (!(parent.hasOwnProperty(key))) {\n      mergeField(key)\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat\n    options[key] = strat(parent[key], child[key], vm, key)\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n *\n * @param {Object} options\n * @param {String} type\n * @param {String} id\n * @return {Object|Function}\n */\n\nexports.resolveAsset = function resolve (options, type, id) {\n  var assets = options[type]\n  var camelizedId\n  return assets[id] ||\n    // camelCase ID\n    assets[camelizedId = _.camelize(id)] ||\n    // Pascal Case ID\n    assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)]\n}\n\n}).call(this,require('_process'))\n\n},{\"../config\":40,\"./index\":91,\"_process\":1}],94:[function(require,module,exports){\n(function (process){\nvar _ = require('./util')\nvar extend = _.extend\n\n/**\n * The exposed Vue constructor.\n *\n * API conventions:\n * - public API methods/properties are prefiexed with `$`\n * - internal methods/properties are prefixed with `_`\n * - non-prefixed properties are assumed to be proxied user\n *   data.\n *\n * @constructor\n * @param {Object} [options]\n * @public\n */\n\nfunction Vue (options) {\n  this._init(options)\n}\n\n/**\n * Mixin global API\n */\n\nextend(Vue, require('./api/global'))\n\n/**\n * Vue and every constructor that extends Vue has an\n * associated options object, which can be accessed during\n * compilation steps as `this.constructor.options`.\n *\n * These can be seen as the default options of every\n * Vue instance.\n */\n\nVue.options = {\n  replace: true,\n  directives: require('./directives/public'),\n  elementDirectives: require('./directives/element'),\n  filters: require('./filters'),\n  transitions: {},\n  components: {},\n  partials: {}\n}\n\n/**\n * Build up the prototype\n */\n\nvar p = Vue.prototype\n\n/**\n * $data has a setter which does a bunch of\n * teardown/setup work\n */\n\nObject.defineProperty(p, '$data', {\n  get: function () {\n    return this._data\n  },\n  set: function (newData) {\n    if (newData !== this._data) {\n      this._setData(newData)\n    }\n  }\n})\n\n/**\n * Mixin internal instance methods\n */\n\nextend(p, require('./instance/init'))\nextend(p, require('./instance/events'))\nextend(p, require('./instance/state'))\nextend(p, require('./instance/lifecycle'))\nextend(p, require('./instance/misc'))\n\n/**\n * Mixin public API methods\n */\n\nextend(p, require('./api/data'))\nextend(p, require('./api/dom'))\nextend(p, require('./api/events'))\nextend(p, require('./api/lifecycle'))\n\nVue.version = '1.0.4'\nmodule.exports = _.Vue = Vue\n\n/* istanbul ignore if */\nif (process.env.NODE_ENV !== 'production') {\n  if (_.inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {\n    window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('init', Vue)\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"./api/data\":29,\"./api/dom\":30,\"./api/events\":31,\"./api/global\":32,\"./api/lifecycle\":33,\"./directives/element\":42,\"./directives/public\":57,\"./filters\":68,\"./instance/events\":71,\"./instance/init\":72,\"./instance/lifecycle\":73,\"./instance/misc\":74,\"./instance/state\":75,\"./util\":91,\"_process\":1}],95:[function(require,module,exports){\n(function (process){\nvar _ = require('./util')\nvar config = require('./config')\nvar Dep = require('./observer/dep')\nvar expParser = require('./parsers/expression')\nvar batcher = require('./batcher')\nvar uid = 0\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n *\n * @param {Vue} vm\n * @param {String} expression\n * @param {Function} cb\n * @param {Object} options\n *                 - {Array} filters\n *                 - {Boolean} twoWay\n *                 - {Boolean} deep\n *                 - {Boolean} user\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n *                 - {Function} [preProcess]\n *                 - {Function} [postProcess]\n * @constructor\n */\n\nfunction Watcher (vm, expOrFn, cb, options) {\n  // mix in options\n  if (options) {\n    _.extend(this, options)\n  }\n  var isFn = typeof expOrFn === 'function'\n  this.vm = vm\n  vm._watchers.push(this)\n  this.expression = isFn ? expOrFn.toString() : expOrFn\n  this.cb = cb\n  this.id = ++uid // uid for batching\n  this.active = true\n  this.dirty = this.lazy // for lazy watchers\n  this.deps = Object.create(null)\n  this.newDeps = null\n  this.prevError = null // for async error stacks\n  // parse expression for getter/setter\n  if (isFn) {\n    this.getter = expOrFn\n    this.setter = undefined\n  } else {\n    var res = expParser.parse(expOrFn, this.twoWay)\n    this.getter = res.get\n    this.setter = res.set\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get()\n  // state for avoiding false triggers for deep and Array\n  // watchers during vm._digest()\n  this.queued = this.shallow = false\n}\n\n/**\n * Add a dependency to this directive.\n *\n * @param {Dep} dep\n */\n\nWatcher.prototype.addDep = function (dep) {\n  var id = dep.id\n  if (!this.newDeps[id]) {\n    this.newDeps[id] = dep\n    if (!this.deps[id]) {\n      this.deps[id] = dep\n      dep.addSub(this)\n    }\n  }\n}\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\n\nWatcher.prototype.get = function () {\n  this.beforeGet()\n  var scope = this.scope || this.vm\n  var value\n  try {\n    value = this.getter.call(scope, scope)\n  } catch (e) {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      config.warnExpressionErrors\n    ) {\n      _.warn(\n        'Error when evaluating expression \"' +\n        this.expression + '\". ' +\n        (config.debug\n          ? ''\n          : 'Turn on debug mode to see stack trace.'\n        ), e\n      )\n    }\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value)\n  }\n  if (this.preProcess) {\n    value = this.preProcess(value)\n  }\n  if (this.filters) {\n    value = scope._applyFilters(value, null, this.filters, false)\n  }\n  if (this.postProcess) {\n    value = this.postProcess(value)\n  }\n  this.afterGet()\n  return value\n}\n\n/**\n * Set the corresponding value with the setter.\n *\n * @param {*} value\n */\n\nWatcher.prototype.set = function (value) {\n  var scope = this.scope || this.vm\n  if (this.filters) {\n    value = scope._applyFilters(\n      value, this.value, this.filters, true)\n  }\n  try {\n    this.setter.call(scope, scope, value)\n  } catch (e) {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      config.warnExpressionErrors\n    ) {\n      _.warn(\n        'Error when evaluating setter \"' +\n        this.expression + '\"', e\n      )\n    }\n  }\n  // two-way sync for v-for alias\n  var forContext = scope.$forContext\n  if (process.env.NODE_ENV !== 'production') {\n    if (\n      forContext &&\n      forContext.filters &&\n      (new RegExp(forContext.alias + '\\\\b')).test(this.expression)\n    ) {\n      _.warn(\n        'It seems you are using two-way binding on ' +\n        'a v-for alias (' + this.expression + '), and the ' +\n        'v-for has filters. This will not work properly. ' +\n        'Either remove the filters or use an array of ' +\n        'objects and bind to object properties instead.'\n      )\n    }\n  }\n  if (\n    forContext &&\n    forContext.alias === this.expression &&\n    !forContext.filters\n  ) {\n    if (scope.$key) { // original is an object\n      forContext.rawValue[scope.$key] = value\n    } else {\n      forContext.rawValue.$set(scope.$index, value)\n    }\n  }\n}\n\n/**\n * Prepare for dependency collection.\n */\n\nWatcher.prototype.beforeGet = function () {\n  Dep.target = this\n  this.newDeps = Object.create(null)\n}\n\n/**\n * Clean up for dependency collection.\n */\n\nWatcher.prototype.afterGet = function () {\n  Dep.target = null\n  var ids = Object.keys(this.deps)\n  var i = ids.length\n  while (i--) {\n    var id = ids[i]\n    if (!this.newDeps[id]) {\n      this.deps[id].removeSub(this)\n    }\n  }\n  this.deps = this.newDeps\n}\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n *\n * @param {Boolean} shallow\n */\n\nWatcher.prototype.update = function (shallow) {\n  if (this.lazy) {\n    this.dirty = true\n  } else if (this.sync || !config.async) {\n    this.run()\n  } else {\n    // if queued, only overwrite shallow with non-shallow,\n    // but not the other way around.\n    this.shallow = this.queued\n      ? shallow\n        ? this.shallow\n        : false\n      : !!shallow\n    this.queued = true\n    // record before-push error stack in debug mode\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.debug) {\n      this.prevError = new Error('[vue] async stack trace')\n    }\n    batcher.push(this)\n  }\n}\n\n/**\n * Batcher job interface.\n * Will be called by the batcher.\n */\n\nWatcher.prototype.run = function () {\n  if (this.active) {\n    var value = this.get()\n    if (\n      value !== this.value ||\n      // Deep watchers and Array watchers should fire even\n      // when the value is the same, because the value may\n      // have mutated; but only do so if this is a\n      // non-shallow update (caused by a vm digest).\n      ((_.isArray(value) || this.deep) && !this.shallow)\n    ) {\n      // set new value\n      var oldValue = this.value\n      this.value = value\n      // in debug + async mode, when a watcher callbacks\n      // throws, we also throw the saved before-push error\n      // so the full cross-tick stack trace is available.\n      var prevError = this.prevError\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' &&\n          config.debug && prevError) {\n        this.prevError = null\n        try {\n          this.cb.call(this.vm, value, oldValue)\n        } catch (e) {\n          _.nextTick(function () {\n            throw prevError\n          }, 0)\n          throw e\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue)\n      }\n    }\n    this.queued = this.shallow = false\n  }\n}\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\n\nWatcher.prototype.evaluate = function () {\n  // avoid overwriting another watcher that is being\n  // collected.\n  var current = Dep.target\n  this.value = this.get()\n  this.dirty = false\n  Dep.target = current\n}\n\n/**\n * Depend on all deps collected by this watcher.\n */\n\nWatcher.prototype.depend = function () {\n  var depIds = Object.keys(this.deps)\n  var i = depIds.length\n  while (i--) {\n    this.deps[depIds[i]].depend()\n  }\n}\n\n/**\n * Remove self from all dependencies' subcriber list.\n */\n\nWatcher.prototype.teardown = function () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // we can skip this if the vm if being destroyed\n    // which can improve teardown performance.\n    if (!this.vm._isBeingDestroyed) {\n      this.vm._watchers.$remove(this)\n    }\n    var depIds = Object.keys(this.deps)\n    var i = depIds.length\n    while (i--) {\n      this.deps[depIds[i]].removeSub(this)\n    }\n    this.active = false\n    this.vm = this.cb = this.value = null\n  }\n}\n\n/**\n * Recrusively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n *\n * @param {*} val\n */\n\nfunction traverse (val) {\n  var i, keys\n  if (_.isArray(val)) {\n    i = val.length\n    while (i--) traverse(val[i])\n  } else if (_.isObject(val)) {\n    keys = Object.keys(val)\n    i = keys.length\n    while (i--) traverse(val[keys[i]])\n  }\n}\n\nmodule.exports = Watcher\n\n}).call(this,require('_process'))\n\n},{\"./batcher\":34,\"./config\":40,\"./observer/dep\":77,\"./parsers/expression\":80,\"./util\":91,\"_process\":1}],96:[function(require,module,exports){\nvar inserted = exports.cache = {}\n\nexports.insert = function (css) {\n  if (inserted[css]) return\n  inserted[css] = true\n\n  var elem = document.createElement('style')\n  elem.setAttribute('type', 'text/css')\n\n  if ('textContent' in elem) {\n    elem.textContent = css\n  } else {\n    elem.styleSheet.cssText = css\n  }\n\n  document.getElementsByTagName('head')[0].appendChild(elem)\n  return elem\n}\n\n},{}],97:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function (require) {\n\n\tvar makePromise = require('./makePromise');\n\tvar Scheduler = require('./Scheduler');\n\tvar async = require('./env').asap;\n\n\treturn makePromise({\n\t\tscheduler: new Scheduler(async)\n\t});\n\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n},{\"./Scheduler\":98,\"./env\":110,\"./makePromise\":112}],98:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for next-tick conflation.\n\n\t/**\n\t * Async task scheduler\n\t * @param {function} async function to schedule a single async function\n\t * @constructor\n\t */\n\tfunction Scheduler(async) {\n\t\tthis._async = async;\n\t\tthis._running = false;\n\n\t\tthis._queue = this;\n\t\tthis._queueLen = 0;\n\t\tthis._afterQueue = {};\n\t\tthis._afterQueueLen = 0;\n\n\t\tvar self = this;\n\t\tthis.drain = function() {\n\t\t\tself._drain();\n\t\t};\n\t}\n\n\t/**\n\t * Enqueue a task\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.enqueue = function(task) {\n\t\tthis._queue[this._queueLen++] = task;\n\t\tthis.run();\n\t};\n\n\t/**\n\t * Enqueue a task to run after the main task queue\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.afterQueue = function(task) {\n\t\tthis._afterQueue[this._afterQueueLen++] = task;\n\t\tthis.run();\n\t};\n\n\tScheduler.prototype.run = function() {\n\t\tif (!this._running) {\n\t\t\tthis._running = true;\n\t\t\tthis._async(this.drain);\n\t\t}\n\t};\n\n\t/**\n\t * Drain the handler queue entirely, and then the after queue\n\t */\n\tScheduler.prototype._drain = function() {\n\t\tvar i = 0;\n\t\tfor (; i < this._queueLen; ++i) {\n\t\t\tthis._queue[i].run();\n\t\t\tthis._queue[i] = void 0;\n\t\t}\n\n\t\tthis._queueLen = 0;\n\t\tthis._running = false;\n\n\t\tfor (i = 0; i < this._afterQueueLen; ++i) {\n\t\t\tthis._afterQueue[i].run();\n\t\t\tthis._afterQueue[i] = void 0;\n\t\t}\n\n\t\tthis._afterQueueLen = 0;\n\t};\n\n\treturn Scheduler;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],99:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\t/**\n\t * Custom error type for promises rejected by promise.timeout\n\t * @param {string} message\n\t * @constructor\n\t */\n\tfunction TimeoutError (message) {\n\t\tError.call(this);\n\t\tthis.message = message;\n\t\tthis.name = TimeoutError.name;\n\t\tif (typeof Error.captureStackTrace === 'function') {\n\t\t\tError.captureStackTrace(this, TimeoutError);\n\t\t}\n\t}\n\n\tTimeoutError.prototype = Object.create(Error.prototype);\n\tTimeoutError.prototype.constructor = TimeoutError;\n\n\treturn TimeoutError;\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n},{}],100:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\tmakeApply.tryCatchResolve = tryCatchResolve;\n\n\treturn makeApply;\n\n\tfunction makeApply(Promise, call) {\n\t\tif(arguments.length < 2) {\n\t\t\tcall = tryCatchResolve;\n\t\t}\n\n\t\treturn apply;\n\n\t\tfunction apply(f, thisArg, args) {\n\t\t\tvar p = Promise._defer();\n\t\t\tvar l = args.length;\n\t\t\tvar params = new Array(l);\n\t\t\tcallAndResolve({ f:f, thisArg:thisArg, args:args, params:params, i:l-1, call:call }, p._handler);\n\n\t\t\treturn p;\n\t\t}\n\n\t\tfunction callAndResolve(c, h) {\n\t\t\tif(c.i < 0) {\n\t\t\t\treturn call(c.f, c.thisArg, c.params, h);\n\t\t\t}\n\n\t\t\tvar handler = Promise._handler(c.args[c.i]);\n\t\t\thandler.fold(callAndResolveNext, c, void 0, h);\n\t\t}\n\n\t\tfunction callAndResolveNext(c, x, h) {\n\t\t\tc.params[c.i] = x;\n\t\t\tc.i -= 1;\n\t\t\tcallAndResolve(c, h);\n\t\t}\n\t}\n\n\tfunction tryCatchResolve(f, thisArg, args, resolver) {\n\t\ttry {\n\t\t\tresolver.resolve(f.apply(thisArg, args));\n\t\t} catch(e) {\n\t\t\tresolver.reject(e);\n\t\t}\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n},{}],101:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar state = require('../state');\n\tvar applier = require('../apply');\n\n\treturn function array(Promise) {\n\n\t\tvar applyFold = applier(Promise);\n\t\tvar toPromise = Promise.resolve;\n\t\tvar all = Promise.all;\n\n\t\tvar ar = Array.prototype.reduce;\n\t\tvar arr = Array.prototype.reduceRight;\n\t\tvar slice = Array.prototype.slice;\n\n\t\t// Additional array combinators\n\n\t\tPromise.any = any;\n\t\tPromise.some = some;\n\t\tPromise.settle = settle;\n\n\t\tPromise.map = map;\n\t\tPromise.filter = filter;\n\t\tPromise.reduce = reduce;\n\t\tPromise.reduceRight = reduceRight;\n\n\t\t/**\n\t\t * When this promise fulfills with an array, do\n\t\t * onFulfilled.apply(void 0, array)\n\t\t * @param {function} onFulfilled function to apply\n\t\t * @returns {Promise} promise for the result of applying onFulfilled\n\t\t */\n\t\tPromise.prototype.spread = function(onFulfilled) {\n\t\t\treturn this.then(all).then(function(array) {\n\t\t\t\treturn onFulfilled.apply(this, array);\n\t\t\t});\n\t\t};\n\n\t\treturn Promise;\n\n\t\t/**\n\t\t * One-winner competitive race.\n\t\t * Return a promise that will fulfill when one of the promises\n\t\t * in the input array fulfills, or will reject when all promises\n\t\t * have rejected.\n\t\t * @param {array} promises\n\t\t * @returns {Promise} promise for the first fulfilled value\n\t\t */\n\t\tfunction any(promises) {\n\t\t\tvar p = Promise._defer();\n\t\t\tvar resolver = p._handler;\n\t\t\tvar l = promises.length>>>0;\n\n\t\t\tvar pending = l;\n\t\t\tvar errors = [];\n\n\t\t\tfor (var h, x, i = 0; i < l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\th = Promise._handler(x);\n\t\t\t\tif(h.state() > 0) {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tPromise._visitRemaining(promises, i, h);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\th.visit(resolver, handleFulfill, handleReject);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.reject(new RangeError('any(): array must not be empty'));\n\t\t\t}\n\n\t\t\treturn p;\n\n\t\t\tfunction handleFulfill(x) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\terrors = null;\n\t\t\t\tthis.resolve(x); // this === resolver\n\t\t\t}\n\n\t\t\tfunction handleReject(e) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\terrors.push(e);\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tthis.reject(errors);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * N-winner competitive race\n\t\t * Return a promise that will fulfill when n input promises have\n\t\t * fulfilled, or will reject when it becomes impossible for n\n\t\t * input promises to fulfill (ie when promises.length - n + 1\n\t\t * have rejected)\n\t\t * @param {array} promises\n\t\t * @param {number} n\n\t\t * @returns {Promise} promise for the earliest n fulfillment values\n\t\t *\n\t\t * @deprecated\n\t\t */\n\t\tfunction some(promises, n) {\n\t\t\t/*jshint maxcomplexity:7*/\n\t\t\tvar p = Promise._defer();\n\t\t\tvar resolver = p._handler;\n\n\t\t\tvar results = [];\n\t\t\tvar errors = [];\n\n\t\t\tvar l = promises.length>>>0;\n\t\t\tvar nFulfill = 0;\n\t\t\tvar nReject;\n\t\t\tvar x, i; // reused in both for() loops\n\n\t\t\t// First pass: count actual array items\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t++nFulfill;\n\t\t\t}\n\n\t\t\t// Compute actual goals\n\t\t\tn = Math.max(n, 0);\n\t\t\tnReject = (nFulfill - n + 1);\n\t\t\tnFulfill = Math.min(n, nFulfill);\n\n\t\t\tif(n > nFulfill) {\n\t\t\t\tresolver.reject(new RangeError('some(): array must contain at least '\n\t\t\t\t+ n + ' item(s), but had ' + nFulfill));\n\t\t\t} else if(nFulfill === 0) {\n\t\t\t\tresolver.resolve(results);\n\t\t\t}\n\n\t\t\t// Second pass: observe each array item, make progress toward goals\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPromise._handler(x).visit(resolver, fulfill, reject, resolver.notify);\n\t\t\t}\n\n\t\t\treturn p;\n\n\t\t\tfunction fulfill(x) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresults.push(x);\n\t\t\t\tif(--nFulfill === 0) {\n\t\t\t\t\terrors = null;\n\t\t\t\t\tthis.resolve(results);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction reject(e) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\terrors.push(e);\n\t\t\t\tif(--nReject === 0) {\n\t\t\t\t\tresults = null;\n\t\t\t\t\tthis.reject(errors);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Apply f to the value of each promise in a list of promises\n\t\t * and return a new list containing the results.\n\t\t * @param {array} promises\n\t\t * @param {function(x:*, index:Number):*} f mapping function\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction map(promises, f) {\n\t\t\treturn Promise._traverse(f, promises);\n\t\t}\n\n\t\t/**\n\t\t * Filter the provided array of promises using the provided predicate.  Input may\n\t\t * contain promises and values\n\t\t * @param {Array} promises array of promises and values\n\t\t * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n\t\t *  Must return truthy (or promise for truthy) for items to retain.\n\t\t * @returns {Promise} promise that will fulfill with an array containing all items\n\t\t *  for which predicate returned truthy.\n\t\t */\n\t\tfunction filter(promises, predicate) {\n\t\t\tvar a = slice.call(promises);\n\t\t\treturn Promise._traverse(predicate, a).then(function(keep) {\n\t\t\t\treturn filterSync(a, keep);\n\t\t\t});\n\t\t}\n\n\t\tfunction filterSync(promises, keep) {\n\t\t\t// Safe because we know all promises have fulfilled if we've made it this far\n\t\t\tvar l = keep.length;\n\t\t\tvar filtered = new Array(l);\n\t\t\tfor(var i=0, j=0; i<l; ++i) {\n\t\t\t\tif(keep[i]) {\n\t\t\t\t\tfiltered[j++] = Promise._handler(promises[i]).value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiltered.length = j;\n\t\t\treturn filtered;\n\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that will always fulfill with an array containing\n\t\t * the outcome states of all input promises.  The returned promise\n\t\t * will never reject.\n\t\t * @param {Array} promises\n\t\t * @returns {Promise} promise for array of settled state descriptors\n\t\t */\n\t\tfunction settle(promises) {\n\t\t\treturn all(promises.map(settleOne));\n\t\t}\n\n\t\tfunction settleOne(p) {\n\t\t\tvar h = Promise._handler(p);\n\t\t\tif(h.state() === 0) {\n\t\t\t\treturn toPromise(p).then(state.fulfilled, state.rejected);\n\t\t\t}\n\n\t\t\th._unreport();\n\t\t\treturn state.inspect(h);\n\t\t}\n\n\t\t/**\n\t\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t\t * input may contain promises and/or values, and reduceFunc\n\t\t * may return either a value or a promise, *and* initialValue may\n\t\t * be a promise for the starting value.\n\t\t * @param {Array|Promise} promises array or promise for an array of anything,\n\t\t *      may contain a mix of promises and values.\n\t\t * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n\t\t * @returns {Promise} that will resolve to the final reduced value\n\t\t */\n\t\tfunction reduce(promises, f /*, initialValue */) {\n\t\t\treturn arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])\n\t\t\t\t\t: ar.call(promises, liftCombine(f));\n\t\t}\n\n\t\t/**\n\t\t * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but\n\t\t * input may contain promises and/or values, and reduceFunc\n\t\t * may return either a value or a promise, *and* initialValue may\n\t\t * be a promise for the starting value.\n\t\t * @param {Array|Promise} promises array or promise for an array of anything,\n\t\t *      may contain a mix of promises and values.\n\t\t * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n\t\t * @returns {Promise} that will resolve to the final reduced value\n\t\t */\n\t\tfunction reduceRight(promises, f /*, initialValue */) {\n\t\t\treturn arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])\n\t\t\t\t\t: arr.call(promises, liftCombine(f));\n\t\t}\n\n\t\tfunction liftCombine(f) {\n\t\t\treturn function(z, x, i) {\n\t\t\t\treturn applyFold(f, void 0, [z,x,i]);\n\t\t\t};\n\t\t}\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n},{\"../apply\":100,\"../state\":113}],102:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function flow(Promise) {\n\n\t\tvar resolve = Promise.resolve;\n\t\tvar reject = Promise.reject;\n\t\tvar origCatch = Promise.prototype['catch'];\n\n\t\t/**\n\t\t * Handle the ultimate fulfillment value or rejection reason, and assume\n\t\t * responsibility for all errors.  If an error propagates out of result\n\t\t * or handleFatalError, it will be rethrown to the host, resulting in a\n\t\t * loud stack track on most platforms and a crash on some.\n\t\t * @param {function?} onResult\n\t\t * @param {function?} onError\n\t\t * @returns {undefined}\n\t\t */\n\t\tPromise.prototype.done = function(onResult, onError) {\n\t\t\tthis._handler.visit(this._handler.receiver, onResult, onError);\n\t\t};\n\n\t\t/**\n\t\t * Add Error-type and predicate matching to catch.  Examples:\n\t\t * promise.catch(TypeError, handleTypeError)\n\t\t *   .catch(predicate, handleMatchedErrors)\n\t\t *   .catch(handleRemainingErrors)\n\t\t * @param onRejected\n\t\t * @returns {*}\n\t\t */\n\t\tPromise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {\n\t\t\tif (arguments.length < 2) {\n\t\t\t\treturn origCatch.call(this, onRejected);\n\t\t\t}\n\n\t\t\tif(typeof onRejected !== 'function') {\n\t\t\t\treturn this.ensure(rejectInvalidPredicate);\n\t\t\t}\n\n\t\t\treturn origCatch.call(this, createCatchFilter(arguments[1], onRejected));\n\t\t};\n\n\t\t/**\n\t\t * Wraps the provided catch handler, so that it will only be called\n\t\t * if the predicate evaluates truthy\n\t\t * @param {?function} handler\n\t\t * @param {function} predicate\n\t\t * @returns {function} conditional catch handler\n\t\t */\n\t\tfunction createCatchFilter(handler, predicate) {\n\t\t\treturn function(e) {\n\t\t\t\treturn evaluatePredicate(e, predicate)\n\t\t\t\t\t? handler.call(this, e)\n\t\t\t\t\t: reject(e);\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Ensures that onFulfilledOrRejected will be called regardless of whether\n\t\t * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n\t\t * receive the promises' value or reason.  Any returned value will be disregarded.\n\t\t * onFulfilledOrRejected may throw or return a rejected promise to signal\n\t\t * an additional error.\n\t\t * @param {function} handler handler to be called regardless of\n\t\t *  fulfillment or rejection\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype['finally'] = Promise.prototype.ensure = function(handler) {\n\t\t\tif(typeof handler !== 'function') {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\treturn this.then(function(x) {\n\t\t\t\treturn runSideEffect(handler, this, identity, x);\n\t\t\t}, function(e) {\n\t\t\t\treturn runSideEffect(handler, this, reject, e);\n\t\t\t});\n\t\t};\n\n\t\tfunction runSideEffect (handler, thisArg, propagate, value) {\n\t\t\tvar result = handler.call(thisArg);\n\t\t\treturn maybeThenable(result)\n\t\t\t\t? propagateValue(result, propagate, value)\n\t\t\t\t: propagate(value);\n\t\t}\n\n\t\tfunction propagateValue (result, propagate, x) {\n\t\t\treturn resolve(result).then(function () {\n\t\t\t\treturn propagate(x);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Recover from a failure by returning a defaultValue.  If defaultValue\n\t\t * is a promise, it's fulfillment value will be used.  If defaultValue is\n\t\t * a promise that rejects, the returned promise will reject with the\n\t\t * same reason.\n\t\t * @param {*} defaultValue\n\t\t * @returns {Promise} new promise\n\t\t */\n\t\tPromise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {\n\t\t\treturn this.then(void 0, function() {\n\t\t\t\treturn defaultValue;\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @return {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\tPromise.prototype['yield'] = function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Runs a side effect when this promise fulfills, without changing the\n\t\t * fulfillment value.\n\t\t * @param {function} onFulfilledSideEffect\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.tap = function(onFulfilledSideEffect) {\n\t\t\treturn this.then(onFulfilledSideEffect)['yield'](this);\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n\tfunction rejectInvalidPredicate() {\n\t\tthrow new TypeError('catch predicate must be a function');\n\t}\n\n\tfunction evaluatePredicate(e, predicate) {\n\t\treturn isError(predicate) ? e instanceof predicate : predicate(e);\n\t}\n\n\tfunction isError(predicate) {\n\t\treturn predicate === Error\n\t\t\t|| (predicate != null && predicate.prototype instanceof Error);\n\t}\n\n\tfunction maybeThenable(x) {\n\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t}\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],103:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n/** @author Jeff Escalante */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function fold(Promise) {\n\n\t\tPromise.prototype.fold = function(f, z) {\n\t\t\tvar promise = this._beget();\n\n\t\t\tthis._handler.fold(function(z, x, to) {\n\t\t\t\tPromise._handler(z).fold(function(x, z, to) {\n\t\t\t\t\tto.resolve(f.call(this, z, x));\n\t\t\t\t}, x, this, to);\n\t\t\t}, z, promise._handler.receiver, promise._handler);\n\n\t\t\treturn promise;\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],104:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar inspect = require('../state').inspect;\n\n\treturn function inspection(Promise) {\n\n\t\tPromise.prototype.inspect = function() {\n\t\t\treturn inspect(Promise._handler(this));\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n},{\"../state\":113}],105:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function generate(Promise) {\n\n\t\tvar resolve = Promise.resolve;\n\n\t\tPromise.iterate = iterate;\n\t\tPromise.unfold = unfold;\n\n\t\treturn Promise;\n\n\t\t/**\n\t\t * @deprecated Use github.com/cujojs/most streams and most.iterate\n\t\t * Generate a (potentially infinite) stream of promised values:\n\t\t * x, f(x), f(f(x)), etc. until condition(x) returns true\n\t\t * @param {function} f function to generate a new x from the previous x\n\t\t * @param {function} condition function that, given the current x, returns\n\t\t *  truthy when the iterate should stop\n\t\t * @param {function} handler function to handle the value produced by f\n\t\t * @param {*|Promise} x starting value, may be a promise\n\t\t * @return {Promise} the result of the last call to f before\n\t\t *  condition returns true\n\t\t */\n\t\tfunction iterate(f, condition, handler, x) {\n\t\t\treturn unfold(function(x) {\n\t\t\t\treturn [x, f(x)];\n\t\t\t}, condition, handler, x);\n\t\t}\n\n\t\t/**\n\t\t * @deprecated Use github.com/cujojs/most streams and most.unfold\n\t\t * Generate a (potentially infinite) stream of promised values\n\t\t * by applying handler(generator(seed)) iteratively until\n\t\t * condition(seed) returns true.\n\t\t * @param {function} unspool function that generates a [value, newSeed]\n\t\t *  given a seed.\n\t\t * @param {function} condition function that, given the current seed, returns\n\t\t *  truthy when the unfold should stop\n\t\t * @param {function} handler function to handle the value produced by unspool\n\t\t * @param x {*|Promise} starting value, may be a promise\n\t\t * @return {Promise} the result of the last value produced by unspool before\n\t\t *  condition returns true\n\t\t */\n\t\tfunction unfold(unspool, condition, handler, x) {\n\t\t\treturn resolve(x).then(function(seed) {\n\t\t\t\treturn resolve(condition(seed)).then(function(done) {\n\t\t\t\t\treturn done ? seed : resolve(unspool(seed)).spread(next);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tfunction next(item, newSeed) {\n\t\t\t\treturn resolve(handler(item)).then(function() {\n\t\t\t\t\treturn unfold(unspool, condition, handler, newSeed);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],106:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function progress(Promise) {\n\n\t\t/**\n\t\t * @deprecated\n\t\t * Register a progress handler for this promise\n\t\t * @param {function} onProgress\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.progress = function(onProgress) {\n\t\t\treturn this.then(void 0, void 0, onProgress);\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],107:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar env = require('../env');\n\tvar TimeoutError = require('../TimeoutError');\n\n\tfunction setTimeout(f, ms, x, y) {\n\t\treturn env.setTimer(function() {\n\t\t\tf(x, y, ms);\n\t\t}, ms);\n\t}\n\n\treturn function timed(Promise) {\n\t\t/**\n\t\t * Return a new promise whose fulfillment value is revealed only\n\t\t * after ms milliseconds\n\t\t * @param {number} ms milliseconds\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.delay = function(ms) {\n\t\t\tvar p = this._beget();\n\t\t\tthis._handler.fold(handleDelay, ms, void 0, p._handler);\n\t\t\treturn p;\n\t\t};\n\n\t\tfunction handleDelay(ms, x, h) {\n\t\t\tsetTimeout(resolveDelay, ms, x, h);\n\t\t}\n\n\t\tfunction resolveDelay(x, h) {\n\t\t\th.resolve(x);\n\t\t}\n\n\t\t/**\n\t\t * Return a new promise that rejects after ms milliseconds unless\n\t\t * this promise fulfills earlier, in which case the returned promise\n\t\t * fulfills with the same value.\n\t\t * @param {number} ms milliseconds\n\t\t * @param {Error|*=} reason optional rejection reason to use, defaults\n\t\t *   to a TimeoutError if not provided\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.timeout = function(ms, reason) {\n\t\t\tvar p = this._beget();\n\t\t\tvar h = p._handler;\n\n\t\t\tvar t = setTimeout(onTimeout, ms, reason, p._handler);\n\n\t\t\tthis._handler.visit(h,\n\t\t\t\tfunction onFulfill(x) {\n\t\t\t\t\tenv.clearTimer(t);\n\t\t\t\t\tthis.resolve(x); // this = h\n\t\t\t\t},\n\t\t\t\tfunction onReject(x) {\n\t\t\t\t\tenv.clearTimer(t);\n\t\t\t\t\tthis.reject(x); // this = h\n\t\t\t\t},\n\t\t\t\th.notify);\n\n\t\t\treturn p;\n\t\t};\n\n\t\tfunction onTimeout(reason, h, ms) {\n\t\t\tvar e = typeof reason === 'undefined'\n\t\t\t\t? new TimeoutError('timed out after ' + ms + 'ms')\n\t\t\t\t: reason;\n\t\t\th.reject(e);\n\t\t}\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n},{\"../TimeoutError\":99,\"../env\":110}],108:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar setTimer = require('../env').setTimer;\n\tvar format = require('../format');\n\n\treturn function unhandledRejection(Promise) {\n\n\t\tvar logError = noop;\n\t\tvar logInfo = noop;\n\t\tvar localConsole;\n\n\t\tif(typeof console !== 'undefined') {\n\t\t\t// Alias console to prevent things like uglify's drop_console option from\n\t\t\t// removing console.log/error. Unhandled rejections fall into the same\n\t\t\t// category as uncaught exceptions, and build tools shouldn't silence them.\n\t\t\tlocalConsole = console;\n\t\t\tlogError = typeof localConsole.error !== 'undefined'\n\t\t\t\t? function (e) { localConsole.error(e); }\n\t\t\t\t: function (e) { localConsole.log(e); };\n\n\t\t\tlogInfo = typeof localConsole.info !== 'undefined'\n\t\t\t\t? function (e) { localConsole.info(e); }\n\t\t\t\t: function (e) { localConsole.log(e); };\n\t\t}\n\n\t\tPromise.onPotentiallyUnhandledRejection = function(rejection) {\n\t\t\tenqueue(report, rejection);\n\t\t};\n\n\t\tPromise.onPotentiallyUnhandledRejectionHandled = function(rejection) {\n\t\t\tenqueue(unreport, rejection);\n\t\t};\n\n\t\tPromise.onFatalRejection = function(rejection) {\n\t\t\tenqueue(throwit, rejection.value);\n\t\t};\n\n\t\tvar tasks = [];\n\t\tvar reported = [];\n\t\tvar running = null;\n\n\t\tfunction report(r) {\n\t\t\tif(!r.handled) {\n\t\t\t\treported.push(r);\n\t\t\t\tlogError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));\n\t\t\t}\n\t\t}\n\n\t\tfunction unreport(r) {\n\t\t\tvar i = reported.indexOf(r);\n\t\t\tif(i >= 0) {\n\t\t\t\treported.splice(i, 1);\n\t\t\t\tlogInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));\n\t\t\t}\n\t\t}\n\n\t\tfunction enqueue(f, x) {\n\t\t\ttasks.push(f, x);\n\t\t\tif(running === null) {\n\t\t\t\trunning = setTimer(flush, 0);\n\t\t\t}\n\t\t}\n\n\t\tfunction flush() {\n\t\t\trunning = null;\n\t\t\twhile(tasks.length > 0) {\n\t\t\t\ttasks.shift()(tasks.shift());\n\t\t\t}\n\t\t}\n\n\t\treturn Promise;\n\t};\n\n\tfunction throwit(e) {\n\t\tthrow e;\n\t}\n\n\tfunction noop() {}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n},{\"../env\":110,\"../format\":111}],109:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function addWith(Promise) {\n\t\t/**\n\t\t * Returns a promise whose handlers will be called with `this` set to\n\t\t * the supplied receiver.  Subsequent promises derived from the\n\t\t * returned promise will also have their handlers called with receiver\n\t\t * as `this`. Calling `with` with undefined or no arguments will return\n\t\t * a promise whose handlers will again be called in the usual Promises/A+\n\t\t * way (no `this`) thus safely undoing any previous `with` in the\n\t\t * promise chain.\n\t\t *\n\t\t * WARNING: Promises returned from `with`/`withThis` are NOT Promises/A+\n\t\t * compliant, specifically violating 2.2.5 (http://promisesaplus.com/#point-41)\n\t\t *\n\t\t * @param {object} receiver `this` value for all handlers attached to\n\t\t *  the returned promise.\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype['with'] = Promise.prototype.withThis = function(receiver) {\n\t\t\tvar p = this._beget();\n\t\t\tvar child = p._handler;\n\t\t\tchild.receiver = receiver;\n\t\t\tthis._handler.chain(child, receiver);\n\t\t\treturn p;\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n},{}],110:[function(require,module,exports){\n(function (process){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/\n(function(define) { 'use strict';\ndefine(function(require) {\n\t/*jshint maxcomplexity:6*/\n\n\t// Sniff \"best\" async scheduling option\n\t// Prefer process.nextTick or MutationObserver, then check for\n\t// setTimeout, and finally vertx, since its the only env that doesn't\n\t// have setTimeout\n\n\tvar MutationObs;\n\tvar capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;\n\n\t// Default env\n\tvar setTimer = function(f, ms) { return setTimeout(f, ms); };\n\tvar clearTimer = function(t) { return clearTimeout(t); };\n\tvar asap = function (f) { return capturedSetTimeout(f, 0); };\n\n\t// Detect specific env\n\tif (isNode()) { // Node\n\t\tasap = function (f) { return process.nextTick(f); };\n\n\t} else if (MutationObs = hasMutationObserver()) { // Modern browser\n\t\tasap = initMutationObserver(MutationObs);\n\n\t} else if (!capturedSetTimeout) { // vert.x\n\t\tvar vertxRequire = require;\n\t\tvar vertx = vertxRequire('vertx');\n\t\tsetTimer = function (f, ms) { return vertx.setTimer(ms, f); };\n\t\tclearTimer = vertx.cancelTimer;\n\t\tasap = vertx.runOnLoop || vertx.runOnContext;\n\t}\n\n\treturn {\n\t\tsetTimer: setTimer,\n\t\tclearTimer: clearTimer,\n\t\tasap: asap\n\t};\n\n\tfunction isNode () {\n\t\treturn typeof process !== 'undefined' &&\n\t\t\tObject.prototype.toString.call(process) === '[object process]';\n\t}\n\n\tfunction hasMutationObserver () {\n\t\treturn (typeof MutationObserver === 'function' && MutationObserver) ||\n\t\t\t(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver);\n\t}\n\n\tfunction initMutationObserver(MutationObserver) {\n\t\tvar scheduled;\n\t\tvar node = document.createTextNode('');\n\t\tvar o = new MutationObserver(run);\n\t\to.observe(node, { characterData: true });\n\n\t\tfunction run() {\n\t\t\tvar f = scheduled;\n\t\t\tscheduled = void 0;\n\t\t\tf();\n\t\t}\n\n\t\tvar i = 0;\n\t\treturn function (f) {\n\t\t\tscheduled = f;\n\t\t\tnode.data = (i ^= 1);\n\t\t};\n\t}\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n}).call(this,require('_process'))\n\n},{\"_process\":1}],111:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn {\n\t\tformatError: formatError,\n\t\tformatObject: formatObject,\n\t\ttryStringify: tryStringify\n\t};\n\n\t/**\n\t * Format an error into a string.  If e is an Error and has a stack property,\n\t * it's returned.  Otherwise, e is formatted using formatObject, with a\n\t * warning added about e not being a proper Error.\n\t * @param {*} e\n\t * @returns {String} formatted string, suitable for output to developers\n\t */\n\tfunction formatError(e) {\n\t\tvar s = typeof e === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);\n\t\treturn e instanceof Error ? s : s + ' (WARNING: non-Error used)';\n\t}\n\n\t/**\n\t * Format an object, detecting \"plain\" objects and running them through\n\t * JSON.stringify if possible.\n\t * @param {Object} o\n\t * @returns {string}\n\t */\n\tfunction formatObject(o) {\n\t\tvar s = String(o);\n\t\tif(s === '[object Object]' && typeof JSON !== 'undefined') {\n\t\t\ts = tryStringify(o, s);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t * Try to return the result of JSON.stringify(x).  If that fails, return\n\t * defaultValue\n\t * @param {*} x\n\t * @param {*} defaultValue\n\t * @returns {String|*} JSON.stringify(x) or defaultValue\n\t */\n\tfunction tryStringify(x, defaultValue) {\n\t\ttry {\n\t\t\treturn JSON.stringify(x);\n\t\t} catch(e) {\n\t\t\treturn defaultValue;\n\t\t}\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],112:[function(require,module,exports){\n(function (process){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function makePromise(environment) {\n\n\t\tvar tasks = environment.scheduler;\n\t\tvar emitRejection = initEmitRejection();\n\n\t\tvar objectCreate = Object.create ||\n\t\t\tfunction(proto) {\n\t\t\t\tfunction Child() {}\n\t\t\t\tChild.prototype = proto;\n\t\t\t\treturn new Child();\n\t\t\t};\n\n\t\t/**\n\t\t * Create a promise whose fate is determined by resolver\n\t\t * @constructor\n\t\t * @returns {Promise} promise\n\t\t * @name Promise\n\t\t */\n\t\tfunction Promise(resolver, handler) {\n\t\t\tthis._handler = resolver === Handler ? handler : init(resolver);\n\t\t}\n\n\t\t/**\n\t\t * Run the supplied resolver\n\t\t * @param resolver\n\t\t * @returns {Pending}\n\t\t */\n\t\tfunction init(resolver) {\n\t\t\tvar handler = new Pending();\n\n\t\t\ttry {\n\t\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t\t} catch (e) {\n\t\t\t\tpromiseReject(e);\n\t\t\t}\n\n\t\t\treturn handler;\n\n\t\t\t/**\n\t\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t\t * @param {*} x resolution value\n\t\t\t */\n\t\t\tfunction promiseResolve (x) {\n\t\t\t\thandler.resolve(x);\n\t\t\t}\n\t\t\t/**\n\t\t\t * Reject this promise with reason, which will be used verbatim\n\t\t\t * @param {Error|*} reason rejection reason, strongly suggested\n\t\t\t *   to be an Error type\n\t\t\t */\n\t\t\tfunction promiseReject (reason) {\n\t\t\t\thandler.reject(reason);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @deprecated\n\t\t\t * Issue a progress event, notifying all progress listeners\n\t\t\t * @param {*} x progress event payload to pass to all listeners\n\t\t\t */\n\t\t\tfunction promiseNotify (x) {\n\t\t\t\thandler.notify(x);\n\t\t\t}\n\t\t}\n\n\t\t// Creation\n\n\t\tPromise.resolve = resolve;\n\t\tPromise.reject = reject;\n\t\tPromise.never = never;\n\n\t\tPromise._defer = defer;\n\t\tPromise._handler = getHandler;\n\n\t\t/**\n\t\t * Returns a trusted promise. If x is already a trusted promise, it is\n\t\t * returned, otherwise returns a new trusted Promise which follows x.\n\t\t * @param  {*} x\n\t\t * @return {Promise} promise\n\t\t */\n\t\tfunction resolve(x) {\n\t\t\treturn isPromise(x) ? x\n\t\t\t\t: new Promise(Handler, new Async(getHandler(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a reject promise with x as its reason (x is used verbatim)\n\t\t * @param {*} x\n\t\t * @returns {Promise} rejected promise\n\t\t */\n\t\tfunction reject(x) {\n\t\t\treturn new Promise(Handler, new Async(new Rejected(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that remains pending forever\n\t\t * @returns {Promise} forever-pending promise.\n\t\t */\n\t\tfunction never() {\n\t\t\treturn foreverPendingPromise; // Should be frozen\n\t\t}\n\n\t\t/**\n\t\t * Creates an internal {promise, resolver} pair\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction defer() {\n\t\t\treturn new Promise(Handler, new Pending());\n\t\t}\n\n\t\t// Transformation and flow control\n\n\t\t/**\n\t\t * Transform this promise's fulfillment value, returning a new Promise\n\t\t * for the transformed result.  If the promise cannot be fulfilled, onRejected\n\t\t * is called with the reason.  onProgress *may* be called with updates toward\n\t\t * this promise's fulfillment.\n\t\t * @param {function=} onFulfilled fulfillment handler\n\t\t * @param {function=} onRejected rejection handler\n\t\t * @param {function=} onProgress @deprecated progress handler\n\t\t * @return {Promise} new promise\n\t\t */\n\t\tPromise.prototype.then = function(onFulfilled, onRejected, onProgress) {\n\t\t\tvar parent = this._handler;\n\t\t\tvar state = parent.join().state();\n\n\t\t\tif ((typeof onFulfilled !== 'function' && state > 0) ||\n\t\t\t\t(typeof onRejected !== 'function' && state < 0)) {\n\t\t\t\t// Short circuit: value will not change, simply share handler\n\t\t\t\treturn new this.constructor(Handler, parent);\n\t\t\t}\n\n\t\t\tvar p = this._beget();\n\t\t\tvar child = p._handler;\n\n\t\t\tparent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);\n\n\t\t\treturn p;\n\t\t};\n\n\t\t/**\n\t\t * If this promise cannot be fulfilled due to an error, call onRejected to\n\t\t * handle the error. Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\tPromise.prototype['catch'] = function(onRejected) {\n\t\t\treturn this.then(void 0, onRejected);\n\t\t};\n\n\t\t/**\n\t\t * Creates a new, pending promise of the same type as this promise\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype._beget = function() {\n\t\t\treturn begetFrom(this._handler, this.constructor);\n\t\t};\n\n\t\tfunction begetFrom(parent, Promise) {\n\t\t\tvar child = new Pending(parent.receiver, parent.join().context);\n\t\t\treturn new Promise(Handler, child);\n\t\t}\n\n\t\t// Array combinators\n\n\t\tPromise.all = all;\n\t\tPromise.race = race;\n\t\tPromise._traverse = traverse;\n\n\t\t/**\n\t\t * Return a promise that will fulfill when all promises in the\n\t\t * input array have fulfilled, or will reject when one of the\n\t\t * promises rejects.\n\t\t * @param {array} promises array of promises\n\t\t * @returns {Promise} promise for array of fulfillment values\n\t\t */\n\t\tfunction all(promises) {\n\t\t\treturn traverseWith(snd, null, promises);\n\t\t}\n\n\t\t/**\n\t\t * Array<Promise<X>> -> Promise<Array<f(X)>>\n\t\t * @private\n\t\t * @param {function} f function to apply to each promise's value\n\t\t * @param {Array} promises array of promises\n\t\t * @returns {Promise} promise for transformed values\n\t\t */\n\t\tfunction traverse(f, promises) {\n\t\t\treturn traverseWith(tryCatch2, f, promises);\n\t\t}\n\n\t\tfunction traverseWith(tryMap, f, promises) {\n\t\t\tvar handler = typeof f === 'function' ? mapAt : settleAt;\n\n\t\t\tvar resolver = new Pending();\n\t\t\tvar pending = promises.length >>> 0;\n\t\t\tvar results = new Array(pending);\n\n\t\t\tfor (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {\n\t\t\t\tx = promises[i];\n\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttraverseAt(promises, handler, i, x, resolver);\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t}\n\n\t\t\treturn new Promise(Handler, resolver);\n\n\t\t\tfunction mapAt(i, x, resolver) {\n\t\t\t\tif(!resolver.resolved) {\n\t\t\t\t\ttraverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction settleAt(i, x, resolver) {\n\t\t\t\tresults[i] = x;\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction traverseAt(promises, handler, i, x, resolver) {\n\t\t\tif (maybeThenable(x)) {\n\t\t\t\tvar h = getHandlerMaybeThenable(x);\n\t\t\t\tvar s = h.state();\n\n\t\t\t\tif (s === 0) {\n\t\t\t\t\th.fold(handler, i, void 0, resolver);\n\t\t\t\t} else if (s > 0) {\n\t\t\t\t\thandler(i, h.value, resolver);\n\t\t\t\t} else {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tvisitRemaining(promises, i+1, h);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thandler(i, x, resolver);\n\t\t\t}\n\t\t}\n\n\t\tPromise._visitRemaining = visitRemaining;\n\t\tfunction visitRemaining(promises, start, handler) {\n\t\t\tfor(var i=start; i<promises.length; ++i) {\n\t\t\t\tmarkAsHandled(getHandler(promises[i]), handler);\n\t\t\t}\n\t\t}\n\n\t\tfunction markAsHandled(h, handler) {\n\t\t\tif(h === handler) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar s = h.state();\n\t\t\tif(s === 0) {\n\t\t\t\th.visit(h, void 0, h._unreport);\n\t\t\t} else if(s < 0) {\n\t\t\t\th._unreport();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fulfill-reject competitive race. Return a promise that will settle\n\t\t * to the same state as the earliest input promise to settle.\n\t\t *\n\t\t * WARNING: The ES6 Promise spec requires that race()ing an empty array\n\t\t * must return a promise that is pending forever.  This implementation\n\t\t * returns a singleton forever-pending promise, the same singleton that is\n\t\t * returned by Promise.never(), thus can be checked with ===\n\t\t *\n\t\t * @param {array} promises array of promises to race\n\t\t * @returns {Promise} if input is non-empty, a promise that will settle\n\t\t * to the same outcome as the earliest input promise to settle. if empty\n\t\t * is empty, returns a promise that will never settle.\n\t\t */\n\t\tfunction race(promises) {\n\t\t\tif(typeof promises !== 'object' || promises === null) {\n\t\t\t\treturn reject(new TypeError('non-iterable passed to race()'));\n\t\t\t}\n\n\t\t\t// Sigh, race([]) is untestable unless we return *something*\n\t\t\t// that is recognizable without calling .then() on it.\n\t\t\treturn promises.length === 0 ? never()\n\t\t\t\t : promises.length === 1 ? resolve(promises[0])\n\t\t\t\t : runRace(promises);\n\t\t}\n\n\t\tfunction runRace(promises) {\n\t\t\tvar resolver = new Pending();\n\t\t\tvar i, x, h;\n\t\t\tfor(i=0; i<promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\th = getHandler(x);\n\t\t\t\tif(h.state() !== 0) {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tvisitRemaining(promises, i+1, h);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\th.visit(resolver, resolver.resolve, resolver.reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new Promise(Handler, resolver);\n\t\t}\n\n\t\t// Promise internals\n\t\t// Below this, everything is @private\n\n\t\t/**\n\t\t * Get an appropriate handler for x, without checking for cycles\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandler(x) {\n\t\t\tif(isPromise(x)) {\n\t\t\t\treturn x._handler.join();\n\t\t\t}\n\t\t\treturn maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for thenable x.\n\t\t * NOTE: You must only call this if maybeThenable(x) == true\n\t\t * @param {object|function|Promise} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerMaybeThenable(x) {\n\t\t\treturn isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for potentially untrusted thenable x\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerUntrusted(x) {\n\t\t\ttry {\n\t\t\t\tvar untrustedThen = x.then;\n\t\t\t\treturn typeof untrustedThen === 'function'\n\t\t\t\t\t? new Thenable(untrustedThen, x)\n\t\t\t\t\t: new Fulfilled(x);\n\t\t\t} catch(e) {\n\t\t\t\treturn new Rejected(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Handler for a promise that is pending forever\n\t\t * @constructor\n\t\t */\n\t\tfunction Handler() {}\n\n\t\tHandler.prototype.when\n\t\t\t= Handler.prototype.become\n\t\t\t= Handler.prototype.notify // deprecated\n\t\t\t= Handler.prototype.fail\n\t\t\t= Handler.prototype._unreport\n\t\t\t= Handler.prototype._report\n\t\t\t= noop;\n\n\t\tHandler.prototype._state = 0;\n\n\t\tHandler.prototype.state = function() {\n\t\t\treturn this._state;\n\t\t};\n\n\t\t/**\n\t\t * Recursively collapse handler chain to find the handler\n\t\t * nearest to the fully resolved value.\n\t\t * @returns {object} handler nearest the fully resolved value\n\t\t */\n\t\tHandler.prototype.join = function() {\n\t\t\tvar h = this;\n\t\t\twhile(h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t}\n\t\t\treturn h;\n\t\t};\n\n\t\tHandler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {\n\t\t\tthis.when({\n\t\t\t\tresolver: to,\n\t\t\t\treceiver: receiver,\n\t\t\t\tfulfilled: fulfilled,\n\t\t\t\trejected: rejected,\n\t\t\t\tprogress: progress\n\t\t\t});\n\t\t};\n\n\t\tHandler.prototype.visit = function(receiver, fulfilled, rejected, progress) {\n\t\t\tthis.chain(failIfRejected, receiver, fulfilled, rejected, progress);\n\t\t};\n\n\t\tHandler.prototype.fold = function(f, z, c, to) {\n\t\t\tthis.when(new Fold(f, z, c, to));\n\t\t};\n\n\t\t/**\n\t\t * Handler that invokes fail() on any handler it becomes\n\t\t * @constructor\n\t\t */\n\t\tfunction FailIfRejected() {}\n\n\t\tinherit(Handler, FailIfRejected);\n\n\t\tFailIfRejected.prototype.become = function(h) {\n\t\t\th.fail();\n\t\t};\n\n\t\tvar failIfRejected = new FailIfRejected();\n\n\t\t/**\n\t\t * Handler that manages a queue of consumers waiting on a pending promise\n\t\t * @constructor\n\t\t */\n\t\tfunction Pending(receiver, inheritedContext) {\n\t\t\tPromise.createContext(this, inheritedContext);\n\n\t\t\tthis.consumers = void 0;\n\t\t\tthis.receiver = receiver;\n\t\t\tthis.handler = void 0;\n\t\t\tthis.resolved = false;\n\t\t}\n\n\t\tinherit(Handler, Pending);\n\n\t\tPending.prototype._state = 0;\n\n\t\tPending.prototype.resolve = function(x) {\n\t\t\tthis.become(getHandler(x));\n\t\t};\n\n\t\tPending.prototype.reject = function(x) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.become(new Rejected(x));\n\t\t};\n\n\t\tPending.prototype.join = function() {\n\t\t\tif (!this.resolved) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar h = this;\n\n\t\t\twhile (h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t\tif (h === this) {\n\t\t\t\t\treturn this.handler = cycle();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn h;\n\t\t};\n\n\t\tPending.prototype.run = function() {\n\t\t\tvar q = this.consumers;\n\t\t\tvar handler = this.handler;\n\t\t\tthis.handler = this.handler.join();\n\t\t\tthis.consumers = void 0;\n\n\t\t\tfor (var i = 0; i < q.length; ++i) {\n\t\t\t\thandler.when(q[i]);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.become = function(handler) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.resolved = true;\n\t\t\tthis.handler = handler;\n\t\t\tif(this.consumers !== void 0) {\n\t\t\t\ttasks.enqueue(this);\n\t\t\t}\n\n\t\t\tif(this.context !== void 0) {\n\t\t\t\thandler._report(this.context);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.when = function(continuation) {\n\t\t\tif(this.resolved) {\n\t\t\t\ttasks.enqueue(new ContinuationTask(continuation, this.handler));\n\t\t\t} else {\n\t\t\t\tif(this.consumers === void 0) {\n\t\t\t\t\tthis.consumers = [continuation];\n\t\t\t\t} else {\n\t\t\t\t\tthis.consumers.push(continuation);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tPending.prototype.notify = function(x) {\n\t\t\tif(!this.resolved) {\n\t\t\t\ttasks.enqueue(new ProgressTask(x, this));\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.fail = function(context) {\n\t\t\tvar c = typeof context === 'undefined' ? this.context : context;\n\t\t\tthis.resolved && this.handler.join().fail(c);\n\t\t};\n\n\t\tPending.prototype._report = function(context) {\n\t\t\tthis.resolved && this.handler.join()._report(context);\n\t\t};\n\n\t\tPending.prototype._unreport = function() {\n\t\t\tthis.resolved && this.handler.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Wrap another handler and force it into a future stack\n\t\t * @param {object} handler\n\t\t * @constructor\n\t\t */\n\t\tfunction Async(handler) {\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tinherit(Handler, Async);\n\n\t\tAsync.prototype.when = function(continuation) {\n\t\t\ttasks.enqueue(new ContinuationTask(continuation, this));\n\t\t};\n\n\t\tAsync.prototype._report = function(context) {\n\t\t\tthis.join()._report(context);\n\t\t};\n\n\t\tAsync.prototype._unreport = function() {\n\t\t\tthis.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Handler that wraps an untrusted thenable and assimilates it in a future stack\n\t\t * @param {function} then\n\t\t * @param {{then: function}} thenable\n\t\t * @constructor\n\t\t */\n\t\tfunction Thenable(then, thenable) {\n\t\t\tPending.call(this);\n\t\t\ttasks.enqueue(new AssimilateTask(then, thenable, this));\n\t\t}\n\n\t\tinherit(Pending, Thenable);\n\n\t\t/**\n\t\t * Handler for a fulfilled promise\n\t\t * @param {*} x fulfillment value\n\t\t * @constructor\n\t\t */\n\t\tfunction Fulfilled(x) {\n\t\t\tPromise.createContext(this);\n\t\t\tthis.value = x;\n\t\t}\n\n\t\tinherit(Handler, Fulfilled);\n\n\t\tFulfilled.prototype._state = 1;\n\n\t\tFulfilled.prototype.fold = function(f, z, c, to) {\n\t\t\trunContinuation3(f, z, this, c, to);\n\t\t};\n\n\t\tFulfilled.prototype.when = function(cont) {\n\t\t\trunContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tvar errorId = 0;\n\n\t\t/**\n\t\t * Handler for a rejected promise\n\t\t * @param {*} x rejection reason\n\t\t * @constructor\n\t\t */\n\t\tfunction Rejected(x) {\n\t\t\tPromise.createContext(this);\n\n\t\t\tthis.id = ++errorId;\n\t\t\tthis.value = x;\n\t\t\tthis.handled = false;\n\t\t\tthis.reported = false;\n\n\t\t\tthis._report();\n\t\t}\n\n\t\tinherit(Handler, Rejected);\n\n\t\tRejected.prototype._state = -1;\n\n\t\tRejected.prototype.fold = function(f, z, c, to) {\n\t\t\tto.become(this);\n\t\t};\n\n\t\tRejected.prototype.when = function(cont) {\n\t\t\tif(typeof cont.rejected === 'function') {\n\t\t\t\tthis._unreport();\n\t\t\t}\n\t\t\trunContinuation1(cont.rejected, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tRejected.prototype._report = function(context) {\n\t\t\ttasks.afterQueue(new ReportTask(this, context));\n\t\t};\n\n\t\tRejected.prototype._unreport = function() {\n\t\t\tif(this.handled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.handled = true;\n\t\t\ttasks.afterQueue(new UnreportTask(this));\n\t\t};\n\n\t\tRejected.prototype.fail = function(context) {\n\t\t\tthis.reported = true;\n\t\t\temitRejection('unhandledRejection', this);\n\t\t\tPromise.onFatalRejection(this, context === void 0 ? this.context : context);\n\t\t};\n\n\t\tfunction ReportTask(rejection, context) {\n\t\t\tthis.rejection = rejection;\n\t\t\tthis.context = context;\n\t\t}\n\n\t\tReportTask.prototype.run = function() {\n\t\t\tif(!this.rejection.handled && !this.rejection.reported) {\n\t\t\t\tthis.rejection.reported = true;\n\t\t\t\temitRejection('unhandledRejection', this.rejection) ||\n\t\t\t\t\tPromise.onPotentiallyUnhandledRejection(this.rejection, this.context);\n\t\t\t}\n\t\t};\n\n\t\tfunction UnreportTask(rejection) {\n\t\t\tthis.rejection = rejection;\n\t\t}\n\n\t\tUnreportTask.prototype.run = function() {\n\t\t\tif(this.rejection.reported) {\n\t\t\t\temitRejection('rejectionHandled', this.rejection) ||\n\t\t\t\t\tPromise.onPotentiallyUnhandledRejectionHandled(this.rejection);\n\t\t\t}\n\t\t};\n\n\t\t// Unhandled rejection hooks\n\t\t// By default, everything is a noop\n\n\t\tPromise.createContext\n\t\t\t= Promise.enterContext\n\t\t\t= Promise.exitContext\n\t\t\t= Promise.onPotentiallyUnhandledRejection\n\t\t\t= Promise.onPotentiallyUnhandledRejectionHandled\n\t\t\t= Promise.onFatalRejection\n\t\t\t= noop;\n\n\t\t// Errors and singletons\n\n\t\tvar foreverPendingHandler = new Handler();\n\t\tvar foreverPendingPromise = new Promise(Handler, foreverPendingHandler);\n\n\t\tfunction cycle() {\n\t\t\treturn new Rejected(new TypeError('Promise cycle'));\n\t\t}\n\n\t\t// Task runners\n\n\t\t/**\n\t\t * Run a single consumer\n\t\t * @constructor\n\t\t */\n\t\tfunction ContinuationTask(continuation, handler) {\n\t\t\tthis.continuation = continuation;\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tContinuationTask.prototype.run = function() {\n\t\t\tthis.handler.join().when(this.continuation);\n\t\t};\n\n\t\t/**\n\t\t * Run a queue of progress handlers\n\t\t * @constructor\n\t\t */\n\t\tfunction ProgressTask(value, handler) {\n\t\t\tthis.handler = handler;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tProgressTask.prototype.run = function() {\n\t\t\tvar q = this.handler.consumers;\n\t\t\tif(q === void 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var c, i = 0; i < q.length; ++i) {\n\t\t\t\tc = q[i];\n\t\t\t\trunNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Assimilate a thenable, sending it's value to resolver\n\t\t * @param {function} then\n\t\t * @param {object|function} thenable\n\t\t * @param {object} resolver\n\t\t * @constructor\n\t\t */\n\t\tfunction AssimilateTask(then, thenable, resolver) {\n\t\t\tthis._then = then;\n\t\t\tthis.thenable = thenable;\n\t\t\tthis.resolver = resolver;\n\t\t}\n\n\t\tAssimilateTask.prototype.run = function() {\n\t\t\tvar h = this.resolver;\n\t\t\ttryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);\n\n\t\t\tfunction _resolve(x) { h.resolve(x); }\n\t\t\tfunction _reject(x)  { h.reject(x); }\n\t\t\tfunction _notify(x)  { h.notify(x); }\n\t\t};\n\n\t\tfunction tryAssimilate(then, thenable, resolve, reject, notify) {\n\t\t\ttry {\n\t\t\t\tthen.call(thenable, resolve, reject, notify);\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fold a handler value with z\n\t\t * @constructor\n\t\t */\n\t\tfunction Fold(f, z, c, to) {\n\t\t\tthis.f = f; this.z = z; this.c = c; this.to = to;\n\t\t\tthis.resolver = failIfRejected;\n\t\t\tthis.receiver = this;\n\t\t}\n\n\t\tFold.prototype.fulfilled = function(x) {\n\t\t\tthis.f.call(this.c, this.z, x, this.to);\n\t\t};\n\n\t\tFold.prototype.rejected = function(x) {\n\t\t\tthis.to.reject(x);\n\t\t};\n\n\t\tFold.prototype.progress = function(x) {\n\t\t\tthis.to.notify(x);\n\t\t};\n\n\t\t// Other helpers\n\n\t\t/**\n\t\t * @param {*} x\n\t\t * @returns {boolean} true iff x is a trusted Promise\n\t\t */\n\t\tfunction isPromise(x) {\n\t\t\treturn x instanceof Promise;\n\t\t}\n\n\t\t/**\n\t\t * Test just enough to rule out primitives, in order to take faster\n\t\t * paths in some code\n\t\t * @param {*} x\n\t\t * @returns {boolean} false iff x is guaranteed *not* to be a thenable\n\t\t */\n\t\tfunction maybeThenable(x) {\n\t\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t\t}\n\n\t\tfunction runContinuation1(f, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject(f, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction runContinuation3(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject3(f, x, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tfunction runNotify(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.notify(x);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReturn(f, x, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction tryCatch2(f, a, b) {\n\t\t\ttry {\n\t\t\t\treturn f(a, b);\n\t\t\t} catch(e) {\n\t\t\t\treturn reject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Return f.call(thisArg, x), or if it throws return a rejected promise for\n\t\t * the thrown exception\n\t\t */\n\t\tfunction tryCatchReject(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.become(getHandler(f.call(thisArg, x)));\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Same as above, but includes the extra argument parameter.\n\t\t */\n\t\tfunction tryCatchReject3(f, x, y, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tf.call(thisArg, x, y, next);\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @deprecated\n\t\t * Return f.call(thisArg, x), or if it throws, *return* the exception\n\t\t */\n\t\tfunction tryCatchReturn(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.notify(f.call(thisArg, x));\n\t\t\t} catch(e) {\n\t\t\t\tnext.notify(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction inherit(Parent, Child) {\n\t\t\tChild.prototype = objectCreate(Parent.prototype);\n\t\t\tChild.prototype.constructor = Child;\n\t\t}\n\n\t\tfunction snd(x, y) {\n\t\t\treturn y;\n\t\t}\n\n\t\tfunction noop() {}\n\n\t\tfunction initEmitRejection() {\n\t\t\t/*global process, self, CustomEvent*/\n\t\t\tif(typeof process !== 'undefined' && process !== null\n\t\t\t\t&& typeof process.emit === 'function') {\n\t\t\t\t// Returning falsy here means to call the default\n\t\t\t\t// onPotentiallyUnhandledRejection API.  This is safe even in\n\t\t\t\t// browserify since process.emit always returns falsy in browserify:\n\t\t\t\t// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46\n\t\t\t\treturn function(type, rejection) {\n\t\t\t\t\treturn type === 'unhandledRejection'\n\t\t\t\t\t\t? process.emit(type, rejection.value, rejection)\n\t\t\t\t\t\t: process.emit(type, rejection);\n\t\t\t\t};\n\t\t\t} else if(typeof self !== 'undefined' && typeof CustomEvent === 'function') {\n\t\t\t\treturn (function(noop, self, CustomEvent) {\n\t\t\t\t\tvar hasCustomEvent = false;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar ev = new CustomEvent('unhandledRejection');\n\t\t\t\t\t\thasCustomEvent = ev instanceof CustomEvent;\n\t\t\t\t\t} catch (e) {}\n\n\t\t\t\t\treturn !hasCustomEvent ? noop : function(type, rejection) {\n\t\t\t\t\t\tvar ev = new CustomEvent(type, {\n\t\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\t\treason: rejection.value,\n\t\t\t\t\t\t\t\tkey: rejection\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbubbles: false,\n\t\t\t\t\t\t\tcancelable: true\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn !self.dispatchEvent(ev);\n\t\t\t\t\t};\n\t\t\t\t}(noop, self, CustomEvent));\n\t\t\t}\n\n\t\t\treturn noop;\n\t\t}\n\n\t\treturn Promise;\n\t};\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n}).call(this,require('_process'))\n\n},{\"_process\":1}],113:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn {\n\t\tpending: toPendingState,\n\t\tfulfilled: toFulfilledState,\n\t\trejected: toRejectedState,\n\t\tinspect: inspect\n\t};\n\n\tfunction toPendingState() {\n\t\treturn { state: 'pending' };\n\t}\n\n\tfunction toRejectedState(e) {\n\t\treturn { state: 'rejected', reason: e };\n\t}\n\n\tfunction toFulfilledState(x) {\n\t\treturn { state: 'fulfilled', value: x };\n\t}\n\n\tfunction inspect(handler) {\n\t\tvar state = handler.state();\n\t\treturn state === 0 ? toPendingState()\n\t\t\t : state > 0   ? toFulfilledState(handler.value)\n\t\t\t               : toRejectedState(handler.value);\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],114:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/**\n * Promises/A+ and when() implementation\n * when is part of the cujoJS family of libraries (http://cujojs.com/)\n * @author Brian Cavalier\n * @author John Hann\n */\n(function(define) { 'use strict';\ndefine(function (require) {\n\n\tvar timed = require('./lib/decorators/timed');\n\tvar array = require('./lib/decorators/array');\n\tvar flow = require('./lib/decorators/flow');\n\tvar fold = require('./lib/decorators/fold');\n\tvar inspect = require('./lib/decorators/inspect');\n\tvar generate = require('./lib/decorators/iterate');\n\tvar progress = require('./lib/decorators/progress');\n\tvar withThis = require('./lib/decorators/with');\n\tvar unhandledRejection = require('./lib/decorators/unhandledRejection');\n\tvar TimeoutError = require('./lib/TimeoutError');\n\n\tvar Promise = [array, flow, fold, generate, progress,\n\t\tinspect, withThis, timed, unhandledRejection]\n\t\t.reduce(function(Promise, feature) {\n\t\t\treturn feature(Promise);\n\t\t}, require('./lib/Promise'));\n\n\tvar apply = require('./lib/apply')(Promise);\n\n\t// Public API\n\n\twhen.promise     = promise;              // Create a pending promise\n\twhen.resolve     = Promise.resolve;      // Create a resolved promise\n\twhen.reject      = Promise.reject;       // Create a rejected promise\n\n\twhen.lift        = lift;                 // lift a function to return promises\n\twhen['try']      = attempt;              // call a function and return a promise\n\twhen.attempt     = attempt;              // alias for when.try\n\n\twhen.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises\n\twhen.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises\n\n\twhen.join        = join;                 // Join 2 or more promises\n\n\twhen.all         = all;                  // Resolve a list of promises\n\twhen.settle      = settle;               // Settle a list of promises\n\n\twhen.any         = lift(Promise.any);    // One-winner race\n\twhen.some        = lift(Promise.some);   // Multi-winner race\n\twhen.race        = lift(Promise.race);   // First-to-settle race\n\n\twhen.map         = map;                  // Array.map() for promises\n\twhen.filter      = filter;               // Array.filter() for promises\n\twhen.reduce      = lift(Promise.reduce);       // Array.reduce() for promises\n\twhen.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises\n\n\twhen.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable\n\n\twhen.Promise     = Promise;              // Promise constructor\n\twhen.defer       = defer;                // Create a {promise, resolve, reject} tuple\n\n\t// Error types\n\n\twhen.TimeoutError = TimeoutError;\n\n\t/**\n\t * Get a trusted promise for x, or by transforming x with onFulfilled\n\t *\n\t * @param {*} x\n\t * @param {function?} onFulfilled callback to be called when x is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} onRejected callback to be called when x is\n\t *   rejected.\n\t * @param {function?} onProgress callback to be called when progress updates\n\t *   are issued for x. @deprecated\n\t * @returns {Promise} a new promise that will fulfill with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(x, onFulfilled, onRejected, onProgress) {\n\t\tvar p = Promise.resolve(x);\n\t\tif (arguments.length < 2) {\n\t\t\treturn p;\n\t\t}\n\n\t\treturn p.then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn new Promise(resolver);\n\t}\n\n\t/**\n\t * Lift the supplied function, creating a version of f that returns\n\t * promises, and accepts promises as arguments.\n\t * @param {function} f\n\t * @returns {Function} version of f that returns promises\n\t */\n\tfunction lift(f) {\n\t\treturn function() {\n\t\t\tfor(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {\n\t\t\t\ta[i] = arguments[i];\n\t\t\t}\n\t\t\treturn apply(f, this, a);\n\t\t};\n\t}\n\n\t/**\n\t * Call f in a future turn, with the supplied args, and return a promise\n\t * for the result.\n\t * @param {function} f\n\t * @returns {Promise}\n\t */\n\tfunction attempt(f /*, args... */) {\n\t\t/*jshint validthis:true */\n\t\tfor(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {\n\t\t\ta[i] = arguments[i+1];\n\t\t}\n\t\treturn apply(f, this, a);\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * @return {{promise: Promise, resolve: function, reject: function, notify: function}}\n\t */\n\tfunction defer() {\n\t\treturn new Deferred();\n\t}\n\n\tfunction Deferred() {\n\t\tvar p = Promise._defer();\n\n\t\tfunction resolve(x) { p._handler.resolve(x); }\n\t\tfunction reject(x) { p._handler.reject(x); }\n\t\tfunction notify(x) { p._handler.notify(x); }\n\n\t\tthis.promise = p;\n\t\tthis.resolve = resolve;\n\t\tthis.reject = reject;\n\t\tthis.notify = notify;\n\t\tthis.resolver = { resolve: resolve, reject: reject, notify: notify };\n\t}\n\n\t/**\n\t * Determines if x is promise-like, i.e. a thenable object\n\t * NOTE: Will return true for *any thenable object*, and isn't truly\n\t * safe, since it may attempt to access the `then` property of x (i.e.\n\t *  clever/malicious getters may do weird things)\n\t * @param {*} x anything\n\t * @returns {boolean} true if x is promise-like\n\t */\n\tfunction isPromiseLike(x) {\n\t\treturn x && typeof x.then === 'function';\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied arguments\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the arguments.\n\t * @param {...*} arguments may be a mix of promises and values\n\t * @returns {Promise}\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn Promise.all(arguments);\n\t}\n\n\t/**\n\t * Return a promise that will fulfill once all input promises have\n\t * fulfilled, or reject when any one input promise rejects.\n\t * @param {array|Promise} promises array (or promise for an array) of promises\n\t * @returns {Promise}\n\t */\n\tfunction all(promises) {\n\t\treturn when(promises, Promise.all);\n\t}\n\n\t/**\n\t * Return a promise that will always fulfill with an array containing\n\t * the outcome states of all input promises.  The returned promise\n\t * will only reject if `promises` itself is a rejected promise.\n\t * @param {array|Promise} promises array (or promise for an array) of promises\n\t * @returns {Promise} promise for array of settled state descriptors\n\t */\n\tfunction settle(promises) {\n\t\treturn when(promises, Promise.settle);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} promises array of anything, may contain promises and values\n\t * @param {function(x:*, index:Number):*} mapFunc map function which may\n\t *  return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(promises, mapFunc) {\n\t\treturn when(promises, function(promises) {\n\t\t\treturn Promise.map(promises, mapFunc);\n\t\t});\n\t}\n\n\t/**\n\t * Filter the provided array of promises using the provided predicate.  Input may\n\t * contain promises and values\n\t * @param {Array|Promise} promises array of promises and values\n\t * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n\t *  Must return truthy (or promise for truthy) for items to retain.\n\t * @returns {Promise} promise that will fulfill with an array containing all items\n\t *  for which predicate returned truthy.\n\t */\n\tfunction filter(promises, predicate) {\n\t\treturn when(promises, function(promises) {\n\t\t\treturn Promise.filter(promises, predicate);\n\t\t});\n\t}\n\n\treturn when;\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n},{\"./lib/Promise\":97,\"./lib/TimeoutError\":99,\"./lib/apply\":100,\"./lib/decorators/array\":101,\"./lib/decorators/flow\":102,\"./lib/decorators/fold\":103,\"./lib/decorators/inspect\":104,\"./lib/decorators/iterate\":105,\"./lib/decorators/progress\":106,\"./lib/decorators/timed\":107,\"./lib/decorators/unhandledRejection\":108,\"./lib/decorators/with\":109}],115:[function(require,module,exports){\n// Import requirements using browserify\n'use strict';\n\n// Insert vue-router and vue-resource into Vue\n\n// Import the actual routes, aliases, ...\n\nvar _routes = require('./routes');\n\n// Create our router object and set options on it\nwindow.Vue = require('vue');\nwindow.VueRouter = require('vue-router');var router = new VueRouter();\n\n// Inject the routes into the VueRouter object\n(0, _routes.configRouter)(router);\n\n// Configure the application\nwindow.config = require('./config');\nVue.config.debug = true;\n\n// Configure our HTTP client\nvar rest = require('rest');\nvar pathPrefix = require('rest/interceptor/pathPrefix');\nvar mime = require('rest/interceptor/mime');\nvar defaultRequest = require('rest/interceptor/defaultRequest');\nvar errorCode = require('rest/interceptor/errorCode');\nvar interceptor = require('rest/interceptor');\nvar jwtAuth = require('./interceptors/jwtAuth');\n\nwindow.client = rest.wrap(pathPrefix, { prefix: config.api.base_url }).wrap(mime).wrap(defaultRequest, config.api.defaultRequest).wrap(errorCode, { code: 400 }).wrap(jwtAuth);\n\n// Bootstrap the app\nVue.component('nav-component', require('./compiled/nav.vue'));\nVue.component('footer-component', require('./compiled/footer.vue'));\nvar App = Vue.extend(require('./compiled/app.vue'));\nrouter.start(App, '#app');\nwindow.router = router;\n\n},{\"./compiled/app.vue\":116,\"./compiled/footer.vue\":117,\"./compiled/nav.vue\":118,\"./config\":139,\"./interceptors/jwtAuth\":142,\"./routes\":143,\"rest\":3,\"rest/interceptor\":7,\"rest/interceptor/defaultRequest\":8,\"rest/interceptor/errorCode\":9,\"rest/interceptor/mime\":10,\"rest/interceptor/pathPrefix\":11,\"vue\":94,\"vue-router\":28}],116:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  ready: function ready() {\n\n    this.$on('userHasLoggedOut', function () {\n      this.destroyLogin();\n    });\n\n    this.$on('userHasLoggedIn', function (user) {\n      this.setLogin(user);\n    });\n\n    // The app has just been initialized, check if we can get the user data with an already existing token\n    var token = localStorage.getItem('jwt-token');\n    if (token !== null && token !== 'undefined') {\n      var that = this;\n      client({ path: '/users/me' }).then(function (response) {\n        // User has successfully logged in using the token from storage\n        that.setLogin(response.entity.user);\n        // broadcast an event telling our children that the data is ready and views can be rendered\n        that.$broadcast('data-loaded');\n      }, function (response) {\n        // Login with our token failed, do some cleanup and redirect if we're on an authenticated route\n        that.destroyLogin();\n      });\n    }\n  },\n\n  data: function data() {\n    return {\n      user: null,\n      token: null,\n      authenticated: false\n    };\n  },\n\n  methods: {\n\n    setLogin: function setLogin(user) {\n      // Save login info in our data and set header in case it's not set already\n      this.user = user;\n      this.authenticated = true;\n      this.token = localStorage.getItem('jwt-token');\n    },\n\n    destroyLogin: function destroyLogin(user) {\n      // Cleanup when token was invalid our user has logged out\n      this.user = null;\n      this.token = null;\n      this.authenticated = false;\n      localStorage.removeItem('jwt-token');\n      if (this.$route.auth) this.$route.router.go('/auth/login');\n    }\n  }\n\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<router-view></router-view>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/app.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],117:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  data: function data() {\n    return {\n      links: {\n        facebook: 'alternativet.party',\n        twitter: 'Alternativet_no',\n        github: 'partialternativet'\n      }\n    };\n  }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div style=\\\"margin-top: 125px;\\\">\\n\\t<!-- Push Footer -->\\n</div>\\n<footer class=\\\"footer\\\">\\n\\t<div class=\\\"container\\\" style=\\\"color: #777;\\\">\\n\\t\\t<!-- Company Information -->\\n\\t\\t<div class=\\\"pull-left\\\" style=\\\"padding-top: 28px;\\\">\\n\\t\\t\\tAlternativet\\n\\t\\t</div>\\n\\t\\t<!-- Social Icons -->\\n\\t\\t<div class=\\\"pull-right footer-social-icons\\\">\\n\\t\\t\\t<a href=\\\"http://facebook.com/{{ links.facebook }}\\\">\\n\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-facebook-square\\\"></i>\\n\\t\\t\\t</a>\\n\\t\\t\\t<a href=\\\"http://twitter.com/{{ links.twitter }}\\\">\\n\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-twitter-square\\\"></i>\\n\\t\\t\\t</a>\\n\\t\\t\\t<!--\\n\\t\\t\\t<a href=\\\"http://github.com/{{ links.github }}\\\">\\n\\t\\t\\t\\t<i class=\\\"fa fa-github-square\\\"></i>\\n\\t\\t\\t</a>\\n\\t\\t\\t-->\\n\\t\\t</div>\\n\\t\\t<div class=\\\"clearfix\\\"></div>\\n\\t</div>\\n</footer>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/footer.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],118:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  data: function data() {\n    return {\n      navTitle: 'Alternativet'\n    };\n  }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<!-- Navigation -->\\n<nav class=\\\"navbar navbar-default\\\">\\n\\t<div class=\\\"container\\\">\\n\\t\\t<div class=\\\"navbar-header\\\">\\n\\t\\t\\t<!-- Collapsed Hamburger -->\\n\\t\\t\\t<button type=\\\"button\\\" class=\\\"navbar-toggle collapsed\\\" data-toggle=\\\"collapse\\\" data-target=\\\"#bs-example-navbar-collapse-1\\\">\\n\\t\\t\\t\\t<span class=\\\"sr-only\\\">Skru navigasjon av/på</span>\\n\\t\\t\\t\\t<span class=\\\"icon-bar\\\"></span>\\n\\t\\t\\t\\t<span class=\\\"icon-bar\\\"></span>\\n\\t\\t\\t\\t<span class=\\\"icon-bar\\\"></span>\\n\\t\\t\\t</button>\\n\\t\\t\\t<!-- Branding Image -->\\n\\t\\t\\t<a class=\\\"navbar-brand\\\" v-link=\\\"{ path: '/' }\\\" style=\\\"padding-top: 19px;\\\">\\n\\t\\t\\t\\t<span class=\\\"sr-only\\\">{{ navTitle }}</span>\\n\\t\\t\\t</a>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"collapse navbar-collapse\\\" id=\\\"bs-example-navbar-collapse-1\\\">\\n\\t\\t\\t<ul class=\\\"nav navbar-nav\\\">\\n\\t\\t\\t\\t<!--<li><a v-link=\\\"{ path: '/home' }\\\">Hjem</a></li>-->\\n\\t\\t\\t\\t<!--<li><a v-link=\\\"{ path: '/dogs' }\\\" v-if=\\\"$root.authenticated\\\">Hunder</a></li>-->\\n\\t\\t\\t</ul>\\n\\t\\t\\t<!-- Right Side Of Navbar -->\\n\\t\\t\\t<ul class=\\\"nav navbar-nav navbar-right\\\">\\n\\t\\t\\t\\t<li><a v-link=\\\"{ path: '/manifest' }\\\">Manifest</a></li>\\n\\t\\t\\t\\t<li><a v-link=\\\"{ path: '/om' }\\\">Om oss</a></li>\\n\\t\\t\\t\\t<li><a v-link=\\\"{ path: '/sporsmal' }\\\">Spørsmål og svar</a></li>\\n\\t\\t\\t\\t<!--<li><a href=\\\"http://wiki.alternativet.party\\\">Wiki</a></li>-->\\n\\t\\t\\t\\t<!-- Login / Registration Links for unauthenticated users -->\\n\\t\\t\\t\\t<li v-if=\\\" ! $root.authenticated\\\"><a class=\\\"auth\\\" v-link=\\\"{ path: '/login' }\\\">Logg inn</a></li>\\n\\t\\t\\t\\t<li v-if=\\\" ! $root.authenticated\\\"><a class=\\\"auth outline\\\" v-link=\\\"{ path: '/register' }\\\">Bli medlem</a></li>\\n\\t\\t\\t\\t<!-- Authenticated Right Dropdown -->\\n\\t\\t\\t\\t<li class=\\\"dropdown\\\" v-if=\\\"$root.authenticated\\\">\\n\\t\\t\\t\\t\\t<a href=\\\"#\\\" class=\\\"dropdown-toggle\\\" data-toggle=\\\"dropdown\\\" role=\\\"button\\\" aria-expanded=\\\"false\\\">\\n\\t\\t\\t\\t\\t\\t{{ $root.user.name }} <span class=\\\"caret\\\"></span>\\n\\t\\t\\t\\t\\t</a>\\n\\n\\t\\t\\t\\t\\t<ul class=\\\"dropdown-menu\\\" role=\\\"menu\\\">\\n\\t\\t\\t\\t\\t\\t<!-- Settings -->\\n\\t\\t\\t\\t\\t\\t<li class=\\\"dropdown-header\\\">Innstillinger</li>\\n\\t\\t\\t\\t\\t\\t<li>\\n\\t\\t\\t\\t\\t\\t\\t<a v-link=\\\"{ path: '/auth/profile' }\\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-fw fa-user\\\"></i>Min profil\\n\\t\\t\\t\\t\\t\\t\\t</a>\\n\\t\\t\\t\\t\\t\\t</li>\\n\\n\\t\\t\\t\\t\\t\\t<!-- Logout -->\\n\\t\\t\\t\\t\\t\\t<li class=\\\"divider\\\"></li>\\n\\t\\t\\t\\t\\t\\t<li>\\n\\t\\t\\t\\t\\t\\t\\t<a v-link=\\\"{ path: '/auth/logout' }\\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-fw fa-sign-out\\\"></i>Logg ut\\n\\t\\t\\t\\t\\t\\t\\t</a>\\n\\t\\t\\t\\t\\t\\t</li>\\n\\t\\t\\t\\t\\t</ul>\\n\\t\\t\\t\\t</li>\\n\\t\\t\\t</ul>\\n\\t\\t</div>\\n\\t</div>\\n</nav>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/nav.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],119:[function(require,module,exports){\nvar __vueify_style__ = require(\"vueify-insert-css\").insert(\"\\n.title {\\n    color: #999;\\n    font-weight: 200;\\n    font-size: 40px;\\n    margin-bottom: 40px;\\n    text-align: center;\\n    margin-top: 20%;\\n}\\n.title a {\\n    display: block;\\n    margin-top: 20px;\\n}\\n.title a:hover {\\n    text-decoration: none;\\n}\")\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"container-fluid\\\">\\n\\t<div class=\\\"row\\\">\\n\\t\\t<div class=\\\"col-md-3\\\"></div>\\n\\t\\t<div class=\\\"col-md-6 title\\\">\\n\\t\\t\\tBeklager, vi fant ikke sida du ser etter : (<br>\\n\\t\\t\\t<a href=\\\"/\\\"><i class=\\\"fa fa-caret-left\\\"></i> Gå tilbake til forsida</a>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"col-md-3\\\"></div>\\n\\t</div>\\n</div>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/404.vue\"\n  module.hot.dispose(function () {\n    require(\"vueify-insert-css\").cache[\"\\n.title {\\n    color: #999;\\n    font-weight: 200;\\n    font-size: 40px;\\n    margin-bottom: 40px;\\n    text-align: center;\\n    margin-top: 20%;\\n}\\n.title a {\\n    display: block;\\n    margin-top: 20px;\\n}\\n.title a:hover {\\n    text-decoration: none;\\n}\"] = false\n    document.head.removeChild(__vueify_style__)\n  })\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27,\"vueify-insert-css\":96}],120:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<nav-component></nav-component>\\n<div class=\\\"container app-screen\\\">\\n\\t<!-- Tabs -->\\n\\t<div class=\\\"col-md-3\\\">\\n\\t\\t<div class=\\\"panel panel-default panel-flush\\\">\\n\\t\\t\\t<div class=\\\"panel-heading\\\">\\n\\t\\t\\t\\tMine sider\\n\\t\\t\\t</div>\\n\\t\\t\\t<div class=\\\"panel-body\\\">\\n\\t\\t\\t\\t<div class=\\\"app-tabs\\\">\\n\\t\\t\\t\\t\\t<ul class=\\\"nav app-tabs-stacked\\\">\\n\\t\\t\\t\\t\\t\\t<li v-if=\\\"! $root.authenticated\\\">\\n\\t\\t\\t\\t\\t\\t\\t<a v-link=\\\"{ path: '/auth/login' }\\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-fw fa-sign-in\\\"></i>&nbsp;Logg inn\\n\\t\\t\\t\\t\\t\\t\\t</a>\\n\\t\\t\\t\\t\\t\\t</li>\\n\\t\\t\\t\\t\\t\\t<li v-if=\\\"! $root.authenticated\\\">\\n\\t\\t\\t\\t\\t\\t\\t<a v-link=\\\"{ path: '/auth/register' }\\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-fw fa-chevron-circle-up\\\"></i>&nbsp;Bli medlem\\n\\t\\t\\t\\t\\t\\t\\t</a>\\n\\t\\t\\t\\t\\t\\t</li>\\n\\t\\t\\t\\t\\t\\t<li v-if=\\\"$root.authenticated\\\">\\n\\t\\t\\t\\t\\t\\t\\t<a v-link=\\\"{ path: '/auth/profile' }\\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-fw fa-user\\\"></i>&nbsp;Min profil\\n\\t\\t\\t\\t\\t\\t\\t</a>\\n\\t\\t\\t\\t\\t\\t</li>\\n\\t\\t\\t\\t\\t</ul>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</div>\\n\\t<!-- Tab Panes -->\\n\\t<div class=\\\"col-md-9\\\">\\n\\t\\t<div class=\\\"tab-content\\\">\\n\\t\\t\\t<div class=\\\"tab-pane\\\">\\n\\t\\t\\t\\t<div class=\\\"panel panel-default\\\">\\n\\t\\t\\t\\t\\t<router-view></router-view>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t</div><!-- End tab panel -->\\n\\t\\t</div><!-- End tab content -->\\n\\t</div><!-- End tab panes col-md-9 -->\\n</div><!-- End container -->\\n<footer-component></footer-component>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/auth.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],121:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  route: {\n    activate: function activate(transition) {\n      this.$root.authenticated = false;\n      this.$root.user = null;\n      localStorage.removeItem('user');\n      localStorage.removeItem('jwt-token');\n      transition.redirect('/');\n    }\n  }\n\n};\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/auth/logout.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],122:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"panel-heading\\\">\\n\\tMin profil\\n</div>\\n<div class=\\\"panel-body\\\">\\n\\t<!-- <button class=\\\"btn btn-primary\\\" v-on=\\\"click: fetch\\\">Fetch</button> -->\\n\\t<table class=\\\"table table-bordered\\\" v-if=\\\"$root.user\\\">\\n\\t\\t<tbody><tr>\\n\\t\\t\\t<th>#</th>\\n\\t\\t\\t<th>Navn</th>\\n\\t\\t\\t<th>E-post</th>\\n\\t\\t</tr>\\n\\t\\t<tr>\\n\\t\\t\\t<td>{{ $root.user.id }}</td>\\n\\t\\t\\t<td>{{ $root.user.name }}</td>\\n\\t\\t\\t<td>{{ $root.user.email }}</td>\\n\\t\\t</tr>\\n\\t</tbody></table>\\n</div>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/auth/profile.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],123:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<nav-component></nav-component>\\n<div class=\\\"container app-screen\\\">\\n\\t<!-- Tabs -->\\n\\t<div class=\\\"col-md-3\\\">\\n\\t\\t<div class=\\\"panel panel-default panel-flush\\\">\\n\\t\\t\\t<div class=\\\"panel-heading\\\">\\n\\t\\t\\t\\tHunder!\\n\\t\\t\\t</div>\\n\\t\\t\\t<div class=\\\"panel-body\\\">\\n\\t\\t\\t\\t<div class=\\\"app-tabs\\\">\\n\\t\\t\\t\\t\\t<ul class=\\\"nav app-tabs-stacked\\\">\\n\\t\\t\\t\\t\\t\\t<li>\\n\\t\\t\\t\\t\\t\\t\\t<a v-link=\\\"{ path: '/dogs' }\\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-fw fa-list\\\"></i>&nbsp;Liste over hunder\\n\\t\\t\\t\\t\\t\\t\\t</a>\\n\\t\\t\\t\\t\\t\\t</li>\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t<li>\\n\\t\\t\\t\\t\\t\\t\\t<a v-link=\\\"{ path: '/dogs/create' }\\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-fw fa-heart\\\"></i>&nbsp;Opprett ny\\n\\t\\t\\t\\t\\t\\t\\t</a>\\n\\t\\t\\t\\t\\t\\t</li>\\n\\t\\t\\t\\t\\t</ul>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</div>\\n\\t<!-- Tab Panes -->\\n\\t<div class=\\\"col-md-9\\\">\\n\\t\\t<div class=\\\"tab-content\\\">\\n\\t\\t\\t<div class=\\\"tab-pane\\\">\\n\\t\\t\\t\\t<div class=\\\"panel panel-default\\\">\\n\\t\\t\\t\\t\\t<router-view></router-view>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t</div><!-- End tab panel -->\\n\\t\\t</div><!-- End tab content -->\\n\\t</div><!-- End tab panes col-md-9 -->\\n</div><!-- End container -->\\n<footer-component></footer-component>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/dogs.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],124:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  data: function data() {\n    return {\n      dog: {\n        name: '',\n        age: ''\n      },\n      messages: []\n    };\n  },\n\n  methods: {\n    createDog: function createDog(e) {\n      e.preventDefault();\n      var that = this;\n      client({ path: 'dogs', entity: this.dog }).then(function (response, status) {\n        that.dog.name = '';\n        that.dog.age = '';\n        that.messages = [{ type: 'success', message: 'Woof woof! Your dog was created' }];\n        Vue.nextTick(function () {\n          document.getElementById('nameInput').focus();\n        });\n      }, function (response, status) {\n        that.messages = [];\n        for (var key in response.entity) {\n          that.messages.push({ type: 'danger', message: response.entity[key] });\n        }\n      });\n    }\n  }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"panel-heading\\\">\\n\\tMake a dog!\\n</div>\\n<div class=\\\"panel-body\\\">\\n\\t<div id=\\\"alerts\\\" v-if=\\\"messages.length > 0\\\">\\n\\t\\t<div v-for=\\\"message in messages\\\" class=\\\"alert alert-{{ message.type }} alert-dismissible\\\" role=\\\"alert\\\">\\n\\t\\t\\t{{ message.message }}\\n\\t\\t</div>\\n\\t</div>\\n\\t<form class=\\\"form-horizontal\\\" role=\\\"form\\\" v-on:submit=\\\"createDog\\\">\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label for=\\\"name\\\" class=\\\"col-sm-2 col-sm-offset-1 control-label\\\">Name your dog</label>\\n\\t\\t\\t<div class=\\\"col-sm-5\\\">\\n\\t\\t\\t\\t<input class=\\\"form-control\\\" required=\\\"required\\\" name=\\\"name\\\" type=\\\"text\\\" v-model=\\\"dog.name\\\" id=\\\"nameInput\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label for=\\\"age\\\" class=\\\"col-sm-2 col-sm-offset-1 control-label\\\">What's the age?</label>\\n\\t\\t\\t<div class=\\\"col-sm-5\\\">\\n\\t\\t\\t\\t<input class=\\\"form-control\\\" required=\\\"required\\\" name=\\\"age\\\" type=\\\"text\\\" v-model=\\\"dog.age\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<div class=\\\"col-sm-4 col-sm-offset-3\\\">\\n\\t\\t\\t\\t<button type=\\\"submit\\\" class=\\\"btn btn-primary\\\"><i class=\\\"fa fa-btn fa-save\\\"></i>Make the dog!</button>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</form>\\n</div>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/dogs/create.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],125:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  data: function data() {\n    return {\n      dogs: [],\n      messages: []\n    };\n  },\n\n  methods: {\n    // Let's fetch some dogs\n    fetch: function fetch(successHandler) {\n      var that = this;\n      client({ path: '/dogs' }).then(function (response) {\n        // Look ma! Puppies!\n        that.$set('dogs', response.entity.data);\n        successHandler(response.entity.data);\n      }, function (response, status) {\n        if (_.contains([401, 500], status)) {\n          that.$dispatch('userHasLoggedOut');\n        }\n      });\n    },\n\n    deleteDog: function deleteDog(index) {\n      var that = this;\n      client({ path: '/dogs/' + this.dogs[index].id, method: 'DELETE' }).then(function (response) {\n        that.dogs.splice(index, 1);\n        that.messages = [{ type: 'success', message: 'Great, dog purged.' }];\n      }, function (response) {\n        that.messages.push({ type: 'danger', message: 'There was a problem removing the dog' });\n      });\n    }\n\n  },\n\n  route: {\n    // Ooh, ooh, are there any new puppies yet?\n    data: function data(transition) {\n      this.fetch(function (data) {\n        transition.next({ dogs: data });\n      });\n    }\n  }\n\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"panel-heading\\\">\\n\\tList of dogs\\n</div>\\n<div class=\\\"panel-body\\\" v-if=\\\"$loadingRouteData\\\">\\n\\tLoading data {{ loadingRouteData }}\\n</div>\\n<div class=\\\"panel-body\\\" v-if=\\\"messages.length > 0\\\">\\n\\t<div v-for=\\\"message in messages\\\" class=\\\"alert alert-{{ message.type }} alert-dismissible\\\" role=\\\"alert\\\">\\n\\t\\t{{ message.message }}\\n\\t</div>\\n</div>\\n\\n<div class=\\\"panel-body\\\" v-if=\\\"dogs.length == 0\\\">\\n\\tYou have no dogs!\\n</div>\\n\\n<table class=\\\"table\\\" v-if=\\\" ! $loadingRouteData &amp;&amp; dogs.length > 0\\\">\\n\\t<thead>\\n\\t\\t<tr>\\n\\t\\t\\t<th>ID</th>\\n\\t\\t\\t<th>Name</th>\\n\\t\\t\\t<th>Age</th>\\n\\t\\t\\t<th width=\\\"120px\\\">Actions</th>\\n\\t\\t</tr>\\n\\t</thead>\\n\\t<tbody>\\n\\t\\t<tr v-for=\\\"dog in dogs\\\">\\n\\t\\t\\t<td>{{ dog.id }}</td>\\n\\t\\t\\t<td>{{ dog.name }}</td>\\n\\t\\t\\t<td>{{ dog.age }}</td>\\n\\t\\t\\t<td>\\n\\t\\t\\t\\t<a class=\\\"btn btn-primary btn-xs\\\" v-link=\\\"{ path: '/dogs/'+dog.id }\\\">Edit</a>\\n\\t\\t\\t\\t<a class=\\\"btn btn-primary btn-xs\\\" v-on:click=\\\"deleteDog($index)\\\">Delete</a>\\n\\t\\t\\t</td>\\n\\t\\t</tr>\\n\\t</tbody>\\n</table>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/dogs/index.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],126:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  data: function data() {\n    return {\n      dog: {\n        id: null,\n        name: null,\n        age: null\n      },\n      messages: []\n    };\n  },\n\n  methods: {\n    // Let's fetch the dog\n    fetch: function fetch(id, successHandler) {\n      var that = this;\n      client({ path: '/dogs/' + id }).then(function (response) {\n        that.$set('dog', response.entity.data);\n        successHandler(response.entity.data);\n      }, function (response, status, request) {\n        // Go tell your parents that you've messed up somehow\n        if (status === 401) {\n          self.$dispatch('userHasLoggedOut');\n        } else {\n          console.log(response);\n        }\n      });\n    },\n\n    updateDog: function updateDog(e) {\n      e.preventDefault();\n      var self = this;\n      client({ path: '/dogs/' + this.dog.id, entity: this.dog, method: 'PUT' }).then(function (response) {\n        self.messages = [];\n        self.messages.push({ type: 'success', message: 'Woof woof! Your dog was updated' });\n      }, function (response) {\n        self.messages = [];\n        for (var key in response.entity) {\n          self.messages.push({ type: 'danger', message: response.entity[key] });\n        }\n      });\n    }\n\n  },\n\n  route: {\n    // Ooh, ooh, are there any new puppies yet?\n    data: function data(transition) {\n      this.fetch(this.$route.params.id, function (data) {\n        transition.next({ dog: data });\n      });\n    }\n  }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"panel-heading\\\">\\n\\tEdit dog\\n</div>\\n<div class=\\\"panel-body\\\">\\n\\t<div id=\\\"alerts\\\" v-if=\\\"messages.length > 0\\\">\\n\\t\\t<div v-for=\\\"message in messages\\\" class=\\\"alert alert-{{ message.type }} alert-dismissible\\\" role=\\\"alert\\\">\\n\\t\\t\\t{{ message.message }}\\n\\t\\t</div>\\n\\t</div>\\n\\t<form class=\\\"form-horizontal\\\" role=\\\"form\\\" v-on:submit=\\\"updateDog\\\">\\n\\t<fieldset disabled=\\\"\\\">\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label for=\\\"name\\\" class=\\\"col-sm-2 col-sm-offset-1 control-label\\\">Dog ID</label>\\n\\t\\t\\t<div class=\\\"col-sm-5\\\">\\n\\t\\t\\t\\t<input class=\\\"form-control\\\" required=\\\"required\\\" name=\\\"name\\\" type=\\\"text\\\" v-model=\\\"dog.id\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</fieldset>\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label for=\\\"name\\\" class=\\\"col-sm-2 col-sm-offset-1 control-label\\\">Name your dog</label>\\n\\t\\t\\t<div class=\\\"col-sm-5\\\">\\n\\t\\t\\t\\t<input class=\\\"form-control\\\" required=\\\"required\\\" name=\\\"name\\\" type=\\\"text\\\" v-model=\\\"dog.name\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label for=\\\"age\\\" class=\\\"col-sm-2 col-sm-offset-1 control-label\\\">What's the age?</label>\\n\\t\\t\\t<div class=\\\"col-sm-5\\\">\\n\\t\\t\\t\\t<input class=\\\"form-control\\\" required=\\\"required\\\" name=\\\"age\\\" type=\\\"text\\\" v-model=\\\"dog.age\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<div class=\\\"col-sm-4 col-sm-offset-3\\\">\\n\\t\\t\\t\\t<button type=\\\"submit\\\" class=\\\"btn btn-primary\\\"><i class=\\\"fa fa-btn fa-save\\\"></i>Update the dog!</button>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</form>\\n</div>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/dogs/show.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],127:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<nav-component></nav-component>\\n<div class=\\\"container\\\">\\n    <div class=\\\"col-md-12\\\">\\n        <p>\\n            Forside\\n        </p>\\n    </div><!-- End tab panes col-md-9 -->\\n</div><!-- End container -->\\n<footer-component></footer-component>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/home.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],128:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  data: function data() {\n    return {\n      user: {\n        email: null,\n        password: null\n      },\n      messages: []\n    };\n  },\n\n  methods: {\n    attempt: function attempt(e) {\n      e.preventDefault();\n      var that = this;\n      client({ path: 'login', entity: this.user }).then(function (response) {\n        that.$dispatch('userHasFetchedToken', response.token);\n        that.getUserData();\n      }, function (response) {\n        that.messages = [];\n        if (response.status && response.status.code === 401) that.messages.push({ type: 'danger', message: 'Beklager, brukernavn eller passord er feil.' });\n      });\n    },\n\n    getUserData: function getUserData() {\n      var that = this;\n      client({ path: '/users/me' }).then(function (response) {\n        that.$dispatch('userHasLoggedIn', response.entity.user);\n        that.$route.router.go('/auth/profile');\n      }, function (response) {\n        console.log(response);\n      });\n    }\n  },\n\n  route: {\n    activate: function activate(transition) {\n      this.$dispatch('userHasLoggedOut');\n      transition.next();\n    }\n  }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<nav-component></nav-component>\\n<div class=\\\"container app-screen\\\">\\n\\n    <div class=\\\"col-md-12\\\">\\n        <form class=\\\"form-horizontal\\\" role=\\\"form\\\">\\n            <div id=\\\"alerts\\\" v-if=\\\"messages.length > 0\\\">\\n                <div v-for=\\\"message in messages\\\" class=\\\"alert alert-{{ message.type }} alert-dismissible\\\" role=\\\"alert\\\">\\n                    {{ message.message }}\\n                </div>\\n            </div>\\n\\n            <div class=\\\"form-group\\\">\\n                <label class=\\\"col-md-4 control-label\\\">E-post</label>\\n                <div class=\\\"col-md-6\\\">\\n                    <input type=\\\"email\\\" class=\\\"form-control\\\" v-model=\\\"user.email\\\">\\n                </div>\\n            </div>\\n\\n            <div class=\\\"form-group\\\">\\n                <label class=\\\"col-md-4 control-label\\\">Passord</label>\\n                <div class=\\\"col-md-6\\\">\\n                    <input type=\\\"password\\\" class=\\\"form-control\\\" v-model=\\\"user.password\\\">\\n                </div>\\n            </div>\\n\\n            <div class=\\\"form-group\\\">\\n                <div class=\\\"col-md-6 col-md-offset-4\\\">\\n                    <button type=\\\"submit\\\" class=\\\"btn btn-primary\\\" v-on:click=\\\"attempt\\\">\\n                        <i class=\\\"fa fa-btn fa-sign-in\\\"></i>Logg inn\\n                    </button>\\n                    <a class=\\\"btn btn-default\\\" v-link=\\\"{ path: '/register' }\\\">\\n                        Opprett bruker\\n                    </a>\\n                    <a class=\\\"btn btn-link\\\" v-link=\\\"{ path: '/auth/forgot' }\\\">Glemt passordet?</a>\\n                </div>\\n            </div>\\n        </form>\\n    </div>\\n</div><!-- End container -->\\n<footer-component></footer-component>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/login.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],129:[function(require,module,exports){\nvar __vueify_style__ = require(\"vueify-insert-css\").insert(\"\\n.manifest {\\n    text-align: center;\\n}\\n\\n.manifest h2 {\\n    margin-top: 0;\\n    margin-bottom: 1em;\\n    font-weight: bold;\\n    font-size: 2.4em;\\n    text-transform: uppercase;\\n}\\n\\n.manifest header h2 {\\n    margin-bottom: .5em;\\n}\\n\\n.manifest p {\\n    font-size: 1.3em;\\n    margin-bottom: 1.4em;\\n}\\n\\n.manifest p span.lead {\\n    font-size: 1em;\\n    font-weight: bold;\\n    text-transform: uppercase;\\n}\")\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<nav-component></nav-component>\\n<div class=\\\"container app-screen manifest\\\">\\n    <div class=\\\"col-md-1\\\">\\n\\n    </div>\\n    <div class=\\\"col-md-9\\\">\\n        <header>\\n            <h2>Manifest</h2>\\n            <p>Det er alltid et alternativ!</p>\\n        </header>\\n        <p><span class=\\\"lead\\\">Alternativet er en politisk idé</span><br>om personlig frihet, sosial verdighet og levende, bærekraftige fellesskap. Et håp. En drøm. En lengsel etter mening, betydning og medmenneskelige relasjoner. Alternativet er et svar på det som skjer i verden i dag. Rundt oss. Med oss.</p>\\n        <p><span class=\\\"lead\\\">Alternativet er et opprop</span><br>mot kynismen, mangelen på raushet og et samfunn som sparker nedover.</p>\\n        <p><span class=\\\"lead\\\">Alternativet er glede.</span><br>Uten humor ingen kreativitet. Uten kreativitet ingen gode idéer. Uten gode idéer ingen skaperkraft. Uten skaperkraft intet resultat.</p>\\n        <p><span class=\\\"lead\\\">Alternativet er en positiv motkraft.</span><br>En lyst til å komme med reelle og seriøse svar på miljø- og ressurskrisen som jorden befinner seg i. En krise som for hver dag forverrer våre egne, våre barns og våre barnebarns muligheter for et godt, rikt og meningsfylt liv.</p>\\n        <p><span class=\\\"lead\\\">Alternativet er nysgjerrighet</span><br>på hvordan vi utvikler bygdene, byene og nasjonene våre. Vi vil selv ta vare på økonomien og de demokratiske beslutningene på arbeidsplassene og i lokalsamfunnene der vi lever våre liv. Vi mister likevel ikke det globale utsynet og ansvaret for å finne felles løsninger med både våre naboer og med de som bor på den andre siden av kloden.</p>\\n        <p><span class=\\\"lead\\\">Alternativet er samarbeid.</span><br>Vi vet at private virksomheter ikke kan løse problemene alene. Det kan heller ikke de offentlige institusjonene eller organisasjonslivet gjøre. Derfor skal vi oppfinne helt nye koblinger og samarbeidsmodeller, der vi bruker det beste fra det private, det offentlige og organisasjonslivet.</p>\\n        <p><span class=\\\"lead\\\">Alternativet er åpenhet.</span><br>Vi vil prøve nye idéer og skape løsninger som virker. Alternativet er også streben etter å forstå komplekse sammenhenger og motstå fristelsen å benytte forenklede argumenter og behagelige illusjoner.</p>\\n        <p><span class=\\\"lead\\\">Alternativet er mot</span><br>til å se problemene i øynene. Men også mot til å møte framtida vi har sammen.</p>\\n        <p><span class=\\\"lead\\\">Alternativet er allerede virkelighet.</span><br>Rundt om på kloden vår blir det i vår tid skapt helt nye institusjonstyper, organisasjonsformer og sosiale nettverk. Om det skjer i Oslo, København, Seoul, Durban eller Rio betyr ikke så mye hver for seg, men tilsammen utgjør de en levedyktig global endringsbølge.</p>\\n        <p><span class=\\\"lead\\\">Alternativet er for deg</span><br>som merker at noe er i bevegelse. Som har en fornemmelse av at noe nytt er i ferd med å avløse det gamle. En annen måte å se på demokrati, vekst, arbeidsliv, ansvar og livskvalitet.<br>\\n            Det er Alternativet.</p>\\n    </div>\\n    <div class=\\\"col-md-2\\\">\\n\\n    </div>\\n</div><!-- End container -->\\n<footer-component></footer-component>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/manifest.vue\"\n  module.hot.dispose(function () {\n    require(\"vueify-insert-css\").cache[\"\\n.manifest {\\n    text-align: center;\\n}\\n\\n.manifest h2 {\\n    margin-top: 0;\\n    margin-bottom: 1em;\\n    font-weight: bold;\\n    font-size: 2.4em;\\n    text-transform: uppercase;\\n}\\n\\n.manifest header h2 {\\n    margin-bottom: .5em;\\n}\\n\\n.manifest p {\\n    font-size: 1.3em;\\n    margin-bottom: 1.4em;\\n}\\n\\n.manifest p span.lead {\\n    font-size: 1em;\\n    font-weight: bold;\\n    text-transform: uppercase;\\n}\"] = false\n    document.head.removeChild(__vueify_style__)\n  })\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27,\"vueify-insert-css\":96}],130:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<nav-component></nav-component>\\n<div class=\\\"container app-screen\\\">\\n\\t<!-- Tabs -->\\n\\t<div class=\\\"col-md-3\\\">\\n\\t\\t<div class=\\\"panel panel-default panel-flush\\\">\\n\\t\\t\\t<div class=\\\"panel-heading\\\">\\n\\t\\t\\t\\tOm oss\\n\\t\\t\\t</div>\\n\\t\\t\\t<div class=\\\"panel-body\\\">\\n\\t\\t\\t\\t<div class=\\\"app-tabs\\\">\\n\\t\\t\\t\\t\\t<ul class=\\\"nav app-tabs-stacked\\\">\\n\\t\\t\\t\\t\\t\\t<li>\\n\\t\\t\\t\\t\\t\\t\\t<a v-link=\\\"{ path: '/om/om' }\\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-fw fa-info\\\"></i>&nbsp;Alternativet\\n\\t\\t\\t\\t\\t\\t\\t</a>\\n\\t\\t\\t\\t\\t\\t</li>\\n\\t\\t\\t\\t\\t\\t<li>\\n\\t\\t\\t\\t\\t\\t\\t<a v-link=\\\"{ path: '/om/kontakt' }\\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-fw fa-envelope\\\"></i>&nbsp;Kontakt\\n\\t\\t\\t\\t\\t\\t\\t</a>\\n\\t\\t\\t\\t\\t\\t</li>\\n\\t\\t\\t\\t\\t\\t<li>\\n\\t\\t\\t\\t\\t\\t\\t<a v-link=\\\"{ path: '/om/folk' }\\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-fw fa-users\\\"></i>&nbsp;Folk\\n\\t\\t\\t\\t\\t\\t\\t</a>\\n\\t\\t\\t\\t\\t\\t</li>\\n                        <li>\\n                            <a v-link=\\\"{ path: '/om/organisasjon' }\\\">\\n                                <i class=\\\"fa fa-btn fa-fw fa-cloud\\\"></i>&nbsp;Organisasjon\\n                            </a>\\n                        </li>\\n\\t\\t\\t\\t\\t</ul>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</div>\\n\\t<!-- Tab Panes -->\\n\\t<div class=\\\"col-md-9\\\">\\n\\t\\t<div class=\\\"tab-content\\\">\\n\\t\\t\\t<div class=\\\"tab-pane\\\">\\n\\t\\t\\t\\t<div class=\\\"panel panel-default\\\">\\n\\t\\t\\t\\t\\t<router-view></router-view>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t</div><!-- End tab panel -->\\n\\t\\t</div><!-- End tab content -->\\n\\t</div><!-- End tab panes col-md-9 -->\\n</div><!-- End container -->\\n<footer-component></footer-component>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/om.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],131:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"panel-heading\\\">\\n    Folk\\n</div>\\n<div class=\\\"panel-body\\\">\\n    <p class=\\\"lead\\\">\\n        Her er noen av medlemmene i Alternativet.\\n    </p>\\n</div>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/om/folk.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],132:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<!--\\n\\t@todo Lag «avtal en date»-knapp på kontaktpersoner\\n-->\\n<div class=\\\"panel-heading\\\">\\n\\tKontakt\\n</div>\\n<div class=\\\"panel-body\\\">\\n\\t<p class=\\\"lead\\\">\\n\\t\\tTa kontakt med oss om du lurer på noe om Alternativet, enten det gjelder politikkutviklingen, organisasjonen,\\n\\t\\tnettplattformene, medlemskapet ditt eller noe helt annet : )\\n\\t</p>\\n\\t<h3>Medlemsservice</h3>\\n\\t<p>\\n\\t\\tSpørsmål om medlemskap:<br>\\n\\t\\t<a href=\\\"mailto:medlem@alternativet.party\\\">medlem@alternativet.party</a><br>\\n\\t\\t<i class=\\\"fa fa-phone\\\"></i> 932 90 567\\n\\t</p>\\n\\t<h3>Kontaktpersoner</h3>\\n\\t<p>\\n\\t\\t<strong><a href=\\\"mailto:kasbschj@gmail.com\\\">Kay Asbjørn Knutsen Schjørlien</a></strong><br>\\n\\t\\tLeder<br>\\n\\t\\t<i class=\\\"fa fa-phone\\\"></i> 974 72 700\\n\\t</p>\\n\\t<p>\\n\\t\\t<strong><a href=\\\"mailto:marianne.grotte@alternativet.party\\\">Marianne Grøtte</a></strong><br>\\n\\t\\tLeder<br>\\n\\t\\t<i class=\\\"fa fa-phone\\\"></i> 988 11 188\\n\\t</p>\\n\\t<p>\\n\\t\\t<strong><a href=\\\"mailto:mohamedali@hotmail.no\\\">Mohamed Ali Rashid</a></strong><br>\\n\\t\\tMedlems- og frivilligkontakt<br>\\n\\t\\t<i class=\\\"fa fa-phone\\\"></i> 932 90 567\\n\\t</p>\\n\\t<p>\\n\\t\\t<strong><a href=\\\"mailto:leo@alternativet.party\\\">Leo Valen</a></strong><br>\\n\\t\\tKommunikasjon og nettplattformer<br>\\n\\t\\t<i class=\\\"fa fa-phone\\\"></i> 466 65 333 (07:00-08:30 og 17:30-21:00)\\n\\t</p>\\n\\t<h3>Postadresse</h3>\\n\\t<p>\\n\\t\\tTing som må sendes på post (bl. a. erklæringer om registrering av Alternativet i partiregisteret)<br>kan sendes til:<br>\\n\\t\\t</p><address>\\n\\t\\t\\tAlternativet<br>\\n\\t\\t\\tc/o Leo Valen<br>\\n\\t\\t\\tTurbinveien 1<br>\\n\\t\\t\\t0195&nbsp;&nbsp;OSLO\\n\\t\\t</address>\\n\\t<p></p>\\n\\t<h3>Bank og registre</h3>\\n\\t<p>\\n\\t\\tOrganisasjonsnummer: <a href=\\\"https://w2.brreg.no/enhet/sok/detalj.jsp?orgnr=916483511\\\">916 483 511</a><br>\\n\\t\\tBankkonto: 1254.62.29937\\n\\t</p>\\n</div>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/om/kontakt.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],133:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"panel-heading\\\">\\n\\tAlternativet\\n</div>\\n<div class=\\\"panel-body\\\">\\n\\t<p class=\\\"lead\\\">\\n\\t\\tAlternativet har til formål å skape en ny politisk kultur som gjør samfunnet i stand til å møte\\n\\t\\tkrisene vi står overfor.\\n\\t</p>\\n\\t<p>\\n\\t\\tDet skal vi gjøre med mot, åpenhet, humor, empati, raushet og ydmykhet.\\n\\t</p>\\n</div>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/om/om.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],134:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"panel-heading\\\">\\n    Organisasjon\\n</div>\\n<div class=\\\"panel-body\\\">\\n    <p class=\\\"lead\\\">\\n        Alternativet ble stiftet 14. desember 2015 som en politisk organisasjon for å møte krisene\\n        samfunnet står overfor. Det skal vi gjøre med kjerneverdiene mot, åpenhet, humor, empati, raushet og ydmykhet.\\n    </p>\\n\\n    <p>\\n        Alternativets <a href=\\\"/#!/manifest\\\">manifest</a>,\\n        kjerneverdiene og <a href=\\\"http://www.fn.no/Tema/FNs-baerekraftsmaal\\\">FNs bærekraftsmål</a> danner grunnlaget\\n        for Alternativets politikkutvikling. Alternativets organisering er fastsatt i <a href=\\\"https://dokumenter.alternativet.io/Vedtekter.pdf\\\">vedtektene</a>.\\n    </p>\\n\\n    <h3>Landsmøtet</h3>\\n    <p>\\n        Landsmøtet er Alternativets høyeste myndighet og treffer beslutninger kontinuerlig gjennom partiets nettbaserte plattformer.\\n        Alle medlemmer har forslagsrett, talerett og stemmerett i landsmøtet.\\n    </p>\\n    <p>\\n        I tillegg til løpende saker, skal landsmøtet årlig behandle partiets årsmelding, regnskap og budsjett,\\n        velge hovedstyre og revisor, og behandle endringer av vedtektene.\\n    </p>\\n    <h3>Hovedstyret</h3>\\n    <p>\\n        Hovedstyret er Alternativets utøvende organ, og har ansvar for å iverksette landsmøtets vedtak.\\n    </p>\\n    <p>\\n        Hovedstyret er per idag et midlertidig styre (interimstyre) som ble valgt ved stiftingen av Alternativet.<br>\\n        Det skal velges nytt styre innen 31. mars 2016.\\n    </p>\\n    <p>\\n        <strong>Hovedstyrets sammensetning:</strong>\\n    </p>\\n    <ul>\\n        <li>Marianne Grøtte (leder)</li>\\n        <li>Kay Asbjørn Knutsen Schjørlien (leder)</li>\\n        <li>Ola Braadland</li>\\n        <li>Ingrid Kvamme Fredriksen</li>\\n        <li>Mona Nesje</li>\\n        <li>Mari Maaø Nilssen</li>\\n        <li>Mohamed Ali Rashid</li>\\n        <li>Leo Valen</li>\\n    </ul>\\n\\n    <h3>Lokallag</h3>\\n    <p>Lokallagene utformer kommune- og bydelspolitikken.</p>\\n    <p>Der Alternativet oppnår representasjon i de folkevalgte organene, har lokallaget ansvar for å følge opp representanter i kommunestyrer, bydelsutvvalg og andre politisk utnevnte verv.</p>\\n    <p>Alternativet har lokallag under etablering i Gamle Oslo, Stavanger, Bodø og Sør-Varanger.</p>\\n\\n    <h3>Fylkeslag</h3>\\n    <p>Fylkeslagene koordinerer lokallagene og utformer fylkespolitikken.</p>\\n    <p>Der Alternativet oppnår representasjon i de folkevalgte organene, har fylkeslaget ansvar for å følge opp representanter i fylkestinget og fylkets representanter i Stortinget.</p>\\n    <p>Alternativet har fylkeslag under etablering i Oslo, Rogaland og Nordland.</p>\\n</div>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/om/organisasjon.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],135:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"container placeholder\\\">\\n    <img src=\\\"/images/alternativet-placeholder.png\\\" alt=\\\"Alternativet\\\" width=\\\"250\\\">\\n    <p>\\n        Alternativet er en plattform for å skape en ny involverende politisk kultur.<br>\\n        Det skal vi gjøre med mot, åpenhet, humor, empati, raushet og ydmykhet.\\n    </p>\\n    <p class=\\\"additional\\\">\\n        Inntil videre skjer det meste <a href=\\\"https://www.facebook.com/groups/528114394010043/\\\">på facebook</a>.<br>\\n        Alle er velkommen i gruppa, ingen forpliktelser.\\n    </p>\\n    <p class=\\\"additional\\\">\\n        Du kan også kontakte oss <a href=\\\"mailto:post@alternativet.io\\\">på epost</a> eller telefon:\\n        Kay Asbjørn Schjørlien, 974 72 700. Marianne Grøtte, 988 11 188.<br>\\n        Mari Maaø Nilssen, 910 00 533. Mohamed Ali Rashid, 932 90 567. Leo Valen, 466 65 533.\\n    </p>\\n    <p>\\n        <b><a href=\\\"https://dokumenter.alternativet.io/Manifest.pdf\\\">Alternativets manifest <i class=\\\"fa fa-caret-right\\\"></i></a></b>\\n    </p>\\n</div>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/placeholder.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],136:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  data: function data() {\n    return {\n      user: {\n        name: null,\n        birth_date: null,\n        postal_code: null,\n        email: null,\n        password: null,\n        password_confirmation: null\n      },\n      messages: []\n    };\n  },\n\n  methods: {\n    registerUser: function registerUser(e) {\n      e.preventDefault();\n      var that = this;\n\n      client({ path: '/register', entity: this.user }).then(function (response) {\n        that.getUserData();\n      }, function (response, status) {\n        that.messages = [];\n        if (response.status && response.status.code === 422) {\n          that.messages = [];\n          for (var key in response.entity) {\n            that.messages.push({ type: 'danger', message: response.entity[key] });\n          }\n        }\n      });\n    },\n\n    getUserData: function getUserData() {\n      var that = this;\n      client({ path: '/users/me' }).then(function (response) {\n        that.$dispatch('userHasLoggedIn', response.entity.user);\n        that.$route.router.go('/auth/profile');\n      });\n    }\n  }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<nav-component></nav-component>\\n<div class=\\\"container app-screen\\\">\\n\\n\\t<form class=\\\"form-horizontal\\\" role=\\\"form\\\" v-on:submit=\\\"registerUser\\\">\\n\\n\\t\\t<div id=\\\"alerts\\\" v-if=\\\"messages.length > 0\\\">\\n\\t\\t\\t<div v-for=\\\"message in messages\\\" class=\\\"alert alert-{{ message.type }} alert-dismissible\\\" role=\\\"alert\\\">\\n\\t\\t\\t\\t{{ message.message }}\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label class=\\\"col-md-4 control-label\\\">Fornavn og etternavn</label>\\n\\t\\t\\t<div class=\\\"col-md-6\\\">\\n\\t\\t\\t\\t<input type=\\\"name\\\" class=\\\"form-control\\\" v-model=\\\"user.name\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label class=\\\"col-md-4 control-label\\\">Fødselsdato</label>\\n\\t\\t\\t<div class=\\\"col-md-6\\\">\\n\\t\\t\\t\\t<input type=\\\"text\\\" class=\\\"form-control\\\" v-model=\\\"user.birth_date\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label class=\\\"col-md-4 control-label\\\">Postnummer</label>\\n\\t\\t\\t<div class=\\\"col-md-6\\\">\\n\\t\\t\\t\\t<input type=\\\"text\\\" class=\\\"form-control\\\" v-model=\\\"user.postal_code\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label class=\\\"col-md-4 control-label\\\">E-post</label>\\n\\t\\t\\t<div class=\\\"col-md-6\\\">\\n\\t\\t\\t\\t<input type=\\\"email\\\" class=\\\"form-control\\\" v-model=\\\"user.email\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label class=\\\"col-md-4 control-label\\\">Passord</label>\\n\\t\\t\\t<div class=\\\"col-md-6\\\">\\n\\t\\t\\t\\t<input type=\\\"password\\\" class=\\\"form-control\\\" v-model=\\\"user.password\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label class=\\\"col-md-4 control-label\\\">Bekreft passord</label>\\n\\t\\t\\t<div class=\\\"col-md-6\\\">\\n\\t\\t\\t\\t<input type=\\\"password\\\" class=\\\"form-control\\\" v-model=\\\"user.password_confirmation\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<div class=\\\"col-md-6 col-md-offset-4\\\">\\n\\t\\t\\t\\t<button type=\\\"submit\\\" class=\\\"btn btn-primary\\\">\\n\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-sign-in\\\"></i> Send innmelding\\n\\t\\t\\t\\t</button>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</form>\\n\\n</div><!-- End container -->\\n<footer-component></footer-component>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/register.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],137:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<nav-component></nav-component>\\n\\n<div class=\\\"container app-screen\\\">\\n\\t<div class=\\\"row\\\">\\n\\t\\t<div class=\\\"tab-content\\\">\\n\\t\\t\\t<div class=\\\"tab-pane\\\">\\n\\t\\t\\t\\t<div class=\\\"panel panel-default\\\">\\n\\t\\t\\t\\t\\t<div class=\\\"panel-heading\\\">\\n\\t\\t\\t\\t\\t\\tTerms of service\\n\\t\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t\\t<!-- Profile Selection notice panel -->\\n\\t\\t\\t\\t\\t<div class=\\\"panel-body\\\">\\n<pre>The MIT License (MIT)\\n\\nCopyright (c) 2015 Yourname\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all\\ncopies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\nSOFTWARE.\\n</pre>\\n\\t\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t</div><!-- End tab panel -->\\n\\t\\t</div><!-- End tab content -->\\n\\t</div><!-- End tab panes col-md-9 -->\\n</div><!-- End container -->\\n\\n<footer-component></footer-component>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/lva/Sites/alternativet/resources/assets/js/compiled/pages/terms.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":94,\"vue-hot-reload-api\":27}],138:[function(require,module,exports){\n'use strict';\n\nvar config = {\n  env: 'development',\n  api: {\n    base_url: 'http://api.development.alternativet.io',\n    defaultRequest: {\n      headers: {\n        'X-Requested-With': 'rest.js',\n        'Content-Type': 'application/json'\n      }\n    }\n  },\n  social: {\n    facebook: '',\n    twitter: '',\n    github: ''\n  },\n  debug: true\n};\n\nmodule.exports = config;\n\n},{}],139:[function(require,module,exports){\n(function (process){\n'use strict';\n\nvar env = process.env.APP_ENV || 'development';\n\nvar config = {\n  development: require('./development.config'),\n  production: require('./production.config'),\n  staging: require('./staging.config')\n};\n\nmodule.exports = config[env];\n\n}).call(this,require('_process'))\n\n},{\"./development.config\":138,\"./production.config\":140,\"./staging.config\":141,\"_process\":1}],140:[function(require,module,exports){\n'use strict';\n\nvar config = {\n  env: 'production',\n  api: {\n    base_url: 'https://api.alternativet.io',\n    defaultRequest: {\n      headers: {\n        'X-Requested-With': 'rest.js',\n        'Content-Type': 'application/json'\n      }\n    }\n  },\n  social: {\n    facebook: '',\n    twitter: '',\n    github: ''\n  },\n  debug: false\n};\n\nmodule.exports = config;\n\n},{}],141:[function(require,module,exports){\n'use strict';\n\nvar config = {\n  env: 'staging',\n  api: {\n    base_url: 'https://api.staging.alternativet.io',\n    defaultRequest: {\n      headers: {\n        'X-Requested-With': 'rest.js',\n        'Content-Type': 'application/json'\n      }\n    }\n  },\n  social: {\n    facebook: '',\n    twitter: '',\n    github: ''\n  },\n  debug: true\n};\nmodule.exports = config;\n\n},{}],142:[function(require,module,exports){\n'use strict';\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor;\n\n\t\tinterceptor = require('rest/interceptor');\n\n\t\t/**\n   * Authenticates the request using JWT Authentication\n   *\n   * @param {Client} [client] client to wrap\n   * @param {Object} config\n   *\n   * @returns {Client}\n   */\n\t\treturn interceptor({\n\t\t\trequest: function request(_request, config) {\n\t\t\t\tvar token, headers;\n\n\t\t\t\ttoken = localStorage.getItem('jwt-token');\n\t\t\t\theaders = _request.headers || (_request.headers = {});\n\n\t\t\t\tif (token !== null && token !== 'undefined') {\n\t\t\t\t\theaders.Authorization = token;\n\t\t\t\t}\n\n\t\t\t\treturn _request;\n\t\t\t},\n\t\t\tresponse: function response(_response) {\n\t\t\t\tif (_response.status && _response.status.code == 401) {\n\t\t\t\t\tlocalStorage.removeItem('jwt-token');\n\t\t\t\t}\n\t\t\t\tif (_response.headers && _response.headers.Authorization) {\n\t\t\t\t\tlocalStorage.setItem('jwt-token', _response.headers.Authorization);\n\t\t\t\t}\n\t\t\t\tif (_response.entity && _response.entity.token && _response.entity.token.length > 10) {\n\t\t\t\t\tlocalStorage.setItem('jwt-token', 'Bearer ' + _response.entity.token);\n\t\t\t\t}\n\t\t\t\treturn _response;\n\t\t\t}\n\t\t});\n\t});\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n\tmodule.exports = factory(require);\n}\n// Boilerplate for AMD and Node\n);\n\n},{\"rest/interceptor\":7}],143:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  configRouter: function configRouter(router) {\n\n    router.map({\n      '/auth': {\n        component: require('./compiled/pages/auth.vue'),\n        subRoutes: {\n          '/profile': {\n            component: require('./compiled/pages/auth/profile.vue'),\n            auth: true\n          },\n          '/logout': {\n            component: require('./compiled/pages/auth/logout.vue'),\n            auth: true\n          }\n        }\n      },\n      '/om': {\n        component: require('./compiled/pages/om.vue'),\n        subRoutes: {\n          '/': {\n            component: require('./compiled/pages/om/om.vue')\n          },\n          '/om': {\n            component: require('./compiled/pages/om/om.vue')\n          },\n          '/kontakt': {\n            component: require('./compiled/pages/om/kontakt.vue')\n          },\n          '/folk': {\n            component: require('./compiled/pages/om/folk.vue')\n          },\n          '/organisasjon': {\n            component: require('./compiled/pages/om/organisasjon.vue')\n          }\n        }\n      },\n      '/dogs': {\n        component: require('./compiled/pages/dogs.vue'),\n        auth: true,\n        subRoutes: {\n          '/': {\n            component: require('./compiled/pages/dogs/index.vue')\n          },\n          '/:id': {\n            component: require('./compiled/pages/dogs/show.vue')\n          },\n          '/create': {\n            component: require('./compiled/pages/dogs/create.vue')\n          }\n        }\n      },\n      '/login': {\n        component: require('./compiled/pages/login.vue'),\n        guest: true\n      },\n      '/register': {\n        component: require('./compiled/pages/register.vue'),\n        guest: true\n      },\n      '/manifest': {\n        component: require('./compiled/pages/manifest.vue')\n      },\n      '/terms': {\n        component: require('./compiled/pages/terms.vue')\n      },\n      '/placeholder': {\n        component: require('./compiled/pages/placeholder.vue')\n      },\n      '/home': {\n        component: require('./compiled/pages/home.vue')\n      },\n      '*': {\n        component: require('./compiled/pages/404.vue')\n      }\n    });\n\n    router.alias({\n      '': '/home',\n      '/auth': '/login'\n    });\n\n    router.beforeEach(function (transition) {\n\n      var token = localStorage.getItem('jwt-token');\n      if (transition.to.auth) {\n        if (!token || token === null) {\n          transition.redirect('/auth/login');\n        }\n      }\n      if (transition.to.guest) {\n        if (token) {\n          transition.redirect('/');\n        }\n      }\n      transition.next();\n    });\n  }\n};\n\n},{\"./compiled/pages/404.vue\":119,\"./compiled/pages/auth.vue\":120,\"./compiled/pages/auth/logout.vue\":121,\"./compiled/pages/auth/profile.vue\":122,\"./compiled/pages/dogs.vue\":123,\"./compiled/pages/dogs/create.vue\":124,\"./compiled/pages/dogs/index.vue\":125,\"./compiled/pages/dogs/show.vue\":126,\"./compiled/pages/home.vue\":127,\"./compiled/pages/login.vue\":128,\"./compiled/pages/manifest.vue\":129,\"./compiled/pages/om.vue\":130,\"./compiled/pages/om/folk.vue\":131,\"./compiled/pages/om/kontakt.vue\":132,\"./compiled/pages/om/om.vue\":133,\"./compiled/pages/om/organisasjon.vue\":134,\"./compiled/pages/placeholder.vue\":135,\"./compiled/pages/register.vue\":136,\"./compiled/pages/terms.vue\":137}]},{},[115])\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvVXJsQnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVzdC9jbGllbnQuanMiLCJub2RlX21vZHVsZXMvcmVzdC9jbGllbnQvZGVmYXVsdC5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L2NsaWVudC94aHIuanMiLCJub2RlX21vZHVsZXMvcmVzdC9pbnRlcmNlcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L2ludGVyY2VwdG9yL2RlZmF1bHRSZXF1ZXN0LmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvaW50ZXJjZXB0b3IvZXJyb3JDb2RlLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvaW50ZXJjZXB0b3IvbWltZS5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L2ludGVyY2VwdG9yL3BhdGhQcmVmaXguanMiLCJub2RlX21vZHVsZXMvcmVzdC9pbnRlcmNlcHRvci90ZW1wbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L21pbWUuanMiLCJub2RlX21vZHVsZXMvcmVzdC9taW1lL3JlZ2lzdHJ5LmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvbWltZS90eXBlL2FwcGxpY2F0aW9uL2hhbC5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L21pbWUvdHlwZS9hcHBsaWNhdGlvbi9qc29uLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvbWltZS90eXBlL2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZC5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L21pbWUvdHlwZS9tdWx0aXBhcnQvZm9ybS1kYXRhLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvbWltZS90eXBlL3RleHQvcGxhaW4uanMiLCJub2RlX21vZHVsZXMvcmVzdC91dGlsL2ZpbmQuanMiLCJub2RlX21vZHVsZXMvcmVzdC91dGlsL2xhenlQcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvdXRpbC9taXhpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L3V0aWwvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L3V0aWwvcmVzcG9uc2VQcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvdXRpbC91cmlFbmNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvdXRpbC91cmlUZW1wbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdnVlLXJvdXRlci9kaXN0L3Z1ZS1yb3V0ZXIuY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvYXBpL2RhdGEuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9hcGkvZG9tLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvYXBpL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2FwaS9nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9hcGkvbGlmZWN5Y2xlLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvYmF0Y2hlci5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2NhY2hlLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvY29tcGlsZXIvY29tcGlsZS1wcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2NvbXBpbGVyL2NvbXBpbGUuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9jb21waWxlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2NvbXBpbGVyL3RyYW5zY2x1ZGUuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9jb25maWcuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmUuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL2VsZW1lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL2VsZW1lbnQvcGFydGlhbC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvZWxlbWVudC9zbG90LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9pbnRlcm5hbC9jbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvaW50ZXJuYWwvY29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9pbnRlcm5hbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvaW50ZXJuYWwvcHJvcC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvaW50ZXJuYWwvc3R5bGUuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL2ludGVybmFsL3RyYW5zaXRpb24uanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL3B1YmxpYy9iaW5kLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9wdWJsaWMvY2xvYWsuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL3B1YmxpYy9lbC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL2Zvci5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL2h0bWwuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL3B1YmxpYy9pZi5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9wdWJsaWMvbW9kZWwvY2hlY2tib3guanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL3B1YmxpYy9tb2RlbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL21vZGVsL3JhZGlvLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9wdWJsaWMvbW9kZWwvc2VsZWN0LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9wdWJsaWMvbW9kZWwvdGV4dC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL29uLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9wdWJsaWMvcmVmLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9wdWJsaWMvc2hvdy5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL3RleHQuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9maWx0ZXJzL2FycmF5LWZpbHRlcnMuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9maWx0ZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZnJhZ21lbnQvZmFjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2ZyYWdtZW50L2ZyYWdtZW50LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvaW5zdGFuY2UvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvaW5zdGFuY2UvaW5pdC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2luc3RhbmNlL2xpZmVjeWNsZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2luc3RhbmNlL21pc2MuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9pbnN0YW5jZS9zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL29ic2VydmVyL2FycmF5LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvb2JzZXJ2ZXIvZGVwLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvb2JzZXJ2ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9wYXJzZXJzL2RpcmVjdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3BhcnNlcnMvZXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3BhcnNlcnMvcGF0aC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3BhcnNlcnMvdGVtcGxhdGUuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9wYXJzZXJzL3RleHQuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy90cmFuc2l0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvdHJhbnNpdGlvbi9xdWV1ZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3RyYW5zaXRpb24vdHJhbnNpdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3V0aWwvY29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvdXRpbC9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3V0aWwvZG9tLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvdXRpbC9lbnYuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy91dGlsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvdXRpbC9sYW5nLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvdXRpbC9vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvdnVlLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvd2F0Y2hlci5qcyIsIm5vZGVfbW9kdWxlcy92dWVpZnktaW5zZXJ0LWNzcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93aGVuL2xpYi9Qcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3doZW4vbGliL1NjaGVkdWxlci5qcyIsIm5vZGVfbW9kdWxlcy93aGVuL2xpYi9UaW1lb3V0RXJyb3IuanMiLCJub2RlX21vZHVsZXMvd2hlbi9saWIvYXBwbHkuanMiLCJub2RlX21vZHVsZXMvd2hlbi9saWIvZGVjb3JhdG9ycy9hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy93aGVuL2xpYi9kZWNvcmF0b3JzL2Zsb3cuanMiLCJub2RlX21vZHVsZXMvd2hlbi9saWIvZGVjb3JhdG9ycy9mb2xkLmpzIiwibm9kZV9tb2R1bGVzL3doZW4vbGliL2RlY29yYXRvcnMvaW5zcGVjdC5qcyIsIm5vZGVfbW9kdWxlcy93aGVuL2xpYi9kZWNvcmF0b3JzL2l0ZXJhdGUuanMiLCJub2RlX21vZHVsZXMvd2hlbi9saWIvZGVjb3JhdG9ycy9wcm9ncmVzcy5qcyIsIm5vZGVfbW9kdWxlcy93aGVuL2xpYi9kZWNvcmF0b3JzL3RpbWVkLmpzIiwibm9kZV9tb2R1bGVzL3doZW4vbGliL2RlY29yYXRvcnMvdW5oYW5kbGVkUmVqZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3doZW4vbGliL2RlY29yYXRvcnMvd2l0aC5qcyIsIm5vZGVfbW9kdWxlcy93aGVuL2xpYi9lbnYuanMiLCJub2RlX21vZHVsZXMvd2hlbi9saWIvZm9ybWF0LmpzIiwibm9kZV9tb2R1bGVzL3doZW4vbGliL21ha2VQcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3doZW4vbGliL3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3doZW4vd2hlbi5qcyIsIi9Vc2Vycy9sdmEvU2l0ZXMvYWx0ZXJuYXRpdmV0L3Jlc291cmNlcy9hc3NldHMvanMvYm9vdHN0cmFwLmpzIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9hcHAudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9mb290ZXIudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9uYXYudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy80MDQudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9hdXRoLnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvYXV0aC9sb2dvdXQudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9hdXRoL3Byb2ZpbGUudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9kb2dzLnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvZG9ncy9jcmVhdGUudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9kb2dzL2luZGV4LnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvZG9ncy9zaG93LnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvaG9tZS52dWUiLCJyZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL2xvZ2luLnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvbWFuaWZlc3QudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9vbS52dWUiLCJyZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL29tL2ZvbGsudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9vbS9rb250YWt0LnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvb20vb20udnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9vbS9vcmdhbmlzYXNqb24udnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9wbGFjZWhvbGRlci52dWUiLCJyZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL3JlZ2lzdGVyLnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvdGVybXMudnVlIiwiL1VzZXJzL2x2YS9TaXRlcy9hbHRlcm5hdGl2ZXQvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb25maWcvZGV2ZWxvcG1lbnQuY29uZmlnLmpzIiwiL1VzZXJzL2x2YS9TaXRlcy9hbHRlcm5hdGl2ZXQvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb25maWcvaW5kZXguanMiLCIvVXNlcnMvbHZhL1NpdGVzL2FsdGVybmF0aXZldC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbmZpZy9wcm9kdWN0aW9uLmNvbmZpZy5qcyIsIi9Vc2Vycy9sdmEvU2l0ZXMvYWx0ZXJuYXRpdmV0L3Jlc291cmNlcy9hc3NldHMvanMvY29uZmlnL3N0YWdpbmcuY29uZmlnLmpzIiwiL1VzZXJzL2x2YS9TaXRlcy9hbHRlcm5hdGl2ZXQvcmVzb3VyY2VzL2Fzc2V0cy9qcy9pbnRlcmNlcHRvcnMvand0QXV0aC5qcyIsIi9Vc2Vycy9sdmEvU2l0ZXMvYWx0ZXJuYXRpdmV0L3Jlc291cmNlcy9hc3NldHMvanMvcm91dGVzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyK0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6c0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaFVBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdmxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdlZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDLzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7c0JDN042QixVQUFVOzs7QUFOdkMsTUFBTSxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUE7QUFDM0IsTUFBTSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUEsQUFReEMsSUFBTSxNQUFNLEdBQUcsSUFBSSxTQUFTLEVBQUUsQ0FBQTs7O0FBRzlCLDBCQUFhLE1BQU0sQ0FBQyxDQUFBOzs7QUFHcEIsTUFBTSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUE7QUFDbkMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFBOzs7QUFHdkIsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFBO0FBQzFCLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyw2QkFBNkIsQ0FBQyxDQUFBO0FBQ3ZELElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFBO0FBQzNDLElBQUksY0FBYyxHQUFHLE9BQU8sQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFBO0FBQy9ELElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyw0QkFBNEIsQ0FBQyxDQUFBO0FBQ3JELElBQUksV0FBVyxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFBO0FBQzdDLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxDQUFBOztBQUUvQyxNQUFNLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FDakQsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUNWLElBQUksQ0FBQyxjQUFjLEVBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FDL0MsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUM5QixJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7OztBQUduQyxHQUFHLENBQUMsU0FBUyxDQUFDLGVBQWUsRUFBRSxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFBO0FBQzdELEdBQUcsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLEVBQUUsT0FBTyxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQTtBQUNuRSxJQUFNLEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUE7QUFDckQsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUE7QUFDekIsTUFBTSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUE7OztBQ3ZDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDWEEsSUFBSSxNQUFNLEdBQUc7QUFDWCxLQUFHLEVBQUUsYUFBYTtBQUNsQixLQUFHLEVBQUU7QUFDSCxZQUFRLEVBQUUsd0NBQXdDO0FBQ2xELGtCQUFjLEVBQUU7QUFDZCxhQUFPLEVBQUU7QUFDUCwwQkFBa0IsRUFBRSxTQUFTO0FBQzdCLHNCQUFjLEVBQUUsa0JBQWtCO09BQ25DO0tBQ0Y7R0FDRjtBQUNELFFBQU0sRUFBRTtBQUNOLFlBQVEsRUFBRSxFQUFFO0FBQ1osV0FBTyxFQUFFLEVBQUU7QUFDWCxVQUFNLEVBQUUsRUFBRTtHQUNYO0FBQ0QsT0FBSyxFQUFFLElBQUk7Q0FDWixDQUFBOztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFBOzs7Ozs7QUNuQnZCLElBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxJQUFJLGFBQWEsQ0FBQTs7QUFFOUMsSUFBSSxNQUFNLEdBQUc7QUFDWCxhQUFXLEVBQUUsT0FBTyxDQUFDLHNCQUFzQixDQUFDO0FBQzVDLFlBQVUsRUFBRSxPQUFPLENBQUMscUJBQXFCLENBQUM7QUFDMUMsU0FBTyxFQUFFLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQztDQUNyQyxDQUFBOztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFBOzs7Ozs7O0FDUjVCLElBQUksTUFBTSxHQUFHO0FBQ1gsS0FBRyxFQUFFLFlBQVk7QUFDakIsS0FBRyxFQUFFO0FBQ0gsWUFBUSxFQUFFLDZCQUE2QjtBQUN2QyxrQkFBYyxFQUFFO0FBQ2QsYUFBTyxFQUFFO0FBQ1AsMEJBQWtCLEVBQUUsU0FBUztBQUM3QixzQkFBYyxFQUFFLGtCQUFrQjtPQUNuQztLQUNGO0dBQ0Y7QUFDRCxRQUFNLEVBQUU7QUFDTixZQUFRLEVBQUUsRUFBRTtBQUNaLFdBQU8sRUFBRSxFQUFFO0FBQ1gsVUFBTSxFQUFFLEVBQUU7R0FDWDtBQUNELE9BQUssRUFBRSxLQUFLO0NBQ2IsQ0FBQTs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQTs7Ozs7QUNuQnZCLElBQUksTUFBTSxHQUFHO0FBQ1gsS0FBRyxFQUFFLFNBQVM7QUFDZCxLQUFHLEVBQUU7QUFDSCxZQUFRLEVBQUUscUNBQXFDO0FBQy9DLGtCQUFjLEVBQUU7QUFDZCxhQUFPLEVBQUU7QUFDUCwwQkFBa0IsRUFBRSxTQUFTO0FBQzdCLHNCQUFjLEVBQUUsa0JBQWtCO09BQ25DO0tBQ0Y7R0FDRjtBQUNELFFBQU0sRUFBRTtBQUNOLFlBQVEsRUFBRSxFQUFFO0FBQ1osV0FBTyxFQUFFLEVBQUU7QUFDWCxVQUFNLEVBQUUsRUFBRTtHQUNYO0FBQ0QsT0FBSyxFQUFFLElBQUk7Q0FDWixDQUFBO0FBQ0QsTUFBTSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUE7Ozs7O0FDbEJ2QixBQUFDLENBQUEsVUFBVSxNQUFNLEVBQUU7QUFDbEIsYUFBWSxDQUFDOztBQUViLE9BQU0sQ0FBQyxVQUFVLE9BQU8sRUFBRTs7QUFFekIsTUFBSSxXQUFXLENBQUM7O0FBRWhCLGFBQVcsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQzs7Ozs7Ozs7OztBQVUxQyxTQUFPLFdBQVcsQ0FBQztBQUNsQixVQUFPLEVBQUUsaUJBQVUsUUFBTyxFQUFFLE1BQU0sRUFBRTtBQUNuQyxRQUFJLEtBQUssRUFBRSxPQUFPLENBQUM7O0FBRW5CLFNBQUssR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQzFDLFdBQU8sR0FBRyxRQUFPLENBQUMsT0FBTyxLQUFLLFFBQU8sQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFBLEFBQUMsQ0FBQzs7QUFFcEQsUUFBSyxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxXQUFXLEVBQUU7QUFDN0MsWUFBTyxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7S0FDOUI7O0FBRUUsV0FBTyxRQUFPLENBQUM7SUFDbEI7QUFDRCxXQUFRLEVBQUUsa0JBQVUsU0FBUSxFQUFFO0FBQzdCLFFBQUksU0FBUSxDQUFDLE1BQU0sSUFBSSxTQUFRLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxHQUFHLEVBQUU7QUFDbkQsaUJBQVksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUM7S0FDckM7QUFDRCxRQUFJLFNBQVEsQ0FBQyxPQUFPLElBQUksU0FBUSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUU7QUFDdkQsaUJBQVksQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLFNBQVEsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUE7S0FDakU7QUFDRCxRQUFJLFNBQVEsQ0FBQyxNQUFNLElBQUksU0FBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLElBQUksU0FBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLEVBQUUsRUFBRTtBQUNsRixpQkFBWSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsU0FBUyxHQUFHLFNBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDckU7QUFDRCxXQUFPLFNBQVEsQ0FBQztJQUNoQjtHQUNELENBQUMsQ0FBQztFQUVILENBQUMsQ0FBQztDQUVILENBQUEsQ0FDQSxPQUFPLE1BQU0sS0FBSyxVQUFVLElBQUksTUFBTSxDQUFDLEdBQUcsR0FBRyxNQUFNLEdBQUcsVUFBVSxPQUFPLEVBQUU7QUFBRSxPQUFNLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUFFOztDQUUvRyxDQUFFOzs7OztBQ2pESCxNQUFNLENBQUMsT0FBTyxHQUFHOztBQUVmLGNBQVksRUFBRSxzQkFBVSxNQUFNLEVBQUU7O0FBRTlCLFVBQU0sQ0FBQyxHQUFHLENBQUM7QUFDVCxhQUFPLEVBQUU7QUFDUCxpQkFBUyxFQUFFLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztBQUMvQyxpQkFBUyxFQUFFO0FBQ1Qsb0JBQVUsRUFBRTtBQUNWLHFCQUFTLEVBQUUsT0FBTyxDQUFDLG1DQUFtQyxDQUFDO0FBQ3ZELGdCQUFJLEVBQUUsSUFBSTtXQUNYO0FBQ0QsbUJBQVMsRUFBRTtBQUNULHFCQUFTLEVBQUUsT0FBTyxDQUFDLGtDQUFrQyxDQUFDO0FBQ3RELGdCQUFJLEVBQUUsSUFBSTtXQUNYO1NBQ0Y7T0FDRjtBQUNELFdBQUssRUFBRTtBQUNMLGlCQUFTLEVBQUUsT0FBTyxDQUFDLHlCQUF5QixDQUFDO0FBQzdDLGlCQUFTLEVBQUU7QUFDVCxhQUFHLEVBQUU7QUFDSCxxQkFBUyxFQUFFLE9BQU8sQ0FBQyw0QkFBNEIsQ0FBQztXQUNqRDtBQUNDLGVBQUssRUFBRTtBQUNILHFCQUFTLEVBQUUsT0FBTyxDQUFDLDRCQUE0QixDQUFDO1dBQ25EO0FBQ0gsb0JBQVUsRUFBRTtBQUNWLHFCQUFTLEVBQUUsT0FBTyxDQUFDLGlDQUFpQyxDQUFDO1dBQ3REO0FBQ0QsaUJBQU8sRUFBRTtBQUNQLHFCQUFTLEVBQUUsT0FBTyxDQUFDLDhCQUE4QixDQUFDO1dBQ25EO0FBQ0MseUJBQWUsRUFBRTtBQUNiLHFCQUFTLEVBQUUsT0FBTyxDQUFDLHNDQUFzQyxDQUFDO1dBQzdEO1NBQ0o7T0FDRjtBQUNELGFBQU8sRUFBRTtBQUNQLGlCQUFTLEVBQUUsT0FBTyxDQUFDLDJCQUEyQixDQUFDO0FBQy9DLFlBQUksRUFBRSxJQUFJO0FBQ1YsaUJBQVMsRUFBRTtBQUNULGFBQUcsRUFBRTtBQUNILHFCQUFTLEVBQUUsT0FBTyxDQUFDLGlDQUFpQyxDQUFDO1dBQ3REO0FBQ0QsZ0JBQU0sRUFBRTtBQUNOLHFCQUFTLEVBQUUsT0FBTyxDQUFDLGdDQUFnQyxDQUFDO1dBQ3JEO0FBQ0QsbUJBQVMsRUFBRTtBQUNULHFCQUFTLEVBQUUsT0FBTyxDQUFDLGtDQUFrQyxDQUFDO1dBQ3ZEO1NBQ0Y7T0FDRjtBQUNELGNBQVEsRUFBRTtBQUNSLGlCQUFTLEVBQUUsT0FBTyxDQUFDLDRCQUE0QixDQUFDO0FBQ2hELGFBQUssRUFBRSxJQUFJO09BQ1o7QUFDQyxpQkFBVyxFQUFFO0FBQ1QsaUJBQVMsRUFBRSxPQUFPLENBQUMsK0JBQStCLENBQUM7QUFDbkQsYUFBSyxFQUFFLElBQUk7T0FDZDtBQUNILGlCQUFXLEVBQUU7QUFDWCxpQkFBUyxFQUFFLE9BQU8sQ0FBQywrQkFBK0IsQ0FBQztPQUNwRDtBQUNELGNBQVEsRUFBRTtBQUNSLGlCQUFTLEVBQUUsT0FBTyxDQUFDLDRCQUE0QixDQUFDO09BQ2pEO0FBQ0Qsb0JBQWMsRUFBRTtBQUNkLGlCQUFTLEVBQUUsT0FBTyxDQUFDLGtDQUFrQyxDQUFDO09BQ3ZEO0FBQ0QsYUFBTyxFQUFFO0FBQ1AsaUJBQVMsRUFBRSxPQUFPLENBQUMsMkJBQTJCLENBQUM7T0FDaEQ7QUFDRCxTQUFHLEVBQUU7QUFDSCxpQkFBUyxFQUFFLE9BQU8sQ0FBQywwQkFBMEIsQ0FBQztPQUMvQztLQUNGLENBQUMsQ0FBQTs7QUFFRixVQUFNLENBQUMsS0FBSyxDQUFDO0FBQ1gsUUFBRSxFQUFFLE9BQU87QUFDWCxhQUFPLEVBQUUsUUFBUTtLQUNsQixDQUFDLENBQUE7O0FBRUYsVUFBTSxDQUFDLFVBQVUsQ0FBQyxVQUFVLFVBQVUsRUFBRTs7QUFFdEMsVUFBSSxLQUFLLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQTtBQUM3QyxVQUFJLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFO0FBQ3RCLFlBQUksQ0FBQyxLQUFLLElBQUksS0FBSyxLQUFLLElBQUksRUFBRTtBQUM1QixvQkFBVSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQTtTQUNuQztPQUNGO0FBQ0QsVUFBSSxVQUFVLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRTtBQUN2QixZQUFJLEtBQUssRUFBRTtBQUNULG9CQUFVLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFBO1NBQ3pCO09BQ0Y7QUFDRCxnQkFBVSxDQUFDLElBQUksRUFBRSxDQUFBO0tBQ2xCLENBQUMsQ0FBQTtHQUNIO0NBQ0YsQ0FBQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDEzIHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSwgbG9jYXRpb24pIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciB1bmRlZjtcblxuXHRkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHRcdHZhciBtaXhpbiwgb3JpZ2luLCB1cmxSRSwgYWJzb2x1dGVVcmxSRSwgZnVsbHlRdWFsaWZpZWRVcmxSRTtcblxuXHRcdG1peGluID0gcmVxdWlyZSgnLi91dGlsL21peGluJyk7XG5cblx0XHR1cmxSRSA9IC8oW2Etel1bYS16MC05XFwrXFwtXFwuXSo6KVxcL1xcLyhbXkBdK0ApPygoW146XFwvXSspKDooWzAtOV0rKSk/KT8oXFwvW14/I10qKT8oXFw/W14jXSopPygjXFxTKik/L2k7XG5cdFx0YWJzb2x1dGVVcmxSRSA9IC9eKFthLXpdW2EtejAtOVxcLVxcK1xcLl0qOlxcL1xcL3xcXC8pL2k7XG5cdFx0ZnVsbHlRdWFsaWZpZWRVcmxSRSA9IC8oW2Etel1bYS16MC05XFwrXFwtXFwuXSo6KVxcL1xcLyhbXkBdK0ApPygoW146XFwvXSspKDooWzAtOV0rKSk/KT9cXC8vaTtcblxuXHRcdC8qKlxuXHRcdCAqIEFwcGx5IHBhcmFtcyB0byB0aGUgdGVtcGxhdGUgdG8gY3JlYXRlIGEgVVJMLlxuXHRcdCAqXG5cdFx0ICogUGFyYW1ldGVycyB0aGF0IGFyZSBub3QgYXBwbGllZCBkaXJlY3RseSB0byB0aGUgdGVtcGxhdGUsIGFyZSBhcHBlbmRlZFxuXHRcdCAqIHRvIHRoZSBVUkwgYXMgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgdGhlIFVSSSB0ZW1wbGF0ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVycyB0byBhcHBseSB0byB0aGUgdGVtcGxhdGVcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSByZXN1bHRpbmcgVVJMXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gYnVpbGRVcmwodGVtcGxhdGUsIHBhcmFtcykge1xuXHRcdFx0Ly8gaW50ZXJuYWwgYnVpbGRlciB0byBjb252ZXJ0IHRlbXBsYXRlIHdpdGggcGFyYW1zLlxuXHRcdFx0dmFyIHVybCwgbmFtZSwgcXVlcnlTdHJpbmdQYXJhbXMsIHJlO1xuXG5cdFx0XHR1cmwgPSB0ZW1wbGF0ZTtcblx0XHRcdHF1ZXJ5U3RyaW5nUGFyYW1zID0ge307XG5cblx0XHRcdGlmIChwYXJhbXMpIHtcblx0XHRcdFx0Zm9yIChuYW1lIGluIHBhcmFtcykge1xuXHRcdFx0XHRcdC8qanNoaW50IGZvcmluOmZhbHNlICovXG5cdFx0XHRcdFx0cmUgPSBuZXcgUmVnRXhwKCdcXFxceycgKyBuYW1lICsgJ1xcXFx9Jyk7XG5cdFx0XHRcdFx0aWYgKHJlLnRlc3QodXJsKSkge1xuXHRcdFx0XHRcdFx0dXJsID0gdXJsLnJlcGxhY2UocmUsIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNbbmFtZV0pLCAnZycpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHF1ZXJ5U3RyaW5nUGFyYW1zW25hbWVdID0gcGFyYW1zW25hbWVdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKG5hbWUgaW4gcXVlcnlTdHJpbmdQYXJhbXMpIHtcblx0XHRcdFx0XHR1cmwgKz0gdXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJic7XG5cdFx0XHRcdFx0dXJsICs9IGVuY29kZVVSSUNvbXBvbmVudChuYW1lKTtcblx0XHRcdFx0XHRpZiAocXVlcnlTdHJpbmdQYXJhbXNbbmFtZV0gIT09IG51bGwgJiYgcXVlcnlTdHJpbmdQYXJhbXNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dXJsICs9ICc9Jztcblx0XHRcdFx0XHRcdHVybCArPSBlbmNvZGVVUklDb21wb25lbnQocXVlcnlTdHJpbmdQYXJhbXNbbmFtZV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHVybDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgdGVzdCkge1xuXHRcdFx0cmV0dXJuIHN0ci5pbmRleE9mKHRlc3QpID09PSAwO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBhIG5ldyBVUkwgQnVpbGRlclxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd8VXJsQnVpbGRlcn0gdGVtcGxhdGUgdGhlIGJhc2UgdGVtcGxhdGUgdG8gYnVpbGQgZnJvbSwgbWF5IGJlIGFub3RoZXIgVXJsQnVpbGRlclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSBiYXNlIHBhcmFtZXRlcnNcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBVcmxCdWlsZGVyKHRlbXBsYXRlLCBwYXJhbXMpIHtcblx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmxCdWlsZGVyKSkge1xuXHRcdFx0XHQvLyBpbnZva2UgYXMgYSBjb25zdHJ1Y3RvclxuXHRcdFx0XHRyZXR1cm4gbmV3IFVybEJ1aWxkZXIodGVtcGxhdGUsIHBhcmFtcyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0ZW1wbGF0ZSBpbnN0YW5jZW9mIFVybEJ1aWxkZXIpIHtcblx0XHRcdFx0dGhpcy5fdGVtcGxhdGUgPSB0ZW1wbGF0ZS50ZW1wbGF0ZTtcblx0XHRcdFx0dGhpcy5fcGFyYW1zID0gbWl4aW4oe30sIHRoaXMuX3BhcmFtcywgcGFyYW1zKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLl90ZW1wbGF0ZSA9ICh0ZW1wbGF0ZSB8fCAnJykudG9TdHJpbmcoKTtcblx0XHRcdFx0dGhpcy5fcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdFVybEJ1aWxkZXIucHJvdG90eXBlID0ge1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIENyZWF0ZSBhIG5ldyBVcmxCdWlsZGVyIGluc3RhbmNlIHRoYXQgZXh0ZW5kcyB0aGUgY3VycmVudCBidWlsZGVyLlxuXHRcdFx0ICogVGhlIGN1cnJlbnQgYnVpbGRlciBpcyB1bm1vZGlmaWVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBbdGVtcGxhdGVdIFVSTCB0ZW1wbGF0ZSB0byBhcHBlbmQgdG8gdGhlIGN1cnJlbnQgdGVtcGxhdGVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSBwYXJhbXMgdG8gY29tYmluZSB3aXRoIGN1cnJlbnQgcGFyYW1zLiAgTmV3IHBhcmFtcyBvdmVycmlkZSBleGlzdGluZyBwYXJhbXNcblx0XHRcdCAqIEByZXR1cm4ge1VybEJ1aWxkZXJ9IHRoZSBuZXcgYnVpbGRlclxuXHRcdFx0ICovXG5cdFx0XHRhcHBlbmQ6IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgIHBhcmFtcykge1xuXHRcdFx0XHQvLyBUT0RPIGNvbnNpZGVyIHF1ZXJ5IHN0cmluZ3MgYW5kIGZyYWdtZW50c1xuXHRcdFx0XHRyZXR1cm4gbmV3IFVybEJ1aWxkZXIodGhpcy5fdGVtcGxhdGUgKyB0ZW1wbGF0ZSwgbWl4aW4oe30sIHRoaXMuX3BhcmFtcywgcGFyYW1zKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIENyZWF0ZSBhIG5ldyBVcmxCdWlsZGVyIHdpdGggYSBmdWxseSBxdWFsaWZpZWQgVVJMIGJhc2VkIG9uIHRoZVxuXHRcdFx0ICogd2luZG93J3MgbG9jYXRpb24gb3IgYmFzZSBocmVmIGFuZCB0aGUgY3VycmVudCB0ZW1wbGF0ZXMgcmVsYXRpdmUgVVJMLlxuXHRcdFx0ICpcblx0XHRcdCAqIFBhdGggdmFyaWFibGVzIGFyZSBwcmVzZXJ2ZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogKkJyb3dzZXIgb25seSpcblx0XHRcdCAqXG5cdFx0XHQgKiBAcmV0dXJuIHtVcmxCdWlsZGVyfSB0aGUgZnVsbHkgcXVhbGlmaWVkIFVSTCB0ZW1wbGF0ZVxuXHRcdFx0ICovXG5cdFx0XHRmdWxseVF1YWxpZnk6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKCFsb2NhdGlvbikgeyByZXR1cm4gdGhpczsgfVxuXHRcdFx0XHRpZiAodGhpcy5pc0Z1bGx5UXVhbGlmaWVkKCkpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdFx0XHR2YXIgdGVtcGxhdGUgPSB0aGlzLl90ZW1wbGF0ZTtcblxuXHRcdFx0XHRpZiAoc3RhcnRzV2l0aCh0ZW1wbGF0ZSwgJy8vJykpIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZSA9IG9yaWdpbi5wcm90b2NvbCArIHRlbXBsYXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHN0YXJ0c1dpdGgodGVtcGxhdGUsICcvJykpIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZSA9IG9yaWdpbi5vcmlnaW4gKyB0ZW1wbGF0ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICghdGhpcy5pc0Fic29sdXRlKCkpIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZSA9IG9yaWdpbi5vcmlnaW4gKyBvcmlnaW4ucGF0aG5hbWUuc3Vic3RyaW5nKDAsIG9yaWdpbi5wYXRobmFtZS5sYXN0SW5kZXhPZignLycpICsgMSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGVtcGxhdGUuaW5kZXhPZignLycsIDgpID09PSAtMSkge1xuXHRcdFx0XHRcdC8vIGRlZmF1bHQgdGhlIHBhdGhuYW1lIHRvICcvJ1xuXHRcdFx0XHRcdHRlbXBsYXRlID0gdGVtcGxhdGUgKyAnLyc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbmV3IFVybEJ1aWxkZXIodGVtcGxhdGUsIHRoaXMuX3BhcmFtcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRydWUgaWYgdGhlIFVSTCBpcyBhYnNvbHV0ZVxuXHRcdFx0ICpcblx0XHRcdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdFx0XHQgKi9cblx0XHRcdGlzQWJzb2x1dGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGFic29sdXRlVXJsUkUudGVzdCh0aGlzLmJ1aWxkKCkpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUcnVlIGlmIHRoZSBVUkwgaXMgZnVsbHkgcXVhbGlmaWVkXG5cdFx0XHQgKlxuXHRcdFx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0XHRcdCAqL1xuXHRcdFx0aXNGdWxseVF1YWxpZmllZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gZnVsbHlRdWFsaWZpZWRVcmxSRS50ZXN0KHRoaXMuYnVpbGQoKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRydWUgaWYgdGhlIFVSTCBpcyBjcm9zcyBvcmlnaW4uIFRoZSBwcm90b2NvbCwgaG9zdCBhbmQgcG9ydCBtdXN0IG5vdCBiZVxuXHRcdFx0ICogdGhlIHNhbWUgaW4gb3JkZXIgdG8gYmUgY3Jvc3Mgb3JpZ2luLFxuXHRcdFx0ICpcblx0XHRcdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdFx0XHQgKi9cblx0XHRcdGlzQ3Jvc3NPcmlnaW46IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKCFvcmlnaW4pIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgdXJsID0gdGhpcy5wYXJ0cygpO1xuXHRcdFx0XHRyZXR1cm4gdXJsLnByb3RvY29sICE9PSBvcmlnaW4ucHJvdG9jb2wgfHxcblx0XHRcdFx0ICAgICAgIHVybC5ob3N0bmFtZSAhPT0gb3JpZ2luLmhvc3RuYW1lIHx8XG5cdFx0XHRcdCAgICAgICB1cmwucG9ydCAhPT0gb3JpZ2luLnBvcnQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNwbGl0IGEgVVJMIGludG8gaXRzIGNvbnNpdHVlbnQgcGFydHMgZm9sbG93aW5nIHRoZSBuYW1pbmcgY29udmVudGlvbiBvZlxuXHRcdFx0ICogJ3dpbmRvdy5sb2NhdGlvbicuIE9uZSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhlIHBvcnQgd2lsbCBjb250YWluIHRoZVxuXHRcdFx0ICogcHJvdG9jb2wgZGVmYXVsdCBpZiBub3Qgc3BlY2lmaWVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vd2luZG93LmxvY2F0aW9uXG5cdFx0XHQgKlxuXHRcdFx0ICogQHJldHVybnMge09iamVjdH0gYSAnd2luZG93LmxvY2F0aW9uJy1saWtlIG9iamVjdFxuXHRcdFx0ICovXG5cdFx0XHRwYXJ0czogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvKmpzaGludCBtYXhjb21wbGV4aXR5OjIwICovXG5cdFx0XHRcdHZhciB1cmwsIHBhcnRzO1xuXHRcdFx0XHR1cmwgPSB0aGlzLmZ1bGx5UXVhbGlmeSgpLmJ1aWxkKCkubWF0Y2godXJsUkUpO1xuXHRcdFx0XHRwYXJ0cyA9IHtcblx0XHRcdFx0XHRocmVmOiB1cmxbMF0sXG5cdFx0XHRcdFx0cHJvdG9jb2w6IHVybFsxXSxcblx0XHRcdFx0XHRob3N0OiB1cmxbM10gfHwgJycsXG5cdFx0XHRcdFx0aG9zdG5hbWU6IHVybFs0XSB8fCAnJyxcblx0XHRcdFx0XHRwb3J0OiB1cmxbNl0sXG5cdFx0XHRcdFx0cGF0aG5hbWU6IHVybFs3XSB8fCAnJyxcblx0XHRcdFx0XHRzZWFyY2g6IHVybFs4XSB8fCAnJyxcblx0XHRcdFx0XHRoYXNoOiB1cmxbOV0gfHwgJydcblx0XHRcdFx0fTtcblx0XHRcdFx0cGFydHMub3JpZ2luID0gcGFydHMucHJvdG9jb2wgKyAnLy8nICsgcGFydHMuaG9zdDtcblx0XHRcdFx0cGFydHMucG9ydCA9IHBhcnRzLnBvcnQgfHwgKHBhcnRzLnByb3RvY29sID09PSAnaHR0cHM6JyA/ICc0NDMnIDogcGFydHMucHJvdG9jb2wgPT09ICdodHRwOicgPyAnODAnIDogJycpO1xuXHRcdFx0XHRyZXR1cm4gcGFydHM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEV4cGFuZCB0aGUgdGVtcGxhdGUgcmVwbGFjaW5nIHBhdGggdmFyaWFibGVzIHdpdGggcGFyYW1ldGVyc1xuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSBwYXJhbXMgdG8gY29tYmluZSB3aXRoIGN1cnJlbnQgcGFyYW1zLiAgTmV3IHBhcmFtcyBvdmVycmlkZSBleGlzdGluZyBwYXJhbXNcblx0XHRcdCAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGV4cGFuZGVkIFVSTFxuXHRcdFx0ICovXG5cdFx0XHRidWlsZDogZnVuY3Rpb24gKHBhcmFtcykge1xuXHRcdFx0XHRyZXR1cm4gYnVpbGRVcmwodGhpcy5fdGVtcGxhdGUsIG1peGluKHt9LCB0aGlzLl9wYXJhbXMsIHBhcmFtcykpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAc2VlIGJ1aWxkXG5cdFx0XHQgKi9cblx0XHRcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmJ1aWxkKCk7XG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0b3JpZ2luID0gbG9jYXRpb24gPyBuZXcgVXJsQnVpbGRlcihsb2NhdGlvbi5ocmVmKS5wYXJ0cygpIDogdW5kZWY7XG5cblx0XHRyZXR1cm4gVXJsQnVpbGRlcjtcblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfSxcblx0dHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24gOiB2b2lkIDBcblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTQgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHRcdHZhciByZXN0ID0gcmVxdWlyZSgnLi9jbGllbnQvZGVmYXVsdCcpLFxuXHRcdCAgICBicm93c2VyID0gcmVxdWlyZSgnLi9jbGllbnQveGhyJyk7XG5cblx0XHRyZXN0LnNldFBsYXRmb3JtRGVmYXVsdENsaWVudChicm93c2VyKTtcblxuXHRcdHJldHVybiByZXN0O1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTQgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKC8qIHJlcXVpcmUgKi8pIHtcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBjb21tb24gaGVscGVyIG1ldGhvZHMgdG8gYSBjbGllbnQgaW1wbFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gaW1wbCB0aGUgY2xpZW50IGltcGxlbWVudGF0aW9uXG5cdFx0ICogQHBhcmFtIHtDbGllbnR9IFt0YXJnZXRdIHRhcmdldCBvZiB0aGlzIGNsaWVudCwgdXNlZCB3aGVuIHdyYXBwaW5nIG90aGVyIGNsaWVudHNcblx0XHQgKiBAcmV0dXJucyB7Q2xpZW50fSB0aGUgY2xpZW50IGltcGwgd2l0aCBhZGRpdGlvbmFsIG1ldGhvZHNcblx0XHQgKi9cblx0XHRyZXR1cm4gZnVuY3Rpb24gY2xpZW50KGltcGwsIHRhcmdldCkge1xuXG5cdFx0XHRpZiAodGFyZ2V0KSB7XG5cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEByZXR1cm5zIHtDbGllbnR9IHRoZSB0YXJnZXQgY2xpZW50XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRpbXBsLnNraXAgPSBmdW5jdGlvbiBza2lwKCkge1xuXHRcdFx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBbGxvdyBhIGNsaWVudCB0byBlYXNpbHkgYmUgd3JhcHBlZCBieSBhbiBpbnRlcmNlcHRvclxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7SW50ZXJjZXB0b3J9IGludGVyY2VwdG9yIHRoZSBpbnRlcmNlcHRvciB0byB3cmFwIHRoaXMgY2xpZW50IHdpdGhcblx0XHRcdCAqIEBwYXJhbSBbY29uZmlnXSBjb25maWd1cmF0aW9uIGZvciB0aGUgaW50ZXJjZXB0b3Jcblx0XHRcdCAqIEByZXR1cm5zIHtDbGllbnR9IHRoZSBuZXdseSB3cmFwcGVkIGNsaWVudFxuXHRcdFx0ICovXG5cdFx0XHRpbXBsLndyYXAgPSBmdW5jdGlvbiB3cmFwKGludGVyY2VwdG9yLCBjb25maWcpIHtcblx0XHRcdFx0cmV0dXJuIGludGVyY2VwdG9yKGltcGwsIGNvbmZpZyk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBkZXByZWNhdGVkXG5cdFx0XHQgKi9cblx0XHRcdGltcGwuY2hhaW4gPSBmdW5jdGlvbiBjaGFpbigpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdyZXN0LmpzOiBjbGllbnQuY2hhaW4oKSBpcyBkZXByZWNhdGVkLCB1c2UgY2xpZW50LndyYXAoKSBpbnN0ZWFkJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gaW1wbC53cmFwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gaW1wbDtcblxuXHRcdH07XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNCB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciB1bmRlZjtcblxuXHRkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHRcdC8qKlxuXHRcdCAqIFBsYWluIEpTIE9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdGhhdCByZXByZXNlbnQgYW4gSFRUUCByZXF1ZXN0LlxuXHRcdCAqXG5cdFx0ICogRGVwZW5kaW5nIG9uIHRoZSBjYXBhYmlsaXRpZXMgb2YgdGhlIHVuZGVybHlpbmcgY2xpZW50LCBhIHJlcXVlc3Rcblx0XHQgKiBtYXkgYmUgY2FuY2VsYWJsZS4gSWYgYSByZXF1ZXN0IG1heSBiZSBjYW5jZWxlZCwgdGhlIGNsaWVudCB3aWxsIGFkZFxuXHRcdCAqIGEgY2FuY2VsZWQgZmxhZyBhbmQgY2FuY2VsIGZ1bmN0aW9uIHRvIHRoZSByZXF1ZXN0IG9iamVjdC4gQ2FuY2VsaW5nXG5cdFx0ICogdGhlIHJlcXVlc3Qgd2lsbCBwdXQgdGhlIHJlc3BvbnNlIGludG8gYW4gZXJyb3Igc3RhdGUuXG5cdFx0ICpcblx0XHQgKiBAZmllbGQge3N0cmluZ30gW21ldGhvZD0nR0VUJ10gSFRUUCBtZXRob2QsIGNvbW1vbmx5IEdFVCwgUE9TVCwgUFVULCBERUxFVEUgb3IgSEVBRFxuXHRcdCAqIEBmaWVsZCB7c3RyaW5nfFVybEJ1aWxkZXJ9IFtwYXRoPScnXSBwYXRoIHRlbXBsYXRlIHdpdGggb3B0aW9uYWwgcGF0aCB2YXJpYWJsZXNcblx0XHQgKiBAZmllbGQge09iamVjdH0gW3BhcmFtc10gcGFyYW1ldGVycyBmb3IgdGhlIHBhdGggdGVtcGxhdGUgYW5kIHF1ZXJ5IHN0cmluZ1xuXHRcdCAqIEBmaWVsZCB7T2JqZWN0fSBbaGVhZGVyc10gY3VzdG9tIEhUVFAgaGVhZGVycyB0byBzZW5kLCBpbiBhZGRpdGlvbiB0byB0aGUgY2xpZW50cyBkZWZhdWx0IGhlYWRlcnNcblx0XHQgKiBAZmllbGQgW2VudGl0eV0gdGhlIEhUVFAgZW50aXR5LCBjb21tb24gZm9yIFBPU1Qgb3IgUFVUIHJlcXVlc3RzXG5cdFx0ICogQGZpZWxkIHtib29sZWFufSBbY2FuY2VsZWRdIHRydWUgaWYgdGhlIHJlcXVlc3QgaGFzIGJlZW4gY2FuY2VsZWQsIHNldCBieSB0aGUgY2xpZW50XG5cdFx0ICogQGZpZWxkIHtGdW5jdGlvbn0gW2NhbmNlbF0gY2FuY2VscyB0aGUgcmVxdWVzdCBpZiBpbnZva2VkLCBwcm92aWRlZCBieSB0aGUgY2xpZW50XG5cdFx0ICogQGZpZWxkIHtDbGllbnR9IFtvcmlnaW5hdG9yXSB0aGUgY2xpZW50IHRoYXQgZmlyc3QgaGFuZGxlZCB0aGlzIHJlcXVlc3QsIHByb3ZpZGVkIGJ5IHRoZSBpbnRlcmNlcHRvclxuXHRcdCAqXG5cdFx0ICogQGNsYXNzIFJlcXVlc3Rcblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIFBsYWluIEpTIE9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdGhhdCByZXByZXNlbnQgYW4gSFRUUCByZXNwb25zZVxuXHRcdCAqXG5cdFx0ICogQGZpZWxkIHtPYmplY3R9IFtyZXF1ZXN0XSB0aGUgcmVxdWVzdCBvYmplY3QgYXMgcmVjZWl2ZWQgYnkgdGhlIHJvb3QgY2xpZW50XG5cdFx0ICogQGZpZWxkIHtPYmplY3R9IFtyYXddIHRoZSB1bmRlcmx5aW5nIHJlcXVlc3Qgb2JqZWN0LCBsaWtlIFhtbEh0dHBSZXF1ZXN0IGluIGEgYnJvd3NlclxuXHRcdCAqIEBmaWVsZCB7bnVtYmVyfSBbc3RhdHVzLmNvZGVdIHN0YXR1cyBjb2RlIG9mIHRoZSByZXNwb25zZSAoaS5lLiAyMDAsIDQwNClcblx0XHQgKiBAZmllbGQge3N0cmluZ30gW3N0YXR1cy50ZXh0XSBzdGF0dXMgcGhyYXNlIG9mIHRoZSByZXNwb25zZVxuXHRcdCAqIEBmaWVsZCB7T2JqZWN0XSBbaGVhZGVyc10gcmVzcG9uc2UgaGVhZGVycyBoYXNoIG9mIG5vcm1hbGl6ZWQgbmFtZSwgdmFsdWUgcGFpcnNcblx0XHQgKiBAZmllbGQgW2VudGl0eV0gdGhlIHJlc3BvbnNlIGJvZHlcblx0XHQgKlxuXHRcdCAqIEBjbGFzcyBSZXNwb25zZVxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogSFRUUCBjbGllbnQgcGFydGljdWxhcmx5IHN1aXRlZCBmb3IgUkVTVGZ1bCBvcGVyYXRpb25zLlxuXHRcdCAqXG5cdFx0ICogQGZpZWxkIHtmdW5jdGlvbn0gd3JhcCB3cmFwcyB0aGlzIGNsaWVudCB3aXRoIGEgbmV3IGludGVyY2VwdG9yIHJldHVybmluZyB0aGUgd3JhcHBlZCBjbGllbnRcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7UmVxdWVzdH0gdGhlIEhUVFAgcmVxdWVzdFxuXHRcdCAqIEByZXR1cm5zIHtSZXNwb25zZVByb21pc2U8UmVzcG9uc2U+fSBhIHByb21pc2UgdGhlIHJlc29sdmVzIHRvIHRoZSBIVFRQIHJlc3BvbnNlXG5cdFx0ICpcblx0XHQgKiBAY2xhc3MgQ2xpZW50XG5cdFx0ICovXG5cblx0XHQgLyoqXG5cdFx0ICAqIEV4dGVuZGVkIHdoZW4uanMgUHJvbWlzZXMvQSsgcHJvbWlzZSB3aXRoIEhUVFAgc3BlY2lmaWMgaGVscGVyc1xuXHRcdCAgKnFcblx0XHQgICogQG1ldGhvZCBlbnRpdHkgcHJvbWlzZSBmb3IgdGhlIEhUVFAgZW50aXR5XG5cdFx0ICAqIEBtZXRob2Qgc3RhdHVzIHByb21pc2UgZm9yIHRoZSBIVFRQIHN0YXR1cyBjb2RlXG5cdFx0ICAqIEBtZXRob2QgaGVhZGVycyBwcm9taXNlIGZvciB0aGUgSFRUUCByZXNwb25zZSBoZWFkZXJzXG5cdFx0ICAqIEBtZXRob2QgaGVhZGVyIHByb21pc2UgZm9yIGEgc3BlY2lmaWMgSFRUUCByZXNwb25zZSBoZWFkZXJcblx0XHQgICpcblx0XHQgICogQGNsYXNzIFJlc3BvbnNlUHJvbWlzZVxuXHRcdCAgKiBAZXh0ZW5kcyBQcm9taXNlXG5cdFx0ICAqL1xuXG5cdFx0dmFyIGNsaWVudCwgdGFyZ2V0LCBwbGF0Zm9ybURlZmF1bHQ7XG5cblx0XHRjbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQnKTtcblxuXHRcdC8qKlxuXHRcdCAqIE1ha2UgYSByZXF1ZXN0IHdpdGggdGhlIGRlZmF1bHQgY2xpZW50XG5cdFx0ICogQHBhcmFtIHtSZXF1ZXN0fSB0aGUgSFRUUCByZXF1ZXN0XG5cdFx0ICogQHJldHVybnMge1Byb21pc2U8UmVzcG9uc2U+fSBhIHByb21pc2UgdGhlIHJlc29sdmVzIHRvIHRoZSBIVFRQIHJlc3BvbnNlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZGVmYXVsdENsaWVudCgpIHtcblx0XHRcdHJldHVybiB0YXJnZXQuYXBwbHkodW5kZWYsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQ2hhbmdlIHRoZSBkZWZhdWx0IGNsaWVudFxuXHRcdCAqIEBwYXJhbSB7Q2xpZW50fSBjbGllbnQgdGhlIG5ldyBkZWZhdWx0IGNsaWVudFxuXHRcdCAqL1xuXHRcdGRlZmF1bHRDbGllbnQuc2V0RGVmYXVsdENsaWVudCA9IGZ1bmN0aW9uIHNldERlZmF1bHRDbGllbnQoY2xpZW50KSB7XG5cdFx0XHR0YXJnZXQgPSBjbGllbnQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIE9idGFpbiBhIGRpcmVjdCByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZGVmYXVsdCBjbGllbnRcblx0XHQgKiBAcmV0dXJucyB7Q2xpZW50fSB0aGUgZGVmYXVsdCBjbGllbnRcblx0XHQgKi9cblx0XHRkZWZhdWx0Q2xpZW50LmdldERlZmF1bHRDbGllbnQgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2xpZW50KCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVzZXQgdGhlIGRlZmF1bHQgY2xpZW50IHRvIHRoZSBwbGF0Zm9ybSBkZWZhdWx0XG5cdFx0ICovXG5cdFx0ZGVmYXVsdENsaWVudC5yZXNldERlZmF1bHRDbGllbnQgPSBmdW5jdGlvbiByZXNldERlZmF1bHRDbGllbnQoKSB7XG5cdFx0XHR0YXJnZXQgPSBwbGF0Zm9ybURlZmF1bHQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0ZGVmYXVsdENsaWVudC5zZXRQbGF0Zm9ybURlZmF1bHRDbGllbnQgPSBmdW5jdGlvbiBzZXRQbGF0Zm9ybURlZmF1bHRDbGllbnQoY2xpZW50KSB7XG5cdFx0XHRpZiAocGxhdGZvcm1EZWZhdWx0KSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlZGVmaW5lIHBsYXRmb3JtRGVmYXVsdENsaWVudCcpO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0ID0gcGxhdGZvcm1EZWZhdWx0ID0gY2xpZW50O1xuXHRcdH07XG5cblx0XHRyZXR1cm4gY2xpZW50KGRlZmF1bHRDbGllbnQpO1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTItMjAxNCB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUsIGdsb2JhbCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0XHR2YXIgd2hlbiwgVXJsQnVpbGRlciwgbm9ybWFsaXplSGVhZGVyTmFtZSwgcmVzcG9uc2VQcm9taXNlLCBjbGllbnQsIGhlYWRlclNwbGl0UkU7XG5cblx0XHR3aGVuID0gcmVxdWlyZSgnd2hlbicpO1xuXHRcdFVybEJ1aWxkZXIgPSByZXF1aXJlKCcuLi9VcmxCdWlsZGVyJyk7XG5cdFx0bm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4uL3V0aWwvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xuXHRcdHJlc3BvbnNlUHJvbWlzZSA9IHJlcXVpcmUoJy4uL3V0aWwvcmVzcG9uc2VQcm9taXNlJyk7XG5cdFx0Y2xpZW50ID0gcmVxdWlyZSgnLi4vY2xpZW50Jyk7XG5cblx0XHQvLyBhY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHRoZSBsaW5lIGJyZWFrIGlzICdcXHJcXG4nLCBidXQgZG9lc24ndCBob2xkIHRydWUgaW4gcHJhY3RpY2Vcblx0XHRoZWFkZXJTcGxpdFJFID0gL1tcXHJ8XFxuXSsvO1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhdykge1xuXHRcdFx0Ly8gTm90ZTogU2V0LUNvb2tpZSB3aWxsIGJlIHJlbW92ZWQgYnkgdGhlIGJyb3dzZXJcblx0XHRcdHZhciBoZWFkZXJzID0ge307XG5cblx0XHRcdGlmICghcmF3KSB7IHJldHVybiBoZWFkZXJzOyB9XG5cblx0XHRcdHJhdy50cmltKCkuc3BsaXQoaGVhZGVyU3BsaXRSRSkuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG5cdFx0XHRcdHZhciBib3VuZGFyeSwgbmFtZSwgdmFsdWU7XG5cdFx0XHRcdGJvdW5kYXJ5ID0gaGVhZGVyLmluZGV4T2YoJzonKTtcblx0XHRcdFx0bmFtZSA9IG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVyLnN1YnN0cmluZygwLCBib3VuZGFyeSkudHJpbSgpKTtcblx0XHRcdFx0dmFsdWUgPSBoZWFkZXIuc3Vic3RyaW5nKGJvdW5kYXJ5ICsgMSkudHJpbSgpO1xuXHRcdFx0XHRpZiAoaGVhZGVyc1tuYW1lXSkge1xuXHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnNbbmFtZV0pKSB7XG5cdFx0XHRcdFx0XHQvLyBhZGQgdG8gYW4gZXhpc3RpbmcgYXJyYXlcblx0XHRcdFx0XHRcdGhlYWRlcnNbbmFtZV0ucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gY29udmVydCBzaW5nbGUgdmFsdWUgdG8gYXJyYXlcblx0XHRcdFx0XHRcdGhlYWRlcnNbbmFtZV0gPSBbaGVhZGVyc1tuYW1lXSwgdmFsdWVdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBuZXcsIHNpbmdsZSB2YWx1ZVxuXHRcdFx0XHRcdGhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBoZWFkZXJzO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNhZmVNaXhpbih0YXJnZXQsIHNvdXJjZSkge1xuXHRcdFx0T2JqZWN0LmtleXMoc291cmNlIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG5cdFx0XHRcdC8vIG1ha2Ugc3VyZSB0aGUgcHJvcGVydHkgYWxyZWFkeSBleGlzdHMgYXNcblx0XHRcdFx0Ly8gSUUgNiB3aWxsIGJsb3cgdXAgaWYgd2UgYWRkIGEgbmV3IHByb3Bcblx0XHRcdFx0aWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBwcm9wIGluIHRhcmdldCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHQvLyBpZ25vcmUsIGV4cGVjdGVkIGZvciBzb21lIHByb3BlcnRpZXMgYXQgc29tZSBwb2ludHMgaW4gdGhlIHJlcXVlc3QgbGlmZWN5Y2xlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2xpZW50KGZ1bmN0aW9uIHhocihyZXF1ZXN0KSB7XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VQcm9taXNlLnByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0XHQvKmpzaGludCBtYXhjb21wbGV4aXR5OjIwICovXG5cblx0XHRcdFx0dmFyIGNsaWVudCwgbWV0aG9kLCB1cmwsIGhlYWRlcnMsIGVudGl0eSwgaGVhZGVyTmFtZSwgcmVzcG9uc2UsIFhNTEh0dHBSZXF1ZXN0O1xuXG5cdFx0XHRcdHJlcXVlc3QgPSB0eXBlb2YgcmVxdWVzdCA9PT0gJ3N0cmluZycgPyB7IHBhdGg6IHJlcXVlc3QgfSA6IHJlcXVlc3QgfHwge307XG5cdFx0XHRcdHJlc3BvbnNlID0geyByZXF1ZXN0OiByZXF1ZXN0IH07XG5cblx0XHRcdFx0aWYgKHJlcXVlc3QuY2FuY2VsZWQpIHtcblx0XHRcdFx0XHRyZXNwb25zZS5lcnJvciA9ICdwcmVjYW5jZWxlZCc7XG5cdFx0XHRcdFx0cmVqZWN0KHJlc3BvbnNlKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRYTUxIdHRwUmVxdWVzdCA9IHJlcXVlc3QuZW5naW5lIHx8IGdsb2JhbC5YTUxIdHRwUmVxdWVzdDtcblx0XHRcdFx0aWYgKCFYTUxIdHRwUmVxdWVzdCkge1xuXHRcdFx0XHRcdHJlamVjdCh7IHJlcXVlc3Q6IHJlcXVlc3QsIGVycm9yOiAneGhyLW5vdC1hdmFpbGFibGUnIH0pO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVudGl0eSA9IHJlcXVlc3QuZW50aXR5O1xuXHRcdFx0XHRyZXF1ZXN0Lm1ldGhvZCA9IHJlcXVlc3QubWV0aG9kIHx8IChlbnRpdHkgPyAnUE9TVCcgOiAnR0VUJyk7XG5cdFx0XHRcdG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuXHRcdFx0XHR1cmwgPSBuZXcgVXJsQnVpbGRlcihyZXF1ZXN0LnBhdGggfHwgJycsIHJlcXVlc3QucGFyYW1zKS5idWlsZCgpO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y2xpZW50ID0gcmVzcG9uc2UucmF3ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0XHRcdFx0XHQvLyBtaXhpbiBleHRyYSByZXF1ZXN0IHByb3BlcnRpZXMgYmVmb3JlIGFuZCBhZnRlciBvcGVuaW5nIHRoZSByZXF1ZXN0IGFzIHNvbWUgcHJvcGVydGllcyByZXF1aXJlIGJlaW5nIHNldCBhdCBkaWZmZXJlbnQgcGhhc2VzIG9mIHRoZSByZXF1ZXN0XG5cdFx0XHRcdFx0c2FmZU1peGluKGNsaWVudCwgcmVxdWVzdC5taXhpbik7XG5cdFx0XHRcdFx0Y2xpZW50Lm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuXHRcdFx0XHRcdHNhZmVNaXhpbihjbGllbnQsIHJlcXVlc3QubWl4aW4pO1xuXG5cdFx0XHRcdFx0aGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycztcblx0XHRcdFx0XHRmb3IgKGhlYWRlck5hbWUgaW4gaGVhZGVycykge1xuXHRcdFx0XHRcdFx0Lypqc2hpbnQgZm9yaW46ZmFsc2UgKi9cblx0XHRcdFx0XHRcdGlmIChoZWFkZXJOYW1lID09PSAnQ29udGVudC1UeXBlJyAmJiBoZWFkZXJzW2hlYWRlck5hbWVdID09PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpIHtcblx0XHRcdFx0XHRcdFx0Ly8gWE1MSHR0cFJlcXVlc3QgZ2VuZXJhdGVzIGl0cyBvd24gQ29udGVudC1UeXBlIGhlYWRlciB3aXRoIHRoZVxuXHRcdFx0XHRcdFx0XHQvLyBhcHByb3ByaWF0ZSBtdWx0aXBhcnQgYm91bmRhcnkgd2hlbiBzZW5kaW5nIG11bHRpcGFydC9mb3JtLWRhdGEuXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjbGllbnQuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lLCBoZWFkZXJzW2hlYWRlck5hbWVdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXF1ZXN0LmNhbmNlbGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0cmVxdWVzdC5jYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwoKSB7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0LmNhbmNlbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGNsaWVudC5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0cmVqZWN0KHJlc3BvbnNlKTtcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Y2xpZW50Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgvKiBlICovKSB7XG5cdFx0XHRcdFx0XHRpZiAocmVxdWVzdC5jYW5jZWxlZCkgeyByZXR1cm47IH1cblx0XHRcdFx0XHRcdGlmIChjbGllbnQucmVhZHlTdGF0ZSA9PT0gKFhNTEh0dHBSZXF1ZXN0LkRPTkUgfHwgNCkpIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2Uuc3RhdHVzID0ge1xuXHRcdFx0XHRcdFx0XHRcdGNvZGU6IGNsaWVudC5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0dGV4dDogY2xpZW50LnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UuaGVhZGVycyA9IHBhcnNlSGVhZGVycyhjbGllbnQuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZS5lbnRpdHkgPSBjbGllbnQucmVzcG9uc2VUZXh0O1xuXG5cdFx0XHRcdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMuY29kZSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBjaGVjayBzdGF0dXMgY29kZSBhcyByZWFkeXN0YXRlY2hhbmdlIGZpcmVzIGJlZm9yZSBlcnJvciBldmVudFxuXHRcdFx0XHRcdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGdpdmUgdGhlIGVycm9yIGNhbGxiYWNrIGEgY2hhbmNlIHRvIGZpcmUgYmVmb3JlIHJlc29sdmluZ1xuXHRcdFx0XHRcdFx0XHRcdC8vIHJlcXVlc3RzIGZvciBmaWxlOi8vIFVSTHMgZG8gbm90IGhhdmUgYSBzdGF0dXMgY29kZVxuXHRcdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdFx0XHRcdFx0fSwgMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGNsaWVudC5vbmVycm9yID0gZnVuY3Rpb24gKC8qIGUgKi8pIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UuZXJyb3IgPSAnbG9hZGVycm9yJztcblx0XHRcdFx0XHRcdFx0cmVqZWN0KHJlc3BvbnNlKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHQvLyBJRSA2IHdpbGwgbm90IHN1cHBvcnQgZXJyb3IgaGFuZGxpbmdcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjbGllbnQuc2VuZChlbnRpdHkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0cmVzcG9uc2UuZXJyb3IgPSAnbG9hZGVycm9yJztcblx0XHRcdFx0XHRyZWplY3QocmVzcG9uc2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH0sXG5cdHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdm9pZCAwXG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHRcdHZhciBkZWZhdWx0Q2xpZW50LCBtaXhpbiwgcmVzcG9uc2VQcm9taXNlLCBjbGllbnQsIHdoZW47XG5cblx0XHRkZWZhdWx0Q2xpZW50ID0gcmVxdWlyZSgnLi9jbGllbnQvZGVmYXVsdCcpO1xuXHRcdG1peGluID0gcmVxdWlyZSgnLi91dGlsL21peGluJyk7XG5cdFx0cmVzcG9uc2VQcm9taXNlID0gcmVxdWlyZSgnLi91dGlsL3Jlc3BvbnNlUHJvbWlzZScpO1xuXHRcdGNsaWVudCA9IHJlcXVpcmUoJy4vY2xpZW50Jyk7XG5cdFx0d2hlbiA9IHJlcXVpcmUoJ3doZW4nKTtcblxuXHRcdC8qKlxuXHRcdCAqIEludGVyY2VwdG9ycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGludGVyY2VwdCB0aGUgcmVxdWVzdCBhbmQvb3JnIHJlc3BvbnNlXG5cdFx0ICogb2JqZWN0cy4gIFRoZXkgbWF5IGF1Z21lbnQsIHBydW5lLCB0cmFuc2Zvcm0gb3IgcmVwbGFjZSB0aGVcblx0XHQgKiByZXF1ZXN0L3Jlc3BvbnNlIGFzIG5lZWRlZC4gIENsaWVudHMgbWF5IGJlIGNvbXBvc2VkIGJ5IHdyYXBwaW5nXG5cdFx0ICogdG9nZXRoZXIgbXVsdGlwbGUgaW50ZXJjZXB0b3JzLlxuXHRcdCAqXG5cdFx0ICogQ29uZmlndXJlZCBpbnRlcmNlcHRvcnMgYXJlIGZ1bmN0aW9uYWwgaW4gbmF0dXJlLiAgV3JhcHBpbmcgYSBjbGllbnQgaW5cblx0XHQgKiBhbiBpbnRlcmNlcHRvciB3aWxsIG5vdCBhZmZlY3QgdGhlIGNsaWVudCwgbWVyZWx5IHRoZSBkYXRhIHRoYXQgZmxvd3MgaW5cblx0XHQgKiBhbmQgb3V0IG9mIHRoYXQgY2xpZW50LiAgQSBjb21tb24gY29uZmlndXJhdGlvbiBjYW4gYmUgY3JlYXRlZCBvbmNlIGFuZFxuXHRcdCAqIHNoYXJlZDsgc3BlY2lhbGl6YXRpb24gY2FuIGJlIGNyZWF0ZWQgYnkgZnVydGhlciB3cmFwcGluZyB0aGF0IGNsaWVudFxuXHRcdCAqIHdpdGggY3VzdG9tIGludGVyY2VwdG9ycy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Q2xpZW50fSBbdGFyZ2V0XSBjbGllbnQgdG8gd3JhcFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBjb25maWd1cmF0aW9uIGZvciB0aGUgaW50ZXJjZXB0b3IsIHByb3BlcnRpZXMgd2lsbCBiZSBzcGVjaWZpYyB0byB0aGUgaW50ZXJjZXB0b3IgaW1wbGVtZW50YXRpb25cblx0XHQgKiBAcmV0dXJucyB7Q2xpZW50fSBBIGNsaWVudCB3cmFwcGVkIHdpdGggdGhlIGludGVyY2VwdG9yXG5cdFx0ICpcblx0XHQgKiBAY2xhc3MgSW50ZXJjZXB0b3Jcblx0XHQgKi9cblxuXHRcdGZ1bmN0aW9uIGRlZmF1bHRJbml0SGFuZGxlcihjb25maWcpIHtcblx0XHRcdHJldHVybiBjb25maWc7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVmYXVsdFJlcXVlc3RIYW5kbGVyKHJlcXVlc3QgLyosIGNvbmZpZywgbWV0YSAqLykge1xuXHRcdFx0cmV0dXJuIHJlcXVlc3Q7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVmYXVsdFJlc3BvbnNlSGFuZGxlcihyZXNwb25zZSAvKiwgY29uZmlnLCBtZXRhICovKSB7XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmFjZShwcm9taXNlc09yVmFsdWVzKSB7XG5cdFx0XHQvLyB0aGlzIGZ1bmN0aW9uIGlzIGRpZmZlcmVudCB0aGFuIHdoZW4uYW55IGFzIHRoZSBmaXJzdCB0byByZWplY3QgYWxzbyB3aW5zXG5cdFx0XHRyZXR1cm4gd2hlbi5wcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdFx0cHJvbWlzZXNPclZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9taXNlT3JWYWx1ZSkge1xuXHRcdFx0XHRcdHdoZW4ocHJvbWlzZU9yVmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQWx0ZXJuYXRlIHJldHVybiB0eXBlIGZvciB0aGUgcmVxdWVzdCBoYW5kbGVyIHRoYXQgYWxsb3dzIGZvciBtb3JlIGNvbXBsZXggaW50ZXJhY3Rpb25zLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHByb3BlcnRpZXMucmVxdWVzdCB0aGUgdHJhZGl0aW9uYWwgcmVxdWVzdCByZXR1cm4gb2JqZWN0XG5cdFx0ICogQHBhcmFtIHtQcm9taXNlfSBbcHJvcGVydGllcy5hYm9ydF0gcHJvbWlzZSB0aGF0IHJlc29sdmVzIGlmL3doZW4gdGhlIHJlcXVlc3QgaXMgYWJvcnRlZFxuXHRcdCAqIEBwYXJhbSB7Q2xpZW50fSBbcHJvcGVydGllcy5jbGllbnRdIG92ZXJyaWRlIHRoZSBkZWZpbmVkIGNsaWVudCB3aXRoIGFuIGFsdGVybmF0ZSBjbGllbnRcblx0XHQgKiBAcGFyYW0gW3Byb3BlcnRpZXMucmVzcG9uc2VdIHJlc3BvbnNlIGZvciB0aGUgcmVxdWVzdCwgc2hvcnQgY2lyY3VpdCB0aGUgcmVxdWVzdFxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIENvbXBsZXhSZXF1ZXN0KHByb3BlcnRpZXMpIHtcblx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb21wbGV4UmVxdWVzdCkpIHtcblx0XHRcdFx0Ly8gaW4gY2FzZSB1c2VycyBmb3JnZXQgdGhlICduZXcnIGRvbid0IG1peCBpbnRvIHRoZSBpbnRlcmNlcHRvclxuXHRcdFx0XHRyZXR1cm4gbmV3IENvbXBsZXhSZXF1ZXN0KHByb3BlcnRpZXMpO1xuXHRcdFx0fVxuXHRcdFx0bWl4aW4odGhpcywgcHJvcGVydGllcyk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgbmV3IGludGVyY2VwdG9yIGZvciB0aGUgcHJvdmlkZWQgaGFuZGxlcnMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcnMuaW5pdF0gb25lIHRpbWUgaW50aWFsaXphdGlvbiwgbXVzdCByZXR1cm4gdGhlIGNvbmZpZyBvYmplY3Rcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcnMucmVxdWVzdF0gcmVxdWVzdCBoYW5kbGVyXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJzLnJlc3BvbnNlXSByZXNwb25zZSBoYW5kbGVyIHJlZ2FyZGxlc3Mgb2YgZXJyb3Igc3RhdGVcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcnMuc3VjY2Vzc10gcmVzcG9uc2UgaGFuZGxlciB3aGVuIHRoZSByZXF1ZXN0IGlzIG5vdCBpbiBlcnJvclxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVycy5lcnJvcl0gcmVzcG9uc2UgaGFuZGxlciB3aGVuIHRoZSByZXF1ZXN0IGlzIGluIGVycm9yLCBtYXkgYmUgdXNlZCB0byAndW5yZWplY3QnIGFuIGVycm9yIHN0YXRlXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJzLmNsaWVudF0gdGhlIGNsaWVudCB0byB1c2UgaWYgb3RoZXJ3aXNlIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHBsYXRmb3JtIGRlZmF1bHQgY2xpZW50XG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7SW50ZXJjZXB0b3J9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gaW50ZXJjZXB0b3IoaGFuZGxlcnMpIHtcblxuXHRcdFx0dmFyIGluaXRIYW5kbGVyLCByZXF1ZXN0SGFuZGxlciwgc3VjY2Vzc1Jlc3BvbnNlSGFuZGxlciwgZXJyb3JSZXNwb25zZUhhbmRsZXI7XG5cblx0XHRcdGhhbmRsZXJzID0gaGFuZGxlcnMgfHwge307XG5cblx0XHRcdGluaXRIYW5kbGVyICAgICAgICAgICAgPSBoYW5kbGVycy5pbml0ICAgIHx8IGRlZmF1bHRJbml0SGFuZGxlcjtcblx0XHRcdHJlcXVlc3RIYW5kbGVyICAgICAgICAgPSBoYW5kbGVycy5yZXF1ZXN0IHx8IGRlZmF1bHRSZXF1ZXN0SGFuZGxlcjtcblx0XHRcdHN1Y2Nlc3NSZXNwb25zZUhhbmRsZXIgPSBoYW5kbGVycy5zdWNjZXNzIHx8IGhhbmRsZXJzLnJlc3BvbnNlIHx8IGRlZmF1bHRSZXNwb25zZUhhbmRsZXI7XG5cdFx0XHRlcnJvclJlc3BvbnNlSGFuZGxlciAgID0gaGFuZGxlcnMuZXJyb3IgICB8fCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSB0aGUgcmVqZWN0aW9uLCB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIGhhbmRsZXJcblx0XHRcdFx0cmV0dXJuIHdoZW4oKGhhbmRsZXJzLnJlc3BvbnNlIHx8IGRlZmF1bHRSZXNwb25zZUhhbmRsZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHdoZW4ucmVqZWN0LCB3aGVuLnJlamVjdCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgY29uZmlnKSB7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0Y29uZmlnID0gdGFyZ2V0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0dGFyZ2V0ID0gaGFuZGxlcnMuY2xpZW50IHx8IGRlZmF1bHRDbGllbnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25maWcgPSBpbml0SGFuZGxlcihjb25maWcgfHwge30pO1xuXG5cdFx0XHRcdGZ1bmN0aW9uIGludGVyY2VwdGVkQ2xpZW50KHJlcXVlc3QpIHtcblx0XHRcdFx0XHR2YXIgY29udGV4dCwgbWV0YTtcblx0XHRcdFx0XHRjb250ZXh0ID0ge307XG5cdFx0XHRcdFx0bWV0YSA9IHsgJ2FyZ3VtZW50cyc6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGNsaWVudDogaW50ZXJjZXB0ZWRDbGllbnQgfTtcblx0XHRcdFx0XHRyZXF1ZXN0ID0gdHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnID8geyBwYXRoOiByZXF1ZXN0IH0gOiByZXF1ZXN0IHx8IHt9O1xuXHRcdFx0XHRcdHJlcXVlc3Qub3JpZ2luYXRvciA9IHJlcXVlc3Qub3JpZ2luYXRvciB8fCBpbnRlcmNlcHRlZENsaWVudDtcblx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2VQcm9taXNlKFxuXHRcdFx0XHRcdFx0cmVxdWVzdEhhbmRsZXIuY2FsbChjb250ZXh0LCByZXF1ZXN0LCBjb25maWcsIG1ldGEpLFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24gKHJlcXVlc3QpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlLCBhYm9ydCwgbmV4dDtcblx0XHRcdFx0XHRcdFx0bmV4dCA9IHRhcmdldDtcblx0XHRcdFx0XHRcdFx0aWYgKHJlcXVlc3QgaW5zdGFuY2VvZiBDb21wbGV4UmVxdWVzdCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHVucGFjayByZXF1ZXN0XG5cdFx0XHRcdFx0XHRcdFx0YWJvcnQgPSByZXF1ZXN0LmFib3J0O1xuXHRcdFx0XHRcdFx0XHRcdG5leHQgPSByZXF1ZXN0LmNsaWVudCB8fCBuZXh0O1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25zZTtcblx0XHRcdFx0XHRcdFx0XHQvLyBub3JtYWxpemUgcmVxdWVzdCwgbXVzdCBiZSBsYXN0XG5cdFx0XHRcdFx0XHRcdFx0cmVxdWVzdCA9IHJlcXVlc3QucmVxdWVzdDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IHJlc3BvbnNlIHx8IHdoZW4ocmVxdWVzdCwgZnVuY3Rpb24gKHJlcXVlc3QpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gd2hlbihcblx0XHRcdFx0XHRcdFx0XHRcdG5leHQocmVxdWVzdCksXG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHN1Y2Nlc3NSZXNwb25zZUhhbmRsZXIuY2FsbChjb250ZXh0LCByZXNwb25zZSwgY29uZmlnLCBtZXRhKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGVycm9yUmVzcG9uc2VIYW5kbGVyLmNhbGwoY29udGV4dCwgcmVzcG9uc2UsIGNvbmZpZywgbWV0YSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBhYm9ydCA/IHJhY2UoW3Jlc3BvbnNlLCBhYm9ydF0pIDogcmVzcG9uc2U7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB3aGVuLnJlamVjdCh7IHJlcXVlc3Q6IHJlcXVlc3QsIGVycm9yOiBlcnJvciB9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGNsaWVudChpbnRlcmNlcHRlZENsaWVudCwgdGFyZ2V0KTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aW50ZXJjZXB0b3IuQ29tcGxleFJlcXVlc3QgPSBDb21wbGV4UmVxdWVzdDtcblxuXHRcdHJldHVybiBpbnRlcmNlcHRvcjtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEzIHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0XHR2YXIgaW50ZXJjZXB0b3IsIG1peGluVXRpbCwgZGVmYXVsdGVyO1xuXG5cdFx0aW50ZXJjZXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcmNlcHRvcicpO1xuXHRcdG1peGluVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbWl4aW4nKTtcblxuXHRcdGRlZmF1bHRlciA9IChmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGZ1bmN0aW9uIG1peGluKHByb3AsIHRhcmdldCwgZGVmYXVsdHMpIHtcblx0XHRcdFx0aWYgKHByb3AgaW4gdGFyZ2V0IHx8IHByb3AgaW4gZGVmYXVsdHMpIHtcblx0XHRcdFx0XHR0YXJnZXRbcHJvcF0gPSBtaXhpblV0aWwoe30sIGRlZmF1bHRzW3Byb3BdLCB0YXJnZXRbcHJvcF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNvcHkocHJvcCwgdGFyZ2V0LCBkZWZhdWx0cykge1xuXHRcdFx0XHRpZiAocHJvcCBpbiBkZWZhdWx0cyAmJiAhKHByb3AgaW4gdGFyZ2V0KSkge1xuXHRcdFx0XHRcdHRhcmdldFtwcm9wXSA9IGRlZmF1bHRzW3Byb3BdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBtYXBwaW5ncyA9IHtcblx0XHRcdFx0bWV0aG9kOiBjb3B5LFxuXHRcdFx0XHRwYXRoOiBjb3B5LFxuXHRcdFx0XHRwYXJhbXM6IG1peGluLFxuXHRcdFx0XHRoZWFkZXJzOiBtaXhpbixcblx0XHRcdFx0ZW50aXR5OiBjb3B5LFxuXHRcdFx0XHRtaXhpbjogbWl4aW5cblx0XHRcdH07XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBkZWZhdWx0cykge1xuXHRcdFx0XHRmb3IgKHZhciBwcm9wIGluIG1hcHBpbmdzKSB7XG5cdFx0XHRcdFx0Lypqc2hpbnQgZm9yaW46IGZhbHNlICovXG5cdFx0XHRcdFx0bWFwcGluZ3NbcHJvcF0ocHJvcCwgdGFyZ2V0LCBkZWZhdWx0cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHRcdH07XG5cblx0XHR9KCkpO1xuXG5cdFx0LyoqXG5cdFx0ICogUHJvdmlkZSBkZWZhdWx0IHZhbHVlcyBmb3IgYSByZXF1ZXN0LiBUaGVzZSB2YWx1ZXMgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZVxuXHRcdCAqIHJlcXVlc3QgaWYgdGhlIHJlcXVlc3Qgb2JqZWN0IGRvZXMgbm90IGFscmVhZHkgY29udGFpbiBhbiBleHBsaWNpdCB2YWx1ZS5cblx0XHQgKlxuXHRcdCAqIEZvciAncGFyYW1zJywgJ2hlYWRlcnMnLCBhbmQgJ21peGluJywgaW5kaXZpZHVhbCB2YWx1ZXMgYXJlIG1peGVkIGluIHdpdGggdGhlXG5cdFx0ICogcmVxdWVzdCdzIHZhbHVlcy4gVGhlIHJlc3VsdCBpcyBhIG5ldyBvYmplY3QgcmVwcmVzZW50aWluZyB0aGUgY29tYmluZWRcblx0XHQgKiByZXF1ZXN0IGFuZCBjb25maWcgdmFsdWVzLiBOZWl0aGVyIGlucHV0IG9iamVjdCBpcyBtdXRhdGVkLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtDbGllbnR9IFtjbGllbnRdIGNsaWVudCB0byB3cmFwXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubWV0aG9kXSB0aGUgZGVmYXVsdCBtZXRob2Rcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5wYXRoXSB0aGUgZGVmYXVsdCBwYXRoXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcucGFyYW1zXSB0aGUgZGVmYXVsdCBwYXJhbXMsIG1peGVkIHdpdGggdGhlIHJlcXVlc3QncyBleGlzdGluZyBwYXJhbXNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5oZWFkZXJzXSB0aGUgZGVmYXVsdCBoZWFkZXJzLCBtaXhlZCB3aXRoIHRoZSByZXF1ZXN0J3MgZXhpc3RpbmcgaGVhZGVyc1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm1peGluXSB0aGUgZGVmYXVsdCBcIm1peGluc1wiIChodHRwL2h0dHBzIG9wdGlvbnMpLCBtaXhlZCB3aXRoIHRoZSByZXF1ZXN0J3MgZXhpc3RpbmcgXCJtaXhpbnNcIlxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge0NsaWVudH1cblx0XHQgKi9cblx0XHRyZXR1cm4gaW50ZXJjZXB0b3Ioe1xuXHRcdFx0cmVxdWVzdDogZnVuY3Rpb24gaGFuZGxlUmVxdWVzdChyZXF1ZXN0LCBjb25maWcpIHtcblx0XHRcdFx0cmV0dXJuIGRlZmF1bHRlcihyZXF1ZXN0LCBjb25maWcpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTItMjAxMyB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0dmFyIGludGVyY2VwdG9yLCB3aGVuO1xuXG5cdFx0aW50ZXJjZXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcmNlcHRvcicpO1xuXHRcdHdoZW4gPSByZXF1aXJlKCd3aGVuJyk7XG5cblx0XHQvKipcblx0XHQgKiBSZWplY3RzIHRoZSByZXNwb25zZSBwcm9taXNlIGJhc2VkIG9uIHRoZSBzdGF0dXMgY29kZS5cblx0XHQgKlxuXHRcdCAqIENvZGVzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgcHJvdmlkZWQgdmFsdWUgYXJlIHJlamVjdGVkLiAgRGVmYXVsdFxuXHRcdCAqIHZhbHVlIDQwMC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Q2xpZW50fSBbY2xpZW50XSBjbGllbnQgdG8gd3JhcFxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmNvZGU9NDAwXSBjb2RlIHRvIGluZGljYXRlIGEgcmVqZWN0aW9uXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7Q2xpZW50fVxuXHRcdCAqL1xuXHRcdHJldHVybiBpbnRlcmNlcHRvcih7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdFx0XHRcdGNvbmZpZy5jb2RlID0gY29uZmlnLmNvZGUgfHwgNDAwO1xuXHRcdFx0XHRyZXR1cm4gY29uZmlnO1xuXHRcdFx0fSxcblx0XHRcdHJlc3BvbnNlOiBmdW5jdGlvbiAocmVzcG9uc2UsIGNvbmZpZykge1xuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzICYmIHJlc3BvbnNlLnN0YXR1cy5jb2RlID49IGNvbmZpZy5jb2RlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHdoZW4ucmVqZWN0KHJlc3BvbnNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE0IHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0XHR2YXIgaW50ZXJjZXB0b3IsIG1pbWUsIHJlZ2lzdHJ5LCBub29wQ29udmVydGVyLCB3aGVuO1xuXG5cdFx0aW50ZXJjZXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcmNlcHRvcicpO1xuXHRcdG1pbWUgPSByZXF1aXJlKCcuLi9taW1lJyk7XG5cdFx0cmVnaXN0cnkgPSByZXF1aXJlKCcuLi9taW1lL3JlZ2lzdHJ5Jyk7XG5cdFx0d2hlbiA9IHJlcXVpcmUoJ3doZW4nKTtcblxuXHRcdG5vb3BDb252ZXJ0ZXIgPSB7XG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmo7IH0sXG5cdFx0XHR3cml0ZTogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqOyB9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIE1JTUUgdHlwZSBzdXBwb3J0IGZvciByZXF1ZXN0IGFuZCByZXNwb25zZSBlbnRpdGllcy4gIEVudGl0aWVzIGFyZVxuXHRcdCAqIChkZSlzZXJpYWxpemVkIHVzaW5nIHRoZSBjb252ZXJ0ZXIgZm9yIHRoZSBNSU1FIHR5cGUuXG5cdFx0ICpcblx0XHQgKiBSZXF1ZXN0IGVudGl0aWVzIGFyZSBjb252ZXJ0ZWQgdXNpbmcgdGhlIGRlc2lyZWQgY29udmVydGVyIGFuZCB0aGVcblx0XHQgKiAnQWNjZXB0JyByZXF1ZXN0IGhlYWRlciBwcmVmZXJzIHRoaXMgTUlNRS5cblx0XHQgKlxuXHRcdCAqIFJlc3BvbnNlIGVudGl0aWVzIGFyZSBjb252ZXJ0ZWQgYmFzZWQgb24gdGhlIENvbnRlbnQtVHlwZSByZXNwb25zZSBoZWFkZXIuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0NsaWVudH0gW2NsaWVudF0gY2xpZW50IHRvIHdyYXBcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5taW1lPSd0ZXh0L3BsYWluJ10gTUlNRSB0eXBlIHRvIGVuY29kZSB0aGUgcmVxdWVzdFxuXHRcdCAqICAgZW50aXR5XG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuYWNjZXB0XSBBY2NlcHQgaGVhZGVyIGZvciB0aGUgcmVxdWVzdFxuXHRcdCAqIEBwYXJhbSB7Q2xpZW50fSBbY29uZmlnLmNsaWVudD08cmVxdWVzdC5vcmlnaW5hdG9yPl0gY2xpZW50IHBhc3NlZCB0byB0aGVcblx0XHQgKiAgIGNvbnZlcnRlciwgZGVmYXVsdHMgdG8gdGhlIGNsaWVudCBvcmlnaW5hdGluZyB0aGUgcmVxdWVzdFxuXHRcdCAqIEBwYXJhbSB7UmVnaXN0cnl9IFtjb25maWcucmVnaXN0cnldIE1JTUUgcmVnaXN0cnksIGRlZmF1bHRzIHRvIHRoZSByb290XG5cdFx0ICogICByZWdpc3RyeVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbmZpZy5wZXJtaXNzaXZlXSBBbGxvdyBhbiB1bmtvd24gcmVxdWVzdCBNSU1FIHR5cGVcblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtDbGllbnR9XG5cdFx0ICovXG5cdFx0cmV0dXJuIGludGVyY2VwdG9yKHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0XHRcdFx0Y29uZmlnLnJlZ2lzdHJ5ID0gY29uZmlnLnJlZ2lzdHJ5IHx8IHJlZ2lzdHJ5O1xuXHRcdFx0XHRyZXR1cm4gY29uZmlnO1xuXHRcdFx0fSxcblx0XHRcdHJlcXVlc3Q6IGZ1bmN0aW9uIChyZXF1ZXN0LCBjb25maWcpIHtcblx0XHRcdFx0dmFyIHR5cGUsIGhlYWRlcnM7XG5cblx0XHRcdFx0aGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycyB8fCAocmVxdWVzdC5oZWFkZXJzID0ge30pO1xuXHRcdFx0XHR0eXBlID0gbWltZS5wYXJzZShoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddIHx8IGNvbmZpZy5taW1lIHx8ICd0ZXh0L3BsYWluJyk7XG5cdFx0XHRcdGhlYWRlcnMuQWNjZXB0ID0gaGVhZGVycy5BY2NlcHQgfHwgY29uZmlnLmFjY2VwdCB8fCB0eXBlLnJhdyArICcsIGFwcGxpY2F0aW9uL2pzb247cT0wLjgsIHRleHQvcGxhaW47cT0wLjUsICovKjtxPTAuMic7XG5cblx0XHRcdFx0aWYgKCEoJ2VudGl0eScgaW4gcmVxdWVzdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVxdWVzdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBjb25maWcucmVnaXN0cnkubG9va3VwKHR5cGUpLm90aGVyd2lzZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Ly8gZmFpbGVkIHRvIHJlc29sdmUgY29udmVydGVyXG5cdFx0XHRcdFx0aWYgKGNvbmZpZy5wZXJtaXNzaXZlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbm9vcENvbnZlcnRlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhyb3cgJ21pbWUtdW5rbm93bic7XG5cdFx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKGNvbnZlcnRlcikge1xuXHRcdFx0XHRcdHZhciBjbGllbnQgPSBjb25maWcuY2xpZW50IHx8IHJlcXVlc3Qub3JpZ2luYXRvcjtcblxuXHRcdFx0XHRcdHJldHVybiB3aGVuLmF0dGVtcHQoY29udmVydGVyLndyaXRlLCByZXF1ZXN0LmVudGl0eSwgeyBjbGllbnQ6IGNsaWVudCwgcmVxdWVzdDogcmVxdWVzdCwgbWltZTogdHlwZSwgcmVnaXN0cnk6IGNvbmZpZy5yZWdpc3RyeSB9KVxuXHRcdFx0XHRcdFx0Lm90aGVyd2lzZShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgJ21pbWUtc2VyaWFsaXphdGlvbic7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LnRoZW4oZnVuY3Rpb24oZW50aXR5KSB7XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3QuZW50aXR5ID0gZW50aXR5O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVxdWVzdDtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHRyZXNwb25zZTogZnVuY3Rpb24gKHJlc3BvbnNlLCBjb25maWcpIHtcblx0XHRcdFx0aWYgKCEocmVzcG9uc2UuaGVhZGVycyAmJiByZXNwb25zZS5oZWFkZXJzWydDb250ZW50LVR5cGUnXSAmJiByZXNwb25zZS5lbnRpdHkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHR5cGUgPSBtaW1lLnBhcnNlKHJlc3BvbnNlLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKTtcblxuXHRcdFx0XHRyZXR1cm4gY29uZmlnLnJlZ2lzdHJ5Lmxvb2t1cCh0eXBlKS5vdGhlcndpc2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gbm9vcENvbnZlcnRlcjsgfSkudGhlbihmdW5jdGlvbiAoY29udmVydGVyKSB7XG5cdFx0XHRcdFx0dmFyIGNsaWVudCA9IGNvbmZpZy5jbGllbnQgfHwgcmVzcG9uc2UucmVxdWVzdCAmJiByZXNwb25zZS5yZXF1ZXN0Lm9yaWdpbmF0b3I7XG5cblx0XHRcdFx0XHRyZXR1cm4gd2hlbi5hdHRlbXB0KGNvbnZlcnRlci5yZWFkLCByZXNwb25zZS5lbnRpdHksIHsgY2xpZW50OiBjbGllbnQsIHJlc3BvbnNlOiByZXNwb25zZSwgbWltZTogdHlwZSwgcmVnaXN0cnk6IGNvbmZpZy5yZWdpc3RyeSB9KVxuXHRcdFx0XHRcdFx0Lm90aGVyd2lzZShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZS5lcnJvciA9ICdtaW1lLWRlc2VyaWFsaXphdGlvbic7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlLmNhdXNlID0gZTtcblx0XHRcdFx0XHRcdFx0dGhyb3cgcmVzcG9uc2U7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKGVudGl0eSkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZS5lbnRpdHkgPSBlbnRpdHk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHRcdHZhciBpbnRlcmNlcHRvciwgVXJsQnVpbGRlcjtcblxuXHRcdGludGVyY2VwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJjZXB0b3InKTtcblx0XHRVcmxCdWlsZGVyID0gcmVxdWlyZSgnLi4vVXJsQnVpbGRlcicpO1xuXG5cdFx0ZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHByZWZpeCkge1xuXHRcdFx0cmV0dXJuIHN0ci5pbmRleE9mKHByZWZpeCkgPT09IDA7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzdWZmaXgpIHtcblx0XHRcdHJldHVybiBzdHIubGFzdEluZGV4T2Yoc3VmZml4KSArIHN1ZmZpeC5sZW5ndGggPT09IHN0ci5sZW5ndGg7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUHJlZml4ZXMgdGhlIHJlcXVlc3QgcGF0aCB3aXRoIGEgY29tbW9uIHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtDbGllbnR9IFtjbGllbnRdIGNsaWVudCB0byB3cmFwXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcucHJlZml4XSBwYXRoIHByZWZpeFxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge0NsaWVudH1cblx0XHQgKi9cblx0XHRyZXR1cm4gaW50ZXJjZXB0b3Ioe1xuXHRcdFx0cmVxdWVzdDogZnVuY3Rpb24gKHJlcXVlc3QsIGNvbmZpZykge1xuXHRcdFx0XHR2YXIgcGF0aDtcblxuXHRcdFx0XHRpZiAoY29uZmlnLnByZWZpeCAmJiAhKG5ldyBVcmxCdWlsZGVyKHJlcXVlc3QucGF0aCkuaXNGdWxseVF1YWxpZmllZCgpKSkge1xuXHRcdFx0XHRcdHBhdGggPSBjb25maWcucHJlZml4O1xuXHRcdFx0XHRcdGlmIChyZXF1ZXN0LnBhdGgpIHtcblx0XHRcdFx0XHRcdGlmICghZW5kc1dpdGgocGF0aCwgJy8nKSAmJiAhc3RhcnRzV2l0aChyZXF1ZXN0LnBhdGgsICcvJykpIHtcblx0XHRcdFx0XHRcdFx0Ly8gYWRkIG1pc3NpbmcgJy8nIGJldHdlZW4gcGF0aCBzZWN0aW9uc1xuXHRcdFx0XHRcdFx0XHRwYXRoICs9ICcvJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBhdGggKz0gcmVxdWVzdC5wYXRoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXF1ZXN0LnBhdGggPSBwYXRoO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHJlcXVlc3Q7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNSB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0dmFyIGludGVyY2VwdG9yLCB1cmlUZW1wbGF0ZSwgbWl4aW47XG5cblx0XHRpbnRlcmNlcHRvciA9IHJlcXVpcmUoJy4uL2ludGVyY2VwdG9yJyk7XG5cdFx0dXJpVGVtcGxhdGUgPSByZXF1aXJlKCcuLi91dGlsL3VyaVRlbXBsYXRlJyk7XG5cdFx0bWl4aW4gPSByZXF1aXJlKCcuLi91dGlsL21peGluJyk7XG5cblx0XHQvKipcblx0XHQgKiBBcHBsaWVzIHJlcXVlc3QgcGFyYW1zIHRvIHRoZSBwYXRoIGFzIGEgVVJJIFRlbXBsYXRlXG5cdFx0ICpcblx0XHQgKiBQYXJhbXMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgcmVxdWVzdCBvYmplY3QsIGFzIHRoZXkgaGF2ZSBiZWVuIGNvbnN1bWVkLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtDbGllbnR9IFtjbGllbnRdIGNsaWVudCB0byB3cmFwXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcucGFyYW1zXSBkZWZhdWx0IHBhcmFtIHZhbHVlc1xuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLnRlbXBsYXRlXSBkZWZhdWx0IHRlbXBsYXRlXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7Q2xpZW50fVxuXHRcdCAqL1xuXHRcdHJldHVybiBpbnRlcmNlcHRvcih7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdFx0XHRcdGNvbmZpZy5wYXJhbXMgPSBjb25maWcucGFyYW1zIHx8IHt9O1xuXHRcdFx0XHRjb25maWcudGVtcGxhdGUgPSBjb25maWcudGVtcGxhdGUgfHwgJyc7XG5cdFx0XHRcdHJldHVybiBjb25maWc7XG5cdFx0XHR9LFxuXHRcdFx0cmVxdWVzdDogZnVuY3Rpb24gKHJlcXVlc3QsIGNvbmZpZykge1xuXHRcdFx0XHR2YXIgdGVtcGxhdGUsIHBhcmFtcztcblxuXHRcdFx0XHR0ZW1wbGF0ZSA9IHJlcXVlc3QucGF0aCB8fCBjb25maWcudGVtcGxhdGU7XG5cdFx0XHRcdHBhcmFtcyA9IG1peGluKHt9LCByZXF1ZXN0LnBhcmFtcywgY29uZmlnLnBhcmFtcyk7XG5cblx0XHRcdFx0cmVxdWVzdC5wYXRoID0gdXJpVGVtcGxhdGUuZXhwYW5kKHRlbXBsYXRlLCBwYXJhbXMpO1xuXHRcdFx0XHRkZWxldGUgcmVxdWVzdC5wYXJhbXM7XG5cblx0XHRcdFx0cmV0dXJuIHJlcXVlc3Q7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4qIENvcHlyaWdodCAyMDE0IHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuKlxuKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgdW5kZWY7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uICgvKiByZXF1aXJlICovKSB7XG5cblx0XHQvKipcblx0XHQgKiBQYXJzZSBhIE1JTUUgdHlwZSBpbnRvIGl0J3MgY29uc3RpdHVlbnQgcGFydHNcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBtaW1lIE1JTUUgdHlwZSB0byBwYXJzZVxuXHRcdCAqIEByZXR1cm4ge3tcblx0XHQgKiAgIHtzdHJpbmd9IHJhdyB0aGUgb3JpZ2luYWwgTUlNRSB0eXBlXG5cdFx0ICogICB7c3RyaW5nfSB0eXBlIHRoZSB0eXBlIGFuZCBzdWJ0eXBlXG5cdFx0ICogICB7c3RyaW5nfSBbc3VmZml4XSBtaW1lIHN1ZmZpeCwgaW5jbHVkaW5nIHRoZSBwbHVzLCBpZiBhbnlcblx0XHQgKiAgIHtPYmplY3R9IHBhcmFtcyBrZXkvdmFsdWUgcGFpciBvZiBhdHRyaWJ1dGVzXG5cdFx0ICogfX1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBwYXJzZShtaW1lKSB7XG5cdFx0XHR2YXIgcGFyYW1zLCB0eXBlO1xuXG5cdFx0XHRwYXJhbXMgPSBtaW1lLnNwbGl0KCc7Jyk7XG5cdFx0XHR0eXBlID0gcGFyYW1zWzBdLnRyaW0oKS5zcGxpdCgnKycpO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyYXc6IG1pbWUsXG5cdFx0XHRcdHR5cGU6IHR5cGVbMF0sXG5cdFx0XHRcdHN1ZmZpeDogdHlwZVsxXSA/ICcrJyArIHR5cGVbMV0gOiAnJyxcblx0XHRcdFx0cGFyYW1zOiBwYXJhbXMuc2xpY2UoMSkucmVkdWNlKGZ1bmN0aW9uIChwYXJhbXMsIHBhaXIpIHtcblx0XHRcdFx0XHRwYWlyID0gcGFpci5zcGxpdCgnPScpO1xuXHRcdFx0XHRcdHBhcmFtc1twYWlyWzBdLnRyaW0oKV0gPSBwYWlyWzFdID8gcGFpclsxXS50cmltKCkgOiB1bmRlZjtcblx0XHRcdFx0XHRyZXR1cm4gcGFyYW1zO1xuXHRcdFx0XHR9LCB7fSlcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHBhcnNlOiBwYXJzZVxuXHRcdH07XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE0IHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0XHR2YXIgbWltZSwgd2hlbiwgcmVnaXN0cnk7XG5cblx0XHRtaW1lID0gcmVxdWlyZSgnLi4vbWltZScpO1xuXHRcdHdoZW4gPSByZXF1aXJlKCd3aGVuJyk7XG5cblx0XHRmdW5jdGlvbiBSZWdpc3RyeShtaW1lcykge1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIExvb2t1cCB0aGUgY29udmVydGVyIGZvciBhIE1JTUUgdHlwZVxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSBNSU1FIHR5cGVcblx0XHRcdCAqIEByZXR1cm4gYSBwcm9taXNlIGZvciB0aGUgY29udmVydGVyXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMubG9va3VwID0gZnVuY3Rpb24gbG9va3VwKHR5cGUpIHtcblx0XHRcdFx0dmFyIHBhcnNlZDtcblxuXHRcdFx0XHRwYXJzZWQgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyBtaW1lLnBhcnNlKHR5cGUpIDogdHlwZTtcblxuXHRcdFx0XHRpZiAobWltZXNbcGFyc2VkLnJhd10pIHtcblx0XHRcdFx0XHRyZXR1cm4gbWltZXNbcGFyc2VkLnJhd107XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG1pbWVzW3BhcnNlZC50eXBlICsgcGFyc2VkLnN1ZmZpeF0pIHtcblx0XHRcdFx0XHRyZXR1cm4gbWltZXNbcGFyc2VkLnR5cGUgKyBwYXJzZWQuc3VmZml4XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobWltZXNbcGFyc2VkLnR5cGVdKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1pbWVzW3BhcnNlZC50eXBlXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobWltZXNbcGFyc2VkLnN1ZmZpeF0pIHtcblx0XHRcdFx0XHRyZXR1cm4gbWltZXNbcGFyc2VkLnN1ZmZpeF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gd2hlbi5yZWplY3QobmV3IEVycm9yKCdVbmFibGUgdG8gbG9jYXRlIGNvbnZlcnRlciBmb3IgbWltZSBcIicgKyBwYXJzZWQucmF3ICsgJ1wiJykpO1xuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDcmVhdGUgYSBsYXRlIGRpc3BhdGNoZWQgcHJveHkgdG8gdGhlIHRhcmdldCBjb252ZXJ0ZXIuXG5cdFx0XHQgKlxuXHRcdFx0ICogQ29tbW9uIHdoZW4gYSBjb252ZXJ0ZXIgaXMgcmVnaXN0ZXJlZCB1bmRlciBtdWx0aXBsZSBuYW1lcyBhbmRcblx0XHRcdCAqIHNob3VsZCBiZSBrZXB0IGluIHN5bmMgaWYgdXBkYXRlZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBtaW1lIGNvbnZlcnRlciB0byBkaXNwYXRjaCB0b1xuXHRcdFx0ICogQHJldHVybnMgY29udmVydGVyIHdob3NlIHJlYWQvd3JpdGUgbWV0aG9kcyB0YXJnZXQgdGhlIGRlc2lyZWQgbWltZSBjb252ZXJ0ZXJcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy5kZWxlZ2F0ZSA9IGZ1bmN0aW9uIGRlbGVnYXRlKHR5cGUpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmxvb2t1cCh0eXBlKS50aGVuKGZ1bmN0aW9uIChjb252ZXJ0ZXIpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbnZlcnRlci5yZWFkLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0XHRcdFx0fS5iaW5kKHRoaXMpKTtcblx0XHRcdFx0XHR9LmJpbmQodGhpcyksXG5cdFx0XHRcdFx0d3JpdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMubG9va3VwKHR5cGUpLnRoZW4oZnVuY3Rpb24gKGNvbnZlcnRlcikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY29udmVydGVyLndyaXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0XHRcdFx0fS5iaW5kKHRoaXMpKTtcblx0XHRcdFx0XHR9LmJpbmQodGhpcylcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmVnaXN0ZXIgYSBjdXN0b20gY29udmVydGVyIGZvciBhIE1JTUUgdHlwZVxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSBNSU1FIHR5cGVcblx0XHRcdCAqIEBwYXJhbSBjb252ZXJ0ZXIgdGhlIGNvbnZlcnRlciBmb3IgdGhlIE1JTUUgdHlwZVxuXHRcdFx0ICogQHJldHVybiBhIHByb21pc2UgZm9yIHRoZSBjb252ZXJ0ZXJcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKHR5cGUsIGNvbnZlcnRlcikge1xuXHRcdFx0XHRtaW1lc1t0eXBlXSA9IHdoZW4oY29udmVydGVyKTtcblx0XHRcdFx0cmV0dXJuIG1pbWVzW3R5cGVdO1xuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDcmVhdGUgYSBjaGlsZCByZWdpc3RyeSB3aG9lcyByZWdpc3RlcmVkIGNvbnZlcnRlcnMgcmVtYWluIGxvY2FsLCB3aGlsZVxuXHRcdFx0ICogYWJsZSB0byBsb29rdXAgY29udmVydGVycyBmcm9tIGl0cyBwYXJlbnQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHJldHVybnMgY2hpbGQgTUlNRSByZWdpc3RyeVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLmNoaWxkID0gZnVuY3Rpb24gY2hpbGQoKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgUmVnaXN0cnkoT2JqZWN0LmNyZWF0ZShtaW1lcykpO1xuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdHJlZ2lzdHJ5ID0gbmV3IFJlZ2lzdHJ5KHt9KTtcblxuXHRcdC8vIGluY2x1ZGUgcHJvdmlkZWQgc2VyaWFsaXplcnNcblx0XHRyZWdpc3RyeS5yZWdpc3RlcignYXBwbGljYXRpb24vaGFsJywgcmVxdWlyZSgnLi90eXBlL2FwcGxpY2F0aW9uL2hhbCcpKTtcblx0XHRyZWdpc3RyeS5yZWdpc3RlcignYXBwbGljYXRpb24vanNvbicsIHJlcXVpcmUoJy4vdHlwZS9hcHBsaWNhdGlvbi9qc29uJykpO1xuXHRcdHJlZ2lzdHJ5LnJlZ2lzdGVyKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLCByZXF1aXJlKCcuL3R5cGUvYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykpO1xuXHRcdHJlZ2lzdHJ5LnJlZ2lzdGVyKCdtdWx0aXBhcnQvZm9ybS1kYXRhJywgcmVxdWlyZSgnLi90eXBlL211bHRpcGFydC9mb3JtLWRhdGEnKSk7XG5cdFx0cmVnaXN0cnkucmVnaXN0ZXIoJ3RleHQvcGxhaW4nLCByZXF1aXJlKCcuL3R5cGUvdGV4dC9wbGFpbicpKTtcblxuXHRcdHJlZ2lzdHJ5LnJlZ2lzdGVyKCcranNvbicsIHJlZ2lzdHJ5LmRlbGVnYXRlKCdhcHBsaWNhdGlvbi9qc29uJykpO1xuXG5cdFx0cmV0dXJuIHJlZ2lzdHJ5O1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0dmFyIHBhdGhQcmVmaXgsIHRlbXBsYXRlLCBmaW5kLCBsYXp5UHJvbWlzZSwgcmVzcG9uc2VQcm9taXNlLCB3aGVuO1xuXG5cdFx0cGF0aFByZWZpeCA9IHJlcXVpcmUoJy4uLy4uLy4uL2ludGVyY2VwdG9yL3BhdGhQcmVmaXgnKTtcblx0XHR0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2ludGVyY2VwdG9yL3RlbXBsYXRlJyk7XG5cdFx0ZmluZCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvZmluZCcpO1xuXHRcdGxhenlQcm9taXNlID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC9sYXp5UHJvbWlzZScpO1xuXHRcdHJlc3BvbnNlUHJvbWlzZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvcmVzcG9uc2VQcm9taXNlJyk7XG5cdFx0d2hlbiA9IHJlcXVpcmUoJ3doZW4nKTtcblxuXHRcdGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwgdmFsdWUpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcblx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0XHR3cml0ZWFibGU6IHRydWVcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEh5cGVydGV4dCBBcHBsaWNhdGlvbiBMYW5ndWFnZSBzZXJpYWxpemVyXG5cdFx0ICpcblx0XHQgKiBJbXBsZW1lbnRlZCB0byBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQta2VsbHktanNvbi1oYWwtMDZcblx0XHQgKlxuXHRcdCAqIEFzIHRoZSBzcGVjIGlzIHN0aWxsIGEgZHJhZnQsIHRoaXMgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1cGRhdGVkIGFzIHRoZVxuXHRcdCAqIHNwZWMgZXZvbHZlc1xuXHRcdCAqXG5cdFx0ICogT2JqZWN0cyBhcmUgcmVhZCBhcyBIQUwgaW5kZXhpbmcgbGlua3MgYW5kIGVtYmVkZGVkIG9iamVjdHMgb24gdG8gdGhlXG5cdFx0ICogcmVzb3VyY2UuIE9iamVjdHMgYXJlIHdyaXR0ZW4gYXMgcGxhaW4gSlNPTi5cblx0XHQgKlxuXHRcdCAqIEVtYmVkZGVkIHJlbGF0aW9uc2hpcHMgYXJlIGluZGV4ZWQgb250byB0aGUgcmVzb3VyY2UgYnkgdGhlIHJlbGF0aW9uc2hpcFxuXHRcdCAqIGFzIGEgcHJvbWlzZSBmb3IgdGhlIHJlbGF0ZWQgcmVzb3VyY2UuXG5cdFx0ICpcblx0XHQgKiBMaW5rcyBhcmUgaW5kZXhlZCBvbnRvIHRoZSByZXNvdXJjZSBhcyBhIGxhenkgcHJvbWlzZSB0aGF0IHdpbGwgR0VUIHRoZVxuXHRcdCAqIHJlc291cmNlIHdoZW4gYSBoYW5kbGVyIGlzIGZpcnN0IHJlZ2lzdGVyZWQgb24gdGhlIHByb21pc2UuXG5cdFx0ICpcblx0XHQgKiBBIGByZXF1ZXN0Rm9yYCBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIGVudGl0eSB0byBtYWtlIGEgcmVxdWVzdCBmb3IgdGhlXG5cdFx0ICogcmVsYXRpb25zaGlwLlxuXHRcdCAqXG5cdFx0ICogQSBgY2xpZW50Rm9yYCBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIGVudGl0eSB0byBnZXQgYSBmdWxsIENsaWVudCBmb3IgYVxuXHRcdCAqIHJlbGF0aW9uc2hpcC5cblx0XHQgKlxuXHRcdCAqIFRoZSBgX2xpbmtzYCBhbmQgYF9lbWJlZGRlZGAgcHJvcGVydGllcyBvbiB0aGUgcmVzb3VyY2UgYXJlIG1hZGVcblx0XHQgKiBub24tZW51bWVyYWJsZS5cblx0XHQgKi9cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG5cdFx0XHRcdHZhciBjbGllbnQsIGNvbnNvbGU7XG5cblx0XHRcdFx0b3B0cyA9IG9wdHMgfHwge307XG5cdFx0XHRcdGNsaWVudCA9IG9wdHMuY2xpZW50O1xuXHRcdFx0XHRjb25zb2xlID0gb3B0cy5jb25zb2xlIHx8IGNvbnNvbGU7XG5cblx0XHRcdFx0ZnVuY3Rpb24gZGVwcmVjYXRpb25XYXJuaW5nKHJlbGF0aW9uc2hpcCwgZGVwcmVjYXRpb24pIHtcblx0XHRcdFx0XHRpZiAoZGVwcmVjYXRpb24gJiYgY29uc29sZSAmJiBjb25zb2xlLndhcm4gfHwgY29uc29sZS5sb2cpIHtcblx0XHRcdFx0XHRcdChjb25zb2xlLndhcm4gfHwgY29uc29sZS5sb2cpLmNhbGwoY29uc29sZSwgJ1JlbGF0aW9uc2hpcCBcXCcnICsgcmVsYXRpb25zaGlwICsgJ1xcJyBpcyBkZXByZWNhdGVkLCBzZWUgJyArIGRlcHJlY2F0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gb3B0cy5yZWdpc3RyeS5sb29rdXAob3B0cy5taW1lLnN1ZmZpeCkudGhlbihmdW5jdGlvbiAoY29udmVydGVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHdoZW4oY29udmVydGVyLnJlYWQoc3RyLCBvcHRzKSkudGhlbihmdW5jdGlvbiAocm9vdCkge1xuXG5cdFx0XHRcdFx0XHRmaW5kLmZpbmRQcm9wZXJ0aWVzKHJvb3QsICdfZW1iZWRkZWQnLCBmdW5jdGlvbiAoZW1iZWRkZWQsIHJlc291cmNlLCBuYW1lKSB7XG5cdFx0XHRcdFx0XHRcdE9iamVjdC5rZXlzKGVtYmVkZGVkKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGlvbnNoaXApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAocmVsYXRpb25zaGlwIGluIHJlc291cmNlKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdFx0XHRcdHZhciByZWxhdGVkID0gcmVzcG9uc2VQcm9taXNlKHtcblx0XHRcdFx0XHRcdFx0XHRcdGVudGl0eTogZW1iZWRkZWRbcmVsYXRpb25zaGlwXVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KHJlc291cmNlLCByZWxhdGlvbnNoaXAsIHJlbGF0ZWQpO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkocmVzb3VyY2UsIG5hbWUsIGVtYmVkZGVkKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0ZmluZC5maW5kUHJvcGVydGllcyhyb290LCAnX2xpbmtzJywgZnVuY3Rpb24gKGxpbmtzLCByZXNvdXJjZSwgbmFtZSkge1xuXHRcdFx0XHRcdFx0XHRPYmplY3Qua2V5cyhsaW5rcykuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpb25zaGlwKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGxpbmsgPSBsaW5rc1tyZWxhdGlvbnNoaXBdO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChyZWxhdGlvbnNoaXAgaW4gcmVzb3VyY2UpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkocmVzb3VyY2UsIHJlbGF0aW9uc2hpcCwgcmVzcG9uc2VQcm9taXNlLm1ha2UobGF6eVByb21pc2UoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGxpbmsuZGVwcmVjYXRpb24pIHsgZGVwcmVjYXRpb25XYXJuaW5nKHJlbGF0aW9uc2hpcCwgbGluay5kZXByZWNhdGlvbik7IH1cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChsaW5rLnRlbXBsYXRlZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGVtcGxhdGUoY2xpZW50KSh7IHBhdGg6IGxpbmsuaHJlZiB9KTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBjbGllbnQoeyBwYXRoOiBsaW5rLmhyZWYgfSk7XG5cdFx0XHRcdFx0XHRcdFx0fSkpKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KHJlc291cmNlLCBuYW1lLCBsaW5rcyk7XG5cdFx0XHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KHJlc291cmNlLCAnY2xpZW50Rm9yJywgZnVuY3Rpb24gKHJlbGF0aW9uc2hpcCwgY2xpZW50T3ZlcnJpZGUpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgbGluayA9IGxpbmtzW3JlbGF0aW9uc2hpcF07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFsaW5rKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcmVsYXRpb25zaGlwOiAnICsgcmVsYXRpb25zaGlwKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGxpbmsuZGVwcmVjYXRpb24pIHsgZGVwcmVjYXRpb25XYXJuaW5nKHJlbGF0aW9uc2hpcCwgbGluay5kZXByZWNhdGlvbik7IH1cblx0XHRcdFx0XHRcdFx0XHRpZiAobGluay50ZW1wbGF0ZWQgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0ZW1wbGF0ZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xpZW50T3ZlcnJpZGUgfHwgY2xpZW50LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRlbXBsYXRlOiBsaW5rLmhyZWYgfVxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhdGhQcmVmaXgoXG5cdFx0XHRcdFx0XHRcdFx0XHRjbGllbnRPdmVycmlkZSB8fCBjbGllbnQsXG5cdFx0XHRcdFx0XHRcdFx0XHR7IHByZWZpeDogbGluay5ocmVmIH1cblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkocmVzb3VyY2UsICdyZXF1ZXN0Rm9yJywgZnVuY3Rpb24gKHJlbGF0aW9uc2hpcCwgcmVxdWVzdCwgY2xpZW50T3ZlcnJpZGUpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgY2xpZW50ID0gdGhpcy5jbGllbnRGb3IocmVsYXRpb25zaGlwLCBjbGllbnRPdmVycmlkZSk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNsaWVudChyZXF1ZXN0KTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHJvb3Q7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHR3cml0ZTogZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuXHRcdFx0XHRyZXR1cm4gb3B0cy5yZWdpc3RyeS5sb29rdXAob3B0cy5taW1lLnN1ZmZpeCkudGhlbihmdW5jdGlvbiAoY29udmVydGVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbnZlcnRlci53cml0ZShvYmosIG9wdHMpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdH07XG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTItMjAxNSB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAoLyogcmVxdWlyZSAqLykge1xuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgbmV3IEpTT04gY29udmVydGVyIHdpdGggY3VzdG9tIHJldml2ZXIvcmVwbGFjZXIuXG5cdFx0ICpcblx0XHQgKiBUaGUgZXh0ZW5kZWQgY29udmVydGVyIG11c3QgYmUgcHVibGlzaGVkIHRvIGEgTUlNRSByZWdpc3RyeSBpbiBvcmRlclxuXHRcdCAqIHRvIGJlIHVzZWQuIFRoZSBleGlzdGluZyBjb252ZXJ0ZXIgd2lsbCBub3QgYmUgbW9kaWZpZWQuXG5cdFx0ICpcblx0XHQgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT05cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZXZpdmVyPXVuZGVmaW5lZF0gY3VzdG9tIEpTT04ucGFyc2UgcmV2aXZlclxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb258QXJyYXl9IFtyZXBsYWNlcj11bmRlZmluZWRdIGN1c3RvbSBKU09OLnN0cmluZ2lmeSByZXBsYWNlclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvbnZlcnRlcihyZXZpdmVyLCByZXBsYWNlcikge1xuXHRcdFx0cmV0dXJuIHtcblxuXHRcdFx0XHRyZWFkOiBmdW5jdGlvbiAoc3RyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEpTT04ucGFyc2Uoc3RyLCByZXZpdmVyKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHR3cml0ZTogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHRleHRlbmQ6IGNyZWF0ZUNvbnZlcnRlclxuXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVDb252ZXJ0ZXIoKTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEyIHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uICgvKiByZXF1aXJlICovKSB7XG5cblx0XHR2YXIgZW5jb2RlZFNwYWNlUkUsIHVybEVuY29kZWRTcGFjZVJFO1xuXG5cdFx0ZW5jb2RlZFNwYWNlUkUgPSAvJTIwL2c7XG5cdFx0dXJsRW5jb2RlZFNwYWNlUkUgPSAvXFwrL2c7XG5cblx0XHRmdW5jdGlvbiB1cmxFbmNvZGUoc3RyKSB7XG5cdFx0XHRzdHIgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyKTtcblx0XHRcdC8vIHNwZWMgc2F5cyBzcGFjZSBzaG91bGQgYmUgZW5jb2RlZCBhcyAnKydcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZShlbmNvZGVkU3BhY2VSRSwgJysnKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cmxEZWNvZGUoc3RyKSB7XG5cdFx0XHQvLyBzcGVjIHNheXMgc3BhY2Ugc2hvdWxkIGJlIGVuY29kZWQgYXMgJysnXG5cdFx0XHRzdHIgPSBzdHIucmVwbGFjZSh1cmxFbmNvZGVkU3BhY2VSRSwgJyAnKTtcblx0XHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhcHBlbmQoc3RyLCBuYW1lLCB2YWx1ZSkge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdFx0c3RyID0gYXBwZW5kKHN0ciwgbmFtZSwgdmFsdWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAoc3RyLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRzdHIgKz0gJyYnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0ciArPSB1cmxFbmNvZGUobmFtZSk7XG5cdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0c3RyICs9ICc9JyArIHVybEVuY29kZSh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBzdHI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0cmVhZDogZnVuY3Rpb24gKHN0cikge1xuXHRcdFx0XHR2YXIgb2JqID0ge307XG5cdFx0XHRcdHN0ci5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG5cdFx0XHRcdFx0dmFyIHBhaXIsIG5hbWUsIHZhbHVlO1xuXHRcdFx0XHRcdHBhaXIgPSBlbnRyeS5zcGxpdCgnPScpO1xuXHRcdFx0XHRcdG5hbWUgPSB1cmxEZWNvZGUocGFpclswXSk7XG5cdFx0XHRcdFx0aWYgKHBhaXIubGVuZ3RoID09PSAyKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHVybERlY29kZShwYWlyWzFdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChuYW1lIGluIG9iaikge1xuXHRcdFx0XHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KG9ialtuYW1lXSkpIHtcblx0XHRcdFx0XHRcdFx0Ly8gY29udmVydCB0byBhbiBhcnJheSwgcGVyc2VydmluZyBjdXJybmVudCB2YWx1ZVxuXHRcdFx0XHRcdFx0XHRvYmpbbmFtZV0gPSBbb2JqW25hbWVdXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG9ialtuYW1lXS5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRvYmpbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fSxcblxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0dmFyIHN0ciA9ICcnO1xuXHRcdFx0XHRPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0XHRzdHIgPSBhcHBlbmQoc3RyLCBuYW1lLCBvYmpbbmFtZV0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIHN0cjtcblx0XHRcdH1cblxuXHRcdH07XG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTQgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgTWljaGFlbCBKYWNrc29uXG4gKi9cblxuLyogZ2xvYmFsIEZvcm1EYXRhLCBGaWxlLCBCbG9iICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKC8qIHJlcXVpcmUgKi8pIHtcblxuXHRcdGZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0KSB7XG5cdFx0XHRyZXR1cm4gb2JqZWN0ICYmXG5cdFx0XHRcdG9iamVjdC5ub2RlVHlwZSA9PT0gMSAmJiAvLyBOb2RlLkVMRU1FTlRfTk9ERVxuXHRcdFx0XHRvYmplY3QudGFnTmFtZSA9PT0gJ0ZPUk0nO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUZvcm1EYXRhRnJvbU9iamVjdChvYmplY3QpIHtcblx0XHRcdHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRmb3IgKHZhciBwcm9wZXJ0eSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG5cblx0XHRcdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBGaWxlKSB7XG5cdFx0XHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQocHJvcGVydHksIHZhbHVlLCB2YWx1ZS5uYW1lKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRcdFx0Zm9ybURhdGEuYXBwZW5kKHByb3BlcnR5LCB2YWx1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZvcm1EYXRhLmFwcGVuZChwcm9wZXJ0eSwgU3RyaW5nKHZhbHVlKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmb3JtRGF0YTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHR3cml0ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIEZvcm1EYXRhID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVGhlIG11bHRpcGFydC9mb3JtLWRhdGEgbWltZSBzZXJpYWxpemVyIHJlcXVpcmVzIEZvcm1EYXRhIHN1cHBvcnQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQgRm9ybURhdGEgZGlyZWN0bHkuXG5cdFx0XHRcdGlmIChvYmplY3QgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuXHRcdFx0XHRcdHJldHVybiBvYmplY3Q7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0IDxmb3JtPiBlbGVtZW50cy5cblx0XHRcdFx0aWYgKGlzRm9ybUVsZW1lbnQob2JqZWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgRm9ybURhdGEob2JqZWN0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQgcGxhaW4gb2JqZWN0cywgbWF5IGNvbnRhaW4gRmlsZS9CbG9iIGFzIHZhbHVlLlxuXHRcdFx0XHRpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNyZWF0ZUZvcm1EYXRhRnJvbU9iamVjdChvYmplY3QpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gY3JlYXRlIEZvcm1EYXRhIGZyb20gb2JqZWN0ICcgKyBvYmplY3QpO1xuXHRcdFx0fVxuXG5cdFx0fTtcblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMiB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAoLyogcmVxdWlyZSAqLykge1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0cmVhZDogZnVuY3Rpb24gKHN0cikge1xuXHRcdFx0XHRyZXR1cm4gc3RyO1xuXHRcdFx0fSxcblxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0cmV0dXJuIG9iai50b1N0cmluZygpO1xuXHRcdFx0fVxuXG5cdFx0fTtcblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMyB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAoLyogcmVxdWlyZSAqLykge1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBGaW5kIG9iamVjdHMgd2l0aGluIGEgZ3JhcGggdGhlIGNvbnRhaW4gYSBwcm9wZXJ0eSBvZiBhIGNlcnRhaW4gbmFtZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBOT1RFOiB0aGlzIG1ldGhvZCB3aWxsIG5vdCBkaXNjb3ZlciBvYmplY3QgZ3JhcGggY3ljbGVzLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7Kn0gb2JqIG9iamVjdCB0byBzZWFyY2ggb25cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHNlYXJjaCBmb3Jcblx0XHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJlY2VpdmUgdGhlIGZvdW5kIHByb3BlcnRpZXMgYW5kIHRoZWlyIHBhcmVudFxuXHRcdFx0ICovXG5cdFx0XHRmaW5kUHJvcGVydGllczogZnVuY3Rpb24gZmluZFByb3BlcnRpZXMob2JqLCBwcm9wLCBjYWxsYmFjaykge1xuXHRcdFx0XHRpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7IHJldHVybjsgfVxuXHRcdFx0XHRpZiAocHJvcCBpbiBvYmopIHtcblx0XHRcdFx0XHRjYWxsYmFjayhvYmpbcHJvcF0sIG9iaiwgcHJvcCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0T2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRmaW5kUHJvcGVydGllcyhvYmpba2V5XSwgcHJvcCwgY2FsbGJhY2spO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMyB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0dmFyIHdoZW47XG5cblx0XHR3aGVuID0gcmVxdWlyZSgnd2hlbicpO1xuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgcHJvbWlzZSB3aG9zZSB3b3JrIGlzIHN0YXJ0ZWQgb25seSB3aGVuIGEgaGFuZGxlciBpcyByZWdpc3RlcmVkLlxuXHRcdCAqXG5cdFx0ICogVGhlIHdvcmsgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGF0IG1vc3Qgb25jZS4gVGhyb3duIHZhbHVlcyB3aWxsIHJlc3VsdFxuXHRcdCAqIGluIHByb21pc2UgcmVqZWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gd29yayBmdW5jdGlvbiB3aG9zZSBvdXB1dCBpcyB1c2VkIHRvIHJlc29sdmUgdGhlXG5cdFx0ICogICByZXR1cm5lZCBwcm9taXNlLlxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBhIGxhenkgcHJvbWlzZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGxhenlQcm9taXNlKHdvcmspIHtcblx0XHRcdHZhciBkZWZlciwgc3RhcnRlZCwgcmVzb2x2ZXIsIHByb21pc2UsIHRoZW47XG5cblx0XHRcdGRlZmVyID0gd2hlbi5kZWZlcigpO1xuXHRcdFx0c3RhcnRlZCA9IGZhbHNlO1xuXG5cdFx0XHRyZXNvbHZlciA9IGRlZmVyLnJlc29sdmVyO1xuXHRcdFx0cHJvbWlzZSA9IGRlZmVyLnByb21pc2U7XG5cdFx0XHR0aGVuID0gcHJvbWlzZS50aGVuO1xuXG5cdFx0XHRwcm9taXNlLnRoZW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmICghc3RhcnRlZCkge1xuXHRcdFx0XHRcdHN0YXJ0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHdoZW4uYXR0ZW1wdCh3b3JrKS50aGVuKHJlc29sdmVyLnJlc29sdmUsIHJlc29sdmVyLnJlamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoZW4uYXBwbHkocHJvbWlzZSwgYXJndW1lbnRzKTtcblx0XHRcdH07XG5cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH1cblxuXHRcdHJldHVybiBsYXp5UHJvbWlzZTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHQvLyBkZXJpdmVkIGZyb20gZG9qby5taXhpblxuXHRkZWZpbmUoZnVuY3Rpb24gKC8qIHJlcXVpcmUgKi8pIHtcblxuXHRcdHZhciBlbXB0eSA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogTWl4IHRoZSBwcm9wZXJ0aWVzIGZyb20gdGhlIHNvdXJjZSBvYmplY3QgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuXHRcdCAqIFdoZW4gdGhlIHNhbWUgcHJvcGVydHkgb2NjdXJzIGluIG1vcmUgdGhlbiBvbmUgb2JqZWN0LCB0aGUgcmlnaHQgbW9zdFxuXHRcdCAqIHZhbHVlIHdpbnMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZGVzdCB0aGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0b1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VzIHRoZSBvYmplY3RzIHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLiAgTWF5IGJlIDEgdG8gTiBhcmd1bWVudHMsIGJ1dCBub3QgYW4gQXJyYXkuXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSB0aGUgZGVzdGluYXRpb24gb2JqZWN0XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gbWl4aW4oZGVzdCAvKiwgc291cmNlcy4uLiAqLykge1xuXHRcdFx0dmFyIGksIGwsIHNvdXJjZSwgbmFtZTtcblxuXHRcdFx0aWYgKCFkZXN0KSB7IGRlc3QgPSB7fTsgfVxuXHRcdFx0Zm9yIChpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcblx0XHRcdFx0c291cmNlID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gc291cmNlKSB7XG5cdFx0XHRcdFx0aWYgKCEobmFtZSBpbiBkZXN0KSB8fCAoZGVzdFtuYW1lXSAhPT0gc291cmNlW25hbWVdICYmICghKG5hbWUgaW4gZW1wdHkpIHx8IGVtcHR5W25hbWVdICE9PSBzb3VyY2VbbmFtZV0pKSkge1xuXHRcdFx0XHRcdFx0ZGVzdFtuYW1lXSA9IHNvdXJjZVtuYW1lXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRlc3Q7IC8vIE9iamVjdFxuXHRcdH1cblxuXHRcdHJldHVybiBtaXhpbjtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEyIHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uICgvKiByZXF1aXJlICovKSB7XG5cblx0XHQvKipcblx0XHQgKiBOb3JtYWxpemUgSFRUUCBoZWFkZXIgbmFtZXMgdXNpbmcgdGhlIHBzZXVkbyBjYW1lbCBjYXNlLlxuXHRcdCAqXG5cdFx0ICogRm9yIGV4YW1wbGU6XG5cdFx0ICogICBjb250ZW50LXR5cGUgICAgICAgICAtPiBDb250ZW50LVR5cGVcblx0XHQgKiAgIGFjY2VwdHMgICAgICAgICAgICAgIC0+IEFjY2VwdHNcblx0XHQgKiAgIHgtY3VzdG9tLWhlYWRlci1uYW1lIC0+IFgtQ3VzdG9tLUhlYWRlci1OYW1lXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcmF3IGhlYWRlciBuYW1lXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfSB0aGUgbm9ybWFsaXplZCBoZWFkZXIgbmFtZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUobmFtZSkge1xuXHRcdFx0cmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuXHRcdFx0XHQuc3BsaXQoJy0nKVxuXHRcdFx0XHQubWFwKGZ1bmN0aW9uIChjaHVuaykgeyByZXR1cm4gY2h1bmsuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjaHVuay5zbGljZSgxKTsgfSlcblx0XHRcdFx0LmpvaW4oJy0nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbm9ybWFsaXplSGVhZGVyTmFtZTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHRcdHZhciB3aGVuID0gcmVxdWlyZSgnd2hlbicpLFxuXHRcdFx0bm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vbm9ybWFsaXplSGVhZGVyTmFtZScpO1xuXG5cdFx0ZnVuY3Rpb24gcHJvcGVydHkocHJvbWlzZSwgbmFtZSkge1xuXHRcdFx0cmV0dXJuIHByb21pc2UudGhlbihcblx0XHRcdFx0ZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlICYmIHZhbHVlW25hbWVdO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gd2hlbi5yZWplY3QodmFsdWUgJiYgdmFsdWVbbmFtZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIE9idGFpbiB0aGUgcmVzcG9uc2UgZW50aXR5XG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gZm9yIHRoZSByZXNwb25zZSBlbnRpdHlcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBlbnRpdHkoKSB7XG5cdFx0XHQvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuXHRcdFx0cmV0dXJuIHByb3BlcnR5KHRoaXMsICdlbnRpdHknKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBPYnRhaW4gdGhlIHJlc3BvbnNlIHN0YXR1c1xuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IGZvciB0aGUgcmVzcG9uc2Ugc3RhdHVzXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gc3RhdHVzKCkge1xuXHRcdFx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cblx0XHRcdHJldHVybiBwcm9wZXJ0eShwcm9wZXJ0eSh0aGlzLCAnc3RhdHVzJyksICdjb2RlJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogT2J0YWluIHRoZSByZXNwb25zZSBoZWFkZXJzIG1hcFxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IGZvciB0aGUgcmVzcG9uc2UgaGVhZGVycyBtYXBcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBoZWFkZXJzKCkge1xuXHRcdFx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cblx0XHRcdHJldHVybiBwcm9wZXJ0eSh0aGlzLCAnaGVhZGVycycpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIE9idGFpbiBhIHNwZWNpZmljIHJlc3BvbnNlIGhlYWRlclxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlck5hbWUgdGhlIGhlYWRlciB0byByZXRyaWV2ZVxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBmb3IgdGhlIHJlc3BvbnNlIGhlYWRlcidzIHZhbHVlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gaGVhZGVyKGhlYWRlck5hbWUpIHtcblx0XHRcdC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG5cdFx0XHRoZWFkZXJOYW1lID0gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJOYW1lKTtcblx0XHRcdHJldHVybiBwcm9wZXJ0eSh0aGlzLmhlYWRlcnMoKSwgaGVhZGVyTmFtZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogRm9sbG93IGEgcmVsYXRlZCByZXNvdXJjZVxuXHRcdCAqXG5cdFx0ICogVGhlIHJlbGF0aW9uc2hpcCB0byBmb2xsb3cgbWF5IGJlIGRlZmluZSBhcyBhIHBsYWluIHN0cmluZywgYW4gb2JqZWN0XG5cdFx0ICogd2l0aCB0aGUgcmVsIGFuZCBwYXJhbXMsIG9yIGFuIGFycmF5IGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgZW50cmllc1xuXHRcdCAqIHdpdGggdGhlIHByZXZpb3VzIGZvcm1zLlxuXHRcdCAqXG5cdFx0ICogRXhhbXBsZXM6XG5cdFx0ICogICByZXNwb25zZS5mb2xsb3coJ25leHQnKVxuXHRcdCAqXG5cdFx0ICogICByZXNwb25zZS5mb2xsb3coeyByZWw6ICduZXh0JywgcGFyYW1zOiB7IHBhZ2VTaXplOiAxMDAgfSB9KVxuXHRcdCAqXG5cdFx0ICogICByZXNwb25zZS5mb2xsb3coW1xuXHRcdCAqICAgICAgIHsgcmVsOiAnaXRlbXMnLCBwYXJhbXM6IHsgcHJvamVjdGlvbjogJ25vSW1hZ2VzJyB9IH0sXG5cdFx0ICogICAgICAgJ3NlYXJjaCcsXG5cdFx0ICogICAgICAgeyByZWw6ICdmaW5kQnlHYWxsZXJ5SXNOdWxsJywgcGFyYW1zOiB7IHByb2plY3Rpb246ICdub0ltYWdlcycgfSB9LFxuXHRcdCAqICAgICAgICdpdGVtcydcblx0XHQgKiAgIF0pXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8QXJyYXl9IHJlbHMgb25lLCBvciBtb3JlLCByZWxhdGlvbnNoaXBzIHRvIGZvbGxvd1xuXHRcdCAqIEByZXR1cm5zIFJlc3BvbnNlUHJvbWlzZTxSZXNwb25zZT4gcmVsYXRlZCByZXNvdXJjZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGZvbGxvdyhyZWxzKSB7XG5cdFx0XHQvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuXHRcdFx0cmVscyA9IFtdLmNvbmNhdChyZWxzKTtcblx0XHRcdHJldHVybiBtYWtlKHdoZW4ucmVkdWNlKHJlbHMsIGZ1bmN0aW9uIChyZXNwb25zZSwgcmVsKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgcmVsID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHJlbCA9IHsgcmVsOiByZWwgfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZW9mIHJlc3BvbnNlLmVudGl0eS5jbGllbnRGb3IgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0h5cGVybWVkaWEgcmVzcG9uc2UgZXhwZWN0ZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgY2xpZW50ID0gcmVzcG9uc2UuZW50aXR5LmNsaWVudEZvcihyZWwucmVsKTtcblx0XHRcdFx0cmV0dXJuIGNsaWVudCh7IHBhcmFtczogcmVsLnBhcmFtcyB9KTtcblx0XHRcdH0sIHRoaXMpKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBXcmFwIGEgUHJvbWlzZSBhcyBhbiBSZXNwb25zZVByb21pc2Vcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7UHJvbWlzZTxSZXNwb25zZT59IHByb21pc2UgdGhlIHByb21pc2UgZm9yIGFuIEhUVFAgUmVzcG9uc2Vcblx0XHQgKiBAcmV0dXJucyB7UmVzcG9uc2VQcm9taXNlPFJlc3BvbnNlPn0gd3JhcHBlZCBwcm9taXNlIGZvciBSZXNwb25zZSB3aXRoIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHNcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBtYWtlKHByb21pc2UpIHtcblx0XHRcdHByb21pc2Uuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0cHJvbWlzZS5oZWFkZXJzID0gaGVhZGVycztcblx0XHRcdHByb21pc2UuaGVhZGVyID0gaGVhZGVyO1xuXHRcdFx0cHJvbWlzZS5lbnRpdHkgPSBlbnRpdHk7XG5cdFx0XHRwcm9taXNlLmZvbGxvdyA9IGZvbGxvdztcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc3BvbnNlUHJvbWlzZSgpIHtcblx0XHRcdHJldHVybiBtYWtlKHdoZW4uYXBwbHkod2hlbiwgYXJndW1lbnRzKSk7XG5cdFx0fVxuXG5cdFx0cmVzcG9uc2VQcm9taXNlLm1ha2UgPSBtYWtlO1xuXHRcdHJlc3BvbnNlUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRyZXR1cm4gbWFrZSh3aGVuLnJlamVjdCh2YWwpKTtcblx0XHR9O1xuXHRcdHJlc3BvbnNlUHJvbWlzZS5wcm9taXNlID0gZnVuY3Rpb24gKGZ1bmMpIHtcblx0XHRcdHJldHVybiBtYWtlKHdoZW4ucHJvbWlzZShmdW5jKSk7XG5cdFx0fTtcblxuXHRcdHJldHVybiByZXNwb25zZVByb21pc2U7XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNSB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAoLyogcmVxdWlyZSAqLykge1xuXG5cdFx0dmFyIGNoYXJNYXA7XG5cblx0XHRjaGFyTWFwID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzdHJpbmdzID0ge1xuXHRcdFx0XHRhbHBoYTogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLFxuXHRcdFx0XHRkaWdpdDogJzAxMjM0NTY3ODknXG5cdFx0XHR9O1xuXG5cdFx0XHRzdHJpbmdzLmdlbkRlbGltcyA9ICc6Lz8jW11AJztcblx0XHRcdHN0cmluZ3Muc3ViRGVsaW1zID0gJyEkJlxcJygpKissOz0nO1xuXHRcdFx0c3RyaW5ncy5yZXNlcnZlZCA9IHN0cmluZ3MuZ2VuRGVsaW1zICsgc3RyaW5ncy5zdWJEZWxpbXM7XG5cdFx0XHRzdHJpbmdzLnVucmVzZXJ2ZWQgPSBzdHJpbmdzLmFscGhhICsgc3RyaW5ncy5kaWdpdCArICctLl9+Jztcblx0XHRcdHN0cmluZ3MudXJsID0gc3RyaW5ncy5yZXNlcnZlZCArIHN0cmluZ3MudW5yZXNlcnZlZDtcblx0XHRcdHN0cmluZ3Muc2NoZW1lID0gc3RyaW5ncy5hbHBoYSArIHN0cmluZ3MuZGlnaXQgKyAnKy0uJztcblx0XHRcdHN0cmluZ3MudXNlcmluZm8gPSBzdHJpbmdzLnVucmVzZXJ2ZWQgKyBzdHJpbmdzLnN1YkRlbGltcyArICc6Jztcblx0XHRcdHN0cmluZ3MuaG9zdCA9IHN0cmluZ3MudW5yZXNlcnZlZCArIHN0cmluZ3Muc3ViRGVsaW1zO1xuXHRcdFx0c3RyaW5ncy5wb3J0ID0gc3RyaW5ncy5kaWdpdDtcblx0XHRcdHN0cmluZ3MucGNoYXIgPSBzdHJpbmdzLnVucmVzZXJ2ZWQgKyBzdHJpbmdzLnN1YkRlbGltcyArICc6QCc7XG5cdFx0XHRzdHJpbmdzLnNlZ21lbnQgPSBzdHJpbmdzLnBjaGFyO1xuXHRcdFx0c3RyaW5ncy5wYXRoID0gc3RyaW5ncy5zZWdtZW50ICsgJy8nO1xuXHRcdFx0c3RyaW5ncy5xdWVyeSA9IHN0cmluZ3MucGNoYXIgKyAnLz8nO1xuXHRcdFx0c3RyaW5ncy5mcmFnbWVudCA9IHN0cmluZ3MucGNoYXIgKyAnLz8nO1xuXG5cdFx0XHRyZXR1cm4gT2JqZWN0LmtleXMoc3RyaW5ncykucmVkdWNlKGZ1bmN0aW9uIChjaGFyTWFwLCBzZXQpIHtcblx0XHRcdFx0Y2hhck1hcFtzZXRdID0gc3RyaW5nc1tzZXRdLnNwbGl0KCcnKS5yZWR1Y2UoZnVuY3Rpb24gKGNoYXJzLCBteUNoYXIpIHtcblx0XHRcdFx0XHRjaGFyc1tteUNoYXJdID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm4gY2hhcnM7XG5cdFx0XHRcdH0sIHt9KTtcblx0XHRcdFx0cmV0dXJuIGNoYXJNYXA7XG5cdFx0XHR9LCB7fSk7XG5cdFx0fSgpKTtcblxuXHRcdGZ1bmN0aW9uIGVuY29kZShzdHIsIGFsbG93ZWQpIHtcblx0XHRcdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyByZXF1aXJlZCBmb3IgVVJMIGVuY29kaW5nJyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKG15Q2hhcikge1xuXHRcdFx0XHRpZiAoYWxsb3dlZC5oYXNPd25Qcm9wZXJ0eShteUNoYXIpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG15Q2hhcjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgY29kZSA9IG15Q2hhci5jaGFyQ29kZUF0KDApO1xuXHRcdFx0XHRpZiAoY29kZSA8PSAxMjcpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnICsgY29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG15Q2hhcikudG9VcHBlckNhc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSkuam9pbignJyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWFrZUVuY29kZXIoYWxsb3dlZCkge1xuXHRcdFx0YWxsb3dlZCA9IGFsbG93ZWQgfHwgY2hhck1hcC51bnJlc2VydmVkO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChzdHIpIHtcblx0XHRcdFx0cmV0dXJuIGVuY29kZShzdHIsIGFsbG93ZWQpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG5cdFx0XHRyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0Lypcblx0XHRcdCAqIERlY29kZSBVUkwgZW5jb2RlZCBzdHJpbmdzXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IFVSTCBlbmNvZGVkIHN0cmluZ1xuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ30gVVJMIGRlY29kZWQgc3RyaW5nXG5cdFx0XHQgKi9cblx0XHRcdGRlY29kZTogZGVjb2RlLFxuXG5cdFx0XHQvKlxuXHRcdFx0ICogVVJMIGVuY29kZSBhIHN0cmluZ1xuXHRcdFx0ICpcblx0XHRcdCAqIEFsbCBidXQgYWxwaGEtbnVtZXJpY3MgYW5kIGEgdmVyeSBsaW1pdGVkIHNldCBvZiBwdW5jdHVhdGlvbiAtIC4gXyB+IGFyZVxuXHRcdFx0ICogZW5jb2RlZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIHRvIGVuY29kZVxuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ30gVVJMIGVuY29kZWQgc3RyaW5nXG5cdFx0XHQgKi9cblx0XHRcdGVuY29kZTogbWFrZUVuY29kZXIoKSxcblxuXHRcdFx0Lypcblx0XHRcdCogVVJMIGVuY29kZSBhIFVSTFxuXHRcdFx0KlxuXHRcdFx0KiBBbGwgY2hhcmFjdGVyIHBlcm1pdHRlZCBhbnl3aGVyZSBpbiBhIFVSTCBhcmUgbGVmdCB1bmVuY29kZWQgZXZlblxuXHRcdFx0KiBpZiB0aGF0IGNoYXJhY3RlciBpcyBub3QgcGVybWl0dGVkIGluIHRoYXQgcG9ydGlvbiBvZiBhIFVSTC5cblx0XHRcdCpcblx0XHRcdCogTm90ZTogVGhpcyBtZXRob2QgaXMgdHlwaWNhbGx5IG5vdCB3aGF0IHlvdSB3YW50LlxuXHRcdFx0KlxuXHRcdFx0KiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIHRvIGVuY29kZVxuXHRcdFx0KiBAcmV0dXJucyB7c3RyaW5nfSBVUkwgZW5jb2RlZCBzdHJpbmdcblx0XHRcdCovXG5cdFx0XHRlbmNvZGVVUkw6IG1ha2VFbmNvZGVyKGNoYXJNYXAudXJsKSxcblxuXHRcdFx0Lypcblx0XHRcdCAqIFVSTCBlbmNvZGUgdGhlIHNjaGVtZSBwb3J0aW9uIG9mIGEgVVJMXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBlbmNvZGVcblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBlbmNvZGVkIHN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRlbmNvZGVTY2hlbWU6IG1ha2VFbmNvZGVyKGNoYXJNYXAuc2NoZW1lKSxcblxuXHRcdFx0Lypcblx0XHRcdCAqIFVSTCBlbmNvZGUgdGhlIHVzZXIgaW5mbyBwb3J0aW9uIG9mIGEgVVJMXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBlbmNvZGVcblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBlbmNvZGVkIHN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRlbmNvZGVVc2VySW5mbzogbWFrZUVuY29kZXIoY2hhck1hcC51c2VyaW5mbyksXG5cblx0XHRcdC8qXG5cdFx0XHQgKiBVUkwgZW5jb2RlIHRoZSBob3N0IHBvcnRpb24gb2YgYSBVUkxcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIHRvIGVuY29kZVxuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ30gVVJMIGVuY29kZWQgc3RyaW5nXG5cdFx0XHQgKi9cblx0XHRcdGVuY29kZUhvc3Q6IG1ha2VFbmNvZGVyKGNoYXJNYXAuaG9zdCksXG5cblx0XHRcdC8qXG5cdFx0XHQgKiBVUkwgZW5jb2RlIHRoZSBwb3J0IHBvcnRpb24gb2YgYSBVUkxcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIHRvIGVuY29kZVxuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ30gVVJMIGVuY29kZWQgc3RyaW5nXG5cdFx0XHQgKi9cblx0XHRcdGVuY29kZVBvcnQ6IG1ha2VFbmNvZGVyKGNoYXJNYXAucG9ydCksXG5cblx0XHRcdC8qXG5cdFx0XHQgKiBVUkwgZW5jb2RlIGEgcGF0aCBzZWdtZW50IHBvcnRpb24gb2YgYSBVUkxcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIHRvIGVuY29kZVxuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ30gVVJMIGVuY29kZWQgc3RyaW5nXG5cdFx0XHQgKi9cblx0XHRcdGVuY29kZVBhdGhTZWdtZW50OiBtYWtlRW5jb2RlcihjaGFyTWFwLnNlZ21lbnQpLFxuXG5cdFx0XHQvKlxuXHRcdFx0ICogVVJMIGVuY29kZSB0aGUgcGF0aCBwb3J0aW9uIG9mIGEgVVJMXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBlbmNvZGVcblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBlbmNvZGVkIHN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRlbmNvZGVQYXRoOiBtYWtlRW5jb2RlcihjaGFyTWFwLnBhdGgpLFxuXG5cdFx0XHQvKlxuXHRcdFx0ICogVVJMIGVuY29kZSB0aGUgcXVlcnkgcG9ydGlvbiBvZiBhIFVSTFxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgdG8gZW5jb2RlXG5cdFx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfSBVUkwgZW5jb2RlZCBzdHJpbmdcblx0XHRcdCAqL1xuXHRcdFx0ZW5jb2RlUXVlcnk6IG1ha2VFbmNvZGVyKGNoYXJNYXAucXVlcnkpLFxuXG5cdFx0XHQvKlxuXHRcdFx0ICogVVJMIGVuY29kZSB0aGUgZnJhZ21lbnQgcG9ydGlvbiBvZiBhIFVSTFxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgdG8gZW5jb2RlXG5cdFx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfSBVUkwgZW5jb2RlZCBzdHJpbmdcblx0XHRcdCAqL1xuXHRcdFx0ZW5jb2RlRnJhZ21lbnQ6IG1ha2VFbmNvZGVyKGNoYXJNYXAuZnJhZ21lbnQpXG5cblx0XHR9O1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTUgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgdW5kZWY7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0XHR2YXIgdXJpRW5jb2Rlciwgb3BlcmF0aW9ucywgcHJlZml4UkU7XG5cblx0XHR1cmlFbmNvZGVyID0gcmVxdWlyZSgnLi91cmlFbmNvZGVyJyk7XG5cblx0XHRwcmVmaXhSRSA9IC9eKFteOl0qKTooWzAtOV0rKSQvO1xuXHRcdG9wZXJhdGlvbnMgPSB7XG5cdFx0XHQnJzogIHsgZmlyc3Q6ICcnLCAgc2VwYXJhdG9yOiAnLCcsIG5hbWVkOiBmYWxzZSwgZW1wdHk6ICcnLCAgZW5jb2RlcjogdXJpRW5jb2Rlci5lbmNvZGUgfSxcblx0XHRcdCcrJzogeyBmaXJzdDogJycsICBzZXBhcmF0b3I6ICcsJywgbmFtZWQ6IGZhbHNlLCBlbXB0eTogJycsICBlbmNvZGVyOiB1cmlFbmNvZGVyLmVuY29kZVVSTCB9LFxuXHRcdFx0JyMnOiB7IGZpcnN0OiAnIycsIHNlcGFyYXRvcjogJywnLCBuYW1lZDogZmFsc2UsIGVtcHR5OiAnJywgIGVuY29kZXI6IHVyaUVuY29kZXIuZW5jb2RlVVJMIH0sXG5cdFx0XHQnLic6IHsgZmlyc3Q6ICcuJywgc2VwYXJhdG9yOiAnLicsIG5hbWVkOiBmYWxzZSwgZW1wdHk6ICcnLCAgZW5jb2RlcjogdXJpRW5jb2Rlci5lbmNvZGUgfSxcblx0XHRcdCcvJzogeyBmaXJzdDogJy8nLCBzZXBhcmF0b3I6ICcvJywgbmFtZWQ6IGZhbHNlLCBlbXB0eTogJycsICBlbmNvZGVyOiB1cmlFbmNvZGVyLmVuY29kZSB9LFxuXHRcdFx0JzsnOiB7IGZpcnN0OiAnOycsIHNlcGFyYXRvcjogJzsnLCBuYW1lZDogdHJ1ZSwgIGVtcHR5OiAnJywgIGVuY29kZXI6IHVyaUVuY29kZXIuZW5jb2RlIH0sXG5cdFx0XHQnPyc6IHsgZmlyc3Q6ICc/Jywgc2VwYXJhdG9yOiAnJicsIG5hbWVkOiB0cnVlLCAgZW1wdHk6ICc9JywgZW5jb2RlcjogdXJpRW5jb2Rlci5lbmNvZGUgfSxcblx0XHRcdCcmJzogeyBmaXJzdDogJyYnLCBzZXBhcmF0b3I6ICcmJywgbmFtZWQ6IHRydWUsICBlbXB0eTogJz0nLCBlbmNvZGVyOiB1cmlFbmNvZGVyLmVuY29kZSB9LFxuXHRcdFx0Jz0nOiB7IHJlc2VydmVkOiB0cnVlIH0sXG5cdFx0XHQnLCc6IHsgcmVzZXJ2ZWQ6IHRydWUgfSxcblx0XHRcdCchJzogeyByZXNlcnZlZDogdHJ1ZSB9LFxuXHRcdFx0J0AnOiB7IHJlc2VydmVkOiB0cnVlIH0sXG5cdFx0XHQnfCc6IHsgcmVzZXJ2ZWQ6IHRydWUgfVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBhcHBseShvcGVyYXRpb24sIGV4cHJlc3Npb24sIHBhcmFtcykge1xuXHRcdFx0Lypqc2hpbnQgbWF4Y29tcGxleGl0eToxMSAqL1xuXHRcdFx0cmV0dXJuIGV4cHJlc3Npb24uc3BsaXQoJywnKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgdmFyaWFibGUpIHtcblx0XHRcdFx0dmFyIG9wdHMsIHZhbHVlO1xuXG5cdFx0XHRcdG9wdHMgPSB7fTtcblx0XHRcdFx0aWYgKHZhcmlhYmxlLnNsaWNlKC0xKSA9PT0gJyonKSB7XG5cdFx0XHRcdFx0dmFyaWFibGUgPSB2YXJpYWJsZS5zbGljZSgwLCAtMSk7XG5cdFx0XHRcdFx0b3B0cy5leHBsb2RlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJlZml4UkUudGVzdCh2YXJpYWJsZSkpIHtcblx0XHRcdFx0XHR2YXIgcHJlZml4ID0gcHJlZml4UkUuZXhlYyh2YXJpYWJsZSk7XG5cdFx0XHRcdFx0dmFyaWFibGUgPSBwcmVmaXhbMV07XG5cdFx0XHRcdFx0b3B0cy5tYXhMZW5ndGggPSBwYXJzZUludChwcmVmaXhbMl0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyaWFibGUgPSB1cmlFbmNvZGVyLmRlY29kZSh2YXJpYWJsZSk7XG5cdFx0XHRcdHZhbHVlID0gcGFyYW1zW3ZhcmlhYmxlXTtcblxuXHRcdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmIHx8IHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRyZXN1bHQgKz0gdmFsdWUucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRpZiAocmVzdWx0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gb3B0cy5leHBsb2RlID8gb3BlcmF0aW9uLnNlcGFyYXRvciA6ICcsJztcblx0XHRcdFx0XHRcdFx0aWYgKG9wZXJhdGlvbi5uYW1lZCAmJiBvcHRzLmV4cGxvZGUpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gb3BlcmF0aW9uLmVuY29kZXIodmFyaWFibGUpO1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdCArPSB2YWx1ZS5sZW5ndGggPyAnPScgOiBvcGVyYXRpb24uZW1wdHk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gb3BlcmF0aW9uLmZpcnN0O1xuXHRcdFx0XHRcdFx0XHRpZiAob3BlcmF0aW9uLm5hbWVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0ICs9IG9wZXJhdGlvbi5lbmNvZGVyKHZhcmlhYmxlKTtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gdmFsdWUubGVuZ3RoID8gJz0nIDogb3BlcmF0aW9uLmVtcHR5O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gb3BlcmF0aW9uLmVuY29kZXIodmFsdWUpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0XHR9LCAnJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHJlc3VsdCArPSBPYmplY3Qua2V5cyh2YWx1ZSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIG5hbWUpIHtcblx0XHRcdFx0XHRcdGlmIChyZXN1bHQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdCArPSBvcHRzLmV4cGxvZGUgPyBvcGVyYXRpb24uc2VwYXJhdG9yIDogJywnO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdCArPSBvcGVyYXRpb24uZmlyc3Q7XG5cdFx0XHRcdFx0XHRcdGlmIChvcGVyYXRpb24ubmFtZWQgJiYgIW9wdHMuZXhwbG9kZSkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdCArPSBvcGVyYXRpb24uZW5jb2Rlcih2YXJpYWJsZSk7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0ICs9IHZhbHVlW25hbWVdLmxlbmd0aCA/ICc9JyA6IG9wZXJhdGlvbi5lbXB0eTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzdWx0ICs9IG9wZXJhdGlvbi5lbmNvZGVyKG5hbWUpO1xuXHRcdFx0XHRcdFx0cmVzdWx0ICs9IG9wdHMuZXhwbG9kZSA/ICc9JyA6ICcsJztcblx0XHRcdFx0XHRcdHJlc3VsdCArPSBvcGVyYXRpb24uZW5jb2Rlcih2YWx1ZVtuYW1lXSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHRcdH0sICcnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG5cdFx0XHRcdFx0aWYgKG9wdHMubWF4TGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIG9wdHMubWF4TGVuZ3RoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0ICs9IHJlc3VsdC5sZW5ndGggPyBvcGVyYXRpb24uc2VwYXJhdG9yIDogb3BlcmF0aW9uLmZpcnN0O1xuXHRcdFx0XHRcdGlmIChvcGVyYXRpb24ubmFtZWQpIHtcblx0XHRcdFx0XHRcdHJlc3VsdCArPSBvcGVyYXRpb24uZW5jb2Rlcih2YXJpYWJsZSk7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gdmFsdWUubGVuZ3RoID8gJz0nIDogb3BlcmF0aW9uLmVtcHR5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHQgKz0gb3BlcmF0aW9uLmVuY29kZXIodmFsdWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH0sICcnKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBleHBhbmRFeHByZXNzaW9uKGV4cHJlc3Npb24sIHBhcmFtcykge1xuXHRcdFx0dmFyIG9wZXJhdGlvbjtcblxuXHRcdFx0b3BlcmF0aW9uID0gb3BlcmF0aW9uc1tleHByZXNzaW9uLnNsaWNlKDAsMSldO1xuXHRcdFx0aWYgKG9wZXJhdGlvbikge1xuXHRcdFx0XHRleHByZXNzaW9uID0gZXhwcmVzc2lvbi5zbGljZSgxKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRvcGVyYXRpb24gPSBvcGVyYXRpb25zWycnXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wZXJhdGlvbi5yZXNlcnZlZCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Jlc2VydmVkIGV4cHJlc3Npb24gb3BlcmF0aW9ucyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXBwbHkob3BlcmF0aW9uLCBleHByZXNzaW9uLCBwYXJhbXMpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGV4cGFuZFRlbXBsYXRlKHRlbXBsYXRlLCBwYXJhbXMpIHtcblx0XHRcdHZhciBzdGFydCwgZW5kLCB1cmk7XG5cblx0XHRcdHVyaSA9ICcnO1xuXHRcdFx0ZW5kID0gMDtcblx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdHN0YXJ0ID0gdGVtcGxhdGUuaW5kZXhPZigneycsIGVuZCk7XG5cdFx0XHRcdGlmIChzdGFydCA9PT0gLTEpIHtcblx0XHRcdFx0XHQvLyBubyBtb3JlIGV4cHJlc3Npb25zXG5cdFx0XHRcdFx0dXJpICs9IHRlbXBsYXRlLnNsaWNlKGVuZCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0dXJpICs9IHRlbXBsYXRlLnNsaWNlKGVuZCwgc3RhcnQpO1xuXHRcdFx0XHRlbmQgPSB0ZW1wbGF0ZS5pbmRleE9mKCd9Jywgc3RhcnQpICsgMTtcblx0XHRcdFx0dXJpICs9IGV4cGFuZEV4cHJlc3Npb24odGVtcGxhdGUuc2xpY2Uoc3RhcnQgKyAxLCBlbmQgLSAxKSwgcGFyYW1zKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVyaTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEV4cGFuZCBhIFVSSSBUZW1wbGF0ZSB3aXRoIHBhcmFtZXRlcnMgdG8gZm9ybSBhIFVSSS5cblx0XHRcdCAqXG5cdFx0XHQgKiBGdWxsIGltcGxlbWVudGF0aW9uIChsZXZlbCA0KSBvZiByZmM2NTcwLlxuXHRcdFx0ICogQHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjU3MFxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSBVUkkgdGVtcGxhdGVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSBwYXJhbXMgdG8gYXBwbHkgdG8gdGhlIHRlbXBsYXRlIGR1cnJpbmcgZXhwYW50aW9uXG5cdFx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfSBleHBhbmRlZCBVUklcblx0XHRcdCAqL1xuXHRcdFx0ZXhwYW5kOiBleHBhbmRUZW1wbGF0ZVxuXG5cdFx0fTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwidmFyIFZ1ZSAvLyBsYXRlIGJpbmRcbnZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG52YXIgc2hpbW1lZCA9IGZhbHNlXG52YXIgaXNCcm93c2VyaWZ5ID0gZmFsc2VcblxuLyoqXG4gKiBEZXRlcm1pbmUgY29tcGF0aWJpbGl0eSBhbmQgYXBwbHkgcGF0Y2guXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdnVlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJyb3dzZXJpZnlcbiAqL1xuXG5leHBvcnRzLmluc3RhbGwgPSBmdW5jdGlvbiAodnVlLCBicm93c2VyaWZ5KSB7XG4gIGlmIChzaGltbWVkKSByZXR1cm5cbiAgc2hpbW1lZCA9IHRydWVcblxuICBWdWUgPSB2dWVcbiAgaXNCcm93c2VyaWZ5ID0gYnJvd3NlcmlmeVxuXG4gIGV4cG9ydHMuY29tcGF0aWJsZSA9ICEhVnVlLmludGVybmFsRGlyZWN0aXZlc1xuICBpZiAoIWV4cG9ydHMuY29tcGF0aWJsZSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdbSE1SXSB2dWUtbG9hZGVyIGhvdCByZWxvYWQgaXMgb25seSBjb21wYXRpYmxlIHdpdGggJyArXG4gICAgICAnVnVlLmpzIDEuMC4wKy4nXG4gICAgKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gcGF0Y2ggdmlldyBkaXJlY3RpdmVcbiAgcGF0Y2hWaWV3KFZ1ZS5pbnRlcm5hbERpcmVjdGl2ZXMuY29tcG9uZW50KVxuICBjb25zb2xlLmxvZygnW0hNUl0gVnVlIGNvbXBvbmVudCBob3QgcmVsb2FkIHNoaW0gYXBwbGllZC4nKVxuICAvLyBzaGltIHJvdXRlci12aWV3IGlmIHByZXNlbnRcbiAgdmFyIHJvdXRlclZpZXcgPSBWdWUuZWxlbWVudERpcmVjdGl2ZSgncm91dGVyLXZpZXcnKVxuICBpZiAocm91dGVyVmlldykge1xuICAgIHBhdGNoVmlldyhyb3V0ZXJWaWV3KVxuICAgIGNvbnNvbGUubG9nKCdbSE1SXSB2dWUtcm91dGVyIDxyb3V0ZXItdmlldz4gaG90IHJlbG9hZCBzaGltIGFwcGxpZWQuJylcbiAgfVxufVxuXG4vKipcbiAqIFNoaW0gdGhlIHZpZXcgZGlyZWN0aXZlIChjb21wb25lbnQgb3Igcm91dGVyLXZpZXcpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBWaWV3XG4gKi9cblxuZnVuY3Rpb24gcGF0Y2hWaWV3IChWaWV3KSB7XG4gIHZhciB1bmJ1aWxkID0gVmlldy51bmJ1aWxkXG4gIFZpZXcudW5idWlsZCA9IGZ1bmN0aW9uIChkZWZlcikge1xuICAgIGlmICghdGhpcy5ob3RVcGRhdGluZykge1xuICAgICAgdmFyIHByZXZDb21wb25lbnQgPSB0aGlzLmNoaWxkVk0gJiYgdGhpcy5jaGlsZFZNLmNvbnN0cnVjdG9yXG4gICAgICByZW1vdmVWaWV3KHByZXZDb21wb25lbnQsIHRoaXMpXG4gICAgICAvLyBkZWZlciA9IHRydWUgbWVhbnMgd2UgYXJlIHRyYW5zaXRpb25pbmcgdG8gYSBuZXdcbiAgICAgIC8vIENvbXBvbmVudC4gUmVnaXN0ZXIgdGhpcyBuZXcgY29tcG9uZW50IHRvIHRoZSBsaXN0LlxuICAgICAgaWYgKGRlZmVyKSB7XG4gICAgICAgIGFkZFZpZXcodGhpcy5Db21wb25lbnQsIHRoaXMpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNhbGwgb3JpZ2luYWxcbiAgICByZXR1cm4gdW5idWlsZC5jYWxsKHRoaXMsIGRlZmVyKVxuICB9XG59XG5cbi8qKlxuICogQWRkIGEgY29tcG9uZW50IHZpZXcgdG8gYSBDb21wb25lbnQncyBob3QgbGlzdFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvbXBvbmVudFxuICogQHBhcmFtIHtEaXJlY3RpdmV9IHZpZXcgLSB2aWV3IGRpcmVjdGl2ZSBpbnN0YW5jZVxuICovXG5cbmZ1bmN0aW9uIGFkZFZpZXcgKENvbXBvbmVudCwgdmlldykge1xuICB2YXIgaWQgPSBDb21wb25lbnQgJiYgQ29tcG9uZW50Lm9wdGlvbnMuaG90SURcbiAgaWYgKGlkKSB7XG4gICAgaWYgKCFtYXBbaWRdKSB7XG4gICAgICBtYXBbaWRdID0ge1xuICAgICAgICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgICAgICAgdmlld3M6IFtdLFxuICAgICAgICBpbnN0YW5jZXM6IFtdXG4gICAgICB9XG4gICAgfVxuICAgIG1hcFtpZF0udmlld3MucHVzaCh2aWV3KVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY29tcG9uZW50IHZpZXcgZnJvbSBhIENvbXBvbmVudCdzIGhvdCBsaXN0XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29tcG9uZW50XG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlldyAtIHZpZXcgZGlyZWN0aXZlIGluc3RhbmNlXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlVmlldyAoQ29tcG9uZW50LCB2aWV3KSB7XG4gIHZhciBpZCA9IENvbXBvbmVudCAmJiBDb21wb25lbnQub3B0aW9ucy5ob3RJRFxuICBpZiAoaWQpIHtcbiAgICBtYXBbaWRdLnZpZXdzLiRyZW1vdmUodmlldylcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJlY29yZCBmb3IgYSBob3QgbW9kdWxlLCB3aGljaCBrZWVwcyB0cmFjayBvZiBpdHMgY29uc3RydWNvdHIsXG4gKiBpbnN0bmFjZXMgYW5kIHZpZXdzIChjb21wb25lbnQgZGlyZWN0aXZlcyBvciByb3V0ZXItdmlld3MpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5leHBvcnRzLmNyZWF0ZVJlY29yZCA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucy5vcHRpb25zXG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmVsICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3B0aW9ucy5kYXRhICE9PSAnb2JqZWN0Jykge1xuICAgIG1ha2VPcHRpb25zSG90KGlkLCBvcHRpb25zKVxuICAgIG1hcFtpZF0gPSB7XG4gICAgICBDb21wb25lbnQ6IG51bGwsXG4gICAgICB2aWV3czogW10sXG4gICAgICBpbnN0YW5jZXM6IFtdXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWFrZSBhIENvbXBvbmVudCBvcHRpb25zIG9iamVjdCBob3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIG1ha2VPcHRpb25zSG90IChpZCwgb3B0aW9ucykge1xuICBvcHRpb25zLmhvdElEID0gaWRcbiAgaW5qZWN0SG9vayhvcHRpb25zLCAnY3JlYXRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjb3JkID0gbWFwW2lkXVxuICAgIGlmICghcmVjb3JkLkNvbXBvbmVudCkge1xuICAgICAgcmVjb3JkLkNvbXBvbmVudCA9IHRoaXMuY29uc3RydWN0b3JcbiAgICB9XG4gICAgcmVjb3JkLmluc3RhbmNlcy5wdXNoKHRoaXMpXG4gIH0pXG4gIGluamVjdEhvb2sob3B0aW9ucywgJ2JlZm9yZURlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgbWFwW2lkXS5pbnN0YW5jZXMuJHJlbW92ZSh0aGlzKVxuICB9KVxufVxuXG4vKipcbiAqIEluamVjdCBhIGhvb2sgdG8gYSBob3QgcmVsb2FkYWJsZSBjb21wb25lbnQgc28gdGhhdFxuICogd2UgY2FuIGtlZXAgdHJhY2sgb2YgaXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gKi9cblxuZnVuY3Rpb24gaW5qZWN0SG9vayAob3B0aW9ucywgbmFtZSwgaG9vaykge1xuICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zW25hbWVdXG4gIG9wdGlvbnNbbmFtZV0gPSBleGlzdGluZ1xuICAgID8gQXJyYXkuaXNBcnJheShleGlzdGluZylcbiAgICAgID8gZXhpc3RpbmcuY29uY2F0KGhvb2spXG4gICAgICA6IFtleGlzdGluZywgaG9va11cbiAgICA6IFtob29rXVxufVxuXG4vKipcbiAqIFVwZGF0ZSBhIGhvdCBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdHxudWxsfSBuZXdPcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBuZXdUZW1wbGF0ZVxuICovXG5cbmV4cG9ydHMudXBkYXRlID0gZnVuY3Rpb24gKGlkLCBuZXdPcHRpb25zLCBuZXdUZW1wbGF0ZSkge1xuICB2YXIgcmVjb3JkID0gbWFwW2lkXVxuICAvLyBmb3JjZSBmdWxsLXJlbG9hZCBpZiBhbiBpbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50IGlzIGFjdGl2ZSBidXQgaXMgbm90XG4gIC8vIG1hbmFnZWQgYnkgYSB2aWV3XG4gIGlmICghcmVjb3JkIHx8IChyZWNvcmQuaW5zdGFuY2VzLmxlbmd0aCAmJiAhcmVjb3JkLnZpZXdzLmxlbmd0aCkpIHtcbiAgICBjb25zb2xlLmxvZygnW0hNUl0gUm9vdCBvciBtYW51YWxseS1tb3VudGVkIGluc3RhbmNlIG1vZGlmaWVkLiBGdWxsIHJlbG9hZCBtYXkgYmUgcmVxdWlyZWQuJylcbiAgICBpZiAoIWlzQnJvd3NlcmlmeSkge1xuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGJyb3dzZXJpZnktaG1yIHNvbWVob3cgc2VuZHMgaW5jb21wbGV0ZSBidW5kbGUgaWYgd2UgcmVsb2FkIGhlcmVcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIWlzQnJvd3NlcmlmeSkge1xuICAgIC8vIGJyb3dzZXJpZnktaG1yIGFscmVhZHkgbG9ncyB0aGlzXG4gICAgY29uc29sZS5sb2coJ1tITVJdIFVwZGF0aW5nIGNvbXBvbmVudDogJyArIGZvcm1hdChpZCkpXG4gIH1cbiAgdmFyIENvbXBvbmVudCA9IHJlY29yZC5Db21wb25lbnRcbiAgLy8gdXBkYXRlIGNvbnN0cnVjdG9yXG4gIGlmIChuZXdPcHRpb25zKSB7XG4gICAgLy8gaW4gY2FzZSB0aGUgdXNlciBleHBvcnRzIGEgY29uc3RydWN0b3JcbiAgICBDb21wb25lbnQgPSByZWNvcmQuQ29tcG9uZW50ID0gdHlwZW9mIG5ld09wdGlvbnMgPT09ICdmdW5jdGlvbidcbiAgICAgID8gbmV3T3B0aW9uc1xuICAgICAgOiBWdWUuZXh0ZW5kKG5ld09wdGlvbnMpXG4gICAgbWFrZU9wdGlvbnNIb3QoaWQsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIGlmIChuZXdUZW1wbGF0ZSkge1xuICAgIENvbXBvbmVudC5vcHRpb25zLnRlbXBsYXRlID0gbmV3VGVtcGxhdGVcbiAgfVxuICAvLyBoYW5kbGUgcmVjdXJzaXZlIGxvb2t1cFxuICBpZiAoQ29tcG9uZW50Lm9wdGlvbnMubmFtZSkge1xuICAgIENvbXBvbmVudC5vcHRpb25zLmNvbXBvbmVudHNbQ29tcG9uZW50Lm9wdGlvbnMubmFtZV0gPSBDb21wb25lbnRcbiAgfVxuICAvLyByZXNldCBjb25zdHJ1Y3RvciBjYWNoZWQgbGlua2VyXG4gIENvbXBvbmVudC5saW5rZXIgPSBudWxsXG4gIC8vIHJlbG9hZCBhbGwgdmlld3NcbiAgcmVjb3JkLnZpZXdzLmZvckVhY2goZnVuY3Rpb24gKHZpZXcpIHtcbiAgICB1cGRhdGVWaWV3KHZpZXcsIENvbXBvbmVudClcbiAgfSlcbn1cblxuLyoqXG4gKiBVcGRhdGUgYSBjb21wb25lbnQgdmlldyBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7RGlyZWN0aXZlfSB2aWV3XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb21wb25lbnRcbiAqL1xuXG5mdW5jdGlvbiB1cGRhdGVWaWV3ICh2aWV3LCBDb21wb25lbnQpIHtcbiAgaWYgKCF2aWV3Ll9ib3VuZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZpZXcuQ29tcG9uZW50ID0gQ29tcG9uZW50XG4gIHZpZXcuaG90VXBkYXRpbmcgPSB0cnVlXG4gIC8vIGRpc2FibGUgdHJhbnNpdGlvbnNcbiAgdmlldy52bS5faXNDb21waWxlZCA9IGZhbHNlXG4gIC8vIHNhdmUgc3RhdGVcbiAgdmFyIHN0YXRlID0gdmlldy5jaGlsZFZNLiRkYXRhXG4gIC8vIHJlbW91bnQsIG1ha2Ugc3VyZSB0byBkaXNhYmxlIGtlZXAtYWxpdmVcbiAgdmFyIGtlZXBBbGl2ZSA9IHZpZXcua2VlcEFsaXZlXG4gIHZpZXcua2VlcEFsaXZlID0gZmFsc2VcbiAgdmlldy5tb3VudENvbXBvbmVudCgpXG4gIHZpZXcua2VlcEFsaXZlID0ga2VlcEFsaXZlXG4gIC8vIHJlc3RvcmUgc3RhdGVcbiAgdmlldy5jaGlsZFZNLiRkYXRhID0gc3RhdGVcbiAgLy8gcmUtZWFuYmxlIHRyYW5zaXRpb25zXG4gIHZpZXcudm0uX2lzQ29tcGlsZWQgPSB0cnVlXG4gIHZpZXcuaG90VXBkYXRpbmcgPSBmYWxzZVxufVxuXG5mdW5jdGlvbiBmb3JtYXQgKGlkKSB7XG4gIHJldHVybiBpZC5tYXRjaCgvW15cXC9dK1xcLnZ1ZSQvKVswXVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmFiZWxIZWxwZXJzID0ge307XG5cbmJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuZnVuY3Rpb24gVGFyZ2V0KHBhdGgsIG1hdGNoZXIsIGRlbGVnYXRlKSB7XG4gIHRoaXMucGF0aCA9IHBhdGg7XG4gIHRoaXMubWF0Y2hlciA9IG1hdGNoZXI7XG4gIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbn1cblxuVGFyZ2V0LnByb3RvdHlwZSA9IHtcbiAgdG86IGZ1bmN0aW9uIHRvKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGVsZWdhdGUgPSB0aGlzLmRlbGVnYXRlO1xuXG4gICAgaWYgKGRlbGVnYXRlICYmIGRlbGVnYXRlLndpbGxBZGRSb3V0ZSkge1xuICAgICAgdGFyZ2V0ID0gZGVsZWdhdGUud2lsbEFkZFJvdXRlKHRoaXMubWF0Y2hlci50YXJnZXQsIHRhcmdldCk7XG4gICAgfVxuXG4gICAgdGhpcy5tYXRjaGVyLmFkZCh0aGlzLnBhdGgsIHRhcmdldCk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGlmIChjYWxsYmFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgaGF2ZSBhbiBhcmd1bWVudCBpbiB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGB0b2BcIik7XG4gICAgICB9XG4gICAgICB0aGlzLm1hdGNoZXIuYWRkQ2hpbGQodGhpcy5wYXRoLCB0YXJnZXQsIGNhbGxiYWNrLCB0aGlzLmRlbGVnYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIE1hdGNoZXIodGFyZ2V0KSB7XG4gIHRoaXMucm91dGVzID0ge307XG4gIHRoaXMuY2hpbGRyZW4gPSB7fTtcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbk1hdGNoZXIucHJvdG90eXBlID0ge1xuICBhZGQ6IGZ1bmN0aW9uIGFkZChwYXRoLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5yb3V0ZXNbcGF0aF0gPSBoYW5kbGVyO1xuICB9LFxuXG4gIGFkZENoaWxkOiBmdW5jdGlvbiBhZGRDaGlsZChwYXRoLCB0YXJnZXQsIGNhbGxiYWNrLCBkZWxlZ2F0ZSkge1xuICAgIHZhciBtYXRjaGVyID0gbmV3IE1hdGNoZXIodGFyZ2V0KTtcbiAgICB0aGlzLmNoaWxkcmVuW3BhdGhdID0gbWF0Y2hlcjtcblxuICAgIHZhciBtYXRjaCA9IGdlbmVyYXRlTWF0Y2gocGF0aCwgbWF0Y2hlciwgZGVsZWdhdGUpO1xuXG4gICAgaWYgKGRlbGVnYXRlICYmIGRlbGVnYXRlLmNvbnRleHRFbnRlcmVkKSB7XG4gICAgICBkZWxlZ2F0ZS5jb250ZXh0RW50ZXJlZCh0YXJnZXQsIG1hdGNoKTtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhtYXRjaCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTWF0Y2goc3RhcnRpbmdQYXRoLCBtYXRjaGVyLCBkZWxlZ2F0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHBhdGgsIG5lc3RlZENhbGxiYWNrKSB7XG4gICAgdmFyIGZ1bGxQYXRoID0gc3RhcnRpbmdQYXRoICsgcGF0aDtcblxuICAgIGlmIChuZXN0ZWRDYWxsYmFjaykge1xuICAgICAgbmVzdGVkQ2FsbGJhY2soZ2VuZXJhdGVNYXRjaChmdWxsUGF0aCwgbWF0Y2hlciwgZGVsZWdhdGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoc3RhcnRpbmdQYXRoICsgcGF0aCwgbWF0Y2hlciwgZGVsZWdhdGUpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkUm91dGUocm91dGVBcnJheSwgcGF0aCwgaGFuZGxlcikge1xuICB2YXIgbGVuID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSByb3V0ZUFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxlbiArPSByb3V0ZUFycmF5W2ldLnBhdGgubGVuZ3RoO1xuICB9XG5cbiAgcGF0aCA9IHBhdGguc3Vic3RyKGxlbik7XG4gIHZhciByb3V0ZSA9IHsgcGF0aDogcGF0aCwgaGFuZGxlcjogaGFuZGxlciB9O1xuICByb3V0ZUFycmF5LnB1c2gocm91dGUpO1xufVxuXG5mdW5jdGlvbiBlYWNoUm91dGUoYmFzZVJvdXRlLCBtYXRjaGVyLCBjYWxsYmFjaywgYmluZGluZykge1xuICB2YXIgcm91dGVzID0gbWF0Y2hlci5yb3V0ZXM7XG5cbiAgZm9yICh2YXIgcGF0aCBpbiByb3V0ZXMpIHtcbiAgICBpZiAocm91dGVzLmhhc093blByb3BlcnR5KHBhdGgpKSB7XG4gICAgICB2YXIgcm91dGVBcnJheSA9IGJhc2VSb3V0ZS5zbGljZSgpO1xuICAgICAgYWRkUm91dGUocm91dGVBcnJheSwgcGF0aCwgcm91dGVzW3BhdGhdKTtcblxuICAgICAgaWYgKG1hdGNoZXIuY2hpbGRyZW5bcGF0aF0pIHtcbiAgICAgICAgZWFjaFJvdXRlKHJvdXRlQXJyYXksIG1hdGNoZXIuY2hpbGRyZW5bcGF0aF0sIGNhbGxiYWNrLCBiaW5kaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwoYmluZGluZywgcm91dGVBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcCAoY2FsbGJhY2ssIGFkZFJvdXRlQ2FsbGJhY2spIHtcbiAgdmFyIG1hdGNoZXIgPSBuZXcgTWF0Y2hlcigpO1xuXG4gIGNhbGxiYWNrKGdlbmVyYXRlTWF0Y2goXCJcIiwgbWF0Y2hlciwgdGhpcy5kZWxlZ2F0ZSkpO1xuXG4gIGVhY2hSb3V0ZShbXSwgbWF0Y2hlciwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgaWYgKGFkZFJvdXRlQ2FsbGJhY2spIHtcbiAgICAgIGFkZFJvdXRlQ2FsbGJhY2sodGhpcywgcm91dGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChyb3V0ZSk7XG4gICAgfVxuICB9LCB0aGlzKTtcbn1cblxudmFyIHNwZWNpYWxzID0gWycvJywgJy4nLCAnKicsICcrJywgJz8nLCAnfCcsICcoJywgJyknLCAnWycsICddJywgJ3snLCAnfScsICdcXFxcJ107XG5cbnZhciBlc2NhcGVSZWdleCA9IG5ldyBSZWdFeHAoJyhcXFxcJyArIHNwZWNpYWxzLmpvaW4oJ3xcXFxcJykgKyAnKScsICdnJyk7XG5cbmZ1bmN0aW9uIGlzQXJyYXkodGVzdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRlc3QpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG59XG5cbi8vIEEgU2VnbWVudCByZXByZXNlbnRzIGEgc2VnbWVudCBpbiB0aGUgb3JpZ2luYWwgcm91dGUgZGVzY3JpcHRpb24uXG4vLyBFYWNoIFNlZ21lbnQgdHlwZSBwcm92aWRlcyBhbiBgZWFjaENoYXJgIGFuZCBgcmVnZXhgIG1ldGhvZC5cbi8vXG4vLyBUaGUgYGVhY2hDaGFyYCBtZXRob2QgaW52b2tlcyB0aGUgY2FsbGJhY2sgd2l0aCBvbmUgb3IgbW9yZSBjaGFyYWN0ZXJcbi8vIHNwZWNpZmljYXRpb25zLiBBIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGNvbnN1bWVzIG9uZSBvciBtb3JlIGlucHV0XG4vLyBjaGFyYWN0ZXJzLlxuLy9cbi8vIFRoZSBgcmVnZXhgIG1ldGhvZCByZXR1cm5zIGEgcmVnZXggZnJhZ21lbnQgZm9yIHRoZSBzZWdtZW50LiBJZiB0aGVcbi8vIHNlZ21lbnQgaXMgYSBkeW5hbWljIG9mIHN0YXIgc2VnbWVudCwgdGhlIHJlZ2V4IGZyYWdtZW50IGFsc28gaW5jbHVkZXNcbi8vIGEgY2FwdHVyZS5cbi8vXG4vLyBBIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGNvbnRhaW5zOlxuLy9cbi8vICogYHZhbGlkQ2hhcnNgOiBhIFN0cmluZyB3aXRoIGEgbGlzdCBvZiBhbGwgdmFsaWQgY2hhcmFjdGVycywgb3Jcbi8vICogYGludmFsaWRDaGFyc2A6IGEgU3RyaW5nIHdpdGggYSBsaXN0IG9mIGFsbCBpbnZhbGlkIGNoYXJhY3RlcnNcbi8vICogYHJlcGVhdGA6IHRydWUgaWYgdGhlIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGNhbiByZXBlYXRcblxuZnVuY3Rpb24gU3RhdGljU2VnbWVudChzdHJpbmcpIHtcbiAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG59XG5TdGF0aWNTZWdtZW50LnByb3RvdHlwZSA9IHtcbiAgZWFjaENoYXI6IGZ1bmN0aW9uIGVhY2hDaGFyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHN0cmluZyA9IHRoaXMuc3RyaW5nLFxuICAgICAgICBjaDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2ggPSBzdHJpbmcuY2hhckF0KGkpO1xuICAgICAgY2FsbGJhY2soeyB2YWxpZENoYXJzOiBjaCB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnZXg6IGZ1bmN0aW9uIHJlZ2V4KCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZy5yZXBsYWNlKGVzY2FwZVJlZ2V4LCAnXFxcXCQxJyk7XG4gIH0sXG5cbiAgZ2VuZXJhdGU6IGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZztcbiAgfVxufTtcblxuZnVuY3Rpb24gRHluYW1pY1NlZ21lbnQobmFtZSkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xufVxuRHluYW1pY1NlZ21lbnQucHJvdG90eXBlID0ge1xuICBlYWNoQ2hhcjogZnVuY3Rpb24gZWFjaENoYXIoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh7IGludmFsaWRDaGFyczogXCIvXCIsIHJlcGVhdDogdHJ1ZSB9KTtcbiAgfSxcblxuICByZWdleDogZnVuY3Rpb24gcmVnZXgoKSB7XG4gICAgcmV0dXJuIFwiKFteL10rKVwiO1xuICB9LFxuXG4gIGdlbmVyYXRlOiBmdW5jdGlvbiBnZW5lcmF0ZShwYXJhbXMpIHtcbiAgICByZXR1cm4gcGFyYW1zW3RoaXMubmFtZV07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFN0YXJTZWdtZW50KG5hbWUpIHtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbn1cblN0YXJTZWdtZW50LnByb3RvdHlwZSA9IHtcbiAgZWFjaENoYXI6IGZ1bmN0aW9uIGVhY2hDaGFyKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soeyBpbnZhbGlkQ2hhcnM6IFwiXCIsIHJlcGVhdDogdHJ1ZSB9KTtcbiAgfSxcblxuICByZWdleDogZnVuY3Rpb24gcmVnZXgoKSB7XG4gICAgcmV0dXJuIFwiKC4rKVwiO1xuICB9LFxuXG4gIGdlbmVyYXRlOiBmdW5jdGlvbiBnZW5lcmF0ZShwYXJhbXMpIHtcbiAgICByZXR1cm4gcGFyYW1zW3RoaXMubmFtZV07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIEVwc2lsb25TZWdtZW50KCkge31cbkVwc2lsb25TZWdtZW50LnByb3RvdHlwZSA9IHtcbiAgZWFjaENoYXI6IGZ1bmN0aW9uIGVhY2hDaGFyKCkge30sXG4gIHJlZ2V4OiBmdW5jdGlvbiByZWdleCgpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfSxcbiAgZ2VuZXJhdGU6IGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwYXJzZShyb3V0ZSwgbmFtZXMsIHNwZWNpZmljaXR5KSB7XG4gIC8vIG5vcm1hbGl6ZSByb3V0ZSBhcyBub3Qgc3RhcnRpbmcgd2l0aCBhIFwiL1wiLiBSZWNvZ25pdGlvbiB3aWxsXG4gIC8vIGFsc28gbm9ybWFsaXplLlxuICBpZiAocm91dGUuY2hhckF0KDApID09PSBcIi9cIikge1xuICAgIHJvdXRlID0gcm91dGUuc3Vic3RyKDEpO1xuICB9XG5cbiAgdmFyIHNlZ21lbnRzID0gcm91dGUuc3BsaXQoXCIvXCIpLFxuICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gIC8vIEEgcm91dGVzIGhhcyBzcGVjaWZpY2l0eSBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGF0IGl0cyBkaWZmZXJlbnQgc2VnbWVudHNcbiAgLy8gYXBwZWFyIGluLiBUaGlzIHN5c3RlbSBtaXJyb3JzIGhvdyB0aGUgbWFnbml0dWRlIG9mIG51bWJlcnMgd3JpdHRlbiBhcyBzdHJpbmdzXG4gIC8vIHdvcmtzLlxuICAvLyBDb25zaWRlciBhIG51bWJlciB3cml0dGVuIGFzOiBcImFiY1wiLiBBbiBleGFtcGxlIHdvdWxkIGJlIFwiMjAwXCIuIEFueSBvdGhlciBudW1iZXIgd3JpdHRlblxuICAvLyBcInh5elwiIHdpbGwgYmUgc21hbGxlciB0aGFuIFwiYWJjXCIgc28gbG9uZyBhcyBgYSA+IHpgLiBGb3IgaW5zdGFuY2UsIFwiMTk5XCIgaXMgc21hbGxlclxuICAvLyB0aGVuIFwiMjAwXCIsIGV2ZW4gdGhvdWdoIFwieVwiIGFuZCBcInpcIiAod2hpY2ggYXJlIGJvdGggOSkgYXJlIGxhcmdlciB0aGFuIFwiMFwiICh0aGUgdmFsdWVcbiAgLy8gb2YgKGBiYCBhbmQgYGNgKS4gVGhpcyBpcyBiZWNhdXNlIHRoZSBsZWFkaW5nIHN5bWJvbCwgXCIyXCIsIGlzIGxhcmdlciB0aGFuIHRoZSBvdGhlclxuICAvLyBsZWFkaW5nIHN5bWJvbCwgXCIxXCIuXG4gIC8vIFRoZSBydWxlIGlzIHRoYXQgc3ltYm9scyB0byB0aGUgbGVmdCBjYXJyeSBtb3JlIHdlaWdodCB0aGFuIHN5bWJvbHMgdG8gdGhlIHJpZ2h0XG4gIC8vIHdoZW4gYSBudW1iZXIgaXMgd3JpdHRlbiBvdXQgYXMgYSBzdHJpbmcuIEluIHRoZSBhYm92ZSBzdHJpbmdzLCB0aGUgbGVhZGluZyBkaWdpdFxuICAvLyByZXByZXNlbnRzIGhvdyBtYW55IDEwMCdzIGFyZSBpbiB0aGUgbnVtYmVyLCBhbmQgaXQgY2FycmllcyBtb3JlIHdlaWdodCB0aGFuIHRoZSBtaWRkbGVcbiAgLy8gbnVtYmVyIHdoaWNoIHJlcHJlc2VudHMgaG93IG1hbnkgMTAncyBhcmUgaW4gdGhlIG51bWJlci5cbiAgLy8gVGhpcyBzeXN0ZW0gb2YgbnVtYmVyIG1hZ25pdHVkZSB3b3JrcyB3ZWxsIGZvciByb3V0ZSBzcGVjaWZpY2l0eSwgdG9vLiBBIHJvdXRlIHdyaXR0ZW4gYXNcbiAgLy8gYGEvYi9jYCB3aWxsIGJlIG1vcmUgc3BlY2lmaWMgdGhhbiBgeC95L3pgIGFzIGxvbmcgYXMgYGFgIGlzIG1vcmUgc3BlY2lmaWMgdGhhblxuICAvLyBgeGAsIGlycmVzcGVjdGl2ZSBvZiB0aGUgb3RoZXIgcGFydHMuXG4gIC8vIEJlY2F1c2Ugb2YgdGhpcyBzaW1pbGFyaXR5LCB3ZSBhc3NpZ24gZWFjaCB0eXBlIG9mIHNlZ21lbnQgYSBudW1iZXIgdmFsdWUgd3JpdHRlbiBhcyBhXG4gIC8vIHN0cmluZy4gV2UgY2FuIGZpbmQgdGhlIHNwZWNpZmljaXR5IG9mIGNvbXBvdW5kIHJvdXRlcyBieSBjb25jYXRlbmF0aW5nIHRoZXNlIHN0cmluZ3NcbiAgLy8gdG9nZXRoZXIsIGZyb20gbGVmdCB0byByaWdodC4gQWZ0ZXIgd2UgaGF2ZSBsb29wZWQgdGhyb3VnaCBhbGwgb2YgdGhlIHNlZ21lbnRzLFxuICAvLyB3ZSBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gYSBudW1iZXIuXG4gIHNwZWNpZmljaXR5LnZhbCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXSxcbiAgICAgICAgbWF0Y2g7XG5cbiAgICBpZiAobWF0Y2ggPSBzZWdtZW50Lm1hdGNoKC9eOihbXlxcL10rKSQvKSkge1xuICAgICAgcmVzdWx0cy5wdXNoKG5ldyBEeW5hbWljU2VnbWVudChtYXRjaFsxXSkpO1xuICAgICAgbmFtZXMucHVzaChtYXRjaFsxXSk7XG4gICAgICBzcGVjaWZpY2l0eS52YWwgKz0gJzMnO1xuICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBzZWdtZW50Lm1hdGNoKC9eXFwqKFteXFwvXSspJC8pKSB7XG4gICAgICByZXN1bHRzLnB1c2gobmV3IFN0YXJTZWdtZW50KG1hdGNoWzFdKSk7XG4gICAgICBzcGVjaWZpY2l0eS52YWwgKz0gJzInO1xuICAgICAgbmFtZXMucHVzaChtYXRjaFsxXSk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50ID09PSBcIlwiKSB7XG4gICAgICByZXN1bHRzLnB1c2gobmV3IEVwc2lsb25TZWdtZW50KCkpO1xuICAgICAgc3BlY2lmaWNpdHkudmFsICs9ICcxJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0cy5wdXNoKG5ldyBTdGF0aWNTZWdtZW50KHNlZ21lbnQpKTtcbiAgICAgIHNwZWNpZmljaXR5LnZhbCArPSAnNCc7XG4gICAgfVxuICB9XG5cbiAgc3BlY2lmaWNpdHkudmFsID0gK3NwZWNpZmljaXR5LnZhbDtcblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuLy8gQSBTdGF0ZSBoYXMgYSBjaGFyYWN0ZXIgc3BlY2lmaWNhdGlvbiBhbmQgKGBjaGFyU3BlY2ApIGFuZCBhIGxpc3Qgb2YgcG9zc2libGVcbi8vIHN1YnNlcXVlbnQgc3RhdGVzIChgbmV4dFN0YXRlc2ApLlxuLy9cbi8vIElmIGEgU3RhdGUgaXMgYW4gYWNjZXB0aW5nIHN0YXRlLCBpdCB3aWxsIGFsc28gaGF2ZSBzZXZlcmFsIGFkZGl0aW9uYWxcbi8vIHByb3BlcnRpZXM6XG4vL1xuLy8gKiBgcmVnZXhgOiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IGlzIHVzZWQgdG8gZXh0cmFjdCBwYXJhbWV0ZXJzIGZyb20gcGF0aHNcbi8vICAgdGhhdCByZWFjaGVkIHRoaXMgYWNjZXB0aW5nIHN0YXRlLlxuLy8gKiBgaGFuZGxlcnNgOiBJbmZvcm1hdGlvbiBvbiBob3cgdG8gY29udmVydCB0aGUgbGlzdCBvZiBjYXB0dXJlcyBpbnRvIGNhbGxzXG4vLyAgIHRvIHJlZ2lzdGVyZWQgaGFuZGxlcnMgd2l0aCB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnNcbi8vICogYHR5cGVzYDogSG93IG1hbnkgc3RhdGljLCBkeW5hbWljIG9yIHN0YXIgc2VnbWVudHMgaW4gdGhpcyByb3V0ZS4gVXNlZCB0b1xuLy8gICBkZWNpZGUgd2hpY2ggcm91dGUgdG8gdXNlIGlmIG11bHRpcGxlIHJlZ2lzdGVyZWQgcm91dGVzIG1hdGNoIGEgcGF0aC5cbi8vXG4vLyBDdXJyZW50bHksIFN0YXRlIGlzIGltcGxlbWVudGVkIG5haXZlbHkgYnkgbG9vcGluZyBvdmVyIGBuZXh0U3RhdGVzYCBhbmRcbi8vIGNvbXBhcmluZyBhIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGFnYWluc3QgYSBjaGFyYWN0ZXIuIEEgbW9yZSBlZmZpY2llbnRcbi8vIGltcGxlbWVudGF0aW9uIHdvdWxkIHVzZSBhIGhhc2ggb2Yga2V5cyBwb2ludGluZyBhdCBvbmUgb3IgbW9yZSBuZXh0IHN0YXRlcy5cblxuZnVuY3Rpb24gU3RhdGUoY2hhclNwZWMpIHtcbiAgdGhpcy5jaGFyU3BlYyA9IGNoYXJTcGVjO1xuICB0aGlzLm5leHRTdGF0ZXMgPSBbXTtcbn1cblxuU3RhdGUucHJvdG90eXBlID0ge1xuICBnZXQ6IGZ1bmN0aW9uIGdldChjaGFyU3BlYykge1xuICAgIHZhciBuZXh0U3RhdGVzID0gdGhpcy5uZXh0U3RhdGVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBuZXh0U3RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbmV4dFN0YXRlc1tpXTtcblxuICAgICAgdmFyIGlzRXF1YWwgPSBjaGlsZC5jaGFyU3BlYy52YWxpZENoYXJzID09PSBjaGFyU3BlYy52YWxpZENoYXJzO1xuICAgICAgaXNFcXVhbCA9IGlzRXF1YWwgJiYgY2hpbGQuY2hhclNwZWMuaW52YWxpZENoYXJzID09PSBjaGFyU3BlYy5pbnZhbGlkQ2hhcnM7XG5cbiAgICAgIGlmIChpc0VxdWFsKSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcHV0OiBmdW5jdGlvbiBwdXQoY2hhclNwZWMpIHtcbiAgICB2YXIgc3RhdGU7XG5cbiAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIHNwZWNpZmljYXRpb24gYWxyZWFkeSBleGlzdHMgaW4gYSBjaGlsZCBvZiB0aGUgY3VycmVudFxuICAgIC8vIHN0YXRlLCBqdXN0IHJldHVybiB0aGF0IHN0YXRlLlxuICAgIGlmIChzdGF0ZSA9IHRoaXMuZ2V0KGNoYXJTcGVjKSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIC8vIE1ha2UgYSBuZXcgc3RhdGUgZm9yIHRoZSBjaGFyYWN0ZXIgc3BlY1xuICAgIHN0YXRlID0gbmV3IFN0YXRlKGNoYXJTcGVjKTtcblxuICAgIC8vIEluc2VydCB0aGUgbmV3IHN0YXRlIGFzIGEgY2hpbGQgb2YgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICB0aGlzLm5leHRTdGF0ZXMucHVzaChzdGF0ZSk7XG5cbiAgICAvLyBJZiB0aGlzIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIHJlcGVhdHMsIGluc2VydCB0aGUgbmV3IHN0YXRlIGFzIGEgY2hpbGRcbiAgICAvLyBvZiBpdHNlbGYuIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IHRyaWdnZXIgYW4gaW5maW5pdGUgbG9vcCBiZWNhdXNlIGVhY2hcbiAgICAvLyB0cmFuc2l0aW9uIGR1cmluZyByZWNvZ25pdGlvbiBjb25zdW1lcyBhIGNoYXJhY3Rlci5cbiAgICBpZiAoY2hhclNwZWMucmVwZWF0KSB7XG4gICAgICBzdGF0ZS5uZXh0U3RhdGVzLnB1c2goc3RhdGUpO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgbmV3IHN0YXRlXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9LFxuXG4gIC8vIEZpbmQgYSBsaXN0IG9mIGNoaWxkIHN0YXRlcyBtYXRjaGluZyB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKGNoKSB7XG4gICAgLy8gREVCVUcgXCJQcm9jZXNzaW5nIGBcIiArIGNoICsgXCJgOlwiXG4gICAgdmFyIG5leHRTdGF0ZXMgPSB0aGlzLm5leHRTdGF0ZXMsXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBjaGFyU3BlYyxcbiAgICAgICAgY2hhcnM7XG5cbiAgICAvLyBERUJVRyBcIiAgXCIgKyBkZWJ1Z1N0YXRlKHRoaXMpXG4gICAgdmFyIHJldHVybmVkID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5leHRTdGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IG5leHRTdGF0ZXNbaV07XG5cbiAgICAgIGNoYXJTcGVjID0gY2hpbGQuY2hhclNwZWM7XG5cbiAgICAgIGlmICh0eXBlb2YgKGNoYXJzID0gY2hhclNwZWMudmFsaWRDaGFycykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChjaGFycy5pbmRleE9mKGNoKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm5lZC5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKGNoYXJzID0gY2hhclNwZWMuaW52YWxpZENoYXJzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKGNoYXJzLmluZGV4T2YoY2gpID09PSAtMSkge1xuICAgICAgICAgIHJldHVybmVkLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVybmVkO1xuICB9XG5cbiAgLyoqIElGIERFQlVHXG4gICwgZGVidWc6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaGFyU3BlYyA9IHRoaXMuY2hhclNwZWMsXG4gICAgICAgIGRlYnVnID0gXCJbXCIsXG4gICAgICAgIGNoYXJzID0gY2hhclNwZWMudmFsaWRDaGFycyB8fCBjaGFyU3BlYy5pbnZhbGlkQ2hhcnM7XG4gICAgIGlmIChjaGFyU3BlYy5pbnZhbGlkQ2hhcnMpIHsgZGVidWcgKz0gXCJeXCI7IH1cbiAgICBkZWJ1ZyArPSBjaGFycztcbiAgICBkZWJ1ZyArPSBcIl1cIjtcbiAgICAgaWYgKGNoYXJTcGVjLnJlcGVhdCkgeyBkZWJ1ZyArPSBcIitcIjsgfVxuICAgICByZXR1cm4gZGVidWc7XG4gIH1cbiAgRU5EIElGICoqL1xufTtcblxuLyoqIElGIERFQlVHXG5mdW5jdGlvbiBkZWJ1Zyhsb2cpIHtcbiAgY29uc29sZS5sb2cobG9nKTtcbn1cblxuZnVuY3Rpb24gZGVidWdTdGF0ZShzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubmV4dFN0YXRlcy5tYXAoZnVuY3Rpb24obikge1xuICAgIGlmIChuLm5leHRTdGF0ZXMubGVuZ3RoID09PSAwKSB7IHJldHVybiBcIiggXCIgKyBuLmRlYnVnKCkgKyBcIiBbYWNjZXB0aW5nXSApXCI7IH1cbiAgICByZXR1cm4gXCIoIFwiICsgbi5kZWJ1ZygpICsgXCIgPHRoZW4+IFwiICsgbi5uZXh0U3RhdGVzLm1hcChmdW5jdGlvbihzKSB7IHJldHVybiBzLmRlYnVnKCkgfSkuam9pbihcIiBvciBcIikgKyBcIiApXCI7XG4gIH0pLmpvaW4oXCIsIFwiKVxufVxuRU5EIElGICoqL1xuXG4vLyBTb3J0IHRoZSByb3V0ZXMgYnkgc3BlY2lmaWNpdHlcbmZ1bmN0aW9uIHNvcnRTb2x1dGlvbnMoc3RhdGVzKSB7XG4gIHJldHVybiBzdGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnNwZWNpZmljaXR5LnZhbCAtIGEuc3BlY2lmaWNpdHkudmFsO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVjb2duaXplQ2hhcihzdGF0ZXMsIGNoKSB7XG4gIHZhciBuZXh0U3RhdGVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHN0YXRlID0gc3RhdGVzW2ldO1xuXG4gICAgbmV4dFN0YXRlcyA9IG5leHRTdGF0ZXMuY29uY2F0KHN0YXRlLm1hdGNoKGNoKSk7XG4gIH1cblxuICByZXR1cm4gbmV4dFN0YXRlcztcbn1cblxudmFyIG9DcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChwcm90bykge1xuICBmdW5jdGlvbiBGKCkge31cbiAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgcmV0dXJuIG5ldyBGKCk7XG59O1xuXG5mdW5jdGlvbiBSZWNvZ25pemVSZXN1bHRzKHF1ZXJ5UGFyYW1zKSB7XG4gIHRoaXMucXVlcnlQYXJhbXMgPSBxdWVyeVBhcmFtcyB8fCB7fTtcbn1cblJlY29nbml6ZVJlc3VsdHMucHJvdG90eXBlID0gb0NyZWF0ZSh7XG4gIHNwbGljZTogQXJyYXkucHJvdG90eXBlLnNwbGljZSxcbiAgc2xpY2U6IEFycmF5LnByb3RvdHlwZS5zbGljZSxcbiAgcHVzaDogQXJyYXkucHJvdG90eXBlLnB1c2gsXG4gIGxlbmd0aDogMCxcbiAgcXVlcnlQYXJhbXM6IG51bGxcbn0pO1xuXG5mdW5jdGlvbiBmaW5kSGFuZGxlcihzdGF0ZSwgcGF0aCwgcXVlcnlQYXJhbXMpIHtcbiAgdmFyIGhhbmRsZXJzID0gc3RhdGUuaGFuZGxlcnMsXG4gICAgICByZWdleCA9IHN0YXRlLnJlZ2V4O1xuICB2YXIgY2FwdHVyZXMgPSBwYXRoLm1hdGNoKHJlZ2V4KSxcbiAgICAgIGN1cnJlbnRDYXB0dXJlID0gMTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBSZWNvZ25pemVSZXN1bHRzKHF1ZXJ5UGFyYW1zKTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbaV0sXG4gICAgICAgIG5hbWVzID0gaGFuZGxlci5uYW1lcyxcbiAgICAgICAgcGFyYW1zID0ge307XG5cbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IG5hbWVzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgcGFyYW1zW25hbWVzW2pdXSA9IGNhcHR1cmVzW2N1cnJlbnRDYXB0dXJlKytdO1xuICAgIH1cblxuICAgIHJlc3VsdC5wdXNoKHsgaGFuZGxlcjogaGFuZGxlci5oYW5kbGVyLCBwYXJhbXM6IHBhcmFtcywgaXNEeW5hbWljOiAhIW5hbWVzLmxlbmd0aCB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGFkZFNlZ21lbnQoY3VycmVudFN0YXRlLCBzZWdtZW50KSB7XG4gIHNlZ21lbnQuZWFjaENoYXIoZnVuY3Rpb24gKGNoKSB7XG4gICAgdmFyIHN0YXRlO1xuXG4gICAgY3VycmVudFN0YXRlID0gY3VycmVudFN0YXRlLnB1dChjaCk7XG4gIH0pO1xuXG4gIHJldHVybiBjdXJyZW50U3RhdGU7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVF1ZXJ5UGFyYW1QYXJ0KHBhcnQpIHtcbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDQwMS9pbnRlcmFjdC9mb3Jtcy5odG1sI2gtMTcuMTMuNC4xXG4gIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL1xcKy9nbSwgJyUyMCcpO1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhcnQpO1xufVxuXG4vLyBUaGUgbWFpbiBpbnRlcmZhY2VcblxudmFyIFJvdXRlUmVjb2duaXplciA9IGZ1bmN0aW9uIFJvdXRlUmVjb2duaXplcigpIHtcbiAgdGhpcy5yb290U3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgdGhpcy5uYW1lcyA9IHt9O1xufTtcblxuUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbiBhZGQocm91dGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMucm9vdFN0YXRlLFxuICAgICAgICByZWdleCA9IFwiXlwiLFxuICAgICAgICBzcGVjaWZpY2l0eSA9IHt9LFxuICAgICAgICBoYW5kbGVycyA9IFtdLFxuICAgICAgICBhbGxTZWdtZW50cyA9IFtdLFxuICAgICAgICBuYW1lO1xuXG4gICAgdmFyIGlzRW1wdHkgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSByb3V0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgcm91dGUgPSByb3V0ZXNbaV0sXG4gICAgICAgICAgbmFtZXMgPSBbXTtcblxuICAgICAgdmFyIHNlZ21lbnRzID0gcGFyc2Uocm91dGUucGF0aCwgbmFtZXMsIHNwZWNpZmljaXR5KTtcblxuICAgICAgYWxsU2VnbWVudHMgPSBhbGxTZWdtZW50cy5jb25jYXQoc2VnbWVudHMpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMCwgbSA9IHNlZ21lbnRzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2pdO1xuXG4gICAgICAgIGlmIChzZWdtZW50IGluc3RhbmNlb2YgRXBzaWxvblNlZ21lbnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzRW1wdHkgPSBmYWxzZTtcblxuICAgICAgICAvLyBBZGQgYSBcIi9cIiBmb3IgdGhlIG5ldyBzZWdtZW50XG4gICAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRTdGF0ZS5wdXQoeyB2YWxpZENoYXJzOiBcIi9cIiB9KTtcbiAgICAgICAgcmVnZXggKz0gXCIvXCI7XG5cbiAgICAgICAgLy8gQWRkIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNlZ21lbnQgdG8gdGhlIE5GQSBhbmQgcmVnZXhcbiAgICAgICAgY3VycmVudFN0YXRlID0gYWRkU2VnbWVudChjdXJyZW50U3RhdGUsIHNlZ21lbnQpO1xuICAgICAgICByZWdleCArPSBzZWdtZW50LnJlZ2V4KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYW5kbGVyID0geyBoYW5kbGVyOiByb3V0ZS5oYW5kbGVyLCBuYW1lczogbmFtZXMgfTtcbiAgICAgIGhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgfVxuXG4gICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRTdGF0ZS5wdXQoeyB2YWxpZENoYXJzOiBcIi9cIiB9KTtcbiAgICAgIHJlZ2V4ICs9IFwiL1wiO1xuICAgIH1cblxuICAgIGN1cnJlbnRTdGF0ZS5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIGN1cnJlbnRTdGF0ZS5yZWdleCA9IG5ldyBSZWdFeHAocmVnZXggKyBcIiRcIik7XG4gICAgY3VycmVudFN0YXRlLnNwZWNpZmljaXR5ID0gc3BlY2lmaWNpdHk7XG5cbiAgICBpZiAobmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hcykge1xuICAgICAgdGhpcy5uYW1lc1tuYW1lXSA9IHtcbiAgICAgICAgc2VnbWVudHM6IGFsbFNlZ21lbnRzLFxuICAgICAgICBoYW5kbGVyczogaGFuZGxlcnNcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZXJzRm9yOiBmdW5jdGlvbiBoYW5kbGVyc0ZvcihuYW1lKSB7XG4gICAgdmFyIHJvdXRlID0gdGhpcy5uYW1lc1tuYW1lXSxcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgaWYgKCFyb3V0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgbm8gcm91dGUgbmFtZWQgXCIgKyBuYW1lKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJvdXRlLmhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2gocm91dGUuaGFuZGxlcnNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgaGFzUm91dGU6IGZ1bmN0aW9uIGhhc1JvdXRlKG5hbWUpIHtcbiAgICByZXR1cm4gISF0aGlzLm5hbWVzW25hbWVdO1xuICB9LFxuXG4gIGdlbmVyYXRlOiBmdW5jdGlvbiBnZW5lcmF0ZShuYW1lLCBwYXJhbXMpIHtcbiAgICB2YXIgcm91dGUgPSB0aGlzLm5hbWVzW25hbWVdLFxuICAgICAgICBvdXRwdXQgPSBcIlwiO1xuICAgIGlmICghcm91dGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIHJvdXRlIG5hbWVkIFwiICsgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHNlZ21lbnRzID0gcm91dGUuc2VnbWVudHM7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblxuICAgICAgaWYgKHNlZ21lbnQgaW5zdGFuY2VvZiBFcHNpbG9uU2VnbWVudCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgb3V0cHV0ICs9IFwiL1wiO1xuICAgICAgb3V0cHV0ICs9IHNlZ21lbnQuZ2VuZXJhdGUocGFyYW1zKTtcbiAgICB9XG5cbiAgICBpZiAob3V0cHV0LmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBvdXRwdXQgPSAnLycgKyBvdXRwdXQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMucXVlcnlQYXJhbXMpIHtcbiAgICAgIG91dHB1dCArPSB0aGlzLmdlbmVyYXRlUXVlcnlTdHJpbmcocGFyYW1zLnF1ZXJ5UGFyYW1zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuXG4gIGdlbmVyYXRlUXVlcnlTdHJpbmc6IGZ1bmN0aW9uIGdlbmVyYXRlUXVlcnlTdHJpbmcocGFyYW1zKSB7XG4gICAgdmFyIHBhaXJzID0gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGtleXMuc29ydCgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW2tleV07XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYWlyID0gZW5jb2RlVVJJQ29tcG9uZW50KGtleSk7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICB2YXIgYXJyYXlQYWlyID0ga2V5ICsgJ1tdJyArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZVtqXSk7XG4gICAgICAgICAgcGFpcnMucHVzaChhcnJheVBhaXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWlyICs9IFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgcGFpcnMucHVzaChwYWlyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFpcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiP1wiICsgcGFpcnMuam9pbihcIiZcIik7XG4gIH0sXG5cbiAgcGFyc2VRdWVyeVN0cmluZzogZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZyhxdWVyeVN0cmluZykge1xuICAgIHZhciBwYWlycyA9IHF1ZXJ5U3RyaW5nLnNwbGl0KFwiJlwiKSxcbiAgICAgICAgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9JyksXG4gICAgICAgICAga2V5ID0gZGVjb2RlUXVlcnlQYXJhbVBhcnQocGFpclswXSksXG4gICAgICAgICAga2V5TGVuZ3RoID0ga2V5Lmxlbmd0aCxcbiAgICAgICAgICBpc0FycmF5ID0gZmFsc2UsXG4gICAgICAgICAgdmFsdWU7XG4gICAgICBpZiAocGFpci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFsdWUgPSAndHJ1ZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL0hhbmRsZSBhcnJheXNcbiAgICAgICAgaWYgKGtleUxlbmd0aCA+IDIgJiYga2V5LnNsaWNlKGtleUxlbmd0aCAtIDIpID09PSAnW10nKSB7XG4gICAgICAgICAgaXNBcnJheSA9IHRydWU7XG4gICAgICAgICAga2V5ID0ga2V5LnNsaWNlKDAsIGtleUxlbmd0aCAtIDIpO1xuICAgICAgICAgIGlmICghcXVlcnlQYXJhbXNba2V5XSkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXNba2V5XSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHBhaXJbMV0gPyBkZWNvZGVRdWVyeVBhcmFtUGFydChwYWlyWzFdKSA6ICcnO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgcXVlcnlQYXJhbXNba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5UGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5UGFyYW1zO1xuICB9LFxuXG4gIHJlY29nbml6ZTogZnVuY3Rpb24gcmVjb2duaXplKHBhdGgpIHtcbiAgICB2YXIgc3RhdGVzID0gW3RoaXMucm9vdFN0YXRlXSxcbiAgICAgICAgcGF0aExlbixcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgcXVlcnlTdGFydCxcbiAgICAgICAgcXVlcnlQYXJhbXMgPSB7fSxcbiAgICAgICAgaXNTbGFzaERyb3BwZWQgPSBmYWxzZTtcblxuICAgIHF1ZXJ5U3RhcnQgPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgICBpZiAocXVlcnlTdGFydCAhPT0gLTEpIHtcbiAgICAgIHZhciBxdWVyeVN0cmluZyA9IHBhdGguc3Vic3RyKHF1ZXJ5U3RhcnQgKyAxLCBwYXRoLmxlbmd0aCk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgcXVlcnlTdGFydCk7XG4gICAgICBxdWVyeVBhcmFtcyA9IHRoaXMucGFyc2VRdWVyeVN0cmluZyhxdWVyeVN0cmluZyk7XG4gICAgfVxuXG4gICAgcGF0aCA9IGRlY29kZVVSSShwYXRoKTtcblxuICAgIC8vIERFQlVHIEdST1VQIHBhdGhcblxuICAgIGlmIChwYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgIHBhdGggPSBcIi9cIiArIHBhdGg7XG4gICAgfVxuXG4gICAgcGF0aExlbiA9IHBhdGgubGVuZ3RoO1xuICAgIGlmIChwYXRoTGVuID4gMSAmJiBwYXRoLmNoYXJBdChwYXRoTGVuIC0gMSkgPT09IFwiL1wiKSB7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgcGF0aExlbiAtIDEpO1xuICAgICAgaXNTbGFzaERyb3BwZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGwgPSBwYXRoLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc3RhdGVzID0gcmVjb2duaXplQ2hhcihzdGF0ZXMsIHBhdGguY2hhckF0KGkpKTtcbiAgICAgIGlmICghc3RhdGVzLmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFTkQgREVCVUcgR1JPVVBcblxuICAgIHZhciBzb2x1dGlvbnMgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gc3RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHN0YXRlc1tpXS5oYW5kbGVycykge1xuICAgICAgICBzb2x1dGlvbnMucHVzaChzdGF0ZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlcyA9IHNvcnRTb2x1dGlvbnMoc29sdXRpb25zKTtcblxuICAgIHZhciBzdGF0ZSA9IHNvbHV0aW9uc1swXTtcblxuICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5oYW5kbGVycykge1xuICAgICAgLy8gaWYgYSB0cmFpbGluZyBzbGFzaCB3YXMgZHJvcHBlZCBhbmQgYSBzdGFyIHNlZ21lbnQgaXMgdGhlIGxhc3Qgc2VnbWVudFxuICAgICAgLy8gc3BlY2lmaWVkLCBwdXQgdGhlIHRyYWlsaW5nIHNsYXNoIGJhY2tcbiAgICAgIGlmIChpc1NsYXNoRHJvcHBlZCAmJiBzdGF0ZS5yZWdleC5zb3VyY2Uuc2xpY2UoLTUpID09PSBcIiguKykkXCIpIHtcbiAgICAgICAgcGF0aCA9IHBhdGggKyBcIi9cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5kSGFuZGxlcihzdGF0ZSwgcGF0aCwgcXVlcnlQYXJhbXMpO1xuICAgIH1cbiAgfVxufTtcblxuUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5tYXAgPSBtYXA7XG5cblJvdXRlUmVjb2duaXplci5WRVJTSU9OID0gJzAuMS45JztcblxudmFyIGdlblF1ZXJ5ID0gUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5nZW5lcmF0ZVF1ZXJ5U3RyaW5nO1xuXG4vLyBleHBvcnQgZGVmYXVsdCBmb3IgaG9sZGluZyB0aGUgVnVlIHJlZmVyZW5jZVxudmFyIGV4cG9ydHMkMSA9IHt9O1xuLyoqXG4gKiBXYXJuIHN0dWZmLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2dcbiAqL1xuXG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAod2luZG93LmNvbnNvbGUpIHtcbiAgICBjb25zb2xlLndhcm4oJ1t2dWUtcm91dGVyXSAnICsgbXNnKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWV4cG9ydHMkMS5WdWUgfHwgZXhwb3J0cyQxLlZ1ZS5jb25maWcuZGVidWcpIHtcbiAgICAgIGNvbnNvbGUud2FybihuZXcgRXJyb3IoJ3dhcm5pbmcgc3RhY2sgdHJhY2U6Jykuc3RhY2spO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBwYXRoLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYXBwZW5kXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgoYmFzZSwgcmVsYXRpdmUsIGFwcGVuZCkge1xuICB2YXIgcXVlcnkgPSBiYXNlLm1hdGNoKC8oXFw/LiopJC8pO1xuICBpZiAocXVlcnkpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5WzFdO1xuICAgIGJhc2UgPSBiYXNlLnNsaWNlKDAsIC1xdWVyeS5sZW5ndGgpO1xuICB9XG4gIC8vIGEgcXVlcnkhXG4gIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgPT09ICc/Jykge1xuICAgIHJldHVybiBiYXNlICsgcmVsYXRpdmU7XG4gIH1cbiAgdmFyIHN0YWNrID0gYmFzZS5zcGxpdCgnLycpO1xuICAvLyByZW1vdmUgdHJhaWxpbmcgc2VnbWVudCBpZjpcbiAgLy8gLSBub3QgYXBwZW5kaW5nXG4gIC8vIC0gYXBwZW5kaW5nIHRvIHRyYWlsaW5nIHNsYXNoIChsYXN0IHNlZ21lbnQgaXMgZW1wdHkpXG4gIGlmICghYXBwZW5kIHx8ICFzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgIHN0YWNrLnBvcCgpO1xuICB9XG4gIC8vIHJlc29sdmUgcmVsYXRpdmUgcGF0aFxuICB2YXIgc2VnbWVudHMgPSByZWxhdGl2ZS5yZXBsYWNlKC9eXFwvLywgJycpLnNwbGl0KCcvJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGlmIChzZWdtZW50ID09PSAnLicpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCA9PT0gJy4uJykge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWNrLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9XG4gIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoXG4gIGlmIChzdGFja1swXSAhPT0gJycpIHtcbiAgICBzdGFjay51bnNoaWZ0KCcnKTtcbiAgfVxuICByZXR1cm4gc3RhY2suam9pbignLycpO1xufVxuXG4vKipcbiAqIEZvcmdpdmluZyBjaGVjayBmb3IgYSBwcm9taXNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNQcm9taXNlKHApIHtcbiAgcmV0dXJuIHAgJiYgdHlwZW9mIHAudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXRyaXZlIGEgcm91dGUgY29uZmlnIGZpZWxkIGZyb20gYSBjb21wb25lbnQgaW5zdGFuY2VcbiAqIE9SIGEgY29tcG9uZW50IGNvbnRydWN0b3IuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxWdWV9IGNvbXBvbmVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuZnVuY3Rpb24gZ2V0Um91dGVDb25maWcoY29tcG9uZW50LCBuYW1lKSB7XG4gIHZhciBvcHRpb25zID0gY29tcG9uZW50ICYmIChjb21wb25lbnQuJG9wdGlvbnMgfHwgY29tcG9uZW50Lm9wdGlvbnMpO1xuICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGVbbmFtZV07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeS4gSGF2ZSB0byBkbyBhIGRpcnR5XG4gKiBtb2NrIGhlcmUgYmVjYXVzZSBvZiBWdWUgY29yZSdzIGludGVybmFsIEFQSSBkZXBlbmRzIG9uXG4gKiBhbiBJRCBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG52YXIgcmVzb2x2ZXIgPSB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudChoYW5kbGVyLCBjYikge1xuICBpZiAoIXJlc29sdmVyKSB7XG4gICAgcmVzb2x2ZXIgPSB7XG4gICAgICByZXNvbHZlOiBleHBvcnRzJDEuVnVlLnByb3RvdHlwZS5fcmVzb2x2ZUNvbXBvbmVudCxcbiAgICAgICRvcHRpb25zOiB7XG4gICAgICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgICBfOiBoYW5kbGVyLmNvbXBvbmVudFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXNvbHZlci4kb3B0aW9ucy5jb21wb25lbnRzLl8gPSBoYW5kbGVyLmNvbXBvbmVudDtcbiAgfVxuICByZXNvbHZlci5yZXNvbHZlKCdfJywgZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgIGhhbmRsZXIuY29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgIGNiKENvbXBvbmVudCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIE1hcCB0aGUgZHluYW1pYyBzZWdtZW50cyBpbiBhIHBhdGggdG8gcGFyYW1zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge09iamVjdH0gcXVlcnlcbiAqL1xuXG5mdW5jdGlvbiBtYXBQYXJhbXMocGF0aCwgcGFyYW1zLCBxdWVyeSkge1xuICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHBhcmFtcyA9IHt9O1xuXG4gIHBhdGggPSBwYXRoLnJlcGxhY2UoLzooW15cXC9dKykvZywgZnVuY3Rpb24gKF8sIGtleSkge1xuICAgIHZhciB2YWwgPSBwYXJhbXNba2V5XTtcbiAgICBpZiAoIXZhbCkge1xuICAgICAgd2FybigncGFyYW0gXCInICsga2V5ICsgJ1wiIG5vdCBmb3VuZCB3aGVuIGdlbmVyYXRpbmcgJyArICdwYXRoIGZvciBcIicgKyBwYXRoICsgJ1wiIHdpdGggcGFyYW1zICcgKyBKU09OLnN0cmluZ2lmeShwYXJhbXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbCB8fCAnJztcbiAgfSk7XG4gIGlmIChxdWVyeSkge1xuICAgIHBhdGggKz0gZ2VuUXVlcnkocXVlcnkpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuXG52YXIgaGFzaFJFID0gLyMuKiQvO1xuXG52YXIgSFRNTDVIaXN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSFRNTDVIaXN0b3J5KF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdDtcbiAgICB2YXIgb25DaGFuZ2UgPSBfcmVmLm9uQ2hhbmdlO1xuICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBIVE1MNUhpc3RvcnkpO1xuXG4gICAgaWYgKHJvb3QpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSdzIHRoZSBzdGFydGluZyBzbGFzaFxuICAgICAgaWYgKHJvb3QuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgICAgcm9vdCA9ICcvJyArIHJvb3Q7XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2hcbiAgICAgIHRoaXMucm9vdCA9IHJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICAgIHRoaXMucm9vdFJFID0gbmV3IFJlZ0V4cCgnXlxcXFwnICsgdGhpcy5yb290KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlO1xuICAgIC8vIGNoZWNrIGJhc2UgdGFnXG4gICAgdmFyIGJhc2VFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcbiAgICB0aGlzLmJhc2UgPSBiYXNlRWwgJiYgYmFzZUVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICB9XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciB1cmwgPSBkZWNvZGVVUkkobG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2gpO1xuICAgICAgaWYgKF90aGlzLnJvb3QpIHtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoX3RoaXMucm9vdFJFLCAnJyk7XG4gICAgICB9XG4gICAgICBfdGhpcy5vbkNoYW5nZSh1cmwsIGUgJiYgZS5zdGF0ZSwgbG9jYXRpb24uaGFzaCk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB0aGlzLmxpc3RlbmVyKCk7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLmxpc3RlbmVyKTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28ocGF0aCwgcmVwbGFjZSwgYXBwZW5kKSB7XG4gICAgdmFyIHVybCA9IHRoaXMuZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpO1xuICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgJycsIHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlY29yZCBzY3JvbGwgcG9zaXRpb24gYnkgcmVwbGFjaW5nIGN1cnJlbnQgc3RhdGVcbiAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHtcbiAgICAgICAgcG9zOiB7XG4gICAgICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldFxuICAgICAgICB9XG4gICAgICB9LCAnJyk7XG4gICAgICAvLyB0aGVuIHB1c2ggbmV3IHN0YXRlXG4gICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7fSwgJycsIHVybCk7XG4gICAgfVxuICAgIHZhciBoYXNoTWF0Y2ggPSBwYXRoLm1hdGNoKGhhc2hSRSk7XG4gICAgdmFyIGhhc2ggPSBoYXNoTWF0Y2ggJiYgaGFzaE1hdGNoWzBdO1xuICAgIHBhdGggPSB1cmxcbiAgICAvLyBzdHJpcCBoYXNoIHNvIGl0IGRvZXNuJ3QgbWVzcyB1cCBwYXJhbXNcbiAgICAucmVwbGFjZShoYXNoUkUsICcnKVxuICAgIC8vIHJlbW92ZSByb290IGJlZm9yZSBtYXRjaGluZ1xuICAgIC5yZXBsYWNlKHRoaXMucm9vdFJFLCAnJyk7XG4gICAgdGhpcy5vbkNoYW5nZShwYXRoLCBudWxsLCBoYXNoKTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmZvcm1hdFBhdGggPSBmdW5jdGlvbiBmb3JtYXRQYXRoKHBhdGgsIGFwcGVuZCkge1xuICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgLy8gYWJzb2x1dGUgcGF0aFxuICAgID8gdGhpcy5yb290ID8gdGhpcy5yb290ICsgJy8nICsgcGF0aC5yZXBsYWNlKC9eXFwvLywgJycpIDogcGF0aCA6IHJlc29sdmVQYXRoKHRoaXMuYmFzZSB8fCBsb2NhdGlvbi5wYXRobmFtZSwgcGF0aCwgYXBwZW5kKTtcbiAgfTtcblxuICByZXR1cm4gSFRNTDVIaXN0b3J5O1xufSkoKTtcblxudmFyIEhhc2hIaXN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSGFzaEhpc3RvcnkoX3JlZikge1xuICAgIHZhciBoYXNoYmFuZyA9IF9yZWYuaGFzaGJhbmc7XG4gICAgdmFyIG9uQ2hhbmdlID0gX3JlZi5vbkNoYW5nZTtcbiAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgSGFzaEhpc3RvcnkpO1xuXG4gICAgdGhpcy5oYXNoYmFuZyA9IGhhc2hiYW5nO1xuICAgIHRoaXMub25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgfVxuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhdGggPSBsb2NhdGlvbi5oYXNoO1xuICAgICAgdmFyIHJhdyA9IHBhdGgucmVwbGFjZSgvXiMhPy8sICcnKTtcbiAgICAgIC8vIGFsd2F5c1xuICAgICAgaWYgKHJhdy5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgICByYXcgPSAnLycgKyByYXc7XG4gICAgICB9XG4gICAgICB2YXIgZm9ybWF0dGVkUGF0aCA9IHNlbGYuZm9ybWF0UGF0aChyYXcpO1xuICAgICAgaWYgKGZvcm1hdHRlZFBhdGggIT09IHBhdGgpIHtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShmb3JtYXR0ZWRQYXRoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gZGV0ZXJtaW5lIHF1ZXJ5XG4gICAgICAvLyBub3RlIGl0J3MgcG9zc2libGUgdG8gaGF2ZSBxdWVyaWVzIGluIGJvdGggdGhlIGFjdHVhbCBVUkxcbiAgICAgIC8vIGFuZCB0aGUgaGFzaCBmcmFnbWVudCBpdHNlbGYuXG4gICAgICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5zZWFyY2ggJiYgcGF0aC5pbmRleE9mKCc/JykgPiAtMSA/ICcmJyArIGxvY2F0aW9uLnNlYXJjaC5zbGljZSgxKSA6IGxvY2F0aW9uLnNlYXJjaDtcbiAgICAgIHNlbGYub25DaGFuZ2UoZGVjb2RlVVJJKHBhdGgucmVwbGFjZSgvXiMhPy8sICcnKSArIHF1ZXJ5KSk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMubGlzdGVuZXIpO1xuICAgIHRoaXMubGlzdGVuZXIoKTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyhwYXRoLCByZXBsYWNlLCBhcHBlbmQpIHtcbiAgICBwYXRoID0gdGhpcy5mb3JtYXRQYXRoKHBhdGgsIGFwcGVuZCk7XG4gICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgIGxvY2F0aW9uLnJlcGxhY2UocGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLmhhc2ggPSBwYXRoO1xuICAgIH1cbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZm9ybWF0UGF0aCA9IGZ1bmN0aW9uIGZvcm1hdFBhdGgocGF0aCwgYXBwZW5kKSB7XG4gICAgdmFyIGlzQWJzb2xvdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgICB2YXIgcHJlZml4ID0gJyMnICsgKHRoaXMuaGFzaGJhbmcgPyAnIScgOiAnJyk7XG4gICAgcmV0dXJuIGlzQWJzb2xvdXRlID8gcHJlZml4ICsgcGF0aCA6IHByZWZpeCArIHJlc29sdmVQYXRoKGxvY2F0aW9uLmhhc2gucmVwbGFjZSgvXiMhPy8sICcnKSwgcGF0aCwgYXBwZW5kKTtcbiAgfTtcblxuICByZXR1cm4gSGFzaEhpc3Rvcnk7XG59KSgpO1xuXG52YXIgQWJzdHJhY3RIaXN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQWJzdHJhY3RIaXN0b3J5KF9yZWYpIHtcbiAgICB2YXIgb25DaGFuZ2UgPSBfcmVmLm9uQ2hhbmdlO1xuICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBBYnN0cmFjdEhpc3RvcnkpO1xuXG4gICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSAnLyc7XG4gIH1cblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgdGhpcy5vbkNoYW5nZSgnLycpO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgLy8gbm9vcFxuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyhwYXRoLCByZXBsYWNlLCBhcHBlbmQpIHtcbiAgICBwYXRoID0gdGhpcy5jdXJyZW50UGF0aCA9IHRoaXMuZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpO1xuICAgIHRoaXMub25DaGFuZ2UocGF0aCk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5mb3JtYXRQYXRoID0gZnVuY3Rpb24gZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpIHtcbiAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGggOiByZXNvbHZlUGF0aCh0aGlzLmN1cnJlbnRQYXRoLCBwYXRoLCBhcHBlbmQpO1xuICB9O1xuXG4gIHJldHVybiBBYnN0cmFjdEhpc3Rvcnk7XG59KSgpO1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgcmV1c2FiaWxpdHkgb2YgYW4gZXhpc3Rpbmcgcm91dGVyIHZpZXcuXG4gKlxuICogQHBhcmFtIHtEaXJlY3RpdmV9IHZpZXdcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gKiBAcGFyYW0ge1RyYW5zaXRpb259IHRyYW5zaXRpb25cbiAqL1xuXG5mdW5jdGlvbiBjYW5SZXVzZSh2aWV3LCBoYW5kbGVyLCB0cmFuc2l0aW9uKSB7XG4gIHZhciBjb21wb25lbnQgPSB2aWV3LmNoaWxkVk07XG4gIGlmICghY29tcG9uZW50IHx8ICFoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGltcG9ydGFudDogY2hlY2sgdmlldy5Db21wb25lbnQgaGVyZSBiZWNhdXNlIGl0IG1heVxuICAvLyBoYXZlIGJlZW4gY2hhbmdlZCBpbiBhY3RpdmF0ZSBob29rXG4gIGlmICh2aWV3LkNvbXBvbmVudCAhPT0gaGFuZGxlci5jb21wb25lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGNhblJldXNlRm4gPSBnZXRSb3V0ZUNvbmZpZyhjb21wb25lbnQsICdjYW5SZXVzZScpO1xuICByZXR1cm4gdHlwZW9mIGNhblJldXNlRm4gPT09ICdib29sZWFuJyA/IGNhblJldXNlRm4gOiBjYW5SZXVzZUZuID8gY2FuUmV1c2VGbi5jYWxsKGNvbXBvbmVudCwge1xuICAgIHRvOiB0cmFuc2l0aW9uLnRvLFxuICAgIGZyb206IHRyYW5zaXRpb24uZnJvbVxuICB9KSA6IHRydWU7IC8vIGRlZmF1bHRzIHRvIHRydWVcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGNvbXBvbmVudCBjYW4gZGVhY3RpdmF0ZS5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlld1xuICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKi9cblxuZnVuY3Rpb24gY2FuRGVhY3RpdmF0ZSh2aWV3LCB0cmFuc2l0aW9uLCBuZXh0KSB7XG4gIHZhciBmcm9tQ29tcG9uZW50ID0gdmlldy5jaGlsZFZNO1xuICB2YXIgaG9vayA9IGdldFJvdXRlQ29uZmlnKGZyb21Db21wb25lbnQsICdjYW5EZWFjdGl2YXRlJyk7XG4gIGlmICghaG9vaykge1xuICAgIG5leHQoKTtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2l0aW9uLmNhbGxIb29rKGhvb2ssIGZyb21Db21wb25lbnQsIG5leHQsIHtcbiAgICAgIGV4cGVjdEJvb2xlYW46IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY29tcG9uZW50IGNhbiBhY3RpdmF0ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlclxuICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKi9cblxuZnVuY3Rpb24gY2FuQWN0aXZhdGUoaGFuZGxlciwgdHJhbnNpdGlvbiwgbmV4dCkge1xuICByZXNvbHZlQXN5bmNDb21wb25lbnQoaGFuZGxlciwgZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgIC8vIGhhdmUgdG8gY2hlY2sgZHVlIHRvIGFzeW5jLW5lc3NcbiAgICBpZiAodHJhbnNpdGlvbi5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGRldGVybWluZSBpZiB0aGlzIGNvbXBvbmVudCBjYW4gYmUgYWN0aXZhdGVkXG4gICAgdmFyIGhvb2sgPSBnZXRSb3V0ZUNvbmZpZyhDb21wb25lbnQsICdjYW5BY3RpdmF0ZScpO1xuICAgIGlmICghaG9vaykge1xuICAgICAgbmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2l0aW9uLmNhbGxIb29rKGhvb2ssIG51bGwsIG5leHQsIHtcbiAgICAgICAgZXhwZWN0Qm9vbGVhbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBDYWxsIGRlYWN0aXZhdGUgaG9va3MgZm9yIGV4aXN0aW5nIHJvdXRlci12aWV3cy5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlld1xuICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKi9cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZSh2aWV3LCB0cmFuc2l0aW9uLCBuZXh0KSB7XG4gIHZhciBjb21wb25lbnQgPSB2aWV3LmNoaWxkVk07XG4gIHZhciBob29rID0gZ2V0Um91dGVDb25maWcoY29tcG9uZW50LCAnZGVhY3RpdmF0ZScpO1xuICBpZiAoIWhvb2spIHtcbiAgICBuZXh0KCk7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNpdGlvbi5jYWxsSG9va3MoaG9vaywgY29tcG9uZW50LCBuZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjdGl2YXRlIC8gc3dpdGNoIGNvbXBvbmVudCBmb3IgYSByb3V0ZXItdmlldy5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlld1xuICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gZGVwdGhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5mdW5jdGlvbiBhY3RpdmF0ZSh2aWV3LCB0cmFuc2l0aW9uLCBkZXB0aCwgY2IsIHJldXNlKSB7XG4gIHZhciBoYW5kbGVyID0gdHJhbnNpdGlvbi5hY3RpdmF0ZVF1ZXVlW2RlcHRoXTtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgLy8gZml4IDEuMC4wLWFscGhhLjMgY29tcGF0XG4gICAgaWYgKHZpZXcuX2JvdW5kKSB7XG4gICAgICB2aWV3LnNldENvbXBvbmVudChudWxsKTtcbiAgICB9XG4gICAgY2IgJiYgY2IoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgQ29tcG9uZW50ID0gdmlldy5Db21wb25lbnQgPSBoYW5kbGVyLmNvbXBvbmVudDtcbiAgdmFyIGFjdGl2YXRlSG9vayA9IGdldFJvdXRlQ29uZmlnKENvbXBvbmVudCwgJ2FjdGl2YXRlJyk7XG4gIHZhciBkYXRhSG9vayA9IGdldFJvdXRlQ29uZmlnKENvbXBvbmVudCwgJ2RhdGEnKTtcbiAgdmFyIHdhaXRGb3JEYXRhID0gZ2V0Um91dGVDb25maWcoQ29tcG9uZW50LCAnd2FpdEZvckRhdGEnKTtcblxuICB2aWV3LmRlcHRoID0gZGVwdGg7XG4gIHZpZXcuYWN0aXZhdGVkID0gZmFsc2U7XG5cbiAgdmFyIGNvbXBvbmVudCA9IHVuZGVmaW5lZDtcbiAgdmFyIGxvYWRpbmcgPSAhIShkYXRhSG9vayAmJiAhd2FpdEZvckRhdGEpO1xuXG4gIC8vIFwicmV1c2VcIiBpcyBhIGZsYWcgcGFzc2VkIGRvd24gd2hlbiB0aGUgcGFyZW50IHZpZXcgaXNcbiAgLy8gZWl0aGVyIHJldXNlZCB2aWEga2VlcC1hbGl2ZSBvciBhcyBhIGNoaWxkIG9mIGEga2VwdC1hbGl2ZSB2aWV3LlxuICAvLyBvZiBjb3Vyc2Ugd2UgY2FuIG9ubHkgcmV1c2UgaWYgdGhlIGN1cnJlbnQga2VwdC1hbGl2ZSBpbnN0YW5jZVxuICAvLyBpcyBvZiB0aGUgY29ycmVjdCB0eXBlLlxuICByZXVzZSA9IHJldXNlICYmIHZpZXcuY2hpbGRWTSAmJiB2aWV3LmNoaWxkVk0uY29uc3RydWN0b3IgPT09IENvbXBvbmVudDtcblxuICBpZiAocmV1c2UpIHtcbiAgICAvLyBqdXN0IHJldXNlXG4gICAgY29tcG9uZW50ID0gdmlldy5jaGlsZFZNO1xuICAgIGNvbXBvbmVudC4kbG9hZGluZ1JvdXRlRGF0YSA9IGxvYWRpbmc7XG4gIH0gZWxzZSB7XG4gICAgLy8gdW5idWlsZCBjdXJyZW50IGNvbXBvbmVudC4gdGhpcyBzdGVwIGFsc28gZGVzdHJveXNcbiAgICAvLyBhbmQgcmVtb3ZlcyBhbGwgbmVzdGVkIGNoaWxkIHZpZXdzLlxuICAgIHZpZXcudW5idWlsZCh0cnVlKTtcbiAgICAvLyBoYW5kbGUga2VlcC1hbGl2ZS5cbiAgICAvLyBpZiB0aGUgdmlldyBoYXMga2VlcC1hbGl2ZSwgdGhlIGNoaWxkIHZtIGlzIG5vdCBhY3R1YWxseVxuICAgIC8vIGRlc3Ryb3llZCAtIGl0cyBuZXN0ZWQgdmlld3Mgd2lsbCBzdGlsbCBiZSBpbiByb3V0ZXInc1xuICAgIC8vIHZpZXcgbGlzdC4gV2UgbmVlZCB0byByZW1vdmVkIHRoZXNlIGNoaWxkIHZpZXdzIGFuZFxuICAgIC8vIGNhY2hlIHRoZW0gb24gdGhlIGNoaWxkIHZtLlxuICAgIGlmICh2aWV3LmtlZXBBbGl2ZSkge1xuICAgICAgdmFyIHZpZXdzID0gdHJhbnNpdGlvbi5yb3V0ZXIuX3ZpZXdzO1xuICAgICAgdmFyIGkgPSB2aWV3cy5pbmRleE9mKHZpZXcpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHRyYW5zaXRpb24ucm91dGVyLl92aWV3cyA9IHZpZXdzLnNsaWNlKGkpO1xuICAgICAgICBpZiAodmlldy5jaGlsZFZNKSB7XG4gICAgICAgICAgdmlldy5jaGlsZFZNLl9yb3V0ZXJWaWV3cyA9IHZpZXdzLnNsaWNlKDAsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgdGhlIG5ldyBjb21wb25lbnQuIHRoaXMgd2lsbCBhbHNvIGNyZWF0ZSB0aGVcbiAgICAvLyBkaXJlY3QgY2hpbGQgdmlldyBvZiB0aGUgY3VycmVudCBvbmUuIGl0IHdpbGwgcmVnaXN0ZXJcbiAgICAvLyBpdHNlbGYgYXMgdmlldy5jaGlsZFZpZXcuXG4gICAgY29tcG9uZW50ID0gdmlldy5idWlsZCh7XG4gICAgICBfbWV0YToge1xuICAgICAgICAkbG9hZGluZ1JvdXRlRGF0YTogbG9hZGluZ1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGhhbmRsZSBrZWVwLWFsaXZlLlxuICAgIC8vIHdoZW4gYSBrZXB0LWFsaXZlIGNoaWxkIHZtIGlzIHJlc3RvcmVkLCB3ZSBuZWVkIHRvXG4gICAgLy8gYWRkIGl0cyBjYWNoZWQgY2hpbGQgdmlld3MgaW50byB0aGUgcm91dGVyJ3MgdmlldyBsaXN0LFxuICAgIC8vIGFuZCBhbHNvIHByb3Blcmx5IHVwZGF0ZSBjdXJyZW50IHZpZXcncyBjaGlsZCB2aWV3LlxuICAgIGlmICh2aWV3LmtlZXBBbGl2ZSkge1xuICAgICAgY29tcG9uZW50LiRsb2FkaW5nUm91dGVEYXRhID0gbG9hZGluZztcbiAgICAgIHZhciBjYWNoZWRWaWV3cyA9IGNvbXBvbmVudC5fcm91dGVyVmlld3M7XG4gICAgICBpZiAoY2FjaGVkVmlld3MpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5yb3V0ZXIuX3ZpZXdzID0gY2FjaGVkVmlld3MuY29uY2F0KHRyYW5zaXRpb24ucm91dGVyLl92aWV3cyk7XG4gICAgICAgIHZpZXcuY2hpbGRWaWV3ID0gY2FjaGVkVmlld3NbY2FjaGVkVmlld3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbXBvbmVudC5fcm91dGVyVmlld3MgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNsZWFudXAgdGhlIGNvbXBvbmVudCBpbiBjYXNlIHRoZSB0cmFuc2l0aW9uIGlzIGFib3J0ZWRcbiAgLy8gYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgZXZlciBpbnNlcnRlZC5cbiAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGNvbXBvbmVudC4kZGVzdHJveSgpO1xuICB9O1xuXG4gIC8vIGFjdHVhbGx5IGluc2VydCB0aGUgY29tcG9uZW50IGFuZCB0cmlnZ2VyIHRyYW5zaXRpb25cbiAgdmFyIGluc2VydCA9IGZ1bmN0aW9uIGluc2VydCgpIHtcbiAgICBpZiAocmV1c2UpIHtcbiAgICAgIGNiICYmIGNiKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByb3V0ZXIgPSB0cmFuc2l0aW9uLnJvdXRlcjtcbiAgICBpZiAocm91dGVyLl9yZW5kZXJlZCB8fCByb3V0ZXIuX3RyYW5zaXRpb25PbkxvYWQpIHtcbiAgICAgIHZpZXcudHJhbnNpdGlvbihjb21wb25lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBubyB0cmFuc2l0aW9uIG9uIGZpcnN0IHJlbmRlciwgbWFudWFsIHRyYW5zaXRpb25cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHZpZXcuc2V0Q3VycmVudCkge1xuICAgICAgICAvLyAwLjEyIGNvbXBhdFxuICAgICAgICB2aWV3LnNldEN1cnJlbnQoY29tcG9uZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDEuMFxuICAgICAgICB2aWV3LmNoaWxkVk0gPSBjb21wb25lbnQ7XG4gICAgICB9XG4gICAgICBjb21wb25lbnQuJGJlZm9yZSh2aWV3LmFuY2hvciwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICBjYiAmJiBjYigpO1xuICB9O1xuXG4gIC8vIGNhbGxlZCBhZnRlciBhY3RpdmF0aW9uIGhvb2sgaXMgcmVzb2x2ZWRcbiAgdmFyIGFmdGVyQWN0aXZhdGUgPSBmdW5jdGlvbiBhZnRlckFjdGl2YXRlKCkge1xuICAgIHZpZXcuYWN0aXZhdGVkID0gdHJ1ZTtcbiAgICAvLyBhY3RpdmF0ZSB0aGUgY2hpbGQgdmlld1xuICAgIGlmICh2aWV3LmNoaWxkVmlldykge1xuICAgICAgYWN0aXZhdGUodmlldy5jaGlsZFZpZXcsIHRyYW5zaXRpb24sIGRlcHRoICsgMSwgbnVsbCwgcmV1c2UgfHwgdmlldy5rZWVwQWxpdmUpO1xuICAgIH1cbiAgICBpZiAoZGF0YUhvb2sgJiYgd2FpdEZvckRhdGEpIHtcbiAgICAgIC8vIHdhaXQgdW50aWwgZGF0YSBsb2FkZWQgdG8gaW5zZXJ0XG4gICAgICBsb2FkRGF0YShjb21wb25lbnQsIHRyYW5zaXRpb24sIGRhdGFIb29rLCBpbnNlcnQsIGNsZWFudXApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb2FkIGRhdGEgYW5kIGluc2VydCBhdCB0aGUgc2FtZSB0aW1lXG4gICAgICBpZiAoZGF0YUhvb2spIHtcbiAgICAgICAgbG9hZERhdGEoY29tcG9uZW50LCB0cmFuc2l0aW9uLCBkYXRhSG9vayk7XG4gICAgICB9XG4gICAgICBpbnNlcnQoKTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKGFjdGl2YXRlSG9vaykge1xuICAgIHRyYW5zaXRpb24uY2FsbEhvb2tzKGFjdGl2YXRlSG9vaywgY29tcG9uZW50LCBhZnRlckFjdGl2YXRlLCB7XG4gICAgICBjbGVhbnVwOiBjbGVhbnVwXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYWZ0ZXJBY3RpdmF0ZSgpO1xuICB9XG59XG5cbi8qKlxuICogUmV1c2UgYSB2aWV3LCBqdXN0IHJlbG9hZCBkYXRhIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlld1xuICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gKi9cblxuZnVuY3Rpb24gcmV1c2UodmlldywgdHJhbnNpdGlvbikge1xuICB2YXIgY29tcG9uZW50ID0gdmlldy5jaGlsZFZNO1xuICB2YXIgZGF0YUhvb2sgPSBnZXRSb3V0ZUNvbmZpZyhjb21wb25lbnQsICdkYXRhJyk7XG4gIGlmIChkYXRhSG9vaykge1xuICAgIGxvYWREYXRhKGNvbXBvbmVudCwgdHJhbnNpdGlvbiwgZGF0YUhvb2spO1xuICB9XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgbG9hZCBhbmQgYXBwbHkgZGF0YSB0byBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtWdWV9IGNvbXBvbmVudFxuICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xlYW51cFxuICovXG5cbmZ1bmN0aW9uIGxvYWREYXRhKGNvbXBvbmVudCwgdHJhbnNpdGlvbiwgaG9vaywgY2IsIGNsZWFudXApIHtcbiAgY29tcG9uZW50LiRsb2FkaW5nUm91dGVEYXRhID0gdHJ1ZTtcbiAgdHJhbnNpdGlvbi5jYWxsSG9va3MoaG9vaywgY29tcG9uZW50LCBmdW5jdGlvbiAoZGF0YSwgb25FcnJvcikge1xuICAgIC8vIG1lcmdlIGRhdGEgZnJvbSBtdWx0aXBsZSBkYXRhIGhvb2tzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgJiYgZGF0YS5fbmVlZE1lcmdlKSB7XG4gICAgICBkYXRhID0gZGF0YS5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgb2JqKSB7XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KG9iaikpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmVzW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgfVxuICAgIC8vIGhhbmRsZSBwcm9taXNlIHN1Z2FyIHN5bnRheFxuICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbCA9IGRhdGFba2V5XTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZSh2YWwpKSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh2YWwudGhlbihmdW5jdGlvbiAocmVzb2x2ZWRWYWwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC4kc2V0KGtleSwgcmVzb2x2ZWRWYWwpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wb25lbnQuJHNldChrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXByb21pc2VzLmxlbmd0aCkge1xuICAgICAgY29tcG9uZW50LiRsb2FkaW5nUm91dGVEYXRhID0gZmFsc2U7XG4gICAgICBjYiAmJiBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlc1swXS5jb25zdHJ1Y3Rvci5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgY29tcG9uZW50LiRsb2FkaW5nUm91dGVEYXRhID0gZmFsc2U7XG4gICAgICAgIGNiICYmIGNiKCk7XG4gICAgICB9LCBvbkVycm9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBjbGVhbnVwOiBjbGVhbnVwLFxuICAgIGV4cGVjdERhdGE6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbi8qKlxuICogQSBSb3V0ZVRyYW5zaXRpb24gb2JqZWN0IG1hbmFnZXMgdGhlIHBpcGVsaW5lIG9mIGFcbiAqIHJvdXRlci12aWV3IHN3aXRjaGluZyBwcm9jZXNzLiBUaGlzIGlzIGFsc28gdGhlIG9iamVjdFxuICogcGFzc2VkIGludG8gdXNlciByb3V0ZSBob29rcy5cbiAqXG4gKiBAcGFyYW0ge1JvdXRlcn0gcm91dGVyXG4gKiBAcGFyYW0ge1JvdXRlfSB0b1xuICogQHBhcmFtIHtSb3V0ZX0gZnJvbVxuICovXG5cbnZhciBSb3V0ZVRyYW5zaXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSb3V0ZVRyYW5zaXRpb24ocm91dGVyLCB0bywgZnJvbSkge1xuICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3V0ZVRyYW5zaXRpb24pO1xuXG4gICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgdGhpcy50byA9IHRvO1xuICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRvbmUgPSBmYWxzZTtcblxuICAgIC8vIHN0YXJ0IGJ5IGRldGVybWluZSB0aGUgcXVldWVzXG5cbiAgICAvLyB0aGUgZGVhY3RpdmF0ZSBxdWV1ZSBpcyBhbiBhcnJheSBvZiByb3V0ZXItdmlld1xuICAgIC8vIGRpcmVjdGl2ZSBpbnN0YW5jZXMgdGhhdCBuZWVkIHRvIGJlIGRlYWN0aXZhdGVkLFxuICAgIC8vIGRlZXBlc3QgZmlyc3QuXG4gICAgdGhpcy5kZWFjdGl2YXRlUXVldWUgPSByb3V0ZXIuX3ZpZXdzO1xuXG4gICAgLy8gY2hlY2sgdGhlIGRlZmF1bHQgaGFuZGxlciBvZiB0aGUgZGVlcGVzdCBtYXRjaFxuICAgIHZhciBtYXRjaGVkID0gdG8ubWF0Y2hlZCA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRvLm1hdGNoZWQpIDogW107XG5cbiAgICAvLyB0aGUgYWN0aXZhdGUgcXVldWUgaXMgYW4gYXJyYXkgb2Ygcm91dGUgaGFuZGxlcnNcbiAgICAvLyB0aGF0IG5lZWQgdG8gYmUgYWN0aXZhdGVkXG4gICAgdGhpcy5hY3RpdmF0ZVF1ZXVlID0gbWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2guaGFuZGxlcjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBYm9ydCBjdXJyZW50IHRyYW5zaXRpb24gYW5kIHJldHVybiB0byBwcmV2aW91cyBsb2NhdGlvbi5cbiAgICovXG5cbiAgUm91dGVUcmFuc2l0aW9uLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIGlmICghdGhpcy5hYm9ydGVkKSB7XG4gICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgLy8gaWYgdGhlIHJvb3QgcGF0aCB0aHJvd3MgYW4gZXJyb3IgZHVyaW5nIHZhbGlkYXRpb25cbiAgICAgIC8vIG9uIGluaXRpYWwgbG9hZCwgaXQgZ2V0cyBjYXVnaHQgaW4gYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgIHZhciBhYm9ydGluZ09uTG9hZCA9ICF0aGlzLmZyb20ucGF0aCAmJiB0aGlzLnRvLnBhdGggPT09ICcvJztcbiAgICAgIGlmICghYWJvcnRpbmdPbkxvYWQpIHtcbiAgICAgICAgdGhpcy5yb3V0ZXIucmVwbGFjZSh0aGlzLmZyb20ucGF0aCB8fCAnLycpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWJvcnQgY3VycmVudCB0cmFuc2l0aW9uIGFuZCByZWRpcmVjdCB0byBhIG5ldyBsb2NhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICovXG5cbiAgUm91dGVUcmFuc2l0aW9uLnByb3RvdHlwZS5yZWRpcmVjdCA9IGZ1bmN0aW9uIHJlZGlyZWN0KHBhdGgpIHtcbiAgICBpZiAoIXRoaXMuYWJvcnRlZCkge1xuICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCA9IG1hcFBhcmFtcyhwYXRoLCB0aGlzLnRvLnBhcmFtcywgdGhpcy50by5xdWVyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoLnBhcmFtcyA9IHBhdGgucGFyYW1zIHx8IHRoaXMudG8ucGFyYW1zO1xuICAgICAgICBwYXRoLnF1ZXJ5ID0gcGF0aC5xdWVyeSB8fCB0aGlzLnRvLnF1ZXJ5O1xuICAgICAgfVxuICAgICAgdGhpcy5yb3V0ZXIucmVwbGFjZShwYXRoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgcm91dGVyIHZpZXcgdHJhbnNpdGlvbidzIHBpcGVsaW5lIGNhbiBiZSBkZXNjcmliZWQgYXNcbiAgICogZm9sbG93cywgYXNzdW1pbmcgd2UgYXJlIHRyYW5zaXRpb25pbmcgZnJvbSBhbiBleGlzdGluZ1xuICAgKiA8cm91dGVyLXZpZXc+IGNoYWluIFtDb21wb25lbnQgQSwgQ29tcG9uZW50IEJdIHRvIGEgbmV3XG4gICAqIGNoYWluIFtDb21wb25lbnQgQSwgQ29tcG9uZW50IENdOlxuICAgKlxuICAgKiAgQSAgICBBXG4gICAqICB8ID0+IHxcbiAgICogIEIgICAgQ1xuICAgKlxuICAgKiAxLiBSZXVzYWJsaXR5IHBoYXNlOlxuICAgKiAgIC0+IGNhblJldXNlKEEsIEEpXG4gICAqICAgLT4gY2FuUmV1c2UoQiwgQylcbiAgICogICAtPiBkZXRlcm1pbmUgbmV3IHF1ZXVlczpcbiAgICogICAgICAtIGRlYWN0aXZhdGlvbjogW0JdXG4gICAqICAgICAgLSBhY3RpdmF0aW9uOiBbQ11cbiAgICpcbiAgICogMi4gVmFsaWRhdGlvbiBwaGFzZTpcbiAgICogICAtPiBjYW5EZWFjdGl2YXRlKEIpXG4gICAqICAgLT4gY2FuQWN0aXZhdGUoQylcbiAgICpcbiAgICogMy4gQWN0aXZhdGlvbiBwaGFzZTpcbiAgICogICAtPiBkZWFjdGl2YXRlKEIpXG4gICAqICAgLT4gYWN0aXZhdGUoQylcbiAgICpcbiAgICogRWFjaCBvZiB0aGVzZSBzdGVwcyBjYW4gYmUgYXN5bmNocm9ub3VzLCBhbmQgYW55XG4gICAqIHN0ZXAgY2FuIHBvdGVudGlhbGx5IGFib3J0IHRoZSB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICBSb3V0ZVRyYW5zaXRpb24ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoY2IpIHtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXM7XG4gICAgdmFyIGRhcSA9IHRoaXMuZGVhY3RpdmF0ZVF1ZXVlO1xuICAgIHZhciBhcSA9IHRoaXMuYWN0aXZhdGVRdWV1ZTtcbiAgICB2YXIgcmRhcSA9IGRhcS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICB2YXIgcmV1c2VRdWV1ZSA9IHVuZGVmaW5lZDtcblxuICAgIC8vIDEuIFJldXNhYmlsaXR5IHBoYXNlXG4gICAgdmFyIGkgPSB1bmRlZmluZWQ7XG4gICAgZm9yIChpID0gMDsgaSA8IHJkYXEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghY2FuUmV1c2UocmRhcVtpXSwgYXFbaV0sIHRyYW5zaXRpb24pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA+IDApIHtcbiAgICAgIHJldXNlUXVldWUgPSByZGFxLnNsaWNlKDAsIGkpO1xuICAgICAgZGFxID0gcmRhcS5zbGljZShpKS5yZXZlcnNlKCk7XG4gICAgICBhcSA9IGFxLnNsaWNlKGkpO1xuICAgIH1cblxuICAgIC8vIDIuIFZhbGlkYXRpb24gcGhhc2VcbiAgICB0cmFuc2l0aW9uLnJ1blF1ZXVlKGRhcSwgY2FuRGVhY3RpdmF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgdHJhbnNpdGlvbi5ydW5RdWV1ZShhcSwgY2FuQWN0aXZhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5ydW5RdWV1ZShkYXEsIGRlYWN0aXZhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyAzLiBBY3RpdmF0aW9uIHBoYXNlXG5cbiAgICAgICAgICAvLyBVcGRhdGUgcm91dGVyIGN1cnJlbnQgcm91dGVcbiAgICAgICAgICB0cmFuc2l0aW9uLnJvdXRlci5fb25UcmFuc2l0aW9uVmFsaWRhdGVkKHRyYW5zaXRpb24pO1xuXG4gICAgICAgICAgLy8gdHJpZ2dlciByZXVzZSBmb3IgYWxsIHJldXNlZCB2aWV3c1xuICAgICAgICAgIHJldXNlUXVldWUgJiYgcmV1c2VRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgICAgICByZXVzZSh2aWV3LCB0cmFuc2l0aW9uKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHRoZSByb290IG9mIHRoZSBjaGFpbiB0aGF0IG5lZWRzIHRvIGJlIHJlcGxhY2VkXG4gICAgICAgICAgLy8gaXMgdGhlIHRvcC1tb3N0IG5vbi1yZXVzYWJsZSB2aWV3LlxuICAgICAgICAgIGlmIChkYXEubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IGRhcVtkYXEubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgZGVwdGggPSByZXVzZVF1ZXVlID8gcmV1c2VRdWV1ZS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgYWN0aXZhdGUodmlldywgdHJhbnNpdGlvbiwgZGVwdGgsIGNiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91c2x5IGFuZCBzZXF1ZW50aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiB0byBhXG4gICAqIHF1ZXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBxdWV1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICBSb3V0ZVRyYW5zaXRpb24ucHJvdG90eXBlLnJ1blF1ZXVlID0gZnVuY3Rpb24gcnVuUXVldWUocXVldWUsIGZuLCBjYikge1xuICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcztcbiAgICBzdGVwKDApO1xuICAgIGZ1bmN0aW9uIHN0ZXAoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA+PSBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgY2IoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuKHF1ZXVlW2luZGV4XSwgdHJhbnNpdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIGEgdXNlciBwcm92aWRlZCByb3V0ZSB0cmFuc2l0aW9uIGhvb2sgYW5kIGhhbmRsZVxuICAgKiB0aGUgcmVzcG9uc2UgKGUuZy4gaWYgdGhlIHVzZXIgcmV0dXJucyBhIHByb21pc2UpLlxuICAgKlxuICAgKiBJZiB0aGUgdXNlciBuZWl0aGVyIGV4cGVjdHMgYW4gYXJndW1lbnQgbm9yIHJldHVybnMgYVxuICAgKiBwcm9taXNlLCB0aGUgaG9vayBpcyBhc3N1bWVkIHRvIGJlIHN5bmNocm9ub3VzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gZXhwZWN0Qm9vbGVhblxuICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gZXhwZWN0RGF0YVxuICAgKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IGNsZWFudXBcbiAgICovXG5cbiAgUm91dGVUcmFuc2l0aW9uLnByb3RvdHlwZS5jYWxsSG9vayA9IGZ1bmN0aW9uIGNhbGxIb29rKGhvb2ssIGNvbnRleHQsIGNiKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1szXTtcblxuICAgIHZhciBfcmVmJGV4cGVjdEJvb2xlYW4gPSBfcmVmLmV4cGVjdEJvb2xlYW47XG4gICAgdmFyIGV4cGVjdEJvb2xlYW4gPSBfcmVmJGV4cGVjdEJvb2xlYW4gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRleHBlY3RCb29sZWFuO1xuICAgIHZhciBfcmVmJGV4cGVjdERhdGEgPSBfcmVmLmV4cGVjdERhdGE7XG4gICAgdmFyIGV4cGVjdERhdGEgPSBfcmVmJGV4cGVjdERhdGEgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRleHBlY3REYXRhO1xuICAgIHZhciBjbGVhbnVwID0gX3JlZi5jbGVhbnVwO1xuXG4gICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzO1xuICAgIHZhciBuZXh0Q2FsbGVkID0gZmFsc2U7XG5cbiAgICAvLyBhYm9ydCB0aGUgdHJhbnNpdGlvblxuICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgY2xlYW51cCAmJiBjbGVhbnVwKCk7XG4gICAgICB0cmFuc2l0aW9uLmFib3J0KCk7XG4gICAgfTtcblxuICAgIC8vIGhhbmRsZSBlcnJvcnNcbiAgICB2YXIgb25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG4gICAgICAvLyBjbGVhbnVwIGluZGljYXRlcyBhbiBhZnRlci1hY3RpdmF0aW9uIGhvb2ssXG4gICAgICAvLyBzbyBpbnN0ZWFkIG9mIGFib3J0aW5nIHdlIGp1c3QgbGV0IHRoZSB0cmFuc2l0aW9uXG4gICAgICAvLyBmaW5pc2guXG4gICAgICBjbGVhbnVwID8gbmV4dCgpIDogYWJvcnQoKTtcbiAgICAgIGlmIChlcnIgJiYgIXRyYW5zaXRpb24ucm91dGVyLl9zdXBwcmVzcykge1xuICAgICAgICB3YXJuKCdVbmNhdWdodCBlcnJvciBkdXJpbmcgdHJhbnNpdGlvbjogJyk7XG4gICAgICAgIHRocm93IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKGVycik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGFkdmFuY2UgdGhlIHRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RlcFxuICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gbmV4dChkYXRhKSB7XG4gICAgICBpZiAobmV4dENhbGxlZCkge1xuICAgICAgICB3YXJuKCd0cmFuc2l0aW9uLm5leHQoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZS4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbmV4dENhbGxlZCA9IHRydWU7XG4gICAgICBpZiAodHJhbnNpdGlvbi5hYm9ydGVkKSB7XG4gICAgICAgIGNsZWFudXAgJiYgY2xlYW51cCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYiAmJiBjYihkYXRhLCBvbkVycm9yKTtcbiAgICB9O1xuXG4gICAgLy8gZXhwb3NlIGEgY2xvbmUgb2YgdGhlIHRyYW5zaXRpb24gb2JqZWN0LCBzbyB0aGF0IGVhY2hcbiAgICAvLyBob29rIGdldHMgYSBjbGVhbiBjb3B5IGFuZCBwcmV2ZW50IHRoZSB1c2VyIGZyb21cbiAgICAvLyBtZXNzaW5nIHdpdGggdGhlIGludGVybmFscy5cbiAgICB2YXIgZXhwb3NlZCA9IHtcbiAgICAgIHRvOiB0cmFuc2l0aW9uLnRvLFxuICAgICAgZnJvbTogdHJhbnNpdGlvbi5mcm9tLFxuICAgICAgYWJvcnQ6IGFib3J0LFxuICAgICAgbmV4dDogbmV4dCxcbiAgICAgIHJlZGlyZWN0OiBmdW5jdGlvbiByZWRpcmVjdCgpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5yZWRpcmVjdC5hcHBseSh0cmFuc2l0aW9uLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBhY3R1YWxseSBjYWxsIHRoZSBob29rXG4gICAgdmFyIHJlcyA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgcmVzID0gaG9vay5jYWxsKGNvbnRleHQsIGV4cG9zZWQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIG9uRXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgYm9vbGVhbi9wcm9taXNlIHJldHVybiB2YWx1ZXNcbiAgICB2YXIgcmVzSXNQcm9taXNlID0gaXNQcm9taXNlKHJlcyk7XG4gICAgaWYgKGV4cGVjdEJvb2xlYW4pIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmVzID8gbmV4dCgpIDogYWJvcnQoKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzSXNQcm9taXNlKSB7XG4gICAgICAgIHJlcy50aGVuKGZ1bmN0aW9uIChvaykge1xuICAgICAgICAgIG9rID8gbmV4dCgpIDogYWJvcnQoKTtcbiAgICAgICAgfSwgb25FcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKCFob29rLmxlbmd0aCkge1xuICAgICAgICBuZXh0KHJlcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZXNJc1Byb21pc2UpIHtcbiAgICAgIHJlcy50aGVuKG5leHQsIG9uRXJyb3IpO1xuICAgIH0gZWxzZSBpZiAoZXhwZWN0RGF0YSAmJiBpc1BsYWluT2piZWN0KHJlcykgfHwgIWhvb2subGVuZ3RoKSB7XG4gICAgICBuZXh0KHJlcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIGEgc2luZ2xlIGhvb2sgb3IgYW4gYXJyYXkgb2YgYXN5bmMgaG9va3MgaW4gc2VyaWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBob29rc1xuICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cblxuICBSb3V0ZVRyYW5zaXRpb24ucHJvdG90eXBlLmNhbGxIb29rcyA9IGZ1bmN0aW9uIGNhbGxIb29rcyhob29rcywgY29udGV4dCwgY2IsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaG9va3MpKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIHJlcy5fbmVlZE1lcmdlID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9uRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLnJ1blF1ZXVlKGhvb2tzLCBmdW5jdGlvbiAoaG9vaywgXywgbmV4dCkge1xuICAgICAgICAgIGlmICghX3RoaXMuYWJvcnRlZCkge1xuICAgICAgICAgICAgX3RoaXMuY2FsbEhvb2soaG9vaywgY29udGV4dCwgZnVuY3Rpb24gKHIsIG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKHIpIHJlcy5wdXNoKHIpO1xuICAgICAgICAgICAgICBvbkVycm9yID0gb25FcnJvcjtcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2IocmVzLCBvbkVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhbGxIb29rKGhvb2tzLCBjb250ZXh0LCBjYiwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBSb3V0ZVRyYW5zaXRpb247XG59KSgpO1xuXG5mdW5jdGlvbiBpc1BsYWluT2piZWN0KHZhbCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG52YXIgaW50ZXJuYWxLZXlzUkUgPSAvXihjb21wb25lbnR8c3ViUm91dGVzKSQvO1xuXG4vKipcbiAqIFJvdXRlIENvbnRleHQgT2JqZWN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7Um91dGVyfSByb3V0ZXJcbiAqL1xuXG52YXIgUm91dGUgPSBmdW5jdGlvbiBSb3V0ZShwYXRoLCByb3V0ZXIpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGUpO1xuXG4gIHZhciBtYXRjaGVkID0gcm91dGVyLl9yZWNvZ25pemVyLnJlY29nbml6ZShwYXRoKTtcbiAgaWYgKG1hdGNoZWQpIHtcbiAgICAvLyBjb3B5IGFsbCBjdXN0b20gZmllbGRzIGZyb20gcm91dGUgY29uZmlnc1xuICAgIFtdLmZvckVhY2guY2FsbChtYXRjaGVkLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBtYXRjaC5oYW5kbGVyKSB7XG4gICAgICAgIGlmICghaW50ZXJuYWxLZXlzUkUudGVzdChrZXkpKSB7XG4gICAgICAgICAgX3RoaXNba2V5XSA9IG1hdGNoLmhhbmRsZXJba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHNldCBxdWVyeSBhbmQgcGFyYW1zXG4gICAgdGhpcy5xdWVyeSA9IG1hdGNoZWQucXVlcnlQYXJhbXM7XG4gICAgdGhpcy5wYXJhbXMgPSBbXS5yZWR1Y2UuY2FsbChtYXRjaGVkLCBmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgICBpZiAoY3VyLnBhcmFtcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY3VyLnBhcmFtcykge1xuICAgICAgICAgIHByZXZba2V5XSA9IGN1ci5wYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwge30pO1xuICB9XG4gIC8vIGV4cG9zZSBwYXRoIGFuZCByb3V0ZXJcbiAgdGhpcy5wYXRoID0gcGF0aDtcbiAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gIC8vIGZvciBpbnRlcm5hbCB1c2VcbiAgdGhpcy5tYXRjaGVkID0gbWF0Y2hlZCB8fCByb3V0ZXIuX25vdEZvdW5kSGFuZGxlcjtcbiAgLy8gSW1wb3J0YW50OiBmcmVlemUgc2VsZiB0byBwcmV2ZW50IG9ic2VydmF0aW9uXG4gIE9iamVjdC5mcmVlemUodGhpcyk7XG59O1xuXG5mdW5jdGlvbiBhcHBseU92ZXJyaWRlIChWdWUpIHtcblxuICB2YXIgXyA9IFZ1ZS51dGlsO1xuXG4gIC8vIG92ZXJyaWRlIFZ1ZSdzIGluaXQgYW5kIGRlc3Ryb3kgcHJvY2VzcyB0byBrZWVwIHRyYWNrIG9mIHJvdXRlciBpbnN0YW5jZXNcbiAgdmFyIGluaXQgPSBWdWUucHJvdG90eXBlLl9pbml0O1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgcm9vdCA9IG9wdGlvbnMuX3BhcmVudCB8fCBvcHRpb25zLnBhcmVudCB8fCB0aGlzO1xuICAgIHZhciByb3V0ZSA9IHJvb3QuJHJvdXRlO1xuICAgIGlmIChyb3V0ZSkge1xuICAgICAgcm91dGUucm91dGVyLl9jaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgaWYgKCF0aGlzLiRyb3V0ZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMuX2RlZmluZU1ldGEpIHtcbiAgICAgICAgICAvLyAwLjEyXG4gICAgICAgICAgdGhpcy5fZGVmaW5lTWV0YSgnJHJvdXRlJywgcm91dGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIDEuMFxuICAgICAgICAgIF8uZGVmaW5lUmVhY3RpdmUodGhpcywgJyRyb3V0ZScsIHJvdXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbml0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIGRlc3Ryb3kgPSBWdWUucHJvdG90eXBlLl9kZXN0cm95O1xuICBWdWUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgdmFyIHJvdXRlID0gdGhpcy4kcm9vdC4kcm91dGU7XG4gICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgcm91dGUucm91dGVyLl9jaGlsZHJlbi4kcmVtb3ZlKHRoaXMpO1xuICAgICAgfVxuICAgICAgZGVzdHJveS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcblxuICAvLyAxLjAgb25seTogZW5hYmxlIHJvdXRlIG1peGluc1xuICB2YXIgc3RyYXRzID0gVnVlLmNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG4gIHZhciBob29rc1RvTWVyZ2VSRSA9IC9eKGRhdGF8YWN0aXZhdGV8ZGVhY3RpdmF0ZSkkLztcblxuICBpZiAoc3RyYXRzKSB7XG4gICAgc3RyYXRzLnJvdXRlID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICAgIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWw7XG4gICAgICBpZiAoIXBhcmVudFZhbCkgcmV0dXJuIGNoaWxkVmFsO1xuICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgXy5leHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgICAgIHZhciBhID0gcmV0W2tleV07XG4gICAgICAgIHZhciBiID0gY2hpbGRWYWxba2V5XTtcbiAgICAgICAgLy8gZm9yIGRhdGEsIGFjdGl2YXRlIGFuZCBkZWFjdGl2YXRlLCB3ZSBuZWVkIHRvIG1lcmdlIHRoZW0gaW50b1xuICAgICAgICAvLyBhcnJheXMgc2ltaWxhciB0byBsaWZlY3ljbGUgaG9va3MuXG4gICAgICAgIGlmIChhICYmIGhvb2tzVG9NZXJnZVJFLnRlc3Qoa2V5KSkge1xuICAgICAgICAgIHJldFtrZXldID0gKF8uaXNBcnJheShhKSA/IGEgOiBbYV0pLmNvbmNhdChiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRba2V5XSA9IGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBWaWV3IChWdWUpIHtcblxuICB2YXIgXyA9IFZ1ZS51dGlsO1xuICB2YXIgY29tcG9uZW50RGVmID1cbiAgLy8gMC4xMlxuICBWdWUuZGlyZWN0aXZlKCdfY29tcG9uZW50JykgfHxcbiAgLy8gMS4wXG4gIFZ1ZS5pbnRlcm5hbERpcmVjdGl2ZXMuY29tcG9uZW50O1xuICAvLyA8cm91dGVyLXZpZXc+IGV4dGVuZHMgdGhlIGludGVybmFsIGNvbXBvbmVudCBkaXJlY3RpdmVcbiAgdmFyIHZpZXdEZWYgPSBfLmV4dGVuZCh7fSwgY29tcG9uZW50RGVmKTtcblxuICAvLyB3aXRoIHNvbWUgb3ZlcnJpZGVzXG4gIF8uZXh0ZW5kKHZpZXdEZWYsIHtcblxuICAgIF9pc1JvdXRlclZpZXc6IHRydWUsXG5cbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgdmFyIHJvdXRlID0gdGhpcy52bS4kcm91dGU7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghcm91dGUpIHtcbiAgICAgICAgd2FybignPHJvdXRlci12aWV3PiBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhICcgKyAncm91dGVyLWVuYWJsZWQgYXBwLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBmb3JjZSBkeW5hbWljIGRpcmVjdGl2ZSBzbyB2LWNvbXBvbmVudCBkb2Vzbid0XG4gICAgICAvLyBhdHRlbXB0IHRvIGJ1aWxkIHJpZ2h0IG5vd1xuICAgICAgdGhpcy5faXNEeW5hbWljTGl0ZXJhbCA9IHRydWU7XG4gICAgICAvLyBmaW5hbGx5LCBpbml0IGJ5IGRlbGVnYXRpbmcgdG8gdi1jb21wb25lbnRcbiAgICAgIGNvbXBvbmVudERlZi5iaW5kLmNhbGwodGhpcyk7XG5cbiAgICAgIC8vIGFsbCB3ZSBuZWVkIHRvIGRvIGhlcmUgaXMgcmVnaXN0ZXJpbmcgdGhpcyB2aWV3XG4gICAgICAvLyBpbiB0aGUgcm91dGVyLiBhY3R1YWwgY29tcG9uZW50IHN3aXRjaGluZyB3aWxsIGJlXG4gICAgICAvLyBtYW5hZ2VkIGJ5IHRoZSBwaXBlbGluZS5cbiAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnJvdXRlciA9IHJvdXRlLnJvdXRlcjtcbiAgICAgIHJvdXRlci5fdmlld3MudW5zaGlmdCh0aGlzKTtcblxuICAgICAgLy8gbm90ZSB0aGUgdmlld3MgYXJlIGluIHJldmVyc2Ugb3JkZXIuXG4gICAgICB2YXIgcGFyZW50VmlldyA9IHJvdXRlci5fdmlld3NbMV07XG4gICAgICBpZiAocGFyZW50Vmlldykge1xuICAgICAgICAvLyByZWdpc3RlciBzZWxmIGFzIGEgY2hpbGQgb2YgdGhlIHBhcmVudCB2aWV3LFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGFjdGl2YXRpbmcgbm93LiBUaGlzIGlzIHNvIHRoYXQgdGhlXG4gICAgICAgIC8vIGNoaWxkJ3MgYWN0aXZhdGUgaG9vayBpcyBjYWxsZWQgYWZ0ZXIgdGhlXG4gICAgICAgIC8vIHBhcmVudCdzIGhhcyByZXNvbHZlZC5cbiAgICAgICAgcGFyZW50Vmlldy5jaGlsZFZpZXcgPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgbGF0ZS1yZW5kZXJlZCB2aWV3XG4gICAgICAvLyB0d28gcG9zc2liaWxpdGllczpcbiAgICAgIC8vIDEuIHJvb3QgdmlldyByZW5kZXJlZCBhZnRlciB0cmFuc2l0aW9uIGhhcyBiZWVuXG4gICAgICAvLyAgICB2YWxpZGF0ZWQ7XG4gICAgICAvLyAyLiBjaGlsZCB2aWV3IHJlbmRlcmVkIGFmdGVyIHBhcmVudCB2aWV3IGhhcyBiZWVuXG4gICAgICAvLyAgICBhY3RpdmF0ZWQuXG4gICAgICB2YXIgdHJhbnNpdGlvbiA9IHJvdXRlLnJvdXRlci5fY3VycmVudFRyYW5zaXRpb247XG4gICAgICBpZiAoIXBhcmVudFZpZXcgJiYgdHJhbnNpdGlvbi5kb25lIHx8IHBhcmVudFZpZXcgJiYgcGFyZW50Vmlldy5hY3RpdmF0ZWQpIHtcbiAgICAgICAgdmFyIGRlcHRoID0gcGFyZW50VmlldyA/IHBhcmVudFZpZXcuZGVwdGggKyAxIDogMDtcbiAgICAgICAgYWN0aXZhdGUodGhpcywgdHJhbnNpdGlvbiwgZGVwdGgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIHRoaXMucm91dGVyLl92aWV3cy4kcmVtb3ZlKHRoaXMpO1xuICAgICAgY29tcG9uZW50RGVmLnVuYmluZC5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgVnVlLmVsZW1lbnREaXJlY3RpdmUoJ3JvdXRlci12aWV3Jywgdmlld0RlZik7XG59XG5cbnZhciB0cmFpbGluZ1NsYXNoUkUgPSAvXFwvJC87XG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG52YXIgcXVlcnlTdHJpbmdSRSA9IC9cXD8uKiQvO1xuXG4vLyBpbnN0YWxsIHYtbGluaywgd2hpY2ggcHJvdmlkZXMgbmF2aWdhdGlvbiBzdXBwb3J0IGZvclxuLy8gSFRNTDUgaGlzdG9yeSBtb2RlXG5mdW5jdGlvbiBMaW5rIChWdWUpIHtcblxuICB2YXIgXyA9IFZ1ZS51dGlsO1xuXG4gIFZ1ZS5kaXJlY3RpdmUoJ2xpbmsnLCB7XG5cbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHZtID0gdGhpcy52bTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCF2bS4kcm91dGUpIHtcbiAgICAgICAgd2Fybigndi1saW5rIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGEgJyArICdyb3V0ZXItZW5hYmxlZCBhcHAuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIG5vIG5lZWQgdG8gaGFuZGxlIGNsaWNrIGlmIGxpbmsgZXhwZWN0cyB0byBiZSBvcGVuZWRcbiAgICAgIC8vIGluIGEgbmV3IHdpbmRvdy90YWIuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLmVsLnRhZ05hbWUgPT09ICdBJyAmJiB0aGlzLmVsLmdldEF0dHJpYnV0ZSgndGFyZ2V0JykgPT09ICdfYmxhbmsnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGhhbmRsZSBjbGlja1xuICAgICAgdmFyIHJvdXRlciA9IHZtLiRyb3V0ZS5yb3V0ZXI7XG4gICAgICB0aGlzLmhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBkb24ndCByZWRpcmVjdCB3aXRoIGNvbnRyb2wga2V5c1xuICAgICAgICBpZiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSByZXR1cm47XG4gICAgICAgIC8vIGRvbid0IHJlZGlyZWN0IHdoZW4gcHJldmVudERlZmF1bHQgY2FsbGVkXG4gICAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgICAgLy8gZG9uJ3QgcmVkaXJlY3Qgb24gcmlnaHQgY2xpY2tcbiAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHRhcmdldCA9IF90aGlzLnRhcmdldDtcbiAgICAgICAgdmFyIGdvID0gZnVuY3Rpb24gZ28odGFyZ2V0KSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcm91dGVyLmdvKHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChfdGhpcy5lbC50YWdOYW1lID09PSAnQScgfHwgZS50YXJnZXQgPT09IF90aGlzLmVsKSB7XG4gICAgICAgICAgLy8gdi1saW5rIG9uIDxhIHYtbGluaz1cIidwYXRoJ1wiPlxuICAgICAgICAgIGdvKHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1saW5rIGRlbGVnYXRlIG9uIDxkaXYgdi1saW5rPlxuICAgICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICAgIHdoaWxlIChlbCAmJiBlbC50YWdOYW1lICE9PSAnQScgJiYgZWwgIT09IF90aGlzLmVsKSB7XG4gICAgICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZWwpIHJldHVybjtcbiAgICAgICAgICBpZiAoZWwudGFnTmFtZSAhPT0gJ0EnIHx8ICFlbC5ocmVmKSB7XG4gICAgICAgICAgICAvLyBhbGxvdyBub3QgYW5jaG9yXG4gICAgICAgICAgICBnbyh0YXJnZXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2FtZU9yaWdpbihlbCkpIHtcbiAgICAgICAgICAgIGdvKHtcbiAgICAgICAgICAgICAgcGF0aDogZWwucGF0aG5hbWUsXG4gICAgICAgICAgICAgIHJlcGxhY2U6IHRhcmdldCAmJiB0YXJnZXQucmVwbGFjZSxcbiAgICAgICAgICAgICAgYXBwZW5kOiB0YXJnZXQgJiYgdGFyZ2V0LmFwcGVuZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlcik7XG4gICAgICAvLyBtYW5hZ2UgYWN0aXZlIGxpbmsgY2xhc3NcbiAgICAgIHRoaXMudW53YXRjaCA9IHZtLiR3YXRjaCgnJHJvdXRlLnBhdGgnLCBfLmJpbmQodGhpcy51cGRhdGVDbGFzc2VzLCB0aGlzKSk7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHBhdGgpIHtcbiAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnZtLiRyb3V0ZS5yb3V0ZXI7XG4gICAgICB2YXIgYXBwZW5kID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy50YXJnZXQgPSBwYXRoO1xuICAgICAgaWYgKF8uaXNPYmplY3QocGF0aCkpIHtcbiAgICAgICAgYXBwZW5kID0gcGF0aC5hcHBlbmQ7XG4gICAgICAgIHRoaXMuZXhhY3QgPSBwYXRoLmV4YWN0O1xuICAgICAgICB0aGlzLnByZXZBY3RpdmVDbGFzcyA9IHRoaXMuYWN0aXZlQ2xhc3M7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2xhc3MgPSBwYXRoLmFjdGl2ZUNsYXNzO1xuICAgICAgfVxuICAgICAgcGF0aCA9IHRoaXMucGF0aCA9IHJvdXRlci5fc3RyaW5naWZ5UGF0aChwYXRoKTtcbiAgICAgIHRoaXMuYWN0aXZlUkUgPSBwYXRoICYmICF0aGlzLmV4YWN0ID8gbmV3IFJlZ0V4cCgnXicgKyBwYXRoLnJlcGxhY2UoL1xcLyQvLCAnJykucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJykgKyAnKFxcXFwvfCQpJykgOiBudWxsO1xuICAgICAgdGhpcy51cGRhdGVDbGFzc2VzKHRoaXMudm0uJHJvdXRlLnBhdGgpO1xuICAgICAgdmFyIGlzQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICAgICAgLy8gZG8gbm90IGZvcm1hdCBub24taGFzaCByZWxhdGl2ZSBwYXRoc1xuICAgICAgdmFyIGhyZWYgPSBwYXRoICYmIChyb3V0ZXIubW9kZSA9PT0gJ2hhc2gnIHx8IGlzQWJzb2x1dGUpID8gcm91dGVyLmhpc3RvcnkuZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpIDogcGF0aDtcbiAgICAgIGlmICh0aGlzLmVsLnRhZ05hbWUgPT09ICdBJykge1xuICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgIHRoaXMuZWwuaHJlZiA9IGhyZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVDbGFzc2VzOiBmdW5jdGlvbiB1cGRhdGVDbGFzc2VzKHBhdGgpIHtcbiAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgICB2YXIgcm91dGVyID0gdGhpcy52bS4kcm91dGUucm91dGVyO1xuICAgICAgdmFyIGFjdGl2ZUNsYXNzID0gdGhpcy5hY3RpdmVDbGFzcyB8fCByb3V0ZXIuX2xpbmtBY3RpdmVDbGFzcztcbiAgICAgIC8vIGNsZWFyIG9sZCBjbGFzc1xuICAgICAgaWYgKHRoaXMucHJldkFjdGl2ZUNsYXNzICE9PSBhY3RpdmVDbGFzcykge1xuICAgICAgICBfLnJlbW92ZUNsYXNzKGVsLCB0aGlzLnByZXZBY3RpdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgcXVlcnkgc3RyaW5nIGJlZm9yZSBtYXRjaGluZ1xuICAgICAgdmFyIGRlc3QgPSB0aGlzLnBhdGgucmVwbGFjZShxdWVyeVN0cmluZ1JFLCAnJyk7XG4gICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKHF1ZXJ5U3RyaW5nUkUsICcnKTtcbiAgICAgIC8vIGFkZCBuZXcgY2xhc3NcbiAgICAgIGlmICh0aGlzLmV4YWN0KSB7XG4gICAgICAgIGlmIChkZXN0ID09PSBwYXRoIHx8XG4gICAgICAgIC8vIGFsc28gYWxsb3cgYWRkaXRpb25hbCB0cmFpbGluZyBzbGFzaFxuICAgICAgICBkZXN0LmNoYXJBdChkZXN0Lmxlbmd0aCAtIDEpICE9PSAnLycgJiYgZGVzdCA9PT0gcGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpKSB7XG4gICAgICAgICAgXy5hZGRDbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF8ucmVtb3ZlQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlUkUgJiYgdGhpcy5hY3RpdmVSRS50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgXy5hZGRDbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF8ucmVtb3ZlQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZXIpO1xuICAgICAgdGhpcy51bndhdGNoICYmIHRoaXMudW53YXRjaCgpO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gc2FtZU9yaWdpbihsaW5rKSB7XG4gICAgcmV0dXJuIGxpbmsucHJvdG9jb2wgPT09IGxvY2F0aW9uLnByb3RvY29sICYmIGxpbmsuaG9zdG5hbWUgPT09IGxvY2F0aW9uLmhvc3RuYW1lICYmIGxpbmsucG9ydCA9PT0gbG9jYXRpb24ucG9ydDtcbiAgfVxufVxuXG52YXIgaGlzdG9yeUJhY2tlbmRzID0ge1xuICBhYnN0cmFjdDogQWJzdHJhY3RIaXN0b3J5LFxuICBoYXNoOiBIYXNoSGlzdG9yeSxcbiAgaHRtbDU6IEhUTUw1SGlzdG9yeVxufTtcblxuLy8gbGF0ZSBiaW5kIGR1cmluZyBpbnN0YWxsXG52YXIgVnVlID0gdW5kZWZpbmVkO1xuXG4vKipcbiAqIFJvdXRlciBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqL1xuXG52YXIgUm91dGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUm91dGVyKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICB2YXIgX3JlZiRoYXNoYmFuZyA9IF9yZWYuaGFzaGJhbmc7XG4gICAgdmFyIGhhc2hiYW5nID0gX3JlZiRoYXNoYmFuZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYkaGFzaGJhbmc7XG4gICAgdmFyIF9yZWYkYWJzdHJhY3QgPSBfcmVmLmFic3RyYWN0O1xuICAgIHZhciBhYnN0cmFjdCA9IF9yZWYkYWJzdHJhY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRhYnN0cmFjdDtcbiAgICB2YXIgX3JlZiRoaXN0b3J5ID0gX3JlZi5oaXN0b3J5O1xuICAgIHZhciBoaXN0b3J5ID0gX3JlZiRoaXN0b3J5ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkaGlzdG9yeTtcbiAgICB2YXIgX3JlZiRzYXZlU2Nyb2xsUG9zaXRpb24gPSBfcmVmLnNhdmVTY3JvbGxQb3NpdGlvbjtcbiAgICB2YXIgc2F2ZVNjcm9sbFBvc2l0aW9uID0gX3JlZiRzYXZlU2Nyb2xsUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRzYXZlU2Nyb2xsUG9zaXRpb247XG4gICAgdmFyIF9yZWYkdHJhbnNpdGlvbk9uTG9hZCA9IF9yZWYudHJhbnNpdGlvbk9uTG9hZDtcbiAgICB2YXIgdHJhbnNpdGlvbk9uTG9hZCA9IF9yZWYkdHJhbnNpdGlvbk9uTG9hZCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHRyYW5zaXRpb25PbkxvYWQ7XG4gICAgdmFyIF9yZWYkc3VwcHJlc3NUcmFuc2l0aW9uRXJyb3IgPSBfcmVmLnN1cHByZXNzVHJhbnNpdGlvbkVycm9yO1xuICAgIHZhciBzdXBwcmVzc1RyYW5zaXRpb25FcnJvciA9IF9yZWYkc3VwcHJlc3NUcmFuc2l0aW9uRXJyb3IgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRzdXBwcmVzc1RyYW5zaXRpb25FcnJvcjtcbiAgICB2YXIgX3JlZiRyb290ID0gX3JlZi5yb290O1xuICAgIHZhciByb290ID0gX3JlZiRyb290ID09PSB1bmRlZmluZWQgPyBudWxsIDogX3JlZiRyb290O1xuICAgIHZhciBfcmVmJGxpbmtBY3RpdmVDbGFzcyA9IF9yZWYubGlua0FjdGl2ZUNsYXNzO1xuICAgIHZhciBsaW5rQWN0aXZlQ2xhc3MgPSBfcmVmJGxpbmtBY3RpdmVDbGFzcyA9PT0gdW5kZWZpbmVkID8gJ3YtbGluay1hY3RpdmUnIDogX3JlZiRsaW5rQWN0aXZlQ2xhc3M7XG4gICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlcik7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIVJvdXRlci5pbnN0YWxsZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGluc3RhbGwgdGhlIFJvdXRlciB3aXRoIFZ1ZS51c2UoKSBiZWZvcmUgJyArICdjcmVhdGluZyBhbiBpbnN0YW5jZS4nKTtcbiAgICB9XG5cbiAgICAvLyBWdWUgaW5zdGFuY2VzXG4gICAgdGhpcy5hcHAgPSBudWxsO1xuICAgIHRoaXMuX3ZpZXdzID0gW107XG4gICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcblxuICAgIC8vIHJvdXRlIHJlY29nbml6ZXJcbiAgICB0aGlzLl9yZWNvZ25pemVyID0gbmV3IFJvdXRlUmVjb2duaXplcigpO1xuICAgIHRoaXMuX2d1YXJkUmVjb2duaXplciA9IG5ldyBSb3V0ZVJlY29nbml6ZXIoKTtcblxuICAgIC8vIHN0YXRlXG4gICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3N0YXJ0Q2IgPSBudWxsO1xuICAgIHRoaXMuX2N1cnJlbnRSb3V0ZSA9IHt9O1xuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uID0gbnVsbDtcbiAgICB0aGlzLl9wcmV2aW91c1RyYW5zaXRpb24gPSBudWxsO1xuICAgIHRoaXMuX25vdEZvdW5kSGFuZGxlciA9IG51bGw7XG4gICAgdGhpcy5fbm90Rm91bmRSZWRpcmVjdCA9IG51bGw7XG4gICAgdGhpcy5fYmVmb3JlRWFjaEhvb2tzID0gW107XG4gICAgdGhpcy5fYWZ0ZXJFYWNoSG9va3MgPSBbXTtcblxuICAgIC8vIGZlYXR1cmUgZGV0ZWN0aW9uXG4gICAgdGhpcy5faGFzUHVzaFN0YXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmhpc3RvcnkgJiYgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlO1xuXG4gICAgLy8gdHJpZ2dlciB0cmFuc2l0aW9uIG9uIGluaXRpYWwgcmVuZGVyP1xuICAgIHRoaXMuX3JlbmRlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5fdHJhbnNpdGlvbk9uTG9hZCA9IHRyYW5zaXRpb25PbkxvYWQ7XG5cbiAgICAvLyBoaXN0b3J5IG1vZGVcbiAgICB0aGlzLl9hYnN0cmFjdCA9IGFic3RyYWN0O1xuICAgIHRoaXMuX2hhc2hiYW5nID0gaGFzaGJhbmc7XG4gICAgdGhpcy5faGlzdG9yeSA9IHRoaXMuX2hhc1B1c2hTdGF0ZSAmJiBoaXN0b3J5O1xuXG4gICAgLy8gb3RoZXIgb3B0aW9uc1xuICAgIHRoaXMuX3NhdmVTY3JvbGxQb3NpdGlvbiA9IHNhdmVTY3JvbGxQb3NpdGlvbjtcbiAgICB0aGlzLl9saW5rQWN0aXZlQ2xhc3MgPSBsaW5rQWN0aXZlQ2xhc3M7XG4gICAgdGhpcy5fc3VwcHJlc3MgPSBzdXBwcmVzc1RyYW5zaXRpb25FcnJvcjtcblxuICAgIC8vIGNyZWF0ZSBoaXN0b3J5IG9iamVjdFxuICAgIHZhciBpbkJyb3dzZXIgPSBWdWUudXRpbC5pbkJyb3dzZXI7XG4gICAgdGhpcy5tb2RlID0gIWluQnJvd3NlciB8fCB0aGlzLl9hYnN0cmFjdCA/ICdhYnN0cmFjdCcgOiB0aGlzLl9oaXN0b3J5ID8gJ2h0bWw1JyA6ICdoYXNoJztcblxuICAgIHZhciBIaXN0b3J5ID0gaGlzdG9yeUJhY2tlbmRzW3RoaXMubW9kZV07XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KHtcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICBoYXNoYmFuZzogdGhpcy5faGFzaGJhbmcsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UocGF0aCwgc3RhdGUsIGFuY2hvcikge1xuICAgICAgICBzZWxmLl9tYXRjaChwYXRoLCBzdGF0ZSwgYW5jaG9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvdyBkaXJlY3RseSBwYXNzaW5nIGNvbXBvbmVudHMgdG8gYSByb3V0ZVxuICAgKiBkZWZpbml0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlclxuICAgKi9cblxuICAvLyBBUEkgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICogUmVnaXN0ZXIgYSBtYXAgb2YgdG9wLWxldmVsIHBhdGhzLlxuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICAqL1xuXG4gIFJvdXRlci5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwKF9tYXApIHtcbiAgICBmb3IgKHZhciByb3V0ZSBpbiBfbWFwKSB7XG4gICAgICB0aGlzLm9uKHJvdXRlLCBfbWFwW3JvdXRlXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHNpbmdsZSByb290LWxldmVsIHBhdGhcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJvb3RQYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGNvbXBvbmVudFxuICAgKiAgICAgICAgICAgICAgICAgLSB7T2JqZWN0fSBbc3ViUm91dGVzXVxuICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gW2ZvcmNlUmVmcmVzaF1cbiAgICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBbYmVmb3JlXVxuICAgKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IFthZnRlcl1cbiAgICovXG5cbiAgUm91dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKHJvb3RQYXRoLCBoYW5kbGVyKSB7XG4gICAgaWYgKHJvb3RQYXRoID09PSAnKicpIHtcbiAgICAgIHRoaXMuX25vdEZvdW5kKGhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hZGRSb3V0ZShyb290UGF0aCwgaGFuZGxlciwgW10pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHJlZGlyZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICAgKi9cblxuICBSb3V0ZXIucHJvdG90eXBlLnJlZGlyZWN0ID0gZnVuY3Rpb24gcmVkaXJlY3QobWFwKSB7XG4gICAgZm9yICh2YXIgcGF0aCBpbiBtYXApIHtcbiAgICAgIHRoaXMuX2FkZFJlZGlyZWN0KHBhdGgsIG1hcFtwYXRoXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYWxpYXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICAgKi9cblxuICBSb3V0ZXIucHJvdG90eXBlLmFsaWFzID0gZnVuY3Rpb24gYWxpYXMobWFwKSB7XG4gICAgZm9yICh2YXIgcGF0aCBpbiBtYXApIHtcbiAgICAgIHRoaXMuX2FkZEFsaWFzKHBhdGgsIG1hcFtwYXRoXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgZ2xvYmFsIGJlZm9yZSBob29rLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKi9cblxuICBSb3V0ZXIucHJvdG90eXBlLmJlZm9yZUVhY2ggPSBmdW5jdGlvbiBiZWZvcmVFYWNoKGZuKSB7XG4gICAgdGhpcy5fYmVmb3JlRWFjaEhvb2tzLnB1c2goZm4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgZ2xvYmFsIGFmdGVyIGhvb2suXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFJvdXRlci5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24gYWZ0ZXJFYWNoKGZuKSB7XG4gICAgdGhpcy5fYWZ0ZXJFYWNoSG9va3MucHVzaChmbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlIHRvIGEgZ2l2ZW4gcGF0aC5cbiAgICogVGhlIHBhdGggY2FuIGJlIGFuIG9iamVjdCBkZXNjcmliaW5nIGEgbmFtZWQgcGF0aCBpblxuICAgKiB0aGUgZm9ybWF0IG9mIHsgbmFtZTogJy4uLicsIHBhcmFtczoge30sIHF1ZXJ5OiB7fX1cbiAgICogVGhlIHBhdGggaXMgYXNzdW1lZCB0byBiZSBhbHJlYWR5IGRlY29kZWQsIGFuZCB3aWxsXG4gICAqIGJlIHJlc29sdmVkIGFnYWluc3Qgcm9vdCAoaWYgcHJvdmlkZWQpXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcGF0aFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZXBsYWNlXVxuICAgKi9cblxuICBSb3V0ZXIucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28ocGF0aCkge1xuICAgIHZhciByZXBsYWNlID0gZmFsc2U7XG4gICAgdmFyIGFwcGVuZCA9IGZhbHNlO1xuICAgIGlmIChWdWUudXRpbC5pc09iamVjdChwYXRoKSkge1xuICAgICAgcmVwbGFjZSA9IHBhdGgucmVwbGFjZTtcbiAgICAgIGFwcGVuZCA9IHBhdGguYXBwZW5kO1xuICAgIH1cbiAgICBwYXRoID0gdGhpcy5fc3RyaW5naWZ5UGF0aChwYXRoKTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgdGhpcy5oaXN0b3J5LmdvKHBhdGgsIHJlcGxhY2UsIGFwcGVuZCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTaG9ydCBoYW5kIGZvciByZXBsYWNpbmcgY3VycmVudCBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqL1xuXG4gIFJvdXRlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCkge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhdGggPSB7IHBhdGg6IHBhdGggfTtcbiAgICB9XG4gICAgcGF0aC5yZXBsYWNlID0gdHJ1ZTtcbiAgICB0aGlzLmdvKHBhdGgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydCB0aGUgcm91dGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZUNvbnN0cnVjdG9yfSBBcHBcbiAgICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gY29udGFpbmVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgUm91dGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KEFwcCwgY29udGFpbmVyLCBjYikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLl9zdGFydGVkKSB7XG4gICAgICB3YXJuKCdhbHJlYWR5IHN0YXJ0ZWQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3N0YXJ0Q2IgPSBjYjtcbiAgICBpZiAoIXRoaXMuYXBwKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghQXBwIHx8ICFjb250YWluZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHN0YXJ0IHZ1ZS1yb3V0ZXIgd2l0aCBhIGNvbXBvbmVudCBhbmQgYSAnICsgJ3Jvb3QgY29udGFpbmVyLicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYXBwQ29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgdmFyIEN0b3IgPSB0aGlzLl9hcHBDb25zdHJ1Y3RvciA9IHR5cGVvZiBBcHAgPT09ICdmdW5jdGlvbicgPyBBcHAgOiBWdWUuZXh0ZW5kKEFwcCk7XG4gICAgICAvLyBnaXZlIGl0IGEgbmFtZSBmb3IgYmV0dGVyIGRlYnVnZ2luZ1xuICAgICAgQ3Rvci5vcHRpb25zLm5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCAnUm91dGVyQXBwJztcbiAgICB9XG4gICAgdGhpcy5oaXN0b3J5LnN0YXJ0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgbGlzdGVuaW5nIHRvIHJvdXRlIGNoYW5nZXMuXG4gICAqL1xuXG4gIFJvdXRlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgdGhpcy5oaXN0b3J5LnN0b3AoKTtcbiAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgbWV0aG9kcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAqIEFkZCBhIHJvdXRlIGNvbnRhaW5pbmcgYSBsaXN0IG9mIHNlZ21lbnRzIHRvIHRoZSBpbnRlcm5hbFxuICAqIHJvdXRlIHJlY29nbml6ZXIuIFdpbGwgYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5IHRvIGFkZCBhbGxcbiAgKiBwb3NzaWJsZSBzdWItcm91dGVzLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlclxuICAqIEBwYXJhbSB7QXJyYXl9IHNlZ21lbnRzXG4gICovXG5cbiAgUm91dGVyLnByb3RvdHlwZS5fYWRkUm91dGUgPSBmdW5jdGlvbiBfYWRkUm91dGUocGF0aCwgaGFuZGxlciwgc2VnbWVudHMpIHtcbiAgICBndWFyZENvbXBvbmVudChwYXRoLCBoYW5kbGVyKTtcbiAgICBoYW5kbGVyLnBhdGggPSBwYXRoO1xuICAgIGhhbmRsZXIuZnVsbFBhdGggPSAoc2VnbWVudHMucmVkdWNlKGZ1bmN0aW9uIChwYXRoLCBzZWdtZW50KSB7XG4gICAgICByZXR1cm4gcGF0aCArIHNlZ21lbnQucGF0aDtcbiAgICB9LCAnJykgKyBwYXRoKS5yZXBsYWNlKCcvLycsICcvJyk7XG4gICAgc2VnbWVudHMucHVzaCh7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgIH0pO1xuICAgIHRoaXMuX3JlY29nbml6ZXIuYWRkKHNlZ21lbnRzLCB7XG4gICAgICBhczogaGFuZGxlci5uYW1lXG4gICAgfSk7XG4gICAgLy8gYWRkIHN1YiByb3V0ZXNcbiAgICBpZiAoaGFuZGxlci5zdWJSb3V0ZXMpIHtcbiAgICAgIGZvciAodmFyIHN1YlBhdGggaW4gaGFuZGxlci5zdWJSb3V0ZXMpIHtcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgd2FsayBhbGwgc3ViIHJvdXRlc1xuICAgICAgICB0aGlzLl9hZGRSb3V0ZShzdWJQYXRoLCBoYW5kbGVyLnN1YlJvdXRlc1tzdWJQYXRoXSxcbiAgICAgICAgLy8gcGFzcyBhIGNvcHkgaW4gcmVjdXJzaW9uIHRvIGF2b2lkIG11dGF0aW5nXG4gICAgICAgIC8vIGFjcm9zcyBicmFuY2hlc1xuICAgICAgICBzZWdtZW50cy5zbGljZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbm90Rm91bmQgcm91dGUgaGFuZGxlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJcbiAgICovXG5cbiAgUm91dGVyLnByb3RvdHlwZS5fbm90Rm91bmQgPSBmdW5jdGlvbiBfbm90Rm91bmQoaGFuZGxlcikge1xuICAgIGd1YXJkQ29tcG9uZW50KCcqJywgaGFuZGxlcik7XG4gICAgdGhpcy5fbm90Rm91bmRIYW5kbGVyID0gW3sgaGFuZGxlcjogaGFuZGxlciB9XTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgcmVkaXJlY3QgcmVjb3JkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVkaXJlY3RQYXRoXG4gICAqL1xuXG4gIFJvdXRlci5wcm90b3R5cGUuX2FkZFJlZGlyZWN0ID0gZnVuY3Rpb24gX2FkZFJlZGlyZWN0KHBhdGgsIHJlZGlyZWN0UGF0aCkge1xuICAgIGlmIChwYXRoID09PSAnKicpIHtcbiAgICAgIHRoaXMuX25vdEZvdW5kUmVkaXJlY3QgPSByZWRpcmVjdFBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FkZEd1YXJkKHBhdGgsIHJlZGlyZWN0UGF0aCwgdGhpcy5yZXBsYWNlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBhbGlhcyByZWNvcmQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhbGlhc1BhdGhcbiAgICovXG5cbiAgUm91dGVyLnByb3RvdHlwZS5fYWRkQWxpYXMgPSBmdW5jdGlvbiBfYWRkQWxpYXMocGF0aCwgYWxpYXNQYXRoKSB7XG4gICAgdGhpcy5fYWRkR3VhcmQocGF0aCwgYWxpYXNQYXRoLCB0aGlzLl9tYXRjaCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHBhdGggZ3VhcmQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtYXBwZWRQYXRoXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG5cbiAgUm91dGVyLnByb3RvdHlwZS5fYWRkR3VhcmQgPSBmdW5jdGlvbiBfYWRkR3VhcmQocGF0aCwgbWFwcGVkUGF0aCwgX2hhbmRsZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fZ3VhcmRSZWNvZ25pemVyLmFkZChbe1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIobWF0Y2gsIHF1ZXJ5KSB7XG4gICAgICAgIHZhciByZWFsUGF0aCA9IG1hcFBhcmFtcyhtYXBwZWRQYXRoLCBtYXRjaC5wYXJhbXMsIHF1ZXJ5KTtcbiAgICAgICAgX2hhbmRsZXIuY2FsbChfdGhpcywgcmVhbFBhdGgpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBwYXRoIG1hdGNoZXMgYW55IHJlZGlyZWN0IHJlY29yZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IC0gaWYgdHJ1ZSwgd2lsbCBza2lwIG5vcm1hbCBtYXRjaC5cbiAgICovXG5cbiAgUm91dGVyLnByb3RvdHlwZS5fY2hlY2tHdWFyZCA9IGZ1bmN0aW9uIF9jaGVja0d1YXJkKHBhdGgpIHtcbiAgICB2YXIgbWF0Y2hlZCA9IHRoaXMuX2d1YXJkUmVjb2duaXplci5yZWNvZ25pemUocGF0aCk7XG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgIG1hdGNoZWRbMF0uaGFuZGxlcihtYXRjaGVkWzBdLCBtYXRjaGVkLnF1ZXJ5UGFyYW1zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fbm90Rm91bmRSZWRpcmVjdCkge1xuICAgICAgbWF0Y2hlZCA9IHRoaXMuX3JlY29nbml6ZXIucmVjb2duaXplKHBhdGgpO1xuICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgIHRoaXMucmVwbGFjZSh0aGlzLl9ub3RGb3VuZFJlZGlyZWN0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNYXRjaCBhIFVSTCBwYXRoIGFuZCBzZXQgdGhlIHJvdXRlIGNvbnRleHQgb24gdm0sXG4gICAqIHRyaWdnZXJpbmcgdmlldyB1cGRhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YXRlXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2FuY2hvcl1cbiAgICovXG5cbiAgUm91dGVyLnByb3RvdHlwZS5fbWF0Y2ggPSBmdW5jdGlvbiBfbWF0Y2gocGF0aCwgc3RhdGUsIGFuY2hvcikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuX2NoZWNrR3VhcmQocGF0aCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFJvdXRlID0gdGhpcy5fY3VycmVudFJvdXRlO1xuICAgIHZhciBjdXJyZW50VHJhbnNpdGlvbiA9IHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uO1xuXG4gICAgaWYgKGN1cnJlbnRUcmFuc2l0aW9uKSB7XG4gICAgICBpZiAoY3VycmVudFRyYW5zaXRpb24udG8ucGF0aCA9PT0gcGF0aCkge1xuICAgICAgICAvLyBkbyBub3RoaW5nIGlmIHdlIGhhdmUgYW4gYWN0aXZlIHRyYW5zaXRpb24gZ29pbmcgdG8gdGhlIHNhbWUgcGF0aFxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSb3V0ZS5wYXRoID09PSBwYXRoKSB7XG4gICAgICAgIC8vIFdlIGFyZSBnb2luZyB0byB0aGUgc2FtZSBwYXRoLCBidXQgd2UgYWxzbyBoYXZlIGFuIG9uZ29pbmcgYnV0XG4gICAgICAgIC8vIG5vdC15ZXQtdmFsaWRhdGVkIHRyYW5zaXRpb24uIEFib3J0IHRoYXQgdHJhbnNpdGlvbiBhbmQgcmVzZXQgdG9cbiAgICAgICAgLy8gcHJldiB0cmFuc2l0aW9uLlxuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRyYW5zaXRpb24gPSB0aGlzLl9wcmV2VHJhbnNpdGlvbjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ29pbmcgdG8gYSB0b3RhbGx5IGRpZmZlcmVudCBwYXRoLiBhYm9ydCBvbmdvaW5nIHRyYW5zaXRpb24uXG4gICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnN0cnVjdCBuZXcgcm91dGUgYW5kIHRyYW5zaXRpb24gY29udGV4dFxuICAgIHZhciByb3V0ZSA9IG5ldyBSb3V0ZShwYXRoLCB0aGlzKTtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IG5ldyBSb3V0ZVRyYW5zaXRpb24odGhpcywgcm91dGUsIGN1cnJlbnRSb3V0ZSk7XG5cbiAgICAvLyBjdXJyZW50IHRyYW5zaXRpb24gaXMgdXBkYXRlZCByaWdodCBub3cuXG4gICAgLy8gaG93ZXZlciwgY3VycmVudCByb3V0ZSB3aWxsIG9ubHkgYmUgdXBkYXRlZCBhZnRlciB0aGUgdHJhbnNpdGlvbiBoYXNcbiAgICAvLyBiZWVuIHZhbGlkYXRlZC5cbiAgICB0aGlzLl9wcmV2VHJhbnNpdGlvbiA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcblxuICAgIGlmICghdGhpcy5hcHApIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB0aGlzLmFwcCA9IG5ldyB0aGlzLl9hcHBDb25zdHJ1Y3Rvcih7XG4gICAgICAgIGVsOiB0aGlzLl9hcHBDb250YWluZXIsXG4gICAgICAgIF9tZXRhOiB7XG4gICAgICAgICAgJHJvdXRlOiByb3V0ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBnbG9iYWwgYmVmb3JlIGhvb2tcbiAgICB2YXIgYmVmb3JlSG9va3MgPSB0aGlzLl9iZWZvcmVFYWNoSG9va3M7XG4gICAgdmFyIHN0YXJ0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbigpIHtcbiAgICAgIHRyYW5zaXRpb24uc3RhcnQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuX3Bvc3RUcmFuc2l0aW9uKHJvdXRlLCBzdGF0ZSwgYW5jaG9yKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoYmVmb3JlSG9va3MubGVuZ3RoKSB7XG4gICAgICB0cmFuc2l0aW9uLnJ1blF1ZXVlKGJlZm9yZUhvb2tzLCBmdW5jdGlvbiAoaG9vaywgXywgbmV4dCkge1xuICAgICAgICBpZiAodHJhbnNpdGlvbiA9PT0gX3RoaXMyLl9jdXJyZW50VHJhbnNpdGlvbikge1xuICAgICAgICAgIHRyYW5zaXRpb24uY2FsbEhvb2soaG9vaywgbnVsbCwgbmV4dCwge1xuICAgICAgICAgICAgZXhwZWN0Qm9vbGVhbjogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCBzdGFydFRyYW5zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFRyYW5zaXRpb24oKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3JlbmRlcmVkICYmIHRoaXMuX3N0YXJ0Q2IpIHtcbiAgICAgIHRoaXMuX3N0YXJ0Q2IuY2FsbChudWxsKTtcbiAgICB9XG5cbiAgICAvLyBIQUNLOlxuICAgIC8vIHNldCByZW5kZXJlZCB0byB0cnVlIGFmdGVyIHRoZSB0cmFuc2l0aW9uIHN0YXJ0LCBzb1xuICAgIC8vIHRoYXQgY29tcG9uZW50cyB0aGF0IGFyZSBhY2l0dmF0ZWQgc3luY2hyb25vdXNseSBrbm93XG4gICAgLy8gd2hldGhlciBpdCBpcyB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgdGhpcy5fcmVuZGVyZWQgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgY3VycmVudCB0byB0aGUgbmV3IHRyYW5zaXRpb24uXG4gICAqIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSB0cmFuc2l0aW9uIG9iamVjdCB3aGVuIHRoZVxuICAgKiB2YWxpZGF0aW9uIG9mIGEgcm91dGUgaGFzIHN1Y2NlZWRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gICAqL1xuXG4gIFJvdXRlci5wcm90b3R5cGUuX29uVHJhbnNpdGlvblZhbGlkYXRlZCA9IGZ1bmN0aW9uIF9vblRyYW5zaXRpb25WYWxpZGF0ZWQodHJhbnNpdGlvbikge1xuICAgIC8vIHNldCBjdXJyZW50IHJvdXRlXG4gICAgdmFyIHJvdXRlID0gdGhpcy5fY3VycmVudFJvdXRlID0gdHJhbnNpdGlvbi50bztcbiAgICAvLyB1cGRhdGUgcm91dGUgY29udGV4dCBmb3IgYWxsIGNoaWxkcmVuXG4gICAgaWYgKHRoaXMuYXBwLiRyb3V0ZSAhPT0gcm91dGUpIHtcbiAgICAgIHRoaXMuYXBwLiRyb3V0ZSA9IHJvdXRlO1xuICAgICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQuJHJvdXRlID0gcm91dGU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gY2FsbCBnbG9iYWwgYWZ0ZXIgaG9va1xuICAgIGlmICh0aGlzLl9hZnRlckVhY2hIb29rcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2FmdGVyRWFjaEhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgcmV0dXJuIGhvb2suY2FsbChudWxsLCB7XG4gICAgICAgICAgdG86IHRyYW5zaXRpb24udG8sXG4gICAgICAgICAgZnJvbTogdHJhbnNpdGlvbi5mcm9tXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uLmRvbmUgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgc3R1ZmYgYWZ0ZXIgdGhlIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7Um91dGV9IHJvdXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhdGVdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbYW5jaG9yXVxuICAgKi9cblxuICBSb3V0ZXIucHJvdG90eXBlLl9wb3N0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIF9wb3N0VHJhbnNpdGlvbihyb3V0ZSwgc3RhdGUsIGFuY2hvcikge1xuICAgIC8vIGhhbmRsZSBzY3JvbGwgcG9zaXRpb25zXG4gICAgLy8gc2F2ZWQgc2Nyb2xsIHBvc2l0aW9ucyB0YWtlIHByaW9yaXR5XG4gICAgLy8gdGhlbiB3ZSBjaGVjayBpZiB0aGUgcGF0aCBoYXMgYW4gYW5jaG9yXG4gICAgdmFyIHBvcyA9IHN0YXRlICYmIHN0YXRlLnBvcztcbiAgICBpZiAocG9zICYmIHRoaXMuX3NhdmVTY3JvbGxQb3NpdGlvbikge1xuICAgICAgVnVlLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHBvcy54LCBwb3MueSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGFuY2hvcikge1xuICAgICAgVnVlLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYW5jaG9yLnNsaWNlKDEpKTtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgd2luZG93LnNjcm9sbFRvKHdpbmRvdy5zY3JvbGxYLCBlbC5vZmZzZXRUb3ApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBuYW1lZCByb3V0ZSBvYmplY3QgLyBzdHJpbmcgcGF0aHMgaW50b1xuICAgKiBhIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfE51bWJlcn0gcGF0aFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIFJvdXRlci5wcm90b3R5cGUuX3N0cmluZ2lmeVBhdGggPSBmdW5jdGlvbiBfc3RyaW5naWZ5UGF0aChwYXRoKSB7XG4gICAgaWYgKHBhdGggJiYgdHlwZW9mIHBhdGggPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocGF0aC5uYW1lKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBwYXRoLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgaWYgKHBhdGgucXVlcnkpIHtcbiAgICAgICAgICBwYXJhbXMucXVlcnlQYXJhbXMgPSBwYXRoLnF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWNvZ25pemVyLmdlbmVyYXRlKHBhdGgubmFtZSwgcGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAocGF0aC5wYXRoKSB7XG4gICAgICAgIHZhciBmdWxsUGF0aCA9IHBhdGgucGF0aDtcbiAgICAgICAgaWYgKHBhdGgucXVlcnkpIHtcbiAgICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLl9yZWNvZ25pemVyLmdlbmVyYXRlUXVlcnlTdHJpbmcocGF0aC5xdWVyeSk7XG4gICAgICAgICAgaWYgKGZ1bGxQYXRoLmluZGV4T2YoJz8nKSA+IC0xKSB7XG4gICAgICAgICAgICBmdWxsUGF0aCArPSAnJicgKyBxdWVyeS5zbGljZSgxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnVsbFBhdGggKz0gcXVlcnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdWxsUGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhdGggPyBwYXRoICsgJycgOiAnJztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJvdXRlcjtcbn0pKCk7XG5cbmZ1bmN0aW9uIGd1YXJkQ29tcG9uZW50KHBhdGgsIGhhbmRsZXIpIHtcbiAgdmFyIGNvbXAgPSBoYW5kbGVyLmNvbXBvbmVudDtcbiAgaWYgKFZ1ZS51dGlsLmlzUGxhaW5PYmplY3QoY29tcCkpIHtcbiAgICBjb21wID0gaGFuZGxlci5jb21wb25lbnQgPSBWdWUuZXh0ZW5kKGNvbXApO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGNvbXAgIT09ICdmdW5jdGlvbicpIHtcbiAgICBoYW5kbGVyLmNvbXBvbmVudCA9IG51bGw7XG4gICAgd2FybignaW52YWxpZCBjb21wb25lbnQgZm9yIHJvdXRlIFwiJyArIHBhdGggKyAnXCIuJyk7XG4gIH1cbn1cblxuLyogSW5zdGFsbGF0aW9uICovXG5cblJvdXRlci5pbnN0YWxsZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBJbnN0YWxsYXRpb24gaW50ZXJmYWNlLlxuICogSW5zdGFsbCB0aGUgbmVjZXNzYXJ5IGRpcmVjdGl2ZXMuXG4gKi9cblxuUm91dGVyLmluc3RhbGwgPSBmdW5jdGlvbiAoZXh0ZXJuYWxWdWUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChSb3V0ZXIuaW5zdGFsbGVkKSB7XG4gICAgd2FybignYWxyZWFkeSBpbnN0YWxsZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIFZ1ZSA9IGV4dGVybmFsVnVlO1xuICBhcHBseU92ZXJyaWRlKFZ1ZSk7XG4gIFZpZXcoVnVlKTtcbiAgTGluayhWdWUpO1xuICBleHBvcnRzJDEuVnVlID0gVnVlO1xuICBSb3V0ZXIuaW5zdGFsbGVkID0gdHJ1ZTtcbn07XG5cbi8vIGF1dG8gaW5zdGFsbFxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuICB3aW5kb3cuVnVlLnVzZShSb3V0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdXRlcjsiLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIFdhdGNoZXIgPSByZXF1aXJlKCcuLi93YXRjaGVyJylcbnZhciBQYXRoID0gcmVxdWlyZSgnLi4vcGFyc2Vycy9wYXRoJylcbnZhciB0ZXh0UGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2Vycy90ZXh0JylcbnZhciBkaXJQYXJzZXIgPSByZXF1aXJlKCcuLi9wYXJzZXJzL2RpcmVjdGl2ZScpXG52YXIgZXhwUGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2Vycy9leHByZXNzaW9uJylcbnZhciBmaWx0ZXJSRSA9IC9bXnxdXFx8W158XS9cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZyb20gYW4gZXhwcmVzc2lvbiBvbiB0aGlzIHZtLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FzU3RhdGVtZW50XVxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5leHBvcnRzLiRnZXQgPSBmdW5jdGlvbiAoZXhwLCBhc1N0YXRlbWVudCkge1xuICB2YXIgcmVzID0gZXhwUGFyc2VyLnBhcnNlKGV4cClcbiAgaWYgKHJlcykge1xuICAgIGlmIChhc1N0YXRlbWVudCAmJiAhZXhwUGFyc2VyLmlzU2ltcGxlUGF0aChleHApKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgIHJldHVybiBmdW5jdGlvbiBzdGF0ZW1lbnRIYW5kbGVyICgpIHtcbiAgICAgICAgcmVzLmdldC5jYWxsKHNlbGYsIHNlbGYpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXMuZ2V0LmNhbGwodGhpcywgdGhpcylcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBmcm9tIGFuIGV4cHJlc3Npb24gb24gdGhpcyB2bS5cbiAqIFRoZSBleHByZXNzaW9uIG11c3QgYmUgYSB2YWxpZCBsZWZ0LWhhbmRcbiAqIGV4cHJlc3Npb24gaW4gYW4gYXNzaWdubWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmV4cG9ydHMuJHNldCA9IGZ1bmN0aW9uIChleHAsIHZhbCkge1xuICB2YXIgcmVzID0gZXhwUGFyc2VyLnBhcnNlKGV4cCwgdHJ1ZSlcbiAgaWYgKHJlcyAmJiByZXMuc2V0KSB7XG4gICAgcmVzLnNldC5jYWxsKHRoaXMsIHRoaXMsIHZhbClcbiAgfVxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IG9uIHRoZSBWTVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqL1xuXG5leHBvcnRzLiRkZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIF8uZGVsZXRlKHRoaXMuX2RhdGEsIGtleSlcbn1cblxuLyoqXG4gKiBXYXRjaCBhbiBleHByZXNzaW9uLCB0cmlnZ2VyIGNhbGxiYWNrIHdoZW4gaXRzXG4gKiB2YWx1ZSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBleHBPckZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGRlZXBcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBpbW1lZGlhdGVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIHVud2F0Y2hGblxuICovXG5cbmV4cG9ydHMuJHdhdGNoID0gZnVuY3Rpb24gKGV4cE9yRm4sIGNiLCBvcHRpb25zKSB7XG4gIHZhciB2bSA9IHRoaXNcbiAgdmFyIHBhcnNlZFxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcGFyc2VkID0gZGlyUGFyc2VyLnBhcnNlKGV4cE9yRm4pXG4gICAgZXhwT3JGbiA9IHBhcnNlZC5leHByZXNzaW9uXG4gIH1cbiAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIHtcbiAgICBkZWVwOiBvcHRpb25zICYmIG9wdGlvbnMuZGVlcCxcbiAgICBmaWx0ZXJzOiBwYXJzZWQgJiYgcGFyc2VkLmZpbHRlcnNcbiAgfSlcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKVxuICB9XG4gIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgIHdhdGNoZXIudGVhcmRvd24oKVxuICB9XG59XG5cbi8qKlxuICogRXZhbHVhdGUgYSB0ZXh0IGRpcmVjdGl2ZSwgaW5jbHVkaW5nIGZpbHRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FzU3RhdGVtZW50XVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmV4cG9ydHMuJGV2YWwgPSBmdW5jdGlvbiAodGV4dCwgYXNTdGF0ZW1lbnQpIHtcbiAgLy8gY2hlY2sgZm9yIGZpbHRlcnMuXG4gIGlmIChmaWx0ZXJSRS50ZXN0KHRleHQpKSB7XG4gICAgdmFyIGRpciA9IGRpclBhcnNlci5wYXJzZSh0ZXh0KVxuICAgIC8vIHRoZSBmaWx0ZXIgcmVnZXggY2hlY2sgbWlnaHQgZ2l2ZSBmYWxzZSBwb3NpdGl2ZVxuICAgIC8vIGZvciBwaXBlcyBpbnNpZGUgc3RyaW5ncywgc28gaXQncyBwb3NzaWJsZSB0aGF0XG4gICAgLy8gd2UgZG9uJ3QgZ2V0IGFueSBmaWx0ZXJzIGhlcmVcbiAgICB2YXIgdmFsID0gdGhpcy4kZ2V0KGRpci5leHByZXNzaW9uLCBhc1N0YXRlbWVudClcbiAgICByZXR1cm4gZGlyLmZpbHRlcnNcbiAgICAgID8gdGhpcy5fYXBwbHlGaWx0ZXJzKHZhbCwgbnVsbCwgZGlyLmZpbHRlcnMpXG4gICAgICA6IHZhbFxuICB9IGVsc2Uge1xuICAgIC8vIG5vIGZpbHRlclxuICAgIHJldHVybiB0aGlzLiRnZXQodGV4dCwgYXNTdGF0ZW1lbnQpXG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcnBvbGF0ZSBhIHBpZWNlIG9mIHRlbXBsYXRlIHRleHQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5leHBvcnRzLiRpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIHZhciB0b2tlbnMgPSB0ZXh0UGFyc2VyLnBhcnNlKHRleHQpXG4gIHZhciB2bSA9IHRoaXNcbiAgaWYgKHRva2Vucykge1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdm0uJGV2YWwodG9rZW5zWzBdLnZhbHVlKSArICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW4udGFnXG4gICAgICAgICAgPyB2bS4kZXZhbCh0b2tlbi52YWx1ZSlcbiAgICAgICAgICA6IHRva2VuLnZhbHVlXG4gICAgICB9KS5qb2luKCcnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGV4dFxuICB9XG59XG5cbi8qKlxuICogTG9nIGluc3RhbmNlIGRhdGEgYXMgYSBwbGFpbiBKUyBvYmplY3RcbiAqIHNvIHRoYXQgaXQgaXMgZWFzaWVyIHRvIGluc3BlY3QgaW4gY29uc29sZS5cbiAqIFRoaXMgbWV0aG9kIGFzc3VtZXMgY29uc29sZSBpcyBhdmFpbGFibGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICovXG5cbmV4cG9ydHMuJGxvZyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIHZhciBkYXRhID0gcGF0aFxuICAgID8gUGF0aC5nZXQodGhpcy5fZGF0YSwgcGF0aClcbiAgICA6IHRoaXMuX2RhdGFcbiAgaWYgKGRhdGEpIHtcbiAgICBkYXRhID0gY2xlYW4oZGF0YSlcbiAgfVxuICAvLyBpbmNsdWRlIGNvbXB1dGVkIGZpZWxkc1xuICBpZiAoIXBhdGgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy4kb3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgZGF0YVtrZXldID0gY2xlYW4odGhpc1trZXldKVxuICAgIH1cbiAgfVxuICBjb25zb2xlLmxvZyhkYXRhKVxufVxuXG4vKipcbiAqIFwiY2xlYW5cIiBhIGdldHRlci9zZXR0ZXIgY29udmVydGVkIG9iamVjdCBpbnRvIGEgcGxhaW5cbiAqIG9iamVjdCBjb3B5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAtIG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGNsZWFuIChvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSlcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgdHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4uL3RyYW5zaXRpb24nKVxuXG4vKipcbiAqIENvbnZlbmllbmNlIG9uLWluc3RhbmNlIG5leHRUaWNrLiBUaGUgY2FsbGJhY2sgaXNcbiAqIGF1dG8tYm91bmQgdG8gdGhlIGluc3RhbmNlLCBhbmQgdGhpcyBhdm9pZHMgY29tcG9uZW50XG4gKiBtb2R1bGVzIGhhdmluZyB0byByZWx5IG9uIHRoZSBnbG9iYWwgVnVlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuZXhwb3J0cy4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgXy5uZXh0VGljayhmbiwgdGhpcylcbn1cblxuLyoqXG4gKiBBcHBlbmQgaW5zdGFuY2UgdG8gdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAqL1xuXG5leHBvcnRzLiRhcHBlbmRUbyA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICByZXR1cm4gaW5zZXJ0KFxuICAgIHRoaXMsIHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uLFxuICAgIGFwcGVuZCwgdHJhbnNpdGlvbi5hcHBlbmRcbiAgKVxufVxuXG4vKipcbiAqIFByZXBlbmQgaW5zdGFuY2UgdG8gdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAqL1xuXG5leHBvcnRzLiRwcmVwZW5kVG8gPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KVxuICBpZiAodGFyZ2V0Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIHRoaXMuJGJlZm9yZSh0YXJnZXQuZmlyc3RDaGlsZCwgY2IsIHdpdGhUcmFuc2l0aW9uKVxuICB9IGVsc2Uge1xuICAgIHRoaXMuJGFwcGVuZFRvKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogSW5zZXJ0IGluc3RhbmNlIGJlZm9yZSB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICovXG5cbmV4cG9ydHMuJGJlZm9yZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICByZXR1cm4gaW5zZXJ0KFxuICAgIHRoaXMsIHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uLFxuICAgIGJlZm9yZSwgdHJhbnNpdGlvbi5iZWZvcmVcbiAgKVxufVxuXG4vKipcbiAqIEluc2VydCBpbnN0YW5jZSBhZnRlciB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICovXG5cbmV4cG9ydHMuJGFmdGVyID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gIHRhcmdldCA9IHF1ZXJ5KHRhcmdldClcbiAgaWYgKHRhcmdldC5uZXh0U2libGluZykge1xuICAgIHRoaXMuJGJlZm9yZSh0YXJnZXQubmV4dFNpYmxpbmcsIGNiLCB3aXRoVHJhbnNpdGlvbilcbiAgfSBlbHNlIHtcbiAgICB0aGlzLiRhcHBlbmRUbyh0YXJnZXQucGFyZW50Tm9kZSwgY2IsIHdpdGhUcmFuc2l0aW9uKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogUmVtb3ZlIGluc3RhbmNlIGZyb20gRE9NXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICovXG5cbmV4cG9ydHMuJHJlbW92ZSA9IGZ1bmN0aW9uIChjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgaWYgKCF0aGlzLiRlbC5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGNiICYmIGNiKClcbiAgfVxuICB2YXIgaW5Eb2MgPSB0aGlzLl9pc0F0dGFjaGVkICYmIF8uaW5Eb2ModGhpcy4kZWwpXG4gIC8vIGlmIHdlIGFyZSBub3QgaW4gZG9jdW1lbnQsIG5vIG5lZWQgdG8gY2hlY2tcbiAgLy8gZm9yIHRyYW5zaXRpb25zXG4gIGlmICghaW5Eb2MpIHdpdGhUcmFuc2l0aW9uID0gZmFsc2VcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciByZWFsQ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGluRG9jKSBzZWxmLl9jYWxsSG9vaygnZGV0YWNoZWQnKVxuICAgIGlmIChjYikgY2IoKVxuICB9XG4gIGlmICh0aGlzLl9pc0ZyYWdtZW50KSB7XG4gICAgXy5yZW1vdmVOb2RlUmFuZ2UoXG4gICAgICB0aGlzLl9mcmFnbWVudFN0YXJ0LFxuICAgICAgdGhpcy5fZnJhZ21lbnRFbmQsXG4gICAgICB0aGlzLCB0aGlzLl9mcmFnbWVudCwgcmVhbENiXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHZhciBvcCA9IHdpdGhUcmFuc2l0aW9uID09PSBmYWxzZVxuICAgICAgPyByZW1vdmVcbiAgICAgIDogdHJhbnNpdGlvbi5yZW1vdmVcbiAgICBvcCh0aGlzLiRlbCwgdGhpcywgcmVhbENiKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogU2hhcmVkIERPTSBpbnNlcnRpb24gZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcDEgLSBvcCBmb3Igbm9uLXRyYW5zaXRpb24gaW5zZXJ0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcDIgLSBvcCBmb3IgdHJhbnNpdGlvbiBpbnNlcnRcbiAqIEByZXR1cm4gdm1cbiAqL1xuXG5mdW5jdGlvbiBpbnNlcnQgKHZtLCB0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbiwgb3AxLCBvcDIpIHtcbiAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KVxuICB2YXIgdGFyZ2V0SXNEZXRhY2hlZCA9ICFfLmluRG9jKHRhcmdldClcbiAgdmFyIG9wID0gd2l0aFRyYW5zaXRpb24gPT09IGZhbHNlIHx8IHRhcmdldElzRGV0YWNoZWRcbiAgICAgID8gb3AxXG4gICAgICA6IG9wMlxuICB2YXIgc2hvdWxkQ2FsbEhvb2sgPVxuICAgICF0YXJnZXRJc0RldGFjaGVkICYmXG4gICAgIXZtLl9pc0F0dGFjaGVkICYmXG4gICAgIV8uaW5Eb2Modm0uJGVsKVxuICBpZiAodm0uX2lzRnJhZ21lbnQpIHtcbiAgICBfLm1hcE5vZGVSYW5nZSh2bS5fZnJhZ21lbnRTdGFydCwgdm0uX2ZyYWdtZW50RW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgb3Aobm9kZSwgdGFyZ2V0LCB2bSlcbiAgICB9KVxuICAgIGNiICYmIGNiKClcbiAgfSBlbHNlIHtcbiAgICBvcCh2bS4kZWwsIHRhcmdldCwgdm0sIGNiKVxuICB9XG4gIGlmIChzaG91bGRDYWxsSG9vaykge1xuICAgIHZtLl9jYWxsSG9vaygnYXR0YWNoZWQnKVxuICB9XG4gIHJldHVybiB2bVxufVxuXG4vKipcbiAqIENoZWNrIGZvciBzZWxlY3RvcnNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICovXG5cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICByZXR1cm4gdHlwZW9mIGVsID09PSAnc3RyaW5nJ1xuICAgID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbClcbiAgICA6IGVsXG59XG5cbi8qKlxuICogQXBwZW5kIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtOb2RlfSBlbFxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIGFwcGVuZCAoZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gIHRhcmdldC5hcHBlbmRDaGlsZChlbClcbiAgaWYgKGNiKSBjYigpXG59XG5cbi8qKlxuICogSW5zZXJ0QmVmb3JlIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtOb2RlfSBlbFxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIGJlZm9yZSAoZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gIF8uYmVmb3JlKGVsLCB0YXJnZXQpXG4gIGlmIChjYikgY2IoKVxufVxuXG4vKipcbiAqIFJlbW92ZSBvcGVyYXRpb24gdGhhdCB0YWtlcyBhIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZSAoZWwsIHZtLCBjYikge1xuICBfLnJlbW92ZShlbClcbiAgaWYgKGNiKSBjYigpXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5cbmV4cG9ydHMuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAodGhpcy5fZXZlbnRzW2V2ZW50XSB8fCAodGhpcy5fZXZlbnRzW2V2ZW50XSA9IFtdKSlcbiAgICAucHVzaChmbilcbiAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgMSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5cbmV4cG9ydHMuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgc2VsZi4kb2ZmKGV2ZW50LCBvbilcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbiAgb24uZm4gPSBmblxuICB0aGlzLiRvbihldmVudCwgb24pXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuXG5leHBvcnRzLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gIHZhciBjYnNcbiAgLy8gYWxsXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGlmICh0aGlzLiRwYXJlbnQpIHtcbiAgICAgIGZvciAoZXZlbnQgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgIGNicyA9IHRoaXMuX2V2ZW50c1tldmVudF1cbiAgICAgICAgaWYgKGNicykge1xuICAgICAgICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIC1jYnMubGVuZ3RoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICAvLyBzcGVjaWZpYyBldmVudFxuICBjYnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdXG4gIGlmICghY2JzKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIC1jYnMubGVuZ3RoKVxuICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSBudWxsXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYlxuICB2YXIgaSA9IGNicy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGNiID0gY2JzW2ldXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIC0xKVxuICAgICAgY2JzLnNwbGljZShpLCAxKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGFuIGV2ZW50IG9uIHNlbGYuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKi9cblxuZXhwb3J0cy4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgY2JzID0gdGhpcy5fZXZlbnRzW2V2ZW50XVxuICB0aGlzLl9zaG91bGRQcm9wYWdhdGUgPSAhY2JzXG4gIGlmIChjYnMpIHtcbiAgICBjYnMgPSBjYnMubGVuZ3RoID4gMVxuICAgICAgPyBfLnRvQXJyYXkoY2JzKVxuICAgICAgOiBjYnNcbiAgICB2YXIgYXJncyA9IF8udG9BcnJheShhcmd1bWVudHMsIDEpXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgcmVzID0gY2JzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICBpZiAocmVzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3Nob3VsZFByb3BhZ2F0ZSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBicm9hZGNhc3QgYW4gZXZlbnQgdG8gYWxsIGNoaWxkcmVuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7Li4uKn0gYWRkaXRpb25hbCBhcmd1bWVudHNcbiAqL1xuXG5leHBvcnRzLiRicm9hZGNhc3QgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gaWYgbm8gY2hpbGQgaGFzIHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnQsXG4gIC8vIHRoZW4gdGhlcmUncyBubyBuZWVkIHRvIGJyb2FkY2FzdC5cbiAgaWYgKCF0aGlzLl9ldmVudHNDb3VudFtldmVudF0pIHJldHVyblxuICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRjaGlsZHJlblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG4gICAgY2hpbGQuJGVtaXQuYXBwbHkoY2hpbGQsIGFyZ3VtZW50cylcbiAgICBpZiAoY2hpbGQuX3Nob3VsZFByb3BhZ2F0ZSkge1xuICAgICAgY2hpbGQuJGJyb2FkY2FzdC5hcHBseShjaGlsZCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHByb3BhZ2F0ZSBhbiBldmVudCB1cCB0aGUgcGFyZW50IGNoYWluLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHsuLi4qfSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICovXG5cbmV4cG9ydHMuJGRpc3BhdGNoID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLiRlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudFxuICB3aGlsZSAocGFyZW50KSB7XG4gICAgcGFyZW50LiRlbWl0LmFwcGx5KHBhcmVudCwgYXJndW1lbnRzKVxuICAgIHBhcmVudCA9IHBhcmVudC5fc2hvdWxkUHJvcGFnYXRlXG4gICAgICA/IHBhcmVudC4kcGFyZW50XG4gICAgICA6IG51bGxcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIE1vZGlmeSB0aGUgbGlzdGVuZXIgY291bnRzIG9uIGFsbCBwYXJlbnRzLlxuICogVGhpcyBib29ra2VlcGluZyBhbGxvd3MgJGJyb2FkY2FzdCB0byByZXR1cm4gZWFybHkgd2hlblxuICogbm8gY2hpbGQgaGFzIGxpc3RlbmVkIHRvIGEgY2VydGFpbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50XG4gKi9cblxudmFyIGhvb2tSRSA9IC9eaG9vazovXG5mdW5jdGlvbiBtb2RpZnlMaXN0ZW5lckNvdW50ICh2bSwgZXZlbnQsIGNvdW50KSB7XG4gIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50XG4gIC8vIGhvb2tzIGRvIG5vdCBnZXQgYnJvYWRjYXN0ZWQgc28gbm8gbmVlZFxuICAvLyB0byBkbyBib29ra2VlcGluZyBmb3IgdGhlbVxuICBpZiAoIXBhcmVudCB8fCAhY291bnQgfHwgaG9va1JFLnRlc3QoZXZlbnQpKSByZXR1cm5cbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIHBhcmVudC5fZXZlbnRzQ291bnRbZXZlbnRdID1cbiAgICAgIChwYXJlbnQuX2V2ZW50c0NvdW50W2V2ZW50XSB8fCAwKSArIGNvdW50XG4gICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnRcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxuXG4vKipcbiAqIEV4cG9zZSB1c2VmdWwgaW50ZXJuYWxzXG4gKi9cblxuZXhwb3J0cy51dGlsID0gX1xuZXhwb3J0cy5jb25maWcgPSBjb25maWdcbmV4cG9ydHMuc2V0ID0gXy5zZXRcbmV4cG9ydHMuZGVsZXRlID0gXy5kZWxldGVcbmV4cG9ydHMubmV4dFRpY2sgPSBfLm5leHRUaWNrXG5cbi8qKlxuICogVGhlIGZvbGxvd2luZyBhcmUgZXhwb3NlZCBmb3IgYWR2YW5jZWQgdXNhZ2UgLyBwbHVnaW5zXG4gKi9cblxuZXhwb3J0cy5jb21waWxlciA9IHJlcXVpcmUoJy4uL2NvbXBpbGVyJylcbmV4cG9ydHMuRnJhZ21lbnRGYWN0b3J5ID0gcmVxdWlyZSgnLi4vZnJhZ21lbnQvZmFjdG9yeScpXG5leHBvcnRzLmludGVybmFsRGlyZWN0aXZlcyA9IHJlcXVpcmUoJy4uL2RpcmVjdGl2ZXMvaW50ZXJuYWwnKVxuZXhwb3J0cy5wYXJzZXJzID0ge1xuICBwYXRoOiByZXF1aXJlKCcuLi9wYXJzZXJzL3BhdGgnKSxcbiAgdGV4dDogcmVxdWlyZSgnLi4vcGFyc2Vycy90ZXh0JyksXG4gIHRlbXBsYXRlOiByZXF1aXJlKCcuLi9wYXJzZXJzL3RlbXBsYXRlJyksXG4gIGRpcmVjdGl2ZTogcmVxdWlyZSgnLi4vcGFyc2Vycy9kaXJlY3RpdmUnKSxcbiAgZXhwcmVzc2lvbjogcmVxdWlyZSgnLi4vcGFyc2Vycy9leHByZXNzaW9uJylcbn1cblxuLyoqXG4gKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICovXG5cbmV4cG9ydHMuY2lkID0gMFxudmFyIGNpZCA9IDFcblxuLyoqXG4gKiBDbGFzcyBpbmhlcml0YW5jZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbmRPcHRpb25zXG4gKi9cblxuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fVxuICB2YXIgU3VwZXIgPSB0aGlzXG4gIHZhciBpc0ZpcnN0RXh0ZW5kID0gU3VwZXIuY2lkID09PSAwXG4gIGlmIChpc0ZpcnN0RXh0ZW5kICYmIGV4dGVuZE9wdGlvbnMuX0N0b3IpIHtcbiAgICByZXR1cm4gZXh0ZW5kT3B0aW9ucy5fQ3RvclxuICB9XG4gIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZVxuICB2YXIgU3ViID0gY3JlYXRlQ2xhc3MobmFtZSB8fCAnVnVlQ29tcG9uZW50JylcbiAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKVxuICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViXG4gIFN1Yi5jaWQgPSBjaWQrK1xuICBTdWIub3B0aW9ucyA9IF8ubWVyZ2VPcHRpb25zKFxuICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgZXh0ZW5kT3B0aW9uc1xuICApXG4gIFN1Ylsnc3VwZXInXSA9IFN1cGVyXG4gIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uXG4gIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmRcbiAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV1cbiAgfSlcbiAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICBpZiAobmFtZSkge1xuICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWJcbiAgfVxuICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICBpZiAoaXNGaXJzdEV4dGVuZCkge1xuICAgIGV4dGVuZE9wdGlvbnMuX0N0b3IgPSBTdWJcbiAgfVxuICByZXR1cm4gU3ViXG59XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdWItY2xhc3MgY29uc3RydWN0b3Igd2l0aCB0aGVcbiAqIGdpdmVuIG5hbWUuIFRoaXMgZ2l2ZXMgdXMgbXVjaCBuaWNlciBvdXRwdXQgd2hlblxuICogbG9nZ2luZyBpbnN0YW5jZXMgaW4gdGhlIGNvbnNvbGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzIChuYW1lKSB7XG4gIHJldHVybiBuZXcgRnVuY3Rpb24oXG4gICAgJ3JldHVybiBmdW5jdGlvbiAnICsgXy5jbGFzc2lmeShuYW1lKSArXG4gICAgJyAob3B0aW9ucykgeyB0aGlzLl9pbml0KG9wdGlvbnMpIH0nXG4gICkoKVxufVxuXG4vKipcbiAqIFBsdWdpbiBzeXN0ZW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luXG4gKi9cblxuZXhwb3J0cy51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgIHJldHVyblxuICB9XG4gIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICB2YXIgYXJncyA9IF8udG9BcnJheShhcmd1bWVudHMsIDEpXG4gIGFyZ3MudW5zaGlmdCh0aGlzKVxuICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKVxuICB9IGVsc2Uge1xuICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKVxuICB9XG4gIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQXBwbHkgYSBnbG9iYWwgbWl4aW4gYnkgbWVyZ2luZyBpdCBpbnRvIHRoZSBkZWZhdWx0XG4gKiBvcHRpb25zLlxuICovXG5cbmV4cG9ydHMubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgdmFyIFZ1ZSA9IF8uVnVlXG4gIFZ1ZS5vcHRpb25zID0gXy5tZXJnZU9wdGlvbnMoVnVlLm9wdGlvbnMsIG1peGluKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcyB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHNpZ25hdHVyZTpcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7Kn0gZGVmaW5pdGlvblxuICovXG5cbmNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIGV4cG9ydHNbdHlwZV0gPSBmdW5jdGlvbiAoaWQsIGRlZmluaXRpb24pIHtcbiAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZSA9PT0gJ2NvbXBvbmVudCcgJiZcbiAgICAgICAgXy5pc1BsYWluT2JqZWN0KGRlZmluaXRpb24pXG4gICAgICApIHtcbiAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gaWRcbiAgICAgICAgZGVmaW5pdGlvbiA9IF8uVnVlLmV4dGVuZChkZWZpbml0aW9uKVxuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb25cbiAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgfVxuICB9XG59KVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBjb21waWxlciA9IHJlcXVpcmUoJy4uL2NvbXBpbGVyJylcblxuLyoqXG4gKiBTZXQgaW5zdGFuY2UgdGFyZ2V0IGVsZW1lbnQgYW5kIGtpY2sgb2ZmIHRoZSBjb21waWxhdGlvblxuICogcHJvY2Vzcy4gVGhlIHBhc3NlZCBpbiBgZWxgIGNhbiBiZSBhIHNlbGVjdG9yIHN0cmluZywgYW5cbiAqIGV4aXN0aW5nIEVsZW1lbnQsIG9yIGEgRG9jdW1lbnRGcmFnbWVudCAoZm9yIGJsb2NrXG4gKiBpbnN0YW5jZXMpLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fHN0cmluZ30gZWxcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLiRtb3VudCA9IGZ1bmN0aW9uIChlbCkge1xuICBpZiAodGhpcy5faXNDb21waWxlZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgJyRtb3VudCgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlLidcbiAgICApXG4gICAgcmV0dXJuXG4gIH1cbiAgZWwgPSBfLnF1ZXJ5KGVsKVxuICBpZiAoIWVsKSB7XG4gICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICB9XG4gIHRoaXMuX2NvbXBpbGUoZWwpXG4gIHRoaXMuX2luaXRET01Ib29rcygpXG4gIGlmIChfLmluRG9jKHRoaXMuJGVsKSkge1xuICAgIHRoaXMuX2NhbGxIb29rKCdhdHRhY2hlZCcpXG4gICAgcmVhZHkuY2FsbCh0aGlzKVxuICB9IGVsc2Uge1xuICAgIHRoaXMuJG9uY2UoJ2hvb2s6YXR0YWNoZWQnLCByZWFkeSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIE1hcmsgYW4gaW5zdGFuY2UgYXMgcmVhZHkuXG4gKi9cblxuZnVuY3Rpb24gcmVhZHkgKCkge1xuICB0aGlzLl9pc0F0dGFjaGVkID0gdHJ1ZVxuICB0aGlzLl9pc1JlYWR5ID0gdHJ1ZVxuICB0aGlzLl9jYWxsSG9vaygncmVhZHknKVxufVxuXG4vKipcbiAqIFRlYXJkb3duIHRoZSBpbnN0YW5jZSwgc2ltcGx5IGRlbGVnYXRlIHRvIHRoZSBpbnRlcm5hbFxuICogX2Rlc3Ryb3kuXG4gKi9cblxuZXhwb3J0cy4kZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmUsIGRlZmVyQ2xlYW51cCkge1xuICB0aGlzLl9kZXN0cm95KHJlbW92ZSwgZGVmZXJDbGVhbnVwKVxufVxuXG4vKipcbiAqIFBhcnRpYWxseSBjb21waWxlIGEgcGllY2Ugb2YgRE9NIGFuZCByZXR1cm4gYVxuICogZGVjb21waWxlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICogQHBhcmFtIHtWdWV9IFtob3N0XVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZXhwb3J0cy4kY29tcGlsZSA9IGZ1bmN0aW9uIChlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgcmV0dXJuIGNvbXBpbGVyLmNvbXBpbGUoZWwsIHRoaXMuJG9wdGlvbnMsIHRydWUpKFxuICAgIHRoaXMsIGVsLCBob3N0LCBzY29wZSwgZnJhZ1xuICApXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4vdXRpbCcpXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKVxuXG4vLyB3ZSBoYXZlIHR3byBzZXBhcmF0ZSBxdWV1ZXM6IG9uZSBmb3IgZGlyZWN0aXZlIHVwZGF0ZXNcbi8vIGFuZCBvbmUgZm9yIHVzZXIgd2F0Y2hlciByZWdpc3RlcmVkIHZpYSAkd2F0Y2goKS5cbi8vIHdlIHdhbnQgdG8gZ3VhcmFudGVlIGRpcmVjdGl2ZSB1cGRhdGVzIHRvIGJlIGNhbGxlZFxuLy8gYmVmb3JlIHVzZXIgd2F0Y2hlcnMgc28gdGhhdCB3aGVuIHVzZXIgd2F0Y2hlcnMgYXJlXG4vLyB0cmlnZ2VyZWQsIHRoZSBET00gd291bGQgaGF2ZSBhbHJlYWR5IGJlZW4gaW4gdXBkYXRlZFxuLy8gc3RhdGUuXG52YXIgcXVldWUgPSBbXVxudmFyIHVzZXJRdWV1ZSA9IFtdXG52YXIgaGFzID0ge31cbnZhciBjaXJjdWxhciA9IHt9XG52YXIgd2FpdGluZyA9IGZhbHNlXG52YXIgaW50ZXJuYWxRdWV1ZURlcGxldGVkID0gZmFsc2VcblxuLyoqXG4gKiBSZXNldCB0aGUgYmF0Y2hlcidzIHN0YXRlLlxuICovXG5cbmZ1bmN0aW9uIHJlc2V0QmF0Y2hlclN0YXRlICgpIHtcbiAgcXVldWUgPSBbXVxuICB1c2VyUXVldWUgPSBbXVxuICBoYXMgPSB7fVxuICBjaXJjdWxhciA9IHt9XG4gIHdhaXRpbmcgPSBpbnRlcm5hbFF1ZXVlRGVwbGV0ZWQgPSBmYWxzZVxufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5cbmZ1bmN0aW9uIGZsdXNoQmF0Y2hlclF1ZXVlICgpIHtcbiAgcnVuQmF0Y2hlclF1ZXVlKHF1ZXVlKVxuICBpbnRlcm5hbFF1ZXVlRGVwbGV0ZWQgPSB0cnVlXG4gIHJ1bkJhdGNoZXJRdWV1ZSh1c2VyUXVldWUpXG4gIC8vIGRldiB0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKF8uaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fKSB7XG4gICAgICB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5lbWl0KCdmbHVzaCcpXG4gICAgfVxuICB9XG4gIHJlc2V0QmF0Y2hlclN0YXRlKClcbn1cblxuLyoqXG4gKiBSdW4gdGhlIHdhdGNoZXJzIGluIGEgc2luZ2xlIHF1ZXVlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHF1ZXVlXG4gKi9cblxuZnVuY3Rpb24gcnVuQmF0Y2hlclF1ZXVlIChxdWV1ZSkge1xuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldXG4gICAgdmFyIGlkID0gd2F0Y2hlci5pZFxuICAgIGhhc1tpZF0gPSBudWxsXG4gICAgd2F0Y2hlci5ydW4oKVxuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxXG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gY29uZmlnLl9tYXhVcGRhdGVDb3VudCkge1xuICAgICAgICBxdWV1ZS5zcGxpY2UoaGFzW2lkXSwgMSlcbiAgICAgICAgXy53YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgZm9yIHdhdGNoZXIgJyArXG4gICAgICAgICAgJ3dpdGggZXhwcmVzc2lvbjogJyArIHdhdGNoZXIuZXhwcmVzc2lvblxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKlxuICogQHBhcmFtIHtXYXRjaGVyfSB3YXRjaGVyXG4gKiAgIHByb3BlcnRpZXM6XG4gKiAgIC0ge051bWJlcn0gaWRcbiAqICAgLSB7RnVuY3Rpb259IHJ1blxuICovXG5cbmV4cG9ydHMucHVzaCA9IGZ1bmN0aW9uICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWRcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIC8vIGlmIGFuIGludGVybmFsIHdhdGNoZXIgaXMgcHVzaGVkLCBidXQgdGhlIGludGVybmFsXG4gICAgLy8gcXVldWUgaXMgYWxyZWFkeSBkZXBsZXRlZCwgd2UgcnVuIGl0IGltbWVkaWF0ZWx5LlxuICAgIGlmIChpbnRlcm5hbFF1ZXVlRGVwbGV0ZWQgJiYgIXdhdGNoZXIudXNlcikge1xuICAgICAgd2F0Y2hlci5ydW4oKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHB1c2ggd2F0Y2hlciBpbnRvIGFwcHJvcHJpYXRlIHF1ZXVlXG4gICAgdmFyIHEgPSB3YXRjaGVyLnVzZXIgPyB1c2VyUXVldWUgOiBxdWV1ZVxuICAgIGhhc1tpZF0gPSBxLmxlbmd0aFxuICAgIHEucHVzaCh3YXRjaGVyKVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWVcbiAgICAgIF8ubmV4dFRpY2soZmx1c2hCYXRjaGVyUXVldWUpXG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEEgZG91Ymx5IGxpbmtlZCBsaXN0LWJhc2VkIExlYXN0IFJlY2VudGx5IFVzZWQgKExSVSlcbiAqIGNhY2hlLiBXaWxsIGtlZXAgbW9zdCByZWNlbnRseSB1c2VkIGl0ZW1zIHdoaWxlXG4gKiBkaXNjYXJkaW5nIGxlYXN0IHJlY2VudGx5IHVzZWQgaXRlbXMgd2hlbiBpdHMgbGltaXQgaXNcbiAqIHJlYWNoZWQuIFRoaXMgaXMgYSBiYXJlLWJvbmUgdmVyc2lvbiBvZlxuICogUmFzbXVzIEFuZGVyc3NvbidzIGpzLWxydTpcbiAqXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9yc21zL2pzLWxydVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gQ2FjaGUgKGxpbWl0KSB7XG4gIHRoaXMuc2l6ZSA9IDBcbiAgdGhpcy5saW1pdCA9IGxpbWl0XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IHVuZGVmaW5lZFxuICB0aGlzLl9rZXltYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG59XG5cbnZhciBwID0gQ2FjaGUucHJvdG90eXBlXG5cbi8qKlxuICogUHV0IDx2YWx1ZT4gaW50byB0aGUgY2FjaGUgYXNzb2NpYXRlZCB3aXRoIDxrZXk+LlxuICogUmV0dXJucyB0aGUgZW50cnkgd2hpY2ggd2FzIHJlbW92ZWQgdG8gbWFrZSByb29tIGZvclxuICogdGhlIG5ldyBlbnRyeS4gT3RoZXJ3aXNlIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAqIChpLmUuIGlmIHRoZXJlIHdhcyBlbm91Z2ggcm9vbSBhbHJlYWR5KS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtFbnRyeXx1bmRlZmluZWR9XG4gKi9cblxucC5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgZW50cnkgPSB7XG4gICAga2V5OiBrZXksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH1cbiAgdGhpcy5fa2V5bWFwW2tleV0gPSBlbnRyeVxuICBpZiAodGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnlcbiAgICBlbnRyeS5vbGRlciA9IHRoaXMudGFpbFxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5XG4gIH1cbiAgdGhpcy50YWlsID0gZW50cnlcbiAgaWYgKHRoaXMuc2l6ZSA9PT0gdGhpcy5saW1pdCkge1xuICAgIHJldHVybiB0aGlzLnNoaWZ0KClcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNpemUrK1xuICB9XG59XG5cbi8qKlxuICogUHVyZ2UgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgKG9sZGVzdCkgZW50cnkgZnJvbSB0aGVcbiAqIGNhY2hlLiBSZXR1cm5zIHRoZSByZW1vdmVkIGVudHJ5IG9yIHVuZGVmaW5lZCBpZiB0aGVcbiAqIGNhY2hlIHdhcyBlbXB0eS5cbiAqL1xuXG5wLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZW50cnkgPSB0aGlzLmhlYWRcbiAgaWYgKGVudHJ5KSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5ld2VyXG4gICAgdGhpcy5oZWFkLm9sZGVyID0gdW5kZWZpbmVkXG4gICAgZW50cnkubmV3ZXIgPSBlbnRyeS5vbGRlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2tleW1hcFtlbnRyeS5rZXldID0gdW5kZWZpbmVkXG4gIH1cbiAgcmV0dXJuIGVudHJ5XG59XG5cbi8qKlxuICogR2V0IGFuZCByZWdpc3RlciByZWNlbnQgdXNlIG9mIDxrZXk+LiBSZXR1cm5zIHRoZSB2YWx1ZVxuICogYXNzb2NpYXRlZCB3aXRoIDxrZXk+IG9yIHVuZGVmaW5lZCBpZiBub3QgaW4gY2FjaGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5FbnRyeVxuICogQHJldHVybiB7RW50cnl8Kn1cbiAqL1xuXG5wLmdldCA9IGZ1bmN0aW9uIChrZXksIHJldHVybkVudHJ5KSB7XG4gIHZhciBlbnRyeSA9IHRoaXMuX2tleW1hcFtrZXldXG4gIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgaWYgKGVudHJ5ID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gcmV0dXJuRW50cnlcbiAgICAgID8gZW50cnlcbiAgICAgIDogZW50cnkudmFsdWVcbiAgfVxuICAvLyBIRUFELS0tLS0tLS0tLS0tLS1UQUlMXG4gIC8vICAgPC5vbGRlciAgIC5uZXdlcj5cbiAgLy8gIDwtLS0gYWRkIGRpcmVjdGlvbiAtLVxuICAvLyAgIEEgIEIgIEMgIDxEPiAgRVxuICBpZiAoZW50cnkubmV3ZXIpIHtcbiAgICBpZiAoZW50cnkgPT09IHRoaXMuaGVhZCkge1xuICAgICAgdGhpcy5oZWFkID0gZW50cnkubmV3ZXJcbiAgICB9XG4gICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlciAvLyBDIDwtLSBFLlxuICB9XG4gIGlmIChlbnRyeS5vbGRlcikge1xuICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXIgLy8gQy4gLS0+IEVcbiAgfVxuICBlbnRyeS5uZXdlciA9IHVuZGVmaW5lZCAvLyBEIC0teFxuICBlbnRyeS5vbGRlciA9IHRoaXMudGFpbCAvLyBELiAtLT4gRVxuICBpZiAodGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnkgLy8gRS4gPC0tIERcbiAgfVxuICB0aGlzLnRhaWwgPSBlbnRyeVxuICByZXR1cm4gcmV0dXJuRW50cnlcbiAgICA/IGVudHJ5XG4gICAgOiBlbnRyeS52YWx1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENhY2hlXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIGRpclBhcnNlciA9IHJlcXVpcmUoJy4uL3BhcnNlcnMvZGlyZWN0aXZlJylcbnZhciBwcm9wRGVmID0gcmVxdWlyZSgnLi4vZGlyZWN0aXZlcy9pbnRlcm5hbC9wcm9wJylcbnZhciBwcm9wQmluZGluZ01vZGVzID0gcmVxdWlyZSgnLi4vY29uZmlnJykuX3Byb3BCaW5kaW5nTW9kZXNcbnZhciBlbXB0eSA9IHt9XG5cbi8vIHJlZ2V4ZXNcbnZhciBpZGVudFJFID0gcmVxdWlyZSgnLi4vcGFyc2Vycy9wYXRoJykuaWRlbnRSRVxudmFyIHNldHRhYmxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKihcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFtbXlxcW1xcXV0rXFxdKSokL1xuXG4vKipcbiAqIENvbXBpbGUgcHJvcHMgb24gYSByb290IGVsZW1lbnQgYW5kIHJldHVyblxuICogYSBwcm9wcyBsaW5rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICogQHBhcmFtIHtBcnJheX0gcHJvcE9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBwcm9wc0xpbmtGblxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tcGlsZVByb3BzIChlbCwgcHJvcE9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gW11cbiAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMocHJvcE9wdGlvbnMpXG4gIHZhciBpID0gbmFtZXMubGVuZ3RoXG4gIHZhciBvcHRpb25zLCBuYW1lLCBhdHRyLCB2YWx1ZSwgcGF0aCwgcGFyc2VkLCBwcm9wLCBpc1RpdGxlQmluZGluZ1xuICB3aGlsZSAoaS0tKSB7XG4gICAgbmFtZSA9IG5hbWVzW2ldXG4gICAgb3B0aW9ucyA9IHByb3BPcHRpb25zW25hbWVdIHx8IGVtcHR5XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnJGRhdGEnKSB7XG4gICAgICBfLndhcm4oJ0RvIG5vdCB1c2UgJGRhdGEgYXMgcHJvcC4nKVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICAvLyBwcm9wcyBjb3VsZCBjb250YWluIGRhc2hlcywgd2hpY2ggd2lsbCBiZVxuICAgIC8vIGludGVycHJldGVkIGFzIG1pbnVzIGNhbGN1bGF0aW9ucyBieSB0aGUgcGFyc2VyXG4gICAgLy8gc28gd2UgbmVlZCB0byBjYW1lbGl6ZSB0aGUgcGF0aCBoZXJlXG4gICAgcGF0aCA9IF8uY2FtZWxpemUobmFtZSlcbiAgICBpZiAoIWlkZW50UkUudGVzdChwYXRoKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3Aga2V5OiBcIicgKyBuYW1lICsgJ1wiLiBQcm9wIGtleXMgJyArXG4gICAgICAgICdtdXN0IGJlIHZhbGlkIGlkZW50aWZpZXJzLidcbiAgICAgIClcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgcHJvcCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgIG1vZGU6IHByb3BCaW5kaW5nTW9kZXMuT05FX1dBWVxuICAgIH1cblxuICAgIC8vIElFIHRpdGxlIGlzc3Vlc1xuICAgIGlzVGl0bGVCaW5kaW5nID0gZmFsc2VcbiAgICBpZiAobmFtZSA9PT0gJ3RpdGxlJyAmJiAoZWwuZ2V0QXR0cmlidXRlKCc6dGl0bGUnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3YtYmluZDp0aXRsZScpKSkge1xuICAgICAgaXNUaXRsZUJpbmRpbmcgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gZmlyc3QgY2hlY2sgbGl0ZXJhbCB2ZXJzaW9uXG4gICAgYXR0ciA9IF8uaHlwaGVuYXRlKG5hbWUpXG4gICAgdmFsdWUgPSBwcm9wLnJhdyA9IF8uYXR0cihlbCwgYXR0cilcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgaXNUaXRsZUJpbmRpbmcpIHtcbiAgICAgIC8vIHRoZW4gY2hlY2sgZHluYW1pYyB2ZXJzaW9uXG4gICAgICBpZiAoKHZhbHVlID0gXy5nZXRCaW5kQXR0cihlbCwgYXR0cikpID09PSBudWxsKSB7XG4gICAgICAgIGlmICgodmFsdWUgPSBfLmdldEJpbmRBdHRyKGVsLCBhdHRyICsgJy5zeW5jJykpICE9PSBudWxsKSB7XG4gICAgICAgICAgcHJvcC5tb2RlID0gcHJvcEJpbmRpbmdNb2Rlcy5UV09fV0FZXG4gICAgICAgIH0gZWxzZSBpZiAoKHZhbHVlID0gXy5nZXRCaW5kQXR0cihlbCwgYXR0ciArICcub25jZScpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIHByb3AubW9kZSA9IHByb3BCaW5kaW5nTW9kZXMuT05FX1RJTUVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcC5yYXcgPSB2YWx1ZVxuICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHBhcnNlZCA9IGRpclBhcnNlci5wYXJzZSh2YWx1ZSlcbiAgICAgICAgdmFsdWUgPSBwYXJzZWQuZXhwcmVzc2lvblxuICAgICAgICBwcm9wLmZpbHRlcnMgPSBwYXJzZWQuZmlsdGVyc1xuICAgICAgICAvLyBjaGVjayBiaW5kaW5nIHR5cGVcbiAgICAgICAgaWYgKF8uaXNMaXRlcmFsKHZhbHVlKSkge1xuICAgICAgICAgIC8vIGZvciBleHByZXNzaW9ucyBjb250YWluaW5nIGxpdGVyYWwgbnVtYmVycyBhbmRcbiAgICAgICAgICAvLyBib29sZWFucywgdGhlcmUncyBubyBuZWVkIHRvIHNldHVwIGEgcHJvcCBiaW5kaW5nLFxuICAgICAgICAgIC8vIHNvIHdlIGNhbiBvcHRpbWl6ZSB0aGVtIGFzIGEgb25lLXRpbWUgc2V0LlxuICAgICAgICAgIHByb3Aub3B0aW1pemVkTGl0ZXJhbCA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wLmR5bmFtaWMgPSB0cnVlXG4gICAgICAgICAgLy8gY2hlY2sgbm9uLXNldHRhYmxlIHBhdGggZm9yIHR3by13YXkgYmluZGluZ3NcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICBwcm9wLm1vZGUgPT09IHByb3BCaW5kaW5nTW9kZXMuVFdPX1dBWSAmJlxuICAgICAgICAgICAgICAhc2V0dGFibGVQYXRoUkUudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHByb3AubW9kZSA9IHByb3BCaW5kaW5nTW9kZXMuT05FX1dBWVxuICAgICAgICAgICAgXy53YXJuKFxuICAgICAgICAgICAgICAnQ2Fubm90IGJpbmQgdHdvLXdheSBwcm9wIHdpdGggbm9uLXNldHRhYmxlICcgK1xuICAgICAgICAgICAgICAncGFyZW50IHBhdGg6ICcgKyB2YWx1ZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9wLnBhcmVudFBhdGggPSB2YWx1ZVxuXG4gICAgICAgIC8vIHdhcm4gcmVxdWlyZWQgdHdvLXdheVxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIG9wdGlvbnMudHdvV2F5ICYmXG4gICAgICAgICAgcHJvcC5tb2RlICE9PSBwcm9wQmluZGluZ01vZGVzLlRXT19XQVlcbiAgICAgICAgKSB7XG4gICAgICAgICAgXy53YXJuKFxuICAgICAgICAgICAgJ1Byb3AgXCInICsgbmFtZSArICdcIiBleHBlY3RzIGEgdHdvLXdheSBiaW5kaW5nIHR5cGUuJ1xuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVxdWlyZWQpIHtcbiAgICAgICAgLy8gd2FybiBtaXNzaW5nIHJlcXVpcmVkXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6ICcgKyBuYW1lXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwdXNoIHByb3BcbiAgICBwcm9wcy5wdXNoKHByb3ApXG4gIH1cbiAgcmV0dXJuIG1ha2VQcm9wc0xpbmtGbihwcm9wcylcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBwcm9wcyB0byBhIHZtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gcHJvcHNMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlUHJvcHNMaW5rRm4gKHByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcm9wc0xpbmtGbiAodm0sIHNjb3BlKSB7XG4gICAgLy8gc3RvcmUgcmVzb2x2ZWQgcHJvcHMgaW5mb1xuICAgIHZtLl9wcm9wcyA9IHt9XG4gICAgdmFyIGkgPSBwcm9wcy5sZW5ndGhcbiAgICB2YXIgcHJvcCwgcGF0aCwgb3B0aW9ucywgdmFsdWUsIHJhd1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHByb3AgPSBwcm9wc1tpXVxuICAgICAgcmF3ID0gcHJvcC5yYXdcbiAgICAgIHBhdGggPSBwcm9wLnBhdGhcbiAgICAgIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnNcbiAgICAgIHZtLl9wcm9wc1twYXRoXSA9IHByb3BcbiAgICAgIGlmIChyYXcgPT09IG51bGwpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBhYnNlbnQgcHJvcFxuICAgICAgICBfLmluaXRQcm9wKHZtLCBwcm9wLCBnZXREZWZhdWx0KHZtLCBvcHRpb25zKSlcbiAgICAgIH0gZWxzZSBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICAgIC8vIGR5bmFtaWMgcHJvcFxuICAgICAgICBpZiAodm0uX2NvbnRleHQpIHtcbiAgICAgICAgICBpZiAocHJvcC5tb2RlID09PSBwcm9wQmluZGluZ01vZGVzLk9ORV9USU1FKSB7XG4gICAgICAgICAgICAvLyBvbmUgdGltZSBiaW5kaW5nXG4gICAgICAgICAgICB2YWx1ZSA9IChzY29wZSB8fCB2bS5fY29udGV4dCkuJGdldChwcm9wLnBhcmVudFBhdGgpXG4gICAgICAgICAgICBfLmluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZHluYW1pYyBiaW5kaW5nXG4gICAgICAgICAgICB2bS5fYmluZERpcih7XG4gICAgICAgICAgICAgIG5hbWU6ICdwcm9wJyxcbiAgICAgICAgICAgICAgZGVmOiBwcm9wRGVmLFxuICAgICAgICAgICAgICBwcm9wOiBwcm9wXG4gICAgICAgICAgICB9LCBudWxsLCBudWxsLCBzY29wZSkgLy8gZWwsIGhvc3QsIHNjb3BlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAgICAgJ0Nhbm5vdCBiaW5kIGR5bmFtaWMgcHJvcCBvbiBhIHJvb3QgaW5zdGFuY2UnICtcbiAgICAgICAgICAgICcgd2l0aCBubyBwYXJlbnQ6ICcgKyBwcm9wLm5hbWUgKyAnPVwiJyArXG4gICAgICAgICAgICByYXcgKyAnXCInXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3Aub3B0aW1pemVkTGl0ZXJhbCkge1xuICAgICAgICAvLyBvcHRpbWl6ZWQgbGl0ZXJhbCwgY2FzdCBpdCBhbmQganVzdCBzZXQgb25jZVxuICAgICAgICByYXcgPSBfLnN0cmlwUXVvdGVzKHJhdylcbiAgICAgICAgdmFsdWUgPSBfLnRvQm9vbGVhbihfLnRvTnVtYmVyKHJhdykpXG4gICAgICAgIF8uaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RyaW5nIGxpdGVyYWwsIGJ1dCB3ZSBuZWVkIHRvIGNhdGVyIGZvclxuICAgICAgICAvLyBCb29sZWFuIHByb3BzIHdpdGggbm8gdmFsdWVcbiAgICAgICAgdmFsdWUgPSBvcHRpb25zLnR5cGUgPT09IEJvb2xlYW4gJiYgcmF3ID09PSAnJ1xuICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgIDogcmF3XG4gICAgICAgIF8uaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Kn1cbiAqL1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0ICh2bSwgb3B0aW9ucykge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpKSB7XG4gICAgLy8gYWJzZW50IGJvb2xlYW4gdmFsdWUgZGVmYXVsdHMgdG8gZmFsc2VcbiAgICByZXR1cm4gb3B0aW9ucy50eXBlID09PSBCb29sZWFuXG4gICAgICA/IGZhbHNlXG4gICAgICA6IHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBvcHRpb25zLmRlZmF1bHRcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAoXy5pc09iamVjdChkZWYpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnT2JqZWN0L0FycmF5IGFzIGRlZmF1bHQgcHJvcCB2YWx1ZXMgd2lsbCBiZSBzaGFyZWQgJyArXG4gICAgICAnYWNyb3NzIG11bHRpcGxlIGluc3RhbmNlcy4gVXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC4nXG4gICAgKVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMudHlwZSAhPT0gRnVuY3Rpb25cbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIHB1YmxpY0RpcmVjdGl2ZXMgPSByZXF1aXJlKCcuLi9kaXJlY3RpdmVzL3B1YmxpYycpXG52YXIgaW50ZXJuYWxEaXJlY3RpdmVzID0gcmVxdWlyZSgnLi4vZGlyZWN0aXZlcy9pbnRlcm5hbCcpXG52YXIgY29tcGlsZVByb3BzID0gcmVxdWlyZSgnLi9jb21waWxlLXByb3BzJylcbnZhciB0ZXh0UGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2Vycy90ZXh0JylcbnZhciBkaXJQYXJzZXIgPSByZXF1aXJlKCcuLi9wYXJzZXJzL2RpcmVjdGl2ZScpXG52YXIgdGVtcGxhdGVQYXJzZXIgPSByZXF1aXJlKCcuLi9wYXJzZXJzL3RlbXBsYXRlJylcbnZhciByZXNvbHZlQXNzZXQgPSBfLnJlc29sdmVBc3NldFxuXG4vLyBzcGVjaWFsIGJpbmRpbmcgcHJlZml4ZXNcbnZhciBiaW5kUkUgPSAvXnYtYmluZDp8XjovXG52YXIgb25SRSA9IC9edi1vbjp8XkAvXG52YXIgYXJnUkUgPSAvOiguKikkL1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW15cXC5dKy9nXG52YXIgdHJhbnNpdGlvblJFID0gL14odi1iaW5kOnw6KT90cmFuc2l0aW9uJC9cblxuLy8gdGVybWluYWwgZGlyZWN0aXZlc1xudmFyIHRlcm1pbmFsRGlyZWN0aXZlcyA9IFtcbiAgJ2ZvcicsXG4gICdpZidcbl1cblxuLy8gZGVmYXVsdCBkaXJlY3RpdmUgcHJpb3JpdHlcbnZhciBERUZBVUxUX1BSSU9SSVRZID0gMTAwMFxuXG4vKipcbiAqIENvbXBpbGUgYSB0ZW1wbGF0ZSBhbmQgcmV0dXJuIGEgcmV1c2FibGUgY29tcG9zaXRlIGxpbmtcbiAqIGZ1bmN0aW9uLCB3aGljaCByZWN1cnNpdmVseSBjb250YWlucyBtb3JlIGxpbmsgZnVuY3Rpb25zXG4gKiBpbnNpZGUuIFRoaXMgdG9wIGxldmVsIGNvbXBpbGUgZnVuY3Rpb24gd291bGQgbm9ybWFsbHlcbiAqIGJlIGNhbGxlZCBvbiBpbnN0YW5jZSByb290IG5vZGVzLCBidXQgY2FuIGFsc28gYmUgdXNlZFxuICogZm9yIHBhcnRpYWwgY29tcGlsYXRpb24gaWYgdGhlIHBhcnRpYWwgYXJndW1lbnQgaXMgdHJ1ZS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgY29tcG9zaXRlIGxpbmsgZnVuY3Rpb24sIHdoZW4gY2FsbGVkLCB3aWxsXG4gKiByZXR1cm4gYW4gdW5saW5rIGZ1bmN0aW9uIHRoYXQgdGVhcnNkb3duIGFsbCBkaXJlY3RpdmVzXG4gKiBjcmVhdGVkIGR1cmluZyB0aGUgbGlua2luZyBwaGFzZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhcnRpYWxcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmV4cG9ydHMuY29tcGlsZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucywgcGFydGlhbCkge1xuICAvLyBsaW5rIGZ1bmN0aW9uIGZvciB0aGUgbm9kZSBpdHNlbGYuXG4gIHZhciBub2RlTGlua0ZuID0gcGFydGlhbCB8fCAhb3B0aW9ucy5fYXNDb21wb25lbnRcbiAgICA/IGNvbXBpbGVOb2RlKGVsLCBvcHRpb25zKVxuICAgIDogbnVsbFxuICAvLyBsaW5rIGZ1bmN0aW9uIGZvciB0aGUgY2hpbGROb2Rlc1xuICB2YXIgY2hpbGRMaW5rRm4gPVxuICAgICEobm9kZUxpbmtGbiAmJiBub2RlTGlua0ZuLnRlcm1pbmFsKSAmJlxuICAgIGVsLnRhZ05hbWUgIT09ICdTQ1JJUFQnICYmXG4gICAgZWwuaGFzQ2hpbGROb2RlcygpXG4gICAgICA/IGNvbXBpbGVOb2RlTGlzdChlbC5jaGlsZE5vZGVzLCBvcHRpb25zKVxuICAgICAgOiBudWxsXG5cbiAgLyoqXG4gICAqIEEgY29tcG9zaXRlIGxpbmtlciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYSBhbHJlYWR5XG4gICAqIGNvbXBpbGVkIHBpZWNlIG9mIERPTSwgd2hpY2ggaW5zdGFudGlhdGVzIGFsbCBkaXJlY3RpdmVcbiAgICogaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsXG4gICAqIEBwYXJhbSB7VnVlfSBbaG9zdF0gLSBob3N0IHZtIG9mIHRyYW5zY2x1ZGVkIGNvbnRlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSB2LWZvciBzY29wZVxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBbZnJhZ10gLSBsaW5rIGNvbnRleHQgZnJhZ21lbnRcbiAgICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICAgKi9cblxuICByZXR1cm4gZnVuY3Rpb24gY29tcG9zaXRlTGlua0ZuICh2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgLy8gY2FjaGUgY2hpbGROb2RlcyBiZWZvcmUgbGlua2luZyBwYXJlbnQsIGZpeCAjNjU3XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBfLnRvQXJyYXkoZWwuY2hpbGROb2RlcylcbiAgICAvLyBsaW5rXG4gICAgdmFyIGRpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiBjb21wb3NpdGVMaW5rQ2FwdHVyZXIgKCkge1xuICAgICAgaWYgKG5vZGVMaW5rRm4pIG5vZGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZylcbiAgICAgIGlmIChjaGlsZExpbmtGbikgY2hpbGRMaW5rRm4odm0sIGNoaWxkTm9kZXMsIGhvc3QsIHNjb3BlLCBmcmFnKVxuICAgIH0sIHZtKVxuICAgIHJldHVybiBtYWtlVW5saW5rRm4odm0sIGRpcnMpXG4gIH1cbn1cblxuLyoqXG4gKiBBcHBseSBhIGxpbmtlciB0byBhIHZtL2VsZW1lbnQgcGFpciBhbmQgY2FwdHVyZSB0aGVcbiAqIGRpcmVjdGl2ZXMgY3JlYXRlZCBkdXJpbmcgdGhlIHByb2Nlc3MuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlua2VyXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5mdW5jdGlvbiBsaW5rQW5kQ2FwdHVyZSAobGlua2VyLCB2bSkge1xuICB2YXIgb3JpZ2luYWxEaXJDb3VudCA9IHZtLl9kaXJlY3RpdmVzLmxlbmd0aFxuICBsaW5rZXIoKVxuICB2YXIgZGlycyA9IHZtLl9kaXJlY3RpdmVzLnNsaWNlKG9yaWdpbmFsRGlyQ291bnQpXG4gIGRpcnMuc29ydChkaXJlY3RpdmVDb21wYXJhdG9yKVxuICBmb3IgKHZhciBpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyc1tpXS5fYmluZCgpXG4gIH1cbiAgcmV0dXJuIGRpcnNcbn1cblxuLyoqXG4gKiBEaXJlY3RpdmUgcHJpb3JpdHkgc29ydCBjb21wYXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKi9cblxuZnVuY3Rpb24gZGlyZWN0aXZlQ29tcGFyYXRvciAoYSwgYikge1xuICBhID0gYS5kZXNjcmlwdG9yLmRlZi5wcmlvcml0eSB8fCBERUZBVUxUX1BSSU9SSVRZXG4gIGIgPSBiLmRlc2NyaXB0b3IuZGVmLnByaW9yaXR5IHx8IERFRkFVTFRfUFJJT1JJVFlcbiAgcmV0dXJuIGEgPiBiID8gLTEgOiBhID09PSBiID8gMCA6IDFcbn1cblxuLyoqXG4gKiBMaW5rZXIgZnVuY3Rpb25zIHJldHVybiBhbiB1bmxpbmsgZnVuY3Rpb24gdGhhdFxuICogdGVhcnNkb3duIGFsbCBkaXJlY3RpdmVzIGluc3RhbmNlcyBnZW5lcmF0ZWQgZHVyaW5nXG4gKiB0aGUgcHJvY2Vzcy5cbiAqXG4gKiBXZSBjcmVhdGUgdW5saW5rIGZ1bmN0aW9ucyB3aXRoIG9ubHkgdGhlIG5lY2Vzc2FyeVxuICogaW5mb3JtYXRpb24gdG8gYXZvaWQgcmV0YWluaW5nIGFkZGl0aW9uYWwgY2xvc3VyZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJzXG4gKiBAcGFyYW0ge1Z1ZX0gW2NvbnRleHRdXG4gKiBAcGFyYW0ge0FycmF5fSBbY29udGV4dERpcnNdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlVW5saW5rRm4gKHZtLCBkaXJzLCBjb250ZXh0LCBjb250ZXh0RGlycykge1xuICByZXR1cm4gZnVuY3Rpb24gdW5saW5rIChkZXN0cm95aW5nKSB7XG4gICAgdGVhcmRvd25EaXJzKHZtLCBkaXJzLCBkZXN0cm95aW5nKVxuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHREaXJzKSB7XG4gICAgICB0ZWFyZG93bkRpcnMoY29udGV4dCwgY29udGV4dERpcnMpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGVhcmRvd24gcGFydGlhbCBsaW5rZWQgZGlyZWN0aXZlcy5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7QXJyYXl9IGRpcnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVzdHJveWluZ1xuICovXG5cbmZ1bmN0aW9uIHRlYXJkb3duRGlycyAodm0sIGRpcnMsIGRlc3Ryb3lpbmcpIHtcbiAgdmFyIGkgPSBkaXJzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAgZGlyc1tpXS5fdGVhcmRvd24oKVxuICAgIGlmICghZGVzdHJveWluZykge1xuICAgICAgdm0uX2RpcmVjdGl2ZXMuJHJlbW92ZShkaXJzW2ldKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgbGluayBwcm9wcyBvbiBhbiBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmV4cG9ydHMuY29tcGlsZUFuZExpbmtQcm9wcyA9IGZ1bmN0aW9uICh2bSwgZWwsIHByb3BzLCBzY29wZSkge1xuICB2YXIgcHJvcHNMaW5rRm4gPSBjb21waWxlUHJvcHMoZWwsIHByb3BzKVxuICB2YXIgcHJvcERpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiAoKSB7XG4gICAgcHJvcHNMaW5rRm4odm0sIHNjb3BlKVxuICB9LCB2bSlcbiAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgcHJvcERpcnMpXG59XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgcm9vdCBlbGVtZW50IG9mIGFuIGluc3RhbmNlLlxuICpcbiAqIDEuIGF0dHJzIG9uIGNvbnRleHQgY29udGFpbmVyIChjb250ZXh0IHNjb3BlKVxuICogMi4gYXR0cnMgb24gdGhlIGNvbXBvbmVudCB0ZW1wbGF0ZSByb290IG5vZGUsIGlmXG4gKiAgICByZXBsYWNlOnRydWUgKGNoaWxkIHNjb3BlKVxuICpcbiAqIElmIHRoaXMgaXMgYSBmcmFnbWVudCBpbnN0YW5jZSwgd2Ugb25seSBuZWVkIHRvIGNvbXBpbGUgMS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dE9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmV4cG9ydHMuY29tcGlsZVJvb3QgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMsIGNvbnRleHRPcHRpb25zKSB7XG4gIHZhciBjb250YWluZXJBdHRycyA9IG9wdGlvbnMuX2NvbnRhaW5lckF0dHJzXG4gIHZhciByZXBsYWNlckF0dHJzID0gb3B0aW9ucy5fcmVwbGFjZXJBdHRyc1xuICB2YXIgY29udGV4dExpbmtGbiwgcmVwbGFjZXJMaW5rRm5cblxuICAvLyBvbmx5IG5lZWQgdG8gY29tcGlsZSBvdGhlciBhdHRyaWJ1dGVzIGZvclxuICAvLyBub24tZnJhZ21lbnQgaW5zdGFuY2VzXG4gIGlmIChlbC5ub2RlVHlwZSAhPT0gMTEpIHtcbiAgICAvLyBmb3IgY29tcG9uZW50cywgY29udGFpbmVyIGFuZCByZXBsYWNlciBuZWVkIHRvIGJlXG4gICAgLy8gY29tcGlsZWQgc2VwYXJhdGVseSBhbmQgbGlua2VkIGluIGRpZmZlcmVudCBzY29wZXMuXG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50KSB7XG4gICAgICAvLyAyLiBjb250YWluZXIgYXR0cmlidXRlc1xuICAgICAgaWYgKGNvbnRhaW5lckF0dHJzICYmIGNvbnRleHRPcHRpb25zKSB7XG4gICAgICAgIGNvbnRleHRMaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhjb250YWluZXJBdHRycywgY29udGV4dE9wdGlvbnMpXG4gICAgICB9XG4gICAgICBpZiAocmVwbGFjZXJBdHRycykge1xuICAgICAgICAvLyAzLiByZXBsYWNlciBhdHRyaWJ1dGVzXG4gICAgICAgIHJlcGxhY2VyTGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMocmVwbGFjZXJBdHRycywgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9uLWNvbXBvbmVudCwganVzdCBjb21waWxlIGFzIGEgbm9ybWFsIGVsZW1lbnQuXG4gICAgICByZXBsYWNlckxpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKGVsLmF0dHJpYnV0ZXMsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29udGFpbmVyQXR0cnMpIHtcbiAgICAvLyB3YXJuIGNvbnRhaW5lciBkaXJlY3RpdmVzIGZvciBmcmFnbWVudCBpbnN0YW5jZXNcbiAgICB2YXIgbmFtZXMgPSBjb250YWluZXJBdHRycy5tYXAoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIHJldHVybiAnXCInICsgYXR0ci5uYW1lICsgJ1wiJ1xuICAgIH0pLmpvaW4oJywgJylcbiAgICB2YXIgcGx1cmFsID0gY29udGFpbmVyQXR0cnMubGVuZ3RoID4gMVxuICAgIF8ud2FybihcbiAgICAgICdBdHRyaWJ1dGUnICsgKHBsdXJhbCA/ICdzICcgOiAnICcpICsgbmFtZXMgK1xuICAgICAgKHBsdXJhbCA/ICcgYXJlJyA6ICcgaXMnKSArICcgaWdub3JlZCBvbiBjb21wb25lbnQgJyArXG4gICAgICAnPCcgKyBvcHRpb25zLmVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArICc+IGJlY2F1c2UgJyArXG4gICAgICAndGhlIGNvbXBvbmVudCBpcyBhIGZyYWdtZW50IGluc3RhbmNlOiAnICtcbiAgICAgICdodHRwOi8vdnVlanMub3JnL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNGcmFnbWVudF9JbnN0YW5jZSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcm9vdExpbmtGbiAodm0sIGVsLCBzY29wZSkge1xuICAgIC8vIGxpbmsgY29udGV4dCBzY29wZSBkaXJzXG4gICAgdmFyIGNvbnRleHQgPSB2bS5fY29udGV4dFxuICAgIHZhciBjb250ZXh0RGlyc1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHRMaW5rRm4pIHtcbiAgICAgIGNvbnRleHREaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZXh0TGlua0ZuKGNvbnRleHQsIGVsLCBudWxsLCBzY29wZSlcbiAgICAgIH0sIGNvbnRleHQpXG4gICAgfVxuXG4gICAgLy8gbGluayBzZWxmXG4gICAgdmFyIHNlbGZEaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJlcGxhY2VyTGlua0ZuKSByZXBsYWNlckxpbmtGbih2bSwgZWwpXG4gICAgfSwgdm0pXG5cbiAgICAvLyByZXR1cm4gdGhlIHVubGluayBmdW5jdGlvbiB0aGF0IHRlYXJzZG93biBjb250ZXh0XG4gICAgLy8gY29udGFpbmVyIGRpcmVjdGl2ZXMuXG4gICAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgc2VsZkRpcnMsIGNvbnRleHQsIGNvbnRleHREaXJzKVxuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIG5vZGUgYW5kIHJldHVybiBhIG5vZGVMaW5rRm4gYmFzZWQgb24gdGhlXG4gKiBub2RlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlTm9kZSAobm9kZSwgb3B0aW9ucykge1xuICB2YXIgdHlwZSA9IG5vZGUubm9kZVR5cGVcbiAgaWYgKHR5cGUgPT09IDEgJiYgbm9kZS50YWdOYW1lICE9PSAnU0NSSVBUJykge1xuICAgIHJldHVybiBjb21waWxlRWxlbWVudChub2RlLCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IDMgJiYgbm9kZS5kYXRhLnRyaW0oKSkge1xuICAgIHJldHVybiBjb21waWxlVGV4dE5vZGUobm9kZSwgb3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZSBhbiBlbGVtZW50IGFuZCByZXR1cm4gYSBub2RlTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVFbGVtZW50IChlbCwgb3B0aW9ucykge1xuICAvLyBwcmVwcm9jZXNzIHRleHRhcmVhcy5cbiAgLy8gdGV4dGFyZWEgdHJlYXRzIGl0cyB0ZXh0IGNvbnRlbnQgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gIC8vIGp1c3QgYmluZCBpdCBhcyBhbiBhdHRyIGRpcmVjdGl2ZSBmb3IgdmFsdWUuXG4gIGlmIChlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgdmFyIHRva2VucyA9IHRleHRQYXJzZXIucGFyc2UoZWwudmFsdWUpXG4gICAgaWYgKHRva2Vucykge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCc6dmFsdWUnLCB0ZXh0UGFyc2VyLnRva2Vuc1RvRXhwKHRva2VucykpXG4gICAgICBlbC52YWx1ZSA9ICcnXG4gICAgfVxuICB9XG4gIHZhciBsaW5rRm5cbiAgdmFyIGhhc0F0dHJzID0gZWwuaGFzQXR0cmlidXRlcygpXG4gIC8vIGNoZWNrIHRlcm1pbmFsIGRpcmVjdGl2ZXMgKGZvciAmIGlmKVxuICBpZiAoaGFzQXR0cnMpIHtcbiAgICBsaW5rRm4gPSBjaGVja1Rlcm1pbmFsRGlyZWN0aXZlcyhlbCwgb3B0aW9ucylcbiAgfVxuICAvLyBjaGVjayBlbGVtZW50IGRpcmVjdGl2ZXNcbiAgaWYgKCFsaW5rRm4pIHtcbiAgICBsaW5rRm4gPSBjaGVja0VsZW1lbnREaXJlY3RpdmVzKGVsLCBvcHRpb25zKVxuICB9XG4gIC8vIGNoZWNrIGNvbXBvbmVudFxuICBpZiAoIWxpbmtGbikge1xuICAgIGxpbmtGbiA9IGNoZWNrQ29tcG9uZW50KGVsLCBvcHRpb25zKVxuICB9XG4gIC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gIGlmICghbGlua0ZuICYmIGhhc0F0dHJzKSB7XG4gICAgbGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMoZWwuYXR0cmlidXRlcywgb3B0aW9ucylcbiAgfVxuICByZXR1cm4gbGlua0ZuXG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHRleHROb2RlIGFuZCByZXR1cm4gYSBub2RlTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7VGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfSB0ZXh0Tm9kZUxpbmtGblxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVUZXh0Tm9kZSAobm9kZSwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gdGV4dFBhcnNlci5wYXJzZShub2RlLmRhdGEpXG4gIGlmICghdG9rZW5zKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICB2YXIgZWwsIHRva2VuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRva2VuID0gdG9rZW5zW2ldXG4gICAgZWwgPSB0b2tlbi50YWdcbiAgICAgID8gcHJvY2Vzc1RleHRUb2tlbih0b2tlbiwgb3B0aW9ucylcbiAgICAgIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodG9rZW4udmFsdWUpXG4gICAgZnJhZy5hcHBlbmRDaGlsZChlbClcbiAgfVxuICByZXR1cm4gbWFrZVRleHROb2RlTGlua0ZuKHRva2VucywgZnJhZywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgc2luZ2xlIHRleHQgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBwcm9jZXNzVGV4dFRva2VuICh0b2tlbiwgb3B0aW9ucykge1xuICB2YXIgZWxcbiAgaWYgKHRva2VuLm9uZVRpbWUpIHtcbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRva2VuLnZhbHVlKVxuICB9IGVsc2Uge1xuICAgIGlmICh0b2tlbi5odG1sKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ3YtaHRtbCcpXG4gICAgICBzZXRUb2tlblR5cGUoJ2h0bWwnKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRSB3aWxsIGNsZWFuIHVwIGVtcHR5IHRleHROb2RlcyBkdXJpbmdcbiAgICAgIC8vIGZyYWcuY2xvbmVOb2RlKHRydWUpLCBzbyB3ZSBoYXZlIHRvIGdpdmUgaXRcbiAgICAgIC8vIHNvbWV0aGluZyBoZXJlLi4uXG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJylcbiAgICAgIHNldFRva2VuVHlwZSgndGV4dCcpXG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldFRva2VuVHlwZSAodHlwZSkge1xuICAgIGlmICh0b2tlbi5kZXNjcmlwdG9yKSByZXR1cm5cbiAgICB2YXIgcGFyc2VkID0gZGlyUGFyc2VyLnBhcnNlKHRva2VuLnZhbHVlKVxuICAgIHRva2VuLmRlc2NyaXB0b3IgPSB7XG4gICAgICBuYW1lOiB0eXBlLFxuICAgICAgZGVmOiBwdWJsaWNEaXJlY3RpdmVzW3R5cGVdLFxuICAgICAgZXhwcmVzc2lvbjogcGFyc2VkLmV4cHJlc3Npb24sXG4gICAgICBmaWx0ZXJzOiBwYXJzZWQuZmlsdGVyc1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGZ1bmN0aW9uIHRoYXQgcHJvY2Vzc2VzIGEgdGV4dE5vZGUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSB0b2tlbnNcbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ1xuICovXG5cbmZ1bmN0aW9uIG1ha2VUZXh0Tm9kZUxpbmtGbiAodG9rZW5zLCBmcmFnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0ZXh0Tm9kZUxpbmtGbiAodm0sIGVsLCBob3N0LCBzY29wZSkge1xuICAgIHZhciBmcmFnQ2xvbmUgPSBmcmFnLmNsb25lTm9kZSh0cnVlKVxuICAgIHZhciBjaGlsZE5vZGVzID0gXy50b0FycmF5KGZyYWdDbG9uZS5jaGlsZE5vZGVzKVxuICAgIHZhciB0b2tlbiwgdmFsdWUsIG5vZGVcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldXG4gICAgICB2YWx1ZSA9IHRva2VuLnZhbHVlXG4gICAgICBpZiAodG9rZW4udGFnKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZE5vZGVzW2ldXG4gICAgICAgIGlmICh0b2tlbi5vbmVUaW1lKSB7XG4gICAgICAgICAgdmFsdWUgPSAoc2NvcGUgfHwgdm0pLiRldmFsKHZhbHVlKVxuICAgICAgICAgIGlmICh0b2tlbi5odG1sKSB7XG4gICAgICAgICAgICBfLnJlcGxhY2Uobm9kZSwgdGVtcGxhdGVQYXJzZXIucGFyc2UodmFsdWUsIHRydWUpKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bS5fYmluZERpcih0b2tlbi5kZXNjcmlwdG9yLCBub2RlLCBob3N0LCBzY29wZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfLnJlcGxhY2UoZWwsIGZyYWdDbG9uZSlcbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgYSBub2RlIGxpc3QgYW5kIHJldHVybiBhIGNoaWxkTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVMaXN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVOb2RlTGlzdCAobm9kZUxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGxpbmtGbnMgPSBbXVxuICB2YXIgbm9kZUxpbmtGbiwgY2hpbGRMaW5rRm4sIG5vZGVcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBub2RlID0gbm9kZUxpc3RbaV1cbiAgICBub2RlTGlua0ZuID0gY29tcGlsZU5vZGUobm9kZSwgb3B0aW9ucylcbiAgICBjaGlsZExpbmtGbiA9XG4gICAgICAhKG5vZGVMaW5rRm4gJiYgbm9kZUxpbmtGbi50ZXJtaW5hbCkgJiZcbiAgICAgIG5vZGUudGFnTmFtZSAhPT0gJ1NDUklQVCcgJiZcbiAgICAgIG5vZGUuaGFzQ2hpbGROb2RlcygpXG4gICAgICAgID8gY29tcGlsZU5vZGVMaXN0KG5vZGUuY2hpbGROb2Rlcywgb3B0aW9ucylcbiAgICAgICAgOiBudWxsXG4gICAgbGlua0Zucy5wdXNoKG5vZGVMaW5rRm4sIGNoaWxkTGlua0ZuKVxuICB9XG4gIHJldHVybiBsaW5rRm5zLmxlbmd0aFxuICAgID8gbWFrZUNoaWxkTGlua0ZuKGxpbmtGbnMpXG4gICAgOiBudWxsXG59XG5cbi8qKlxuICogTWFrZSBhIGNoaWxkIGxpbmsgZnVuY3Rpb24gZm9yIGEgbm9kZSdzIGNoaWxkTm9kZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxGdW5jdGlvbj59IGxpbmtGbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBjaGlsZExpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VDaGlsZExpbmtGbiAobGlua0Zucykge1xuICByZXR1cm4gZnVuY3Rpb24gY2hpbGRMaW5rRm4gKHZtLCBub2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICB2YXIgbm9kZSwgbm9kZUxpbmtGbiwgY2hpbGRyZW5MaW5rRm5cbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IDAsIGwgPSBsaW5rRm5zLmxlbmd0aDsgaSA8IGw7IG4rKykge1xuICAgICAgbm9kZSA9IG5vZGVzW25dXG4gICAgICBub2RlTGlua0ZuID0gbGlua0Zuc1tpKytdXG4gICAgICBjaGlsZHJlbkxpbmtGbiA9IGxpbmtGbnNbaSsrXVxuICAgICAgLy8gY2FjaGUgY2hpbGROb2RlcyBiZWZvcmUgbGlua2luZyBwYXJlbnQsIGZpeCAjNjU3XG4gICAgICB2YXIgY2hpbGROb2RlcyA9IF8udG9BcnJheShub2RlLmNoaWxkTm9kZXMpXG4gICAgICBpZiAobm9kZUxpbmtGbikge1xuICAgICAgICBub2RlTGlua0ZuKHZtLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZylcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZHJlbkxpbmtGbikge1xuICAgICAgICBjaGlsZHJlbkxpbmtGbih2bSwgY2hpbGROb2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIGVsZW1lbnQgZGlyZWN0aXZlcyAoY3VzdG9tIGVsZW1lbnRzIHRoYXQgc2hvdWxkXG4gKiBiZSByZXNvdmxlZCBhcyB0ZXJtaW5hbCBkaXJlY3RpdmVzKS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGNoZWNrRWxlbWVudERpcmVjdGl2ZXMgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB0YWcgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgaWYgKF8uY29tbW9uVGFnUkUudGVzdCh0YWcpKSByZXR1cm5cbiAgdmFyIGRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZWxlbWVudERpcmVjdGl2ZXMnLCB0YWcpXG4gIGlmIChkZWYpIHtcbiAgICByZXR1cm4gbWFrZVRlcm1pbmFsTm9kZUxpbmtGbihlbCwgdGFnLCAnJywgb3B0aW9ucywgZGVmKVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBhIGNvbXBvbmVudC4gSWYgeWVzLCByZXR1cm5cbiAqIGEgY29tcG9uZW50IGxpbmsgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudCAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbXBvbmVudCA9IF8uY2hlY2tDb21wb25lbnQoZWwsIG9wdGlvbnMpXG4gIGlmIChjb21wb25lbnQpIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgIG5hbWU6ICdjb21wb25lbnQnLFxuICAgICAgZXhwcmVzc2lvbjogY29tcG9uZW50LmlkLFxuICAgICAgZGVmOiBpbnRlcm5hbERpcmVjdGl2ZXMuY29tcG9uZW50LFxuICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgIGxpdGVyYWw6ICFjb21wb25lbnQuZHluYW1pY1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY29tcG9uZW50TGlua0ZuID0gZnVuY3Rpb24gKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICAgIHZtLl9iaW5kRGlyKGRlc2NyaXB0b3IsIGVsLCBob3N0LCBzY29wZSwgZnJhZylcbiAgICB9XG4gICAgY29tcG9uZW50TGlua0ZuLnRlcm1pbmFsID0gdHJ1ZVxuICAgIHJldHVybiBjb21wb25lbnRMaW5rRm5cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGFuIGVsZW1lbnQgZm9yIHRlcm1pbmFsIGRpcmVjdGl2ZXMgaW4gZml4ZWQgb3JkZXIuXG4gKiBJZiBpdCBmaW5kcyBvbmUsIHJldHVybiBhIHRlcm1pbmFsIGxpbmsgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0ZXJtaW5hbExpbmtGblxuICovXG5cbmZ1bmN0aW9uIGNoZWNrVGVybWluYWxEaXJlY3RpdmVzIChlbCwgb3B0aW9ucykge1xuICAvLyBza2lwIHYtcHJlXG4gIGlmIChfLmF0dHIoZWwsICd2LXByZScpICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNraXBcbiAgfVxuICAvLyBza2lwIHYtZWxzZSBibG9jaywgYnV0IG9ubHkgaWYgZm9sbG93aW5nIHYtaWZcbiAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgndi1lbHNlJykpIHtcbiAgICB2YXIgcHJldiA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmdcbiAgICBpZiAocHJldiAmJiBwcmV2Lmhhc0F0dHJpYnV0ZSgndi1pZicpKSB7XG4gICAgICByZXR1cm4gc2tpcFxuICAgIH1cbiAgfVxuICB2YXIgdmFsdWUsIGRpck5hbWVcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0ZXJtaW5hbERpcmVjdGl2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyTmFtZSA9IHRlcm1pbmFsRGlyZWN0aXZlc1tpXVxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgaWYgKHZhbHVlID0gZWwuZ2V0QXR0cmlidXRlKCd2LScgKyBkaXJOYW1lKSkge1xuICAgICAgcmV0dXJuIG1ha2VUZXJtaW5hbE5vZGVMaW5rRm4oZWwsIGRpck5hbWUsIHZhbHVlLCBvcHRpb25zKVxuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gIH1cbn1cblxuZnVuY3Rpb24gc2tpcCAoKSB7fVxuc2tpcC50ZXJtaW5hbCA9IHRydWVcblxuLyoqXG4gKiBCdWlsZCBhIG5vZGUgbGluayBmdW5jdGlvbiBmb3IgYSB0ZXJtaW5hbCBkaXJlY3RpdmUuXG4gKiBBIHRlcm1pbmFsIGxpbmsgZnVuY3Rpb24gdGVybWluYXRlcyB0aGUgY3VycmVudFxuICogY29tcGlsYXRpb24gcmVjdXJzaW9uIGFuZCBoYW5kbGVzIGNvbXBpbGF0aW9uIG9mIHRoZVxuICogc3VidHJlZSBpbiB0aGUgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBkaXJOYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW2RlZl1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0ZXJtaW5hbExpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VUZXJtaW5hbE5vZGVMaW5rRm4gKGVsLCBkaXJOYW1lLCB2YWx1ZSwgb3B0aW9ucywgZGVmKSB7XG4gIHZhciBwYXJzZWQgPSBkaXJQYXJzZXIucGFyc2UodmFsdWUpXG4gIHZhciBkZXNjcmlwdG9yID0ge1xuICAgIG5hbWU6IGRpck5hbWUsXG4gICAgZXhwcmVzc2lvbjogcGFyc2VkLmV4cHJlc3Npb24sXG4gICAgZmlsdGVyczogcGFyc2VkLmZpbHRlcnMsXG4gICAgcmF3OiB2YWx1ZSxcbiAgICAvLyBlaXRoZXIgYW4gZWxlbWVudCBkaXJlY3RpdmUsIG9yIGlmL2ZvclxuICAgIGRlZjogZGVmIHx8IHB1YmxpY0RpcmVjdGl2ZXNbZGlyTmFtZV1cbiAgfVxuICB2YXIgZm4gPSBmdW5jdGlvbiB0ZXJtaW5hbE5vZGVMaW5rRm4gKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICB2bS5fYmluZERpcihkZXNjcmlwdG9yLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpXG4gIH1cbiAgZm4udGVybWluYWwgPSB0cnVlXG4gIHJldHVybiBmblxufVxuXG4vKipcbiAqIENvbXBpbGUgdGhlIGRpcmVjdGl2ZXMgb24gYW4gZWxlbWVudCBhbmQgcmV0dXJuIGEgbGlua2VyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8TmFtZWROb2RlTWFwfSBhdHRyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVEaXJlY3RpdmVzIChhdHRycywgb3B0aW9ucykge1xuICB2YXIgaSA9IGF0dHJzLmxlbmd0aFxuICB2YXIgZGlycyA9IFtdXG4gIHZhciBhdHRyLCBuYW1lLCB2YWx1ZSwgcmF3TmFtZSwgcmF3VmFsdWUsIGRpck5hbWUsIGFyZywgbW9kaWZpZXJzLCBkaXJEZWYsIHRva2Vuc1xuICB3aGlsZSAoaS0tKSB7XG4gICAgYXR0ciA9IGF0dHJzW2ldXG4gICAgbmFtZSA9IHJhd05hbWUgPSBhdHRyLm5hbWVcbiAgICB2YWx1ZSA9IHJhd1ZhbHVlID0gYXR0ci52YWx1ZVxuICAgIHRva2VucyA9IHRleHRQYXJzZXIucGFyc2UodmFsdWUpXG4gICAgLy8gcmVzZXQgYXJnXG4gICAgYXJnID0gbnVsbFxuICAgIC8vIGNoZWNrIG1vZGlmaWVyc1xuICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJylcblxuICAgIC8vIGF0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uc1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIHZhbHVlID0gdGV4dFBhcnNlci50b2tlbnNUb0V4cCh0b2tlbnMpXG4gICAgICBhcmcgPSBuYW1lXG4gICAgICBwdXNoRGlyKCdiaW5kJywgcHVibGljRGlyZWN0aXZlcy5iaW5kLCB0cnVlKVxuICAgIH0gZWxzZVxuXG4gICAgLy8gc3BlY2lhbCBhdHRyaWJ1dGU6IHRyYW5zaXRpb25cbiAgICBpZiAodHJhbnNpdGlvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgIG1vZGlmaWVycy5saXRlcmFsID0gIWJpbmRSRS50ZXN0KG5hbWUpXG4gICAgICBwdXNoRGlyKCd0cmFuc2l0aW9uJywgaW50ZXJuYWxEaXJlY3RpdmVzLnRyYW5zaXRpb24pXG4gICAgfSBlbHNlXG5cbiAgICAvLyBldmVudCBoYW5kbGVyc1xuICAgIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgIGFyZyA9IG5hbWUucmVwbGFjZShvblJFLCAnJylcbiAgICAgIHB1c2hEaXIoJ29uJywgcHVibGljRGlyZWN0aXZlcy5vbilcbiAgICB9IGVsc2VcblxuICAgIC8vIGF0dHJpYnV0ZSBiaW5kaW5nc1xuICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkge1xuICAgICAgZGlyTmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKVxuICAgICAgaWYgKGRpck5hbWUgPT09ICdzdHlsZScgfHwgZGlyTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICBwdXNoRGlyKGRpck5hbWUsIGludGVybmFsRGlyZWN0aXZlc1tkaXJOYW1lXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZyA9IGRpck5hbWVcbiAgICAgICAgcHVzaERpcignYmluZCcsIHB1YmxpY0RpcmVjdGl2ZXMuYmluZClcbiAgICAgIH1cbiAgICB9IGVsc2VcblxuICAgIC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgaWYgKG5hbWUuaW5kZXhPZigndi0nKSA9PT0gMCkge1xuICAgICAgLy8gY2hlY2sgYXJnXG4gICAgICBhcmcgPSAoYXJnID0gbmFtZS5tYXRjaChhcmdSRSkpICYmIGFyZ1sxXVxuICAgICAgaWYgKGFyZykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGFyZ1JFLCAnJylcbiAgICAgIH1cbiAgICAgIC8vIGV4dHJhY3QgZGlyZWN0aXZlIG5hbWVcbiAgICAgIGRpck5hbWUgPSBuYW1lLnNsaWNlKDIpXG5cbiAgICAgIC8vIHNraXAgdi1lbHNlICh3aGVuIHVzZWQgd2l0aCB2LXNob3cpXG4gICAgICBpZiAoZGlyTmFtZSA9PT0gJ2Vsc2UnKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGRpckRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpck5hbWUpXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIF8uYXNzZXJ0QXNzZXQoZGlyRGVmLCAnZGlyZWN0aXZlJywgZGlyTmFtZSlcbiAgICAgIH1cblxuICAgICAgaWYgKGRpckRlZikge1xuICAgICAgICBpZiAoXy5pc0xpdGVyYWwodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSBfLnN0cmlwUXVvdGVzKHZhbHVlKVxuICAgICAgICAgIG1vZGlmaWVycy5saXRlcmFsID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHB1c2hEaXIoZGlyTmFtZSwgZGlyRGVmKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIGEgZGlyZWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyTmFtZVxuICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gZGVmXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ludGVycF1cbiAgICovXG5cbiAgZnVuY3Rpb24gcHVzaERpciAoZGlyTmFtZSwgZGVmLCBpbnRlcnApIHtcbiAgICB2YXIgcGFyc2VkID0gZGlyUGFyc2VyLnBhcnNlKHZhbHVlKVxuICAgIGRpcnMucHVzaCh7XG4gICAgICBuYW1lOiBkaXJOYW1lLFxuICAgICAgYXR0cjogcmF3TmFtZSxcbiAgICAgIHJhdzogcmF3VmFsdWUsXG4gICAgICBkZWY6IGRlZixcbiAgICAgIGFyZzogYXJnLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgICBleHByZXNzaW9uOiBwYXJzZWQuZXhwcmVzc2lvbixcbiAgICAgIGZpbHRlcnM6IHBhcnNlZC5maWx0ZXJzLFxuICAgICAgaW50ZXJwOiBpbnRlcnBcbiAgICB9KVxuICB9XG5cbiAgaWYgKGRpcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG1ha2VOb2RlTGlua0ZuKGRpcnMpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBtb2RpZmllcnMgZnJvbSBkaXJlY3RpdmUgYXR0cmlidXRlIG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpXG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBpID0gbWF0Y2gubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcmVzW21hdGNoW2ldLnNsaWNlKDEpXSA9IHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgbGluayBmdW5jdGlvbiBmb3IgYWxsIGRpcmVjdGl2ZXMgb24gYSBzaW5nbGUgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJlY3RpdmVzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gZGlyZWN0aXZlc0xpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VOb2RlTGlua0ZuIChkaXJlY3RpdmVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBub2RlTGlua0ZuICh2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgLy8gcmV2ZXJzZSBhcHBseSBiZWNhdXNlIGl0J3Mgc29ydGVkIGxvdyB0byBoaWdoXG4gICAgdmFyIGkgPSBkaXJlY3RpdmVzLmxlbmd0aFxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl9iaW5kRGlyKGRpcmVjdGl2ZXNbaV0sIGVsLCBob3N0LCBzY29wZSwgZnJhZylcbiAgICB9XG4gIH1cbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG5cbl8uZXh0ZW5kKGV4cG9ydHMsIHJlcXVpcmUoJy4vY29tcGlsZScpKVxuXy5leHRlbmQoZXhwb3J0cywgcmVxdWlyZSgnLi90cmFuc2NsdWRlJykpXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIHRlbXBsYXRlUGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2Vycy90ZW1wbGF0ZScpXG52YXIgc3BlY2lhbENoYXJSRSA9IC9bXlxcd1xcLTpcXC5dL1xuXG4vKipcbiAqIFByb2Nlc3MgYW4gZWxlbWVudCBvciBhIERvY3VtZW50RnJhZ21lbnQgYmFzZWQgb24gYVxuICogaW5zdGFuY2Ugb3B0aW9uIG9iamVjdC4gVGhpcyBhbGxvd3MgdXMgdG8gdHJhbnNjbHVkZVxuICogYSB0ZW1wbGF0ZSBub2RlL2ZyYWdtZW50IGJlZm9yZSB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCxcbiAqIHNvIHRoZSBwcm9jZXNzZWQgZnJhZ21lbnQgY2FuIHRoZW4gYmUgY2xvbmVkIGFuZCByZXVzZWRcbiAqIGluIHYtZm9yLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZXhwb3J0cy50cmFuc2NsdWRlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIC8vIGV4dHJhY3QgY29udGFpbmVyIGF0dHJpYnV0ZXMgdG8gcGFzcyB0aGVtIGRvd25cbiAgLy8gdG8gY29tcGlsZXIsIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIGNvbXBpbGVkIGluXG4gIC8vIHBhcmVudCBzY29wZS4gd2UgYXJlIG11dGF0aW5nIHRoZSBvcHRpb25zIG9iamVjdCBoZXJlXG4gIC8vIGFzc3VtaW5nIHRoZSBzYW1lIG9iamVjdCB3aWxsIGJlIHVzZWQgZm9yIGNvbXBpbGVcbiAgLy8gcmlnaHQgYWZ0ZXIgdGhpcy5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLl9jb250YWluZXJBdHRycyA9IGV4dHJhY3RBdHRycyhlbClcbiAgfVxuICAvLyBmb3IgdGVtcGxhdGUgdGFncywgd2hhdCB3ZSB3YW50IGlzIGl0cyBjb250ZW50IGFzXG4gIC8vIGEgZG9jdW1lbnRGcmFnbWVudCAoZm9yIGZyYWdtZW50IGluc3RhbmNlcylcbiAgaWYgKF8uaXNUZW1wbGF0ZShlbCkpIHtcbiAgICBlbCA9IHRlbXBsYXRlUGFyc2VyLnBhcnNlKGVsKVxuICB9XG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50ICYmICFvcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICBvcHRpb25zLnRlbXBsYXRlID0gJzxzbG90Pjwvc2xvdD4nXG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICBvcHRpb25zLl9jb250ZW50ID0gXy5leHRyYWN0Q29udGVudChlbClcbiAgICAgIGVsID0gdHJhbnNjbHVkZVRlbXBsYXRlKGVsLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuICBpZiAoZWwgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgLy8gYW5jaG9ycyBmb3IgZnJhZ21lbnQgaW5zdGFuY2VcbiAgICAvLyBwYXNzaW5nIGluIGBwZXJzaXN0OiB0cnVlYCB0byBhdm9pZCB0aGVtIGJlaW5nXG4gICAgLy8gZGlzY2FyZGVkIGJ5IElFIGR1cmluZyB0ZW1wbGF0ZSBjbG9uaW5nXG4gICAgXy5wcmVwZW5kKF8uY3JlYXRlQW5jaG9yKCd2LXN0YXJ0JywgdHJ1ZSksIGVsKVxuICAgIGVsLmFwcGVuZENoaWxkKF8uY3JlYXRlQW5jaG9yKCd2LWVuZCcsIHRydWUpKVxuICB9XG4gIHJldHVybiBlbFxufVxuXG4vKipcbiAqIFByb2Nlc3MgdGhlIHRlbXBsYXRlIG9wdGlvbi5cbiAqIElmIHRoZSByZXBsYWNlIG9wdGlvbiBpcyB0cnVlIHRoaXMgd2lsbCBzd2FwIHRoZSAkZWwuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2NsdWRlVGVtcGxhdGUgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGVcbiAgdmFyIGZyYWcgPSB0ZW1wbGF0ZVBhcnNlci5wYXJzZSh0ZW1wbGF0ZSwgdHJ1ZSlcbiAgaWYgKGZyYWcpIHtcbiAgICB2YXIgcmVwbGFjZXIgPSBmcmFnLmZpcnN0Q2hpbGRcbiAgICB2YXIgdGFnID0gcmVwbGFjZXIudGFnTmFtZSAmJiByZXBsYWNlci50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICBpZiAob3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgICAnWW91IGFyZSBtb3VudGluZyBhbiBpbnN0YW5jZSB3aXRoIGEgdGVtcGxhdGUgdG8gJyArXG4gICAgICAgICAgJzxib2R5Pi4gVGhpcyB3aWxsIHJlcGxhY2UgPGJvZHk+IGVudGlyZWx5LiBZb3UgJyArXG4gICAgICAgICAgJ3Nob3VsZCBwcm9iYWJseSB1c2UgYHJlcGxhY2U6IGZhbHNlYCBoZXJlLidcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgLy8gdGhlcmUgYXJlIG1hbnkgY2FzZXMgd2hlcmUgdGhlIGluc3RhbmNlIG11c3RcbiAgICAgIC8vIGJlY29tZSBhIGZyYWdtZW50IGluc3RhbmNlOiBiYXNpY2FsbHkgYW55dGhpbmcgdGhhdFxuICAgICAgLy8gY2FuIGNyZWF0ZSBtb3JlIHRoYW4gMSByb290IG5vZGVzLlxuICAgICAgaWYgKFxuICAgICAgICAvLyBtdWx0aS1jaGlsZHJlbiB0ZW1wbGF0ZVxuICAgICAgICBmcmFnLmNoaWxkTm9kZXMubGVuZ3RoID4gMSB8fFxuICAgICAgICAvLyBub24tZWxlbWVudCB0ZW1wbGF0ZVxuICAgICAgICByZXBsYWNlci5ub2RlVHlwZSAhPT0gMSB8fFxuICAgICAgICAvLyBzaW5nbGUgbmVzdGVkIGNvbXBvbmVudFxuICAgICAgICB0YWcgPT09ICdjb21wb25lbnQnIHx8XG4gICAgICAgIF8ucmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSB8fFxuICAgICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ2lzJykgfHxcbiAgICAgICAgcmVwbGFjZXIuaGFzQXR0cmlidXRlKCc6aXMnKSB8fFxuICAgICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ3YtYmluZDppcycpIHx8XG4gICAgICAgIC8vIGVsZW1lbnQgZGlyZWN0aXZlXG4gICAgICAgIF8ucmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdlbGVtZW50RGlyZWN0aXZlcycsIHRhZykgfHxcbiAgICAgICAgLy8gZm9yIGJsb2NrXG4gICAgICAgIHJlcGxhY2VyLmhhc0F0dHJpYnV0ZSgndi1mb3InKSB8fFxuICAgICAgICAvLyBpZiBibG9ja1xuICAgICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ3YtaWYnKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmcmFnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLl9yZXBsYWNlckF0dHJzID0gZXh0cmFjdEF0dHJzKHJlcGxhY2VyKVxuICAgICAgICBtZXJnZUF0dHJzKGVsLCByZXBsYWNlcilcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKGZyYWcpXG4gICAgICByZXR1cm4gZWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnSW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246ICcgKyB0ZW1wbGF0ZVxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB0byBleHRyYWN0IGEgY29tcG9uZW50IGNvbnRhaW5lcidzIGF0dHJpYnV0ZXNcbiAqIGludG8gYSBwbGFpbiBvYmplY3QgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gZXh0cmFjdEF0dHJzIChlbCkge1xuICBpZiAoZWwubm9kZVR5cGUgPT09IDEgJiYgZWwuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgcmV0dXJuIF8udG9BcnJheShlbC5hdHRyaWJ1dGVzKVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdGhlIGF0dHJpYnV0ZXMgb2YgdHdvIGVsZW1lbnRzLCBhbmQgbWFrZSBzdXJlXG4gKiB0aGUgY2xhc3MgbmFtZXMgYXJlIG1lcmdlZCBwcm9wZXJseS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGZyb21cbiAqIEBwYXJhbSB7RWxlbWVudH0gdG9cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZUF0dHJzIChmcm9tLCB0bykge1xuICB2YXIgYXR0cnMgPSBmcm9tLmF0dHJpYnV0ZXNcbiAgdmFyIGkgPSBhdHRycy5sZW5ndGhcbiAgdmFyIG5hbWUsIHZhbHVlXG4gIHdoaWxlIChpLS0pIHtcbiAgICBuYW1lID0gYXR0cnNbaV0ubmFtZVxuICAgIHZhbHVlID0gYXR0cnNbaV0udmFsdWVcbiAgICBpZiAoIXRvLmhhc0F0dHJpYnV0ZShuYW1lKSAmJiAhc3BlY2lhbENoYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICB0by5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICB2YWx1ZSA9IHRvLmdldEF0dHJpYnV0ZShuYW1lKSArICcgJyArIHZhbHVlXG4gICAgICB0by5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKipcbiAgICogV2hldGhlciB0byBwcmludCBkZWJ1ZyBtZXNzYWdlcy5cbiAgICogQWxzbyBlbmFibGVzIHN0YWNrIHRyYWNlIGZvciB3YXJuaW5ncy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIGRlYnVnOiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gdXNlIGFzeW5jIHJlbmRlcmluZy5cbiAgICovXG5cbiAgYXN5bmM6IHRydWUsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gd2FybiBhZ2FpbnN0IGVycm9ycyBjYXVnaHQgd2hlbiBldmFsdWF0aW5nXG4gICAqIGV4cHJlc3Npb25zLlxuICAgKi9cblxuICB3YXJuRXhwcmVzc2lvbkVycm9yczogdHJ1ZSxcblxuICAvKipcbiAgICogSW50ZXJuYWwgZmxhZyB0byBpbmRpY2F0ZSB0aGUgZGVsaW1pdGVycyBoYXZlIGJlZW5cbiAgICogY2hhbmdlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIF9kZWxpbWl0ZXJzQ2hhbmdlZDogdHJ1ZSxcblxuICAvKipcbiAgICogTGlzdCBvZiBhc3NldCB0eXBlcyB0aGF0IGEgY29tcG9uZW50IGNhbiBvd24uXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG5cbiAgX2Fzc2V0VHlwZXM6IFtcbiAgICAnY29tcG9uZW50JyxcbiAgICAnZGlyZWN0aXZlJyxcbiAgICAnZWxlbWVudERpcmVjdGl2ZScsXG4gICAgJ2ZpbHRlcicsXG4gICAgJ3RyYW5zaXRpb24nLFxuICAgICdwYXJ0aWFsJ1xuICBdLFxuXG4gIC8qKlxuICAgKiBwcm9wIGJpbmRpbmcgbW9kZXNcbiAgICovXG5cbiAgX3Byb3BCaW5kaW5nTW9kZXM6IHtcbiAgICBPTkVfV0FZOiAwLFxuICAgIFRXT19XQVk6IDEsXG4gICAgT05FX1RJTUU6IDJcbiAgfSxcblxuICAvKipcbiAgICogTWF4IGNpcmN1bGFyIHVwZGF0ZXMgYWxsb3dlZCBpbiBhIGJhdGNoZXIgZmx1c2ggY3ljbGUuXG4gICAqL1xuXG4gIF9tYXhVcGRhdGVDb3VudDogMTAwXG5cbn1cblxuLyoqXG4gKiBJbnRlcnBvbGF0aW9uIGRlbGltaXRlcnMuIENoYW5naW5nIHRoZXNlIHdvdWxkIHRyaWdnZXJcbiAqIHRoZSB0ZXh0IHBhcnNlciB0byByZS1jb21waWxlIHRoZSByZWd1bGFyIGV4cHJlc3Npb25zLlxuICpcbiAqIEB0eXBlIHtBcnJheTxTdHJpbmc+fVxuICovXG5cbnZhciBkZWxpbWl0ZXJzID0gWyd7eycsICd9fSddXG52YXIgdW5zYWZlRGVsaW1pdGVycyA9IFsne3t7JywgJ319fSddXG52YXIgdGV4dFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2Vycy90ZXh0JylcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAnZGVsaW1pdGVycycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRlbGltaXRlcnNcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgZGVsaW1pdGVycyA9IHZhbFxuICAgIHRleHRQYXJzZXIuY29tcGlsZVJlZ2V4KClcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAndW5zYWZlRGVsaW1pdGVycycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVuc2FmZURlbGltaXRlcnNcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdW5zYWZlRGVsaW1pdGVycyA9IHZhbFxuICAgIHRleHRQYXJzZXIuY29tcGlsZVJlZ2V4KClcbiAgfVxufSlcbiIsInZhciBfID0gcmVxdWlyZSgnLi91dGlsJylcbnZhciBXYXRjaGVyID0gcmVxdWlyZSgnLi93YXRjaGVyJylcbnZhciBleHBQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcnMvZXhwcmVzc2lvbicpXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgbGlua3MgYSBET00gZWxlbWVudCB3aXRoIGEgcGllY2Ugb2YgZGF0YSxcbiAqIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgZXZhbHVhdGluZyBhbiBleHByZXNzaW9uLlxuICogSXQgcmVnaXN0ZXJzIGEgd2F0Y2hlciB3aXRoIHRoZSBleHByZXNzaW9uIGFuZCBjYWxsc1xuICogdGhlIERPTSB1cGRhdGUgZnVuY3Rpb24gd2hlbiBhIGNoYW5nZSBpcyB0cmlnZ2VyZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0b3JcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IG5hbWVcbiAqICAgICAgICAgICAgICAgICAtIHtPYmplY3R9IGRlZlxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gZXhwcmVzc2lvblxuICogICAgICAgICAgICAgICAgIC0ge0FycmF5PE9iamVjdD59IFtmaWx0ZXJzXVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGxpdGVyYWxcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGF0dHJcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IHJhd1xuICogQHBhcmFtIHtPYmplY3R9IGRlZiAtIGRpcmVjdGl2ZSBkZWZpbml0aW9uIG9iamVjdFxuICogQHBhcmFtIHtWdWV9IFtob3N0XSAtIHRyYW5zY2x1c2lvbiBob3N0IGNvbXBvbmVudFxuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSB2LWZvciBzY29wZVxuICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddIC0gb3duZXIgZnJhZ21lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIERpcmVjdGl2ZSAoZGVzY3JpcHRvciwgdm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICB0aGlzLnZtID0gdm1cbiAgdGhpcy5lbCA9IGVsXG4gIC8vIGNvcHkgZGVzY3JpcHRvciBwcm9wZXJ0aWVzXG4gIHRoaXMuZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JcbiAgdGhpcy5uYW1lID0gZGVzY3JpcHRvci5uYW1lXG4gIHRoaXMuZXhwcmVzc2lvbiA9IGRlc2NyaXB0b3IuZXhwcmVzc2lvblxuICB0aGlzLmFyZyA9IGRlc2NyaXB0b3IuYXJnXG4gIHRoaXMubW9kaWZpZXJzID0gZGVzY3JpcHRvci5tb2RpZmllcnNcbiAgdGhpcy5maWx0ZXJzID0gZGVzY3JpcHRvci5maWx0ZXJzXG4gIHRoaXMubGl0ZXJhbCA9IHRoaXMubW9kaWZpZXJzICYmIHRoaXMubW9kaWZpZXJzLmxpdGVyYWxcbiAgLy8gcHJpdmF0ZVxuICB0aGlzLl9sb2NrZWQgPSBmYWxzZVxuICB0aGlzLl9ib3VuZCA9IGZhbHNlXG4gIHRoaXMuX2xpc3RlbmVycyA9IG51bGxcbiAgLy8gbGluayBjb250ZXh0XG4gIHRoaXMuX2hvc3QgPSBob3N0XG4gIHRoaXMuX3Njb3BlID0gc2NvcGVcbiAgdGhpcy5fZnJhZyA9IGZyYWdcbiAgLy8gc3RvcmUgZGlyZWN0aXZlcyBvbiBub2RlIGluIGRldiBtb2RlXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuZWwpIHtcbiAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcyA9IHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzIHx8IFtdXG4gICAgdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMucHVzaCh0aGlzKVxuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgZGlyZWN0aXZlLCBtaXhpbiBkZWZpbml0aW9uIHByb3BlcnRpZXMsXG4gKiBzZXR1cCB0aGUgd2F0Y2hlciwgY2FsbCBkZWZpbml0aW9uIGJpbmQoKSBhbmQgdXBkYXRlKClcbiAqIGlmIHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZlxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX2JpbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lXG4gIHZhciBkZXNjcmlwdG9yID0gdGhpcy5kZXNjcmlwdG9yXG5cbiAgLy8gcmVtb3ZlIGF0dHJpYnV0ZVxuICBpZiAoXG4gICAgKG5hbWUgIT09ICdjbG9haycgfHwgdGhpcy52bS5faXNDb21waWxlZCkgJiZcbiAgICB0aGlzLmVsICYmIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlXG4gICkge1xuICAgIHZhciBhdHRyID0gZGVzY3JpcHRvci5hdHRyIHx8ICgndi0nICsgbmFtZSlcbiAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKVxuICB9XG5cbiAgLy8gY29weSBkZWYgcHJvcGVydGllc1xuICB2YXIgZGVmID0gZGVzY3JpcHRvci5kZWZcbiAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLnVwZGF0ZSA9IGRlZlxuICB9IGVsc2Uge1xuICAgIF8uZXh0ZW5kKHRoaXMsIGRlZilcbiAgfVxuXG4gIC8vIHNldHVwIGRpcmVjdGl2ZSBwYXJhbXNcbiAgdGhpcy5fc2V0dXBQYXJhbXMoKVxuXG4gIC8vIGluaXRpYWwgYmluZFxuICBpZiAodGhpcy5iaW5kKSB7XG4gICAgdGhpcy5iaW5kKClcbiAgfVxuXG4gIGlmICh0aGlzLmxpdGVyYWwpIHtcbiAgICB0aGlzLnVwZGF0ZSAmJiB0aGlzLnVwZGF0ZShkZXNjcmlwdG9yLnJhdylcbiAgfSBlbHNlIGlmIChcbiAgICAodGhpcy5leHByZXNzaW9uIHx8IHRoaXMubW9kaWZpZXJzKSAmJlxuICAgICh0aGlzLnVwZGF0ZSB8fCB0aGlzLnR3b1dheSkgJiZcbiAgICAhdGhpcy5fY2hlY2tTdGF0ZW1lbnQoKVxuICApIHtcbiAgICAvLyB3cmFwcGVkIHVwZGF0ZXIgZm9yIGNvbnRleHRcbiAgICB2YXIgZGlyID0gdGhpc1xuICAgIGlmICh0aGlzLnVwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZhbCwgb2xkVmFsKSB7XG4gICAgICAgIGlmICghZGlyLl9sb2NrZWQpIHtcbiAgICAgICAgICBkaXIudXBkYXRlKHZhbCwgb2xkVmFsKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSA9IG5vb3BcbiAgICB9XG4gICAgdmFyIHByZVByb2Nlc3MgPSB0aGlzLl9wcmVQcm9jZXNzXG4gICAgICA/IF8uYmluZCh0aGlzLl9wcmVQcm9jZXNzLCB0aGlzKVxuICAgICAgOiBudWxsXG4gICAgdmFyIHBvc3RQcm9jZXNzID0gdGhpcy5fcG9zdFByb2Nlc3NcbiAgICAgID8gXy5iaW5kKHRoaXMuX3Bvc3RQcm9jZXNzLCB0aGlzKVxuICAgICAgOiBudWxsXG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl93YXRjaGVyID0gbmV3IFdhdGNoZXIoXG4gICAgICB0aGlzLnZtLFxuICAgICAgdGhpcy5leHByZXNzaW9uLFxuICAgICAgdGhpcy5fdXBkYXRlLCAvLyBjYWxsYmFja1xuICAgICAge1xuICAgICAgICBmaWx0ZXJzOiB0aGlzLmZpbHRlcnMsXG4gICAgICAgIHR3b1dheTogdGhpcy50d29XYXksXG4gICAgICAgIGRlZXA6IHRoaXMuZGVlcCxcbiAgICAgICAgcHJlUHJvY2VzczogcHJlUHJvY2VzcyxcbiAgICAgICAgcG9zdFByb2Nlc3M6IHBvc3RQcm9jZXNzLFxuICAgICAgICBzY29wZTogdGhpcy5fc2NvcGVcbiAgICAgIH1cbiAgICApXG4gICAgLy8gdi1tb2RlbCB3aXRoIGluaXRhbCBpbmxpbmUgdmFsdWUgbmVlZCB0byBzeW5jIGJhY2sgdG9cbiAgICAvLyBtb2RlbCBpbnN0ZWFkIG9mIHVwZGF0ZSB0byBET00gb24gaW5pdC4gVGhleSB3b3VsZFxuICAgIC8vIHNldCB0aGUgYWZ0ZXJCaW5kIGhvb2sgdG8gaW5kaWNhdGUgdGhhdC5cbiAgICBpZiAodGhpcy5hZnRlckJpbmQpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kKClcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZSh3YXRjaGVyLnZhbHVlKVxuICAgIH1cbiAgfVxuICB0aGlzLl9ib3VuZCA9IHRydWVcbn1cblxuLyoqXG4gKiBTZXR1cCBhbGwgcGFyYW0gYXR0cmlidXRlcywgZS5nLiB0cmFjay1ieSxcbiAqIHRyYW5zaXRpb24tbW9kZSwgZXRjLi4uXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fc2V0dXBQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5wYXJhbXMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXNcbiAgLy8gc3dhcCB0aGUgcGFyYW1zIGFycmF5IHdpdGggYSBmcmVzaCBvYmplY3QuXG4gIHRoaXMucGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICB2YXIgaSA9IHBhcmFtcy5sZW5ndGhcbiAgdmFyIGtleSwgdmFsLCBtYXBwZWRLZXlcbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IHBhcmFtc1tpXVxuICAgIG1hcHBlZEtleSA9IF8uY2FtZWxpemUoa2V5KVxuICAgIHZhbCA9IF8uZ2V0QmluZEF0dHIodGhpcy5lbCwga2V5KVxuICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgLy8gZHluYW1pY1xuICAgICAgdGhpcy5fc2V0dXBQYXJhbVdhdGNoZXIobWFwcGVkS2V5LCB2YWwpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN0YXRpY1xuICAgICAgdmFsID0gXy5hdHRyKHRoaXMuZWwsIGtleSlcbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnBhcmFtc1ttYXBwZWRLZXldID0gdmFsID09PSAnJyA/IHRydWUgOiB2YWxcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZXR1cCBhIHdhdGNoZXIgZm9yIGEgZHluYW1pYyBwYXJhbS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvblxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3NldHVwUGFyYW1XYXRjaGVyID0gZnVuY3Rpb24gKGtleSwgZXhwcmVzc2lvbikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gIHZhciB1bndhdGNoID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiR3YXRjaChleHByZXNzaW9uLCBmdW5jdGlvbiAodmFsLCBvbGRWYWwpIHtcbiAgICBzZWxmLnBhcmFtc1trZXldID0gdmFsXG4gICAgLy8gc2luY2Ugd2UgYXJlIGluIGltbWVkaWF0ZSBtb2RlLFxuICAgIC8vIG9ubHkgY2FsbCB0aGUgcGFyYW0gY2hhbmdlIGNhbGxiYWNrcyBpZiB0aGlzIGlzIG5vdCB0aGUgZmlyc3QgdXBkYXRlLlxuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHZhciBjYiA9IHNlbGYucGFyYW1XYXRjaGVycyAmJiBzZWxmLnBhcmFtV2F0Y2hlcnNba2V5XVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiLmNhbGwoc2VsZiwgdmFsLCBvbGRWYWwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxlZCA9IHRydWVcbiAgICB9XG4gIH0sIHtcbiAgICBpbW1lZGlhdGU6IHRydWVcbiAgfSlcbiAgOyh0aGlzLl9wYXJhbVVud2F0Y2hGbnMgfHwgKHRoaXMuX3BhcmFtVW53YXRjaEZucyA9IFtdKSkucHVzaCh1bndhdGNoKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBkaXJlY3RpdmUgaXMgYSBmdW5jdGlvbiBjYWxsZXJcbiAqIGFuZCBpZiB0aGUgZXhwcmVzc2lvbiBpcyBhIGNhbGxhYmxlIG9uZS4gSWYgYm90aCB0cnVlLFxuICogd2Ugd3JhcCB1cCB0aGUgZXhwcmVzc2lvbiBhbmQgdXNlIGl0IGFzIHRoZSBldmVudFxuICogaGFuZGxlci5cbiAqXG4gKiBlLmcuIG9uLWNsaWNrPVwiYSsrXCJcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX2NoZWNrU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvblxuICBpZiAoXG4gICAgZXhwcmVzc2lvbiAmJiB0aGlzLmFjY2VwdFN0YXRlbWVudCAmJlxuICAgICFleHBQYXJzZXIuaXNTaW1wbGVQYXRoKGV4cHJlc3Npb24pXG4gICkge1xuICAgIHZhciBmbiA9IGV4cFBhcnNlci5wYXJzZShleHByZXNzaW9uKS5nZXRcbiAgICB2YXIgc2NvcGUgPSB0aGlzLl9zY29wZSB8fCB0aGlzLnZtXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmbi5jYWxsKHNjb3BlLCBzY29wZSlcbiAgICB9XG4gICAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgICAgaGFuZGxlciA9IHNjb3BlLl9hcHBseUZpbHRlcnMoaGFuZGxlciwgbnVsbCwgdGhpcy5maWx0ZXJzKVxuICAgIH1cbiAgICB0aGlzLnVwZGF0ZShoYW5kbGVyKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgd2l0aCB0aGUgc2V0dGVyLlxuICogVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGluIHR3by13YXkgZGlyZWN0aXZlc1xuICogZS5nLiB2LW1vZGVsLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwdWJsaWNcbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy50d29XYXkpIHtcbiAgICB0aGlzLl93aXRoTG9jayhmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl93YXRjaGVyLnNldCh2YWx1ZSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBfLndhcm4oXG4gICAgICAnRGlyZWN0aXZlLnNldCgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHR3b1dheScgK1xuICAgICAgJ2RpcmVjdGl2ZXMuJ1xuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIEV4ZWN1dGUgYSBmdW5jdGlvbiB3aGlsZSBwcmV2ZW50aW5nIHRoYXQgZnVuY3Rpb24gZnJvbVxuICogdHJpZ2dlcmluZyB1cGRhdGVzIG9uIHRoaXMgZGlyZWN0aXZlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fd2l0aExvY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2xvY2tlZCA9IHRydWVcbiAgZm4uY2FsbChzZWxmKVxuICBfLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9sb2NrZWQgPSBmYWxzZVxuICB9KVxufVxuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF0dGFjaGVzIGEgRE9NIGV2ZW50IGxpc3RlbmVyXG4gKiB0byB0aGUgZGlyZWN0aXZlIGVsZW1lbnQgYW5kIGF1dG9tZXRpY2FsbHkgdGVhcnMgaXQgZG93blxuICogZHVyaW5nIHVuYmluZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyKSB7XG4gIF8ub24odGhpcy5lbCwgZXZlbnQsIGhhbmRsZXIpXG4gIDsodGhpcy5fbGlzdGVuZXJzIHx8ICh0aGlzLl9saXN0ZW5lcnMgPSBbXSkpXG4gICAgLnB1c2goW2V2ZW50LCBoYW5kbGVyXSlcbn1cblxuLyoqXG4gKiBUZWFyZG93biB0aGUgd2F0Y2hlciBhbmQgY2FsbCB1bmJpbmQuXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fdGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9ib3VuZCkge1xuICAgIHRoaXMuX2JvdW5kID0gZmFsc2VcbiAgICBpZiAodGhpcy51bmJpbmQpIHtcbiAgICAgIHRoaXMudW5iaW5kKClcbiAgICB9XG4gICAgaWYgKHRoaXMuX3dhdGNoZXIpIHtcbiAgICAgIHRoaXMuX3dhdGNoZXIudGVhcmRvd24oKVxuICAgIH1cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzXG4gICAgdmFyIGlcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICBpID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBfLm9mZih0aGlzLmVsLCBsaXN0ZW5lcnNbaV1bMF0sIGxpc3RlbmVyc1tpXVsxXSlcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVud2F0Y2hGbnMgPSB0aGlzLl9wYXJhbVVud2F0Y2hGbnNcbiAgICBpZiAodW53YXRjaEZucykge1xuICAgICAgaSA9IHVud2F0Y2hGbnMubGVuZ3RoXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHVud2F0Y2hGbnNbaV0oKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLmVsKSB7XG4gICAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcy4kcmVtb3ZlKHRoaXMpXG4gICAgfVxuICAgIHRoaXMudm0gPSB0aGlzLmVsID0gdGhpcy5fd2F0Y2hlciA9IHRoaXMuX2xpc3RlbmVycyA9IG51bGxcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpcmVjdGl2ZVxuIiwiZXhwb3J0cy5zbG90ID0gcmVxdWlyZSgnLi9zbG90JylcbmV4cG9ydHMucGFydGlhbCA9IHJlcXVpcmUoJy4vcGFydGlhbCcpXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIHZJZiA9IHJlcXVpcmUoJy4uL3B1YmxpYy9pZicpXG52YXIgRnJhZ21lbnRGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vZnJhZ21lbnQvZmFjdG9yeScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIHByaW9yaXR5OiAxNzUwLFxuXG4gIHBhcmFtczogWyduYW1lJ10sXG5cbiAgLy8gd2F0Y2ggY2hhbmdlcyB0byBuYW1lIGZvciBkeW5hbWljIHBhcnRpYWxzXG4gIHBhcmFtV2F0Y2hlcnM6IHtcbiAgICBuYW1lOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZJZi5yZW1vdmUuY2FsbCh0aGlzKVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0KHZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hbmNob3IgPSBfLmNyZWF0ZUFuY2hvcigndi1wYXJ0aWFsJylcbiAgICBfLnJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpXG4gICAgdGhpcy5pbnNlcnQodGhpcy5wYXJhbXMubmFtZSlcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBwYXJ0aWFsID0gXy5yZXNvbHZlQXNzZXQodGhpcy52bS4kb3B0aW9ucywgJ3BhcnRpYWxzJywgaWQpXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIF8uYXNzZXJ0QXNzZXQocGFydGlhbCwgJ3BhcnRpYWwnLCBpZClcbiAgICB9XG4gICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgIHRoaXMuZmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy52bSwgcGFydGlhbClcbiAgICAgIHZJZi5pbnNlcnQuY2FsbCh0aGlzKVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5mcmFnKSB7XG4gICAgICB0aGlzLmZyYWcuZGVzdHJveSgpXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIHRlbXBsYXRlUGFyc2VyID0gcmVxdWlyZSgnLi4vLi4vcGFyc2Vycy90ZW1wbGF0ZScpXG5cbi8vIFRoaXMgaXMgdGhlIGVsZW1lbnREaXJlY3RpdmUgdGhhdCBoYW5kbGVzIDxjb250ZW50PlxuLy8gdHJhbnNjbHVzaW9ucy4gSXQgcmVsaWVzIG9uIHRoZSByYXcgY29udGVudCBvZiBhblxuLy8gaW5zdGFuY2UgYmVpbmcgc3RvcmVkIGFzIGAkb3B0aW9ucy5fY29udGVudGAgZHVyaW5nXG4vLyB0aGUgdHJhbnNjbHVkZSBwaGFzZS5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcHJpb3JpdHk6IDE3NTAsXG5cbiAgcGFyYW1zOiBbJ25hbWUnXSxcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvc3QgPSB0aGlzLnZtXG4gICAgdmFyIHJhdyA9IGhvc3QuJG9wdGlvbnMuX2NvbnRlbnRcbiAgICB2YXIgY29udGVudFxuICAgIGlmICghcmF3KSB7XG4gICAgICB0aGlzLmZhbGxiYWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgY29udGV4dCA9IGhvc3QuX2NvbnRleHRcbiAgICB2YXIgc2xvdE5hbWUgPSB0aGlzLnBhcmFtcy5uYW1lXG4gICAgaWYgKCFzbG90TmFtZSkge1xuICAgICAgLy8gRGVmYXVsdCBjb250ZW50XG4gICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgIHZhciBjb21waWxlRGVmYXVsdENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuY29tcGlsZShcbiAgICAgICAgICBleHRyYWN0RnJhZ21lbnQocmF3LmNoaWxkTm9kZXMsIHJhdywgdHJ1ZSksXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBob3N0XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICghaG9zdC5faXNDb21waWxlZCkge1xuICAgICAgICAvLyBkZWZlciB1bnRpbCB0aGUgZW5kIG9mIGluc3RhbmNlIGNvbXBpbGF0aW9uLFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBkZWZhdWx0IG91dGxldCBtdXN0IHdhaXQgdW50aWwgYWxsXG4gICAgICAgIC8vIG90aGVyIHBvc3NpYmxlIG91dGxldHMgd2l0aCBzZWxlY3RvcnMgaGF2ZSBwaWNrZWRcbiAgICAgICAgLy8gb3V0IHRoZWlyIGNvbnRlbnRzLlxuICAgICAgICBob3N0LiRvbmNlKCdob29rOmNvbXBpbGVkJywgY29tcGlsZURlZmF1bHRDb250ZW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGlsZURlZmF1bHRDb250ZW50KClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlbGVjdG9yID0gJ1tzbG90PVwiJyArIHNsb3ROYW1lICsgJ1wiXSdcbiAgICAgIHZhciBub2RlcyA9IHJhdy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKVxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICBjb250ZW50ID0gZXh0cmFjdEZyYWdtZW50KG5vZGVzLCByYXcpXG4gICAgICAgIGlmIChjb250ZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIHRoaXMuY29tcGlsZShjb250ZW50LCBjb250ZXh0LCBob3N0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZmFsbGJhY2soKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZhbGxiYWNrKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZmFsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbXBpbGUoXy5leHRyYWN0Q29udGVudCh0aGlzLmVsLCB0cnVlKSwgdGhpcy52bSlcbiAgfSxcblxuICBjb21waWxlOiBmdW5jdGlvbiAoY29udGVudCwgY29udGV4dCwgaG9zdCkge1xuICAgIGlmIChjb250ZW50ICYmIGNvbnRleHQpIHtcbiAgICAgIHZhciBzY29wZSA9IGhvc3RcbiAgICAgICAgPyBob3N0Ll9zY29wZVxuICAgICAgICA6IHRoaXMuX3Njb3BlXG4gICAgICB0aGlzLnVubGluayA9IGNvbnRleHQuJGNvbXBpbGUoXG4gICAgICAgIGNvbnRlbnQsIGhvc3QsIHNjb3BlLCB0aGlzLl9mcmFnXG4gICAgICApXG4gICAgfVxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBfLnJlcGxhY2UodGhpcy5lbCwgY29udGVudClcbiAgICB9IGVsc2Uge1xuICAgICAgXy5yZW1vdmUodGhpcy5lbClcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudW5saW5rKSB7XG4gICAgICB0aGlzLnVubGluaygpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBxdWFsaWZpZWQgY29udGVudCBub2RlcyBmcm9tIGEgbm9kZSBsaXN0LlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFxuICogQHBhcmFtIHtCb29sZWFufSBtYWluXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RGcmFnbWVudCAobm9kZXMsIHBhcmVudCwgbWFpbikge1xuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV1cbiAgICAvLyBpZiB0aGlzIGlzIHRoZSBtYWluIG91dGxldCwgd2Ugd2FudCB0byBza2lwIGFsbFxuICAgIC8vIHByZXZpb3VzbHkgc2VsZWN0ZWQgbm9kZXM7XG4gICAgLy8gb3RoZXJ3aXNlLCB3ZSB3YW50IHRvIG1hcmsgdGhlIG5vZGUgYXMgc2VsZWN0ZWQuXG4gICAgLy8gY2xvbmUgdGhlIG5vZGUgc28gdGhlIG9yaWdpbmFsIHJhdyBjb250ZW50IHJlbWFpbnNcbiAgICAvLyBpbnRhY3QuIHRoaXMgZW5zdXJlcyBwcm9wZXIgcmUtY29tcGlsYXRpb24gaW4gY2FzZXNcbiAgICAvLyB3aGVyZSB0aGUgb3V0bGV0IGlzIGluc2lkZSBhIGNvbmRpdGlvbmFsIGJsb2NrXG4gICAgaWYgKG1haW4gJiYgIW5vZGUuX192X3NlbGVjdGVkKSB7XG4gICAgICBhcHBlbmQobm9kZSlcbiAgICB9IGVsc2UgaWYgKCFtYWluICYmIG5vZGUucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICBub2RlLl9fdl9zZWxlY3RlZCA9IHRydWVcbiAgICAgIGFwcGVuZChub2RlKVxuICAgIH1cbiAgfVxuICByZXR1cm4gZnJhZ1xuXG4gIGZ1bmN0aW9uIGFwcGVuZCAobm9kZSkge1xuICAgIGlmIChfLmlzVGVtcGxhdGUobm9kZSkgJiZcbiAgICAgICAgIW5vZGUuaGFzQXR0cmlidXRlKCd2LWlmJykgJiZcbiAgICAgICAgIW5vZGUuaGFzQXR0cmlidXRlKCd2LWZvcicpKSB7XG4gICAgICBub2RlID0gdGVtcGxhdGVQYXJzZXIucGFyc2Uobm9kZSlcbiAgICB9XG4gICAgbm9kZSA9IHRlbXBsYXRlUGFyc2VyLmNsb25lKG5vZGUpXG4gICAgZnJhZy5hcHBlbmRDaGlsZChub2RlKVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIGFkZENsYXNzID0gXy5hZGRDbGFzc1xudmFyIHJlbW92ZUNsYXNzID0gXy5yZW1vdmVDbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBkZWVwOiB0cnVlLFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHN0cmluZ1RvT2JqZWN0KHZhbHVlKSlcbiAgICB9IGVsc2UgaWYgKF8uaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlKVxuICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhpcy5oYW5kbGVBcnJheSh2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhbnVwKClcbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlT2JqZWN0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNsZWFudXAodmFsdWUpXG4gICAgdmFyIGtleXMgPSB0aGlzLnByZXZLZXlzID0gT2JqZWN0LmtleXModmFsdWUpXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuZWwsIGtleSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIGtleSlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlQXJyYXk6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuY2xlYW51cCh2YWx1ZSlcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHZhbHVlW2ldKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuZWwsIHZhbHVlW2ldKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByZXZLZXlzID0gdmFsdWUuc2xpY2UoKVxuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnByZXZLZXlzKSB7XG4gICAgICB2YXIgaSA9IHRoaXMucHJldktleXMubGVuZ3RoXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLnByZXZLZXlzW2ldXG4gICAgICAgIGlmIChrZXkgJiYgKCF2YWx1ZSB8fCAhY29udGFpbnModmFsdWUsIGtleSkpKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwga2V5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvT2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0ge31cbiAgdmFyIGtleXMgPSB2YWx1ZS50cmltKCkuc3BsaXQoL1xccysvKVxuICB2YXIgaSA9IGtleXMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXNba2V5c1tpXV0gPSB0cnVlXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjb250YWlucyAodmFsdWUsIGtleSkge1xuICByZXR1cm4gXy5pc0FycmF5KHZhbHVlKVxuICAgID8gdmFsdWUuaW5kZXhPZihrZXkpID4gLTFcbiAgICA6IHZhbHVlLmhhc093blByb3BlcnR5KGtleSlcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG52YXIgdGVtcGxhdGVQYXJzZXIgPSByZXF1aXJlKCcuLi8uLi9wYXJzZXJzL3RlbXBsYXRlJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcHJpb3JpdHk6IDE1MDAsXG5cbiAgcGFyYW1zOiBbXG4gICAgJ2tlZXAtYWxpdmUnLFxuICAgICd0cmFuc2l0aW9uLW1vZGUnLFxuICAgICdpbmxpbmUtdGVtcGxhdGUnXG4gIF0sXG5cbiAgLyoqXG4gICAqIFNldHVwLiBUd28gcG9zc2libGUgdXNhZ2VzOlxuICAgKlxuICAgKiAtIHN0YXRpYzpcbiAgICogICA8Y29tcD4gb3IgPGRpdiB2LWNvbXBvbmVudD1cImNvbXBcIj5cbiAgICpcbiAgICogLSBkeW5hbWljOlxuICAgKiAgIDxjb21wb25lbnQgOmlzPVwidmlld1wiPlxuICAgKi9cblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmVsLl9fdnVlX18pIHtcbiAgICAgIC8vIGNoZWNrIHJlZlxuICAgICAgdGhpcy5yZWYgPSBfLmZpbmRSZWYodGhpcy5lbClcbiAgICAgIHZhciByZWZzID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRyZWZzXG4gICAgICBpZiAodGhpcy5yZWYgJiYgIXJlZnMuaGFzT3duUHJvcGVydHkodGhpcy5yZWYpKSB7XG4gICAgICAgIF8uZGVmaW5lUmVhY3RpdmUocmVmcywgdGhpcy5yZWYsIG51bGwpXG4gICAgICB9XG4gICAgICAvLyBrZWVwLWFsaXZlIGNhY2hlXG4gICAgICB0aGlzLmtlZXBBbGl2ZSA9IHRoaXMucGFyYW1zLmtlZXBBbGl2ZVxuICAgICAgaWYgKHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fVxuICAgICAgfVxuICAgICAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlXG4gICAgICBpZiAodGhpcy5wYXJhbXMuaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgICAgLy8gZXh0cmFjdCBpbmxpbmUgdGVtcGxhdGUgYXMgYSBEb2N1bWVudEZyYWdtZW50XG4gICAgICAgIHRoaXMuaW5saW5lVGVtcGxhdGUgPSBfLmV4dHJhY3RDb250ZW50KHRoaXMuZWwsIHRydWUpXG4gICAgICB9XG4gICAgICAvLyBjb21wb25lbnQgcmVzb2x1dGlvbiByZWxhdGVkIHN0YXRlXG4gICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYiA9XG4gICAgICB0aGlzLkNvbXBvbmVudCA9IG51bGxcbiAgICAgIC8vIHRyYW5zaXRpb24gcmVsYXRlZCBzdGF0ZVxuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHMgPSAwXG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFsQ2IgPSBudWxsXG4gICAgICAvLyBjaGVjayBkeW5hbWljIGNvbXBvbmVudCBwYXJhbXNcbiAgICAgICAgLy8gY3JlYXRlIGEgcmVmIGFuY2hvclxuICAgICAgdGhpcy5hbmNob3IgPSBfLmNyZWF0ZUFuY2hvcigndi1jb21wb25lbnQnKVxuICAgICAgXy5yZXBsYWNlKHRoaXMuZWwsIHRoaXMuYW5jaG9yKVxuICAgICAgLy8gaWYgc3RhdGljLCBidWlsZCByaWdodCBub3cuXG4gICAgICBpZiAodGhpcy5saXRlcmFsKSB7XG4gICAgICAgIHRoaXMuc2V0Q29tcG9uZW50KHRoaXMuZXhwcmVzc2lvbilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICdjYW5ub3QgbW91bnQgY29tcG9uZW50IFwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiAnICtcbiAgICAgICAgJ29uIGFscmVhZHkgbW91bnRlZCBlbGVtZW50OiAnICsgdGhpcy5lbFxuICAgICAgKVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUHVibGljIHVwZGF0ZSwgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyIGluIHRoZSBkeW5hbWljXG4gICAqIGxpdGVyYWwgc2NlbmFyaW8sIGUuZy4gPGNvbXBvbmVudCA6aXM9XCJ2aWV3XCI+XG4gICAqL1xuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmxpdGVyYWwpIHtcbiAgICAgIHRoaXMuc2V0Q29tcG9uZW50KHZhbHVlKVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU3dpdGNoIGR5bmFtaWMgY29tcG9uZW50cy4gTWF5IHJlc29sdmUgdGhlIGNvbXBvbmVudFxuICAgKiBhc3luY2hyb25vdXNseSwgYW5kIHBlcmZvcm0gdHJhbnNpdGlvbiBiYXNlZCBvblxuICAgKiBzcGVjaWZpZWQgdHJhbnNpdGlvbiBtb2RlLiBBY2NlcHRzIGEgZmV3IGFkZGl0aW9uYWxcbiAgICogYXJndW1lbnRzIHNwZWNpZmljYWxseSBmb3IgdnVlLXJvdXRlci5cbiAgICpcbiAgICogVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBmdWxsIHRyYW5zaXRpb24gaXNcbiAgICogZmluaXNoZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIHNldENvbXBvbmVudDogZnVuY3Rpb24gKHZhbHVlLCBjYikge1xuICAgIHRoaXMuaW52YWxpZGF0ZVBlbmRpbmcoKVxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIC8vIGp1c3QgcmVtb3ZlIGN1cnJlbnRcbiAgICAgIHRoaXMudW5idWlsZCh0cnVlKVxuICAgICAgdGhpcy5yZW1vdmUodGhpcy5jaGlsZFZNLCBjYilcbiAgICAgIHRoaXMuY2hpbGRWTSA9IG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICB0aGlzLnJlc29sdmVDb21wb25lbnQodmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5tb3VudENvbXBvbmVudChjYilcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSBjb21wb25lbnQgY29uc3RydWN0b3IgdG8gdXNlIHdoZW4gY3JlYXRpbmdcbiAgICogdGhlIGNoaWxkIHZtLlxuICAgKi9cblxuICByZXNvbHZlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSBfLmNhbmNlbGxhYmxlKGZ1bmN0aW9uIChDb21wb25lbnQpIHtcbiAgICAgIHNlbGYuQ29tcG9uZW50TmFtZSA9IENvbXBvbmVudC5vcHRpb25zLm5hbWUgfHwgaWRcbiAgICAgIHNlbGYuQ29tcG9uZW50ID0gQ29tcG9uZW50XG4gICAgICBjYigpXG4gICAgfSlcbiAgICB0aGlzLnZtLl9yZXNvbHZlQ29tcG9uZW50KGlkLCB0aGlzLnBlbmRpbmdDb21wb25lbnRDYilcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIHVzaW5nIHRoZSBjdXJyZW50IGNvbnN0cnVjdG9yIGFuZFxuICAgKiByZXBsYWNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS4gVGhpcyBtZXRob2QgZG9lc24ndCBjYXJlXG4gICAqIHdoZXRoZXIgdGhlIG5ldyBjb21wb25lbnQgYW5kIHRoZSBvbGQgb25lIGFyZSBhY3R1YWxseVxuICAgKiB0aGUgc2FtZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGNiKSB7XG4gICAgLy8gYWN0dWFsIG1vdW50XG4gICAgdGhpcy51bmJ1aWxkKHRydWUpXG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgdmFyIGFjdGl2YXRlSG9vayA9IHRoaXMuQ29tcG9uZW50Lm9wdGlvbnMuYWN0aXZhdGVcbiAgICB2YXIgY2FjaGVkID0gdGhpcy5nZXRDYWNoZWQoKVxuICAgIHZhciBuZXdDb21wb25lbnQgPSB0aGlzLmJ1aWxkKClcbiAgICBpZiAoYWN0aXZhdGVIb29rICYmICFjYWNoZWQpIHtcbiAgICAgIHRoaXMud2FpdGluZ0ZvciA9IG5ld0NvbXBvbmVudFxuICAgICAgYWN0aXZhdGVIb29rLmNhbGwobmV3Q29tcG9uZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYud2FpdGluZ0ZvciA9IG51bGxcbiAgICAgICAgc2VsZi50cmFuc2l0aW9uKG5ld0NvbXBvbmVudCwgY2IpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24obmV3Q29tcG9uZW50LCBjYilcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNvbXBvbmVudCBjaGFuZ2VzIG9yIHVuYmluZHMgYmVmb3JlIGFuIGFzeW5jXG4gICAqIGNvbnN0cnVjdG9yIGlzIHJlc29sdmVkLCB3ZSBuZWVkIHRvIGludmFsaWRhdGUgaXRzXG4gICAqIHBlbmRpbmcgY2FsbGJhY2suXG4gICAqL1xuXG4gIGludmFsaWRhdGVQZW5kaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NvbXBvbmVudENiKSB7XG4gICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYi5jYW5jZWwoKVxuICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSBudWxsXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZS9pbnNlcnQgYSBuZXcgY2hpbGQgdm0uXG4gICAqIElmIGtlZXAgYWxpdmUgYW5kIGhhcyBjYWNoZWQgaW5zdGFuY2UsIGluc2VydCB0aGF0XG4gICAqIGluc3RhbmNlOyBvdGhlcndpc2UgYnVpbGQgYSBuZXcgb25lIGFuZCBjYWNoZSBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRyYU9wdGlvbnNdXG4gICAqIEByZXR1cm4ge1Z1ZX0gLSB0aGUgY3JlYXRlZCBpbnN0YW5jZVxuICAgKi9cblxuICBidWlsZDogZnVuY3Rpb24gKGV4dHJhT3B0aW9ucykge1xuICAgIHZhciBjYWNoZWQgPSB0aGlzLmdldENhY2hlZCgpXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFxuICAgIH1cbiAgICBpZiAodGhpcy5Db21wb25lbnQpIHtcbiAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIG5hbWU6IHRoaXMuQ29tcG9uZW50TmFtZSxcbiAgICAgICAgZWw6IHRlbXBsYXRlUGFyc2VyLmNsb25lKHRoaXMuZWwpLFxuICAgICAgICB0ZW1wbGF0ZTogdGhpcy5pbmxpbmVUZW1wbGF0ZSxcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGFkZCB0aGUgY2hpbGQgd2l0aCBjb3JyZWN0IHBhcmVudFxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNjbHVkZWQgY29tcG9uZW50LCBpdHMgcGFyZW50XG4gICAgICAgIC8vIHNob3VsZCBiZSB0aGUgdHJhbnNjbHVzaW9uIGhvc3QuXG4gICAgICAgIHBhcmVudDogdGhpcy5faG9zdCB8fCB0aGlzLnZtLFxuICAgICAgICAvLyBpZiBubyBpbmxpbmUtdGVtcGxhdGUsIHRoZW4gdGhlIGNvbXBpbGVkXG4gICAgICAgIC8vIGxpbmtlciBjYW4gYmUgY2FjaGVkIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAgICAgIF9saW5rZXJDYWNoYWJsZTogIXRoaXMuaW5saW5lVGVtcGxhdGUsXG4gICAgICAgIF9yZWY6IHRoaXMucmVmLFxuICAgICAgICBfYXNDb21wb25lbnQ6IHRydWUsXG4gICAgICAgIF9pc1JvdXRlclZpZXc6IHRoaXMuX2lzUm91dGVyVmlldyxcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHRyYW5zY2x1ZGVkIGNvbXBvbmVudCwgY29udGV4dFxuICAgICAgICAvLyB3aWxsIGJlIHRoZSBjb21tb24gcGFyZW50IHZtIG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgLy8gYW5kIGl0cyBob3N0LlxuICAgICAgICBfY29udGV4dDogdGhpcy52bSxcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBpbnNpZGUgYW4gaW5saW5lIHYtZm9yLCB0aGUgc2NvcGVcbiAgICAgICAgLy8gd2lsbCBiZSB0aGUgaW50ZXJtZWRpYXRlIHNjb3BlIGNyZWF0ZWQgZm9yIHRoaXNcbiAgICAgICAgLy8gcmVwZWF0IGZyYWdtZW50LiB0aGlzIGlzIHVzZWQgZm9yIGxpbmtpbmcgcHJvcHNcbiAgICAgICAgLy8gYW5kIGNvbnRhaW5lciBkaXJlY3RpdmVzLlxuICAgICAgICBfc2NvcGU6IHRoaXMuX3Njb3BlLFxuICAgICAgICAvLyBwYXNzIGluIHRoZSBvd25lciBmcmFnbWVudCBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3Nhcnkgc28gdGhhdCB0aGUgZnJhZ21lbnQgY2FuIGtlZXBcbiAgICAgICAgLy8gdHJhY2sgb2YgaXRzIGNvbnRhaW5lZCBjb21wb25lbnRzIGluIG9yZGVyIHRvXG4gICAgICAgIC8vIGNhbGwgYXR0YWNoL2RldGFjaCBob29rcyBmb3IgdGhlbS5cbiAgICAgICAgX2ZyYWc6IHRoaXMuX2ZyYWdcbiAgICAgIH1cbiAgICAgIC8vIGV4dHJhIG9wdGlvbnNcbiAgICAgIC8vIGluIDEuMC4wIHRoaXMgaXMgdXNlZCBieSB2dWUtcm91dGVyIG9ubHlcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGV4dHJhT3B0aW9ucykge1xuICAgICAgICBfLmV4dGVuZChvcHRpb25zLCBleHRyYU9wdGlvbnMpXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5Db21wb25lbnQob3B0aW9ucylcbiAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgICB0aGlzLmNhY2hlW3RoaXMuQ29tcG9uZW50LmNpZF0gPSBjaGlsZFxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIHRoaXMuZWwuaGFzQXR0cmlidXRlKCd0cmFuc2l0aW9uJykgJiZcbiAgICAgICAgICBjaGlsZC5faXNGcmFnbWVudCkge1xuICAgICAgICBfLndhcm4oXG4gICAgICAgICAgJ1RyYW5zaXRpb25zIHdpbGwgbm90IHdvcmsgb24gYSBmcmFnbWVudCBpbnN0YW5jZS4gJyArXG4gICAgICAgICAgJ1RlbXBsYXRlOiAnICsgY2hpbGQuJG9wdGlvbnMudGVtcGxhdGVcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUcnkgdG8gZ2V0IGEgY2FjaGVkIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHJldHVybiB7VnVlfHVuZGVmaW5lZH1cbiAgICovXG5cbiAgZ2V0Q2FjaGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMua2VlcEFsaXZlICYmIHRoaXMuY2FjaGVbdGhpcy5Db21wb25lbnQuY2lkXVxuICB9LFxuXG4gIC8qKlxuICAgKiBUZWFyZG93biB0aGUgY3VycmVudCBjaGlsZCwgYnV0IGRlZmVycyBjbGVhbnVwIHNvXG4gICAqIHRoYXQgd2UgY2FuIHNlcGFyYXRlIHRoZSBkZXN0cm95IGFuZCByZW1vdmFsIHN0ZXBzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZmVyXG4gICAqL1xuXG4gIHVuYnVpbGQ6IGZ1bmN0aW9uIChkZWZlcikge1xuICAgIGlmICh0aGlzLndhaXRpbmdGb3IpIHtcbiAgICAgIHRoaXMud2FpdGluZ0Zvci4kZGVzdHJveSgpXG4gICAgICB0aGlzLndhaXRpbmdGb3IgPSBudWxsXG4gICAgfVxuICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRWTVxuICAgIGlmICghY2hpbGQgfHwgdGhpcy5rZWVwQWxpdmUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyB0aGUgc29sZSBwdXJwb3NlIG9mIGBkZWZlckNsZWFudXBgIGlzIHNvIHRoYXQgd2UgY2FuXG4gICAgLy8gXCJkZWFjdGl2YXRlXCIgdGhlIHZtIHJpZ2h0IG5vdyBhbmQgcGVyZm9ybSBET00gcmVtb3ZhbFxuICAgIC8vIGxhdGVyLlxuICAgIGNoaWxkLiRkZXN0cm95KGZhbHNlLCBkZWZlcilcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGN1cnJlbnQgZGVzdHJveWVkIGNoaWxkIGFuZCBtYW51YWxseSBkb1xuICAgKiB0aGUgY2xlYW51cCBhZnRlciByZW1vdmFsLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICByZW1vdmU6IGZ1bmN0aW9uIChjaGlsZCwgY2IpIHtcbiAgICB2YXIga2VlcEFsaXZlID0gdGhpcy5rZWVwQWxpdmVcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIC8vIHdlIG1heSBoYXZlIGEgY29tcG9uZW50IHN3aXRjaCB3aGVuIGEgcHJldmlvdXNcbiAgICAgIC8vIGNvbXBvbmVudCBpcyBzdGlsbCBiZWluZyB0cmFuc2l0aW9uZWQgb3V0LlxuICAgICAgLy8gd2Ugd2FudCB0byB0cmlnZ2VyIG9ubHkgb25lIGxhc3Rlc3QgaW5zZXJ0aW9uIGNiXG4gICAgICAvLyB3aGVuIHRoZSBleGlzdGluZyB0cmFuc2l0aW9uIGZpbmlzaGVzLiAoIzExMTkpXG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFscysrXG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFsQ2IgPSBjYlxuICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICBjaGlsZC4kcmVtb3ZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wZW5kaW5nUmVtb3ZhbHMtLVxuICAgICAgICBpZiAoIWtlZXBBbGl2ZSkgY2hpbGQuX2NsZWFudXAoKVxuICAgICAgICBpZiAoIXNlbGYucGVuZGluZ1JlbW92YWxzICYmIHNlbGYucGVuZGluZ1JlbW92YWxDYikge1xuICAgICAgICAgIHNlbGYucGVuZGluZ1JlbW92YWxDYigpXG4gICAgICAgICAgc2VsZi5wZW5kaW5nUmVtb3ZhbENiID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKClcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFjdHVhbGx5IHN3YXAgdGhlIGNvbXBvbmVudHMsIGRlcGVuZGluZyBvbiB0aGVcbiAgICogdHJhbnNpdGlvbiBtb2RlLiBEZWZhdWx0cyB0byBzaW11bHRhbmVvdXMuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICB0cmFuc2l0aW9uOiBmdW5jdGlvbiAodGFyZ2V0LCBjYikge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jaGlsZFZNXG4gICAgLy8gZm9yIGRldnRvb2wgaW5zcGVjdGlvblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY3VycmVudCkgY3VycmVudC5faW5hY3RpdmUgPSB0cnVlXG4gICAgICB0YXJnZXQuX2luYWN0aXZlID0gZmFsc2VcbiAgICB9XG4gICAgdGhpcy5jaGlsZFZNID0gdGFyZ2V0XG4gICAgc3dpdGNoIChzZWxmLnBhcmFtcy50cmFuc2l0aW9uTW9kZSkge1xuICAgICAgY2FzZSAnaW4tb3V0JzpcbiAgICAgICAgdGFyZ2V0LiRiZWZvcmUoc2VsZi5hbmNob3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLnJlbW92ZShjdXJyZW50LCBjYilcbiAgICAgICAgfSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ291dC1pbic6XG4gICAgICAgIHNlbGYucmVtb3ZlKGN1cnJlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgY2IpXG4gICAgICAgIH0pXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzZWxmLnJlbW92ZShjdXJyZW50KVxuICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgY2IpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVbmJpbmQuXG4gICAqL1xuXG4gIHVuYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaW52YWxpZGF0ZVBlbmRpbmcoKVxuICAgIC8vIERvIG5vdCBkZWZlciBjbGVhbnVwIHdoZW4gdW5iaW5kaW5nXG4gICAgdGhpcy51bmJ1aWxkKClcbiAgICAvLyBkZXN0cm95IGFsbCBrZWVwLWFsaXZlIGNhY2hlZCBpbnN0YW5jZXNcbiAgICBpZiAodGhpcy5jYWNoZSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldLiRkZXN0cm95KClcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUgPSBudWxsXG4gICAgfVxuICB9XG59XG4iLCJleHBvcnRzLnN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpXG5leHBvcnRzWydjbGFzcyddID0gcmVxdWlyZSgnLi9jbGFzcycpXG5leHBvcnRzLmNvbXBvbmVudCA9IHJlcXVpcmUoJy4vY29tcG9uZW50JylcbmV4cG9ydHMucHJvcCA9IHJlcXVpcmUoJy4vcHJvcCcpXG5leHBvcnRzLnRyYW5zaXRpb24gPSByZXF1aXJlKCcuL3RyYW5zaXRpb24nKVxuIiwiLy8gTk9URTogdGhlIHByb3AgaW50ZXJuYWwgZGlyZWN0aXZlIGlzIGNvbXBpbGVkIGFuZCBsaW5rZWRcbi8vIGR1cmluZyBfaW5pdFNjb3BlKCksIGJlZm9yZSB0aGUgY3JlYXRlZCBob29rIGlzIGNhbGxlZC5cbi8vIFRoZSBwdXJwb3NlIGlzIHRvIG1ha2UgdGhlIGluaXRpYWwgcHJvcCB2YWx1ZXMgYXZhaWxhYmxlXG4vLyBpbnNpZGUgYGNyZWF0ZWRgIGhvb2tzIGFuZCBgZGF0YWAgZnVuY3Rpb25zLlxuXG52YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIFdhdGNoZXIgPSByZXF1aXJlKCcuLi8uLi93YXRjaGVyJylcbnZhciBiaW5kaW5nTW9kZXMgPSByZXF1aXJlKCcuLi8uLi9jb25maWcnKS5fcHJvcEJpbmRpbmdNb2Rlc1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgY2hpbGQgPSB0aGlzLnZtXG4gICAgdmFyIHBhcmVudCA9IGNoaWxkLl9jb250ZXh0XG4gICAgLy8gcGFzc2VkIGluIGZyb20gY29tcGlsZXIgZGlyZWN0bHlcbiAgICB2YXIgcHJvcCA9IHRoaXMuZGVzY3JpcHRvci5wcm9wXG4gICAgdmFyIGNoaWxkS2V5ID0gcHJvcC5wYXRoXG4gICAgdmFyIHBhcmVudEtleSA9IHByb3AucGFyZW50UGF0aFxuICAgIHZhciB0d29XYXkgPSBwcm9wLm1vZGUgPT09IGJpbmRpbmdNb2Rlcy5UV09fV0FZXG5cbiAgICB2YXIgcGFyZW50V2F0Y2hlciA9IHRoaXMucGFyZW50V2F0Y2hlciA9IG5ldyBXYXRjaGVyKFxuICAgICAgcGFyZW50LFxuICAgICAgcGFyZW50S2V5LFxuICAgICAgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBpZiAoXy5hc3NlcnRQcm9wKHByb3AsIHZhbCkpIHtcbiAgICAgICAgICBjaGlsZFtjaGlsZEtleV0gPSB2YWxcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0d29XYXk6IHR3b1dheSxcbiAgICAgICAgZmlsdGVyczogcHJvcC5maWx0ZXJzLFxuICAgICAgICAvLyBpbXBvcnRhbnQ6IHByb3BzIG5lZWQgdG8gYmUgb2JzZXJ2ZWQgb24gdGhlXG4gICAgICAgIC8vIHYtZm9yIHNjb3BlIGlmIHByZXNlbnRcbiAgICAgICAgc2NvcGU6IHRoaXMuX3Njb3BlXG4gICAgICB9XG4gICAgKVxuXG4gICAgLy8gc2V0IHRoZSBjaGlsZCBpbml0aWFsIHZhbHVlLlxuICAgIF8uaW5pdFByb3AoY2hpbGQsIHByb3AsIHBhcmVudFdhdGNoZXIudmFsdWUpXG5cbiAgICAvLyBzZXR1cCB0d28td2F5IGJpbmRpbmdcbiAgICBpZiAodHdvV2F5KSB7XG4gICAgICAvLyBpbXBvcnRhbnQ6IGRlZmVyIHRoZSBjaGlsZCB3YXRjaGVyIGNyZWF0aW9uIHVudGlsXG4gICAgICAvLyB0aGUgY3JlYXRlZCBob29rIChhZnRlciBkYXRhIG9ic2VydmF0aW9uKVxuICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICBjaGlsZC4kb25jZSgnaG9vazpjcmVhdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmNoaWxkV2F0Y2hlciA9IG5ldyBXYXRjaGVyKFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIGNoaWxkS2V5LFxuICAgICAgICAgIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHBhcmVudFdhdGNoZXIuc2V0KHZhbClcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGFyZW50V2F0Y2hlci50ZWFyZG93bigpXG4gICAgaWYgKHRoaXMuY2hpbGRXYXRjaGVyKSB7XG4gICAgICB0aGlzLmNoaWxkV2F0Y2hlci50ZWFyZG93bigpXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIHByZWZpeGVzID0gWyctd2Via2l0LScsICctbW96LScsICctbXMtJ11cbnZhciBjYW1lbFByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ11cbnZhciBpbXBvcnRhbnRSRSA9IC8haW1wb3J0YW50Oz8kL1xudmFyIHRlc3RFbCA9IG51bGxcbnZhciBwcm9wQ2FjaGUgPSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBkZWVwOiB0cnVlLFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuZWwuc3R5bGUuY3NzVGV4dCA9IHZhbHVlXG4gICAgfSBlbHNlIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZS5yZWR1Y2UoXy5leHRlbmQsIHt9KSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVPYmplY3QodmFsdWUgfHwge30pXG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZU9iamVjdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gY2FjaGUgb2JqZWN0IHN0eWxlcyBzbyB0aGF0IG9ubHkgY2hhbmdlZCBwcm9wc1xuICAgIC8vIGFyZSBhY3R1YWxseSB1cGRhdGVkLlxuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUgfHwgKHRoaXMuY2FjaGUgPSB7fSlcbiAgICB2YXIgbmFtZSwgdmFsXG4gICAgZm9yIChuYW1lIGluIGNhY2hlKSB7XG4gICAgICBpZiAoIShuYW1lIGluIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZShuYW1lLCBudWxsKVxuICAgICAgICBkZWxldGUgY2FjaGVbbmFtZV1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChuYW1lIGluIHZhbHVlKSB7XG4gICAgICB2YWwgPSB2YWx1ZVtuYW1lXVxuICAgICAgaWYgKHZhbCAhPT0gY2FjaGVbbmFtZV0pIHtcbiAgICAgICAgY2FjaGVbbmFtZV0gPSB2YWxcbiAgICAgICAgdGhpcy5oYW5kbGVTaW5nbGUobmFtZSwgdmFsKVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBoYW5kbGVTaW5nbGU6IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgIHByb3AgPSBub3JtYWxpemUocHJvcClcbiAgICBpZiAoIXByb3ApIHJldHVybiAvLyB1bnN1cHBvcnRlZCBwcm9wXG4gICAgLy8gY2FzdCBwb3NzaWJsZSBudW1iZXJzL2Jvb2xlYW5zIGludG8gc3RyaW5nc1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB2YWx1ZSArPSAnJ1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdmFyIGlzSW1wb3J0YW50ID0gaW1wb3J0YW50UkUudGVzdCh2YWx1ZSlcbiAgICAgICAgPyAnaW1wb3J0YW50J1xuICAgICAgICA6ICcnXG4gICAgICBpZiAoaXNJbXBvcnRhbnQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGltcG9ydGFudFJFLCAnJykudHJpbSgpXG4gICAgICB9XG4gICAgICB0aGlzLmVsLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIHZhbHVlLCBpc0ltcG9ydGFudClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wKVxuICAgIH1cbiAgfVxuXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgQ1NTIHByb3BlcnR5IG5hbWUuXG4gKiAtIGNhY2hlIHJlc3VsdFxuICogLSBhdXRvIHByZWZpeFxuICogLSBjYW1lbENhc2UgLT4gZGFzaC1jYXNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemUgKHByb3ApIHtcbiAgaWYgKHByb3BDYWNoZVtwcm9wXSkge1xuICAgIHJldHVybiBwcm9wQ2FjaGVbcHJvcF1cbiAgfVxuICB2YXIgcmVzID0gcHJlZml4KHByb3ApXG4gIHByb3BDYWNoZVtwcm9wXSA9IHByb3BDYWNoZVtyZXNdID0gcmVzXG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBBdXRvIGRldGVjdCB0aGUgYXBwcm9wcmlhdGUgcHJlZml4IGZvciBhIENTUyBwcm9wZXJ0eS5cbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81MjM2OTJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHByZWZpeCAocHJvcCkge1xuICBwcm9wID0gXy5oeXBoZW5hdGUocHJvcClcbiAgdmFyIGNhbWVsID0gXy5jYW1lbGl6ZShwcm9wKVxuICB2YXIgdXBwZXIgPSBjYW1lbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhbWVsLnNsaWNlKDEpXG4gIGlmICghdGVzdEVsKSB7XG4gICAgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgfVxuICBpZiAoY2FtZWwgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgaSA9IHByZWZpeGVzLmxlbmd0aFxuICB2YXIgcHJlZml4ZWRcbiAgd2hpbGUgKGktLSkge1xuICAgIHByZWZpeGVkID0gY2FtZWxQcmVmaXhlc1tpXSArIHVwcGVyXG4gICAgaWYgKHByZWZpeGVkIGluIHRlc3RFbC5zdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVzW2ldICsgcHJvcFxuICAgIH1cbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbnZhciBUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcHJpb3JpdHk6IDEwMDAsXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoaWQsIG9sZElkKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbFxuICAgIC8vIHJlc29sdmUgb24gb3duZXIgdm1cbiAgICB2YXIgaG9va3MgPSBfLnJlc29sdmVBc3NldCh0aGlzLnZtLiRvcHRpb25zLCAndHJhbnNpdGlvbnMnLCBpZClcbiAgICBpZCA9IGlkIHx8ICd2J1xuICAgIC8vIGFwcGx5IG9uIGNsb3Nlc3Qgdm1cbiAgICBlbC5fX3ZfdHJhbnMgPSBuZXcgVHJhbnNpdGlvbihlbCwgaWQsIGhvb2tzLCB0aGlzLmVsLl9fdnVlX18gfHwgdGhpcy52bSlcbiAgICBpZiAob2xkSWQpIHtcbiAgICAgIF8ucmVtb3ZlQ2xhc3MoZWwsIG9sZElkICsgJy10cmFuc2l0aW9uJylcbiAgICB9XG4gICAgXy5hZGRDbGFzcyhlbCwgaWQgKyAnLXRyYW5zaXRpb24nKVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuXG4vLyB4bGlua1xudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaydcbnZhciB4bGlua1JFID0gL154bGluazovXG5cbi8vIHRoZXNlIGlucHV0IGVsZW1lbnQgYXR0cmlidXRlcyBzaG91bGQgYWxzbyBzZXQgdGhlaXJcbi8vIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllc1xudmFyIGlucHV0UHJvcHMgPSB7XG4gIHZhbHVlOiAxLFxuICBjaGVja2VkOiAxLFxuICBzZWxlY3RlZDogMVxufVxuXG4vLyB0aGVzZSBhdHRyaWJ1dGVzIHNob3VsZCBzZXQgYSBoaWRkZW4gcHJvcGVydHkgZm9yXG4vLyBiaW5kaW5nIHYtbW9kZWwgdG8gb2JqZWN0IHZhbHVlc1xudmFyIG1vZGVsUHJvcHMgPSB7XG4gIHZhbHVlOiAnX3ZhbHVlJyxcbiAgJ3RydWUtdmFsdWUnOiAnX3RydWVWYWx1ZScsXG4gICdmYWxzZS12YWx1ZSc6ICdfZmFsc2VWYWx1ZSdcbn1cblxuLy8gY2hlY2sgZm9yIGF0dHJpYnV0ZXMgdGhhdCBwcm9oaWJpdCBpbnRlcnBvbGF0aW9uc1xudmFyIGRpc2FsbG93ZWRJbnRlcnBBdHRyUkUgPSAvXnYtfF46fF5AfF4oaXN8dHJhbnNpdGlvbnx0cmFuc2l0aW9uLW1vZGV8ZGVib3VuY2V8dHJhY2stYnl8c3RhZ2dlcnxlbnRlci1zdGFnZ2VyfGxlYXZlLXN0YWdnZXIpJC9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcHJpb3JpdHk6IDg1MCxcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF0dHIgPSB0aGlzLmFyZ1xuICAgIHZhciB0YWcgPSB0aGlzLmVsLnRhZ05hbWVcbiAgICAvLyBzaG91bGQgYmUgZGVlcCB3YXRjaCBvbiBvYmplY3QgbW9kZVxuICAgIGlmICghYXR0cikge1xuICAgICAgdGhpcy5kZWVwID0gdHJ1ZVxuICAgIH1cbiAgICAvLyBoYW5kbGUgaW50ZXJwb2xhdGlvbiBiaW5kaW5nc1xuICAgIGlmICh0aGlzLmRlc2NyaXB0b3IuaW50ZXJwKSB7XG4gICAgICAvLyBvbmx5IGFsbG93IGJpbmRpbmcgb24gbmF0aXZlIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChcbiAgICAgICAgZGlzYWxsb3dlZEludGVycEF0dHJSRS50ZXN0KGF0dHIpIHx8XG4gICAgICAgIChhdHRyID09PSAnbmFtZScgJiYgKHRhZyA9PT0gJ1BBUlRJQUwnIHx8IHRhZyA9PT0gJ1NMT1QnKSlcbiAgICAgICkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgICBhdHRyICsgJz1cIicgKyB0aGlzLmRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnICtcbiAgICAgICAgICAnYXR0cmlidXRlIGludGVycG9sYXRpb24gaXMgbm90IGFsbG93ZWQgaW4gVnVlLmpzICcgK1xuICAgICAgICAgICdkaXJlY3RpdmVzIGFuZCBzcGVjaWFsIGF0dHJpYnV0ZXMuJ1xuICAgICAgICApXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpXG4gICAgICAgIHRoaXMuaW52YWxpZCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgcmF3ID0gYXR0ciArICc9XCInICsgdGhpcy5kZXNjcmlwdG9yLnJhdyArICdcIjogJ1xuICAgICAgICAvLyB3YXJuIHNyY1xuICAgICAgICBpZiAoYXR0ciA9PT0gJ3NyYycpIHtcbiAgICAgICAgICBfLndhcm4oXG4gICAgICAgICAgICByYXcgKyAnaW50ZXJwb2xhdGlvbiBpbiBcInNyY1wiIGF0dHJpYnV0ZSB3aWxsIGNhdXNlICcgK1xuICAgICAgICAgICAgJ2EgNDA0IHJlcXVlc3QuIFVzZSB2LWJpbmQ6c3JjIGluc3RlYWQuJ1xuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdhcm4gc3R5bGVcbiAgICAgICAgaWYgKGF0dHIgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICBfLndhcm4oXG4gICAgICAgICAgICByYXcgKyAnaW50ZXJwb2xhdGlvbiBpbiBcInN0eWxlXCIgYXR0cmlidXRlIHdpbGwgY2F1c2UgJyArXG4gICAgICAgICAgICAndGhlIGF0dHJpYnV0ZSB0byBiZSBkaXNjYXJkZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQ6c3R5bGUgaW5zdGVhZC4nXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBhdHRyID0gdGhpcy5hcmdcbiAgICBpZiAodGhpcy5hcmcpIHtcbiAgICAgIHRoaXMuaGFuZGxlU2luZ2xlKGF0dHIsIHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZSB8fCB7fSlcbiAgICB9XG4gIH0sXG5cbiAgLy8gc2hhcmUgb2JqZWN0IGhhbmRsZXIgd2l0aCB2LWJpbmQ6Y2xhc3NcbiAgaGFuZGxlT2JqZWN0OiByZXF1aXJlKCcuLi9pbnRlcm5hbC9zdHlsZScpLmhhbmRsZU9iamVjdCxcblxuICBoYW5kbGVTaW5nbGU6IGZ1bmN0aW9uIChhdHRyLCB2YWx1ZSkge1xuICAgIGlmIChpbnB1dFByb3BzW2F0dHJdICYmIGF0dHIgaW4gdGhpcy5lbCkge1xuICAgICAgdGhpcy5lbFthdHRyXSA9IGF0dHIgPT09ICd2YWx1ZSdcbiAgICAgICAgPyAodmFsdWUgfHwgJycpIC8vIElFOSB3aWxsIHNldCBpbnB1dC52YWx1ZSB0byBcIm51bGxcIiBmb3IgbnVsbC4uLlxuICAgICAgICA6IHZhbHVlXG4gICAgfVxuICAgIC8vIHNldCBtb2RlbCBwcm9wc1xuICAgIHZhciBtb2RlbFByb3AgPSBtb2RlbFByb3BzW2F0dHJdXG4gICAgaWYgKG1vZGVsUHJvcCkge1xuICAgICAgdGhpcy5lbFttb2RlbFByb3BdID0gdmFsdWVcbiAgICAgIC8vIHVwZGF0ZSB2LW1vZGVsIGlmIHByZXNlbnRcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuZWwuX192X21vZGVsXG4gICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgbW9kZWwubGlzdGVuZXIoKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBkbyBub3Qgc2V0IHZhbHVlIGF0dHJpYnV0ZSBmb3IgdGV4dGFyZWFcbiAgICBpZiAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiB0aGlzLmVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gdXBkYXRlIGF0dHJpYnV0ZVxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgaWYgKHhsaW5rUkUudGVzdChhdHRyKSkge1xuICAgICAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGF0dHIsIHZhbHVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWxcbiAgICB0aGlzLnZtLiRvbmNlKCdob29rOmNvbXBpbGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCd2LWNsb2FrJylcbiAgICB9KVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBwcmlvcml0eTogMTUwMCxcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF0aGlzLmFyZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpZCA9IHRoaXMuaWQgPSBfLmNhbWVsaXplKHRoaXMuYXJnKVxuICAgIHZhciByZWZzID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRlbHNcbiAgICBpZiAocmVmcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIHJlZnNbaWRdID0gdGhpcy5lbFxuICAgIH0gZWxzZSB7XG4gICAgICBfLmRlZmluZVJlYWN0aXZlKHJlZnMsIGlkLCB0aGlzLmVsKVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVmcyA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kZWxzXG4gICAgaWYgKHJlZnNbdGhpcy5pZF0gPT09IHRoaXMuZWwpIHtcbiAgICAgIHJlZnNbdGhpcy5pZF0gPSBudWxsXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIEZyYWdtZW50RmFjdG9yeSA9IHJlcXVpcmUoJy4uLy4uL2ZyYWdtZW50L2ZhY3RvcnknKVxudmFyIGlzT2JqZWN0ID0gXy5pc09iamVjdFxudmFyIHVpZCA9IDBcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcHJpb3JpdHk6IDIwMDAsXG5cbiAgcGFyYW1zOiBbXG4gICAgJ3RyYWNrLWJ5JyxcbiAgICAnc3RhZ2dlcicsXG4gICAgJ2VudGVyLXN0YWdnZXInLFxuICAgICdsZWF2ZS1zdGFnZ2VyJ1xuICBdLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzdXBwb3J0IFwiaXRlbSBpbiBpdGVtc1wiIHN5bnRheFxuICAgIHZhciBpbk1hdGNoID0gdGhpcy5leHByZXNzaW9uLm1hdGNoKC8oLiopIGluICguKikvKVxuICAgIGlmIChpbk1hdGNoKSB7XG4gICAgICB2YXIgaXRNYXRjaCA9IGluTWF0Y2hbMV0ubWF0Y2goL1xcKCguKiksKC4qKVxcKS8pXG4gICAgICBpZiAoaXRNYXRjaCkge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRNYXRjaFsxXS50cmltKClcbiAgICAgICAgdGhpcy5hbGlhcyA9IGl0TWF0Y2hbMl0udHJpbSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFsaWFzID0gaW5NYXRjaFsxXS50cmltKClcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGluTWF0Y2hbMl1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYWxpYXMpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAnQWxpYXMgaXMgcmVxdWlyZWQgaW4gdi1mb3IuJ1xuICAgICAgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gdWlkIGFzIGEgY2FjaGUgaWRlbnRpZmllclxuICAgIHRoaXMuaWQgPSAnX192LWZvcl9fJyArICgrK3VpZClcblxuICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgYW4gb3B0aW9uIGxpc3QsXG4gICAgLy8gc28gdGhhdCB3ZSBrbm93IGlmIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSA8c2VsZWN0PidzXG4gICAgLy8gdi1tb2RlbCB3aGVuIHRoZSBvcHRpb24gbGlzdCBoYXMgY2hhbmdlZC5cbiAgICAvLyBiZWNhdXNlIHYtbW9kZWwgaGFzIGEgbG93ZXIgcHJpb3JpdHkgdGhhbiB2LWZvcixcbiAgICAvLyB0aGUgdi1tb2RlbCBpcyBub3QgYm91bmQgaGVyZSB5ZXQsIHNvIHdlIGhhdmUgdG9cbiAgICAvLyByZXRyaXZlIGl0IGluIHRoZSBhY3R1YWwgdXBkYXRlTW9kZWwoKSBmdW5jdGlvbi5cbiAgICB2YXIgdGFnID0gdGhpcy5lbC50YWdOYW1lXG4gICAgdGhpcy5pc09wdGlvbiA9XG4gICAgICAodGFnID09PSAnT1BUSU9OJyB8fCB0YWcgPT09ICdPUFRHUk9VUCcpICYmXG4gICAgICB0aGlzLmVsLnBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ1NFTEVDVCdcblxuICAgIC8vIHNldHVwIGFuY2hvciBub2Rlc1xuICAgIHRoaXMuc3RhcnQgPSBfLmNyZWF0ZUFuY2hvcigndi1mb3Itc3RhcnQnKVxuICAgIHRoaXMuZW5kID0gXy5jcmVhdGVBbmNob3IoJ3YtZm9yLWVuZCcpXG4gICAgXy5yZXBsYWNlKHRoaXMuZWwsIHRoaXMuZW5kKVxuICAgIF8uYmVmb3JlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKVxuXG4gICAgLy8gY2hlY2sgcmVmXG4gICAgdGhpcy5yZWYgPSBfLmZpbmRSZWYodGhpcy5lbClcblxuICAgIC8vIGNhY2hlXG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAgIC8vIGZyYWdtZW50IGZhY3RvcnlcbiAgICB0aGlzLmZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMudm0sIHRoaXMuZWwpXG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuZGlmZihkYXRhKVxuICAgIHRoaXMudXBkYXRlUmVmKClcbiAgICB0aGlzLnVwZGF0ZU1vZGVsKClcbiAgfSxcblxuICAvKipcbiAgICogRGlmZiwgYmFzZWQgb24gbmV3IGRhdGEgYW5kIG9sZCBkYXRhLCBkZXRlcm1pbmUgdGhlXG4gICAqIG1pbmltdW0gYW1vdW50IG9mIERPTSBtYW5pcHVsYXRpb25zIG5lZWRlZCB0byBtYWtlIHRoZVxuICAgKiBET00gcmVmbGVjdCB0aGUgbmV3IGRhdGEgQXJyYXkuXG4gICAqXG4gICAqIFRoZSBhbGdvcml0aG0gZGlmZnMgdGhlIG5ldyBkYXRhIEFycmF5IGJ5IHN0b3JpbmcgYVxuICAgKiBoaWRkZW4gcmVmZXJlbmNlIHRvIGFuIG93bmVyIHZtIGluc3RhbmNlIG9uIHByZXZpb3VzbHlcbiAgICogc2VlbiBkYXRhLiBUaGlzIGFsbG93cyB1cyB0byBhY2hpZXZlIE8obikgd2hpY2ggaXNcbiAgICogYmV0dGVyIHRoYW4gYSBsZXZlbnNodGVpbiBkaXN0YW5jZSBiYXNlZCBhbGdvcml0aG0sXG4gICAqIHdoaWNoIGlzIE8obSAqIG4pLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gICAqL1xuXG4gIGRpZmY6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIEFycmF5IHdhcyBjb252ZXJ0ZWQgZnJvbSBhbiBPYmplY3RcbiAgICB2YXIgaXRlbSA9IGRhdGFbMF1cbiAgICB2YXIgY29udmVydGVkRnJvbU9iamVjdCA9IHRoaXMuZnJvbU9iamVjdCA9XG4gICAgICBpc09iamVjdChpdGVtKSAmJlxuICAgICAgaXRlbS5oYXNPd25Qcm9wZXJ0eSgnJGtleScpICYmXG4gICAgICBpdGVtLmhhc093blByb3BlcnR5KCckdmFsdWUnKVxuXG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5XG4gICAgdmFyIG9sZEZyYWdzID0gdGhpcy5mcmFnc1xuICAgIHZhciBmcmFncyA9IHRoaXMuZnJhZ3MgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpXG4gICAgdmFyIGFsaWFzID0gdGhpcy5hbGlhc1xuICAgIHZhciBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3JcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0XG4gICAgdmFyIGVuZCA9IHRoaXMuZW5kXG4gICAgdmFyIGluRG9jID0gXy5pbkRvYyhzdGFydClcbiAgICB2YXIgaW5pdCA9ICFvbGRGcmFnc1xuICAgIHZhciBpLCBsLCBmcmFnLCBrZXksIHZhbHVlLCBwcmltaXRpdmVcblxuICAgIC8vIEZpcnN0IHBhc3MsIGdvIHRocm91Z2ggdGhlIG5ldyBBcnJheSBhbmQgZmlsbCB1cFxuICAgIC8vIHRoZSBuZXcgZnJhZ3MgYXJyYXkuIElmIGEgcGllY2Ugb2YgZGF0YSBoYXMgYSBjYWNoZWRcbiAgICAvLyBpbnN0YW5jZSBmb3IgaXQsIHdlIHJldXNlIGl0LiBPdGhlcndpc2UgYnVpbGQgYSBuZXdcbiAgICAvLyBpbnN0YW5jZS5cbiAgICBmb3IgKGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBkYXRhW2ldXG4gICAgICBrZXkgPSBjb252ZXJ0ZWRGcm9tT2JqZWN0ID8gaXRlbS4ka2V5IDogbnVsbFxuICAgICAgdmFsdWUgPSBjb252ZXJ0ZWRGcm9tT2JqZWN0ID8gaXRlbS4kdmFsdWUgOiBpdGVtXG4gICAgICBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpXG4gICAgICBmcmFnID0gIWluaXQgJiYgdGhpcy5nZXRDYWNoZWRGcmFnKHZhbHVlLCBpLCBrZXkpXG4gICAgICBpZiAoZnJhZykgeyAvLyByZXVzYWJsZSBmcmFnbWVudFxuICAgICAgICBmcmFnLnJldXNlZCA9IHRydWVcbiAgICAgICAgLy8gdXBkYXRlICRpbmRleFxuICAgICAgICBmcmFnLnNjb3BlLiRpbmRleCA9IGlcbiAgICAgICAgLy8gdXBkYXRlICRrZXlcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGZyYWcuc2NvcGUuJGtleSA9IGtleVxuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBpdGVyYXRvclxuICAgICAgICBpZiAoaXRlcmF0b3IpIHtcbiAgICAgICAgICBmcmFnLnNjb3BlW2l0ZXJhdG9yXSA9IGtleSAhPT0gbnVsbCA/IGtleSA6IGlcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgZGF0YSBmb3IgdHJhY2stYnksIG9iamVjdCByZXBlYXQgJlxuICAgICAgICAvLyBwcmltaXRpdmUgdmFsdWVzLlxuICAgICAgICBpZiAodHJhY2tCeUtleSB8fCBjb252ZXJ0ZWRGcm9tT2JqZWN0IHx8IHByaW1pdGl2ZSkge1xuICAgICAgICAgIGZyYWcuc2NvcGVbYWxpYXNdID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHsgLy8gbmV3IGlzbnRhbmNlXG4gICAgICAgIGZyYWcgPSB0aGlzLmNyZWF0ZSh2YWx1ZSwgYWxpYXMsIGksIGtleSlcbiAgICAgICAgZnJhZy5mcmVzaCA9ICFpbml0XG4gICAgICB9XG4gICAgICBmcmFnc1tpXSA9IGZyYWdcbiAgICAgIGlmIChpbml0KSB7XG4gICAgICAgIGZyYWcuYmVmb3JlKGVuZClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSdyZSBkb25lIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgaWYgKGluaXQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFNlY29uZCBwYXNzLCBnbyB0aHJvdWdoIHRoZSBvbGQgZnJhZ21lbnRzIGFuZFxuICAgIC8vIGRlc3Ryb3kgdGhvc2Ugd2hvIGFyZSBub3QgcmV1c2VkIChhbmQgcmVtb3ZlIHRoZW1cbiAgICAvLyBmcm9tIGNhY2hlKVxuICAgIHZhciByZW1vdmFsSW5kZXggPSAwXG4gICAgdmFyIHRvdGFsUmVtb3ZlZCA9IG9sZEZyYWdzLmxlbmd0aCAtIGZyYWdzLmxlbmd0aFxuICAgIGZvciAoaSA9IDAsIGwgPSBvbGRGcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZyYWcgPSBvbGRGcmFnc1tpXVxuICAgICAgaWYgKCFmcmFnLnJldXNlZCkge1xuICAgICAgICB0aGlzLmRlbGV0ZUNhY2hlZEZyYWcoZnJhZylcbiAgICAgICAgdGhpcy5yZW1vdmUoZnJhZywgcmVtb3ZhbEluZGV4KyssIHRvdGFsUmVtb3ZlZCwgaW5Eb2MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmluYWwgcGFzcywgbW92ZS9pbnNlcnQgbmV3IGZyYWdtZW50cyBpbnRvIHRoZVxuICAgIC8vIHJpZ2h0IHBsYWNlLlxuICAgIHZhciB0YXJnZXRQcmV2LCBwcmV2RWwsIGN1cnJlbnRQcmV2XG4gICAgdmFyIGluc2VydGlvbkluZGV4ID0gMFxuICAgIGZvciAoaSA9IDAsIGwgPSBmcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZyYWcgPSBmcmFnc1tpXVxuICAgICAgLy8gdGhpcyBpcyB0aGUgZnJhZyB0aGF0IHdlIHNob3VsZCBiZSBhZnRlclxuICAgICAgdGFyZ2V0UHJldiA9IGZyYWdzW2kgLSAxXVxuICAgICAgcHJldkVsID0gdGFyZ2V0UHJldlxuICAgICAgICA/IHRhcmdldFByZXYuc3RhZ2dlckNiXG4gICAgICAgICAgPyB0YXJnZXRQcmV2LnN0YWdnZXJBbmNob3JcbiAgICAgICAgICA6IHRhcmdldFByZXYuZW5kIHx8IHRhcmdldFByZXYubm9kZVxuICAgICAgICA6IHN0YXJ0XG4gICAgICBpZiAoZnJhZy5yZXVzZWQgJiYgIWZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICAgIGN1cnJlbnRQcmV2ID0gZmluZFByZXZGcmFnKGZyYWcsIHN0YXJ0LCB0aGlzLmlkKVxuICAgICAgICBpZiAoY3VycmVudFByZXYgIT09IHRhcmdldFByZXYpIHtcbiAgICAgICAgICB0aGlzLm1vdmUoZnJhZywgcHJldkVsKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZXcgaW5zdGFuY2UsIG9yIHN0aWxsIGluIHN0YWdnZXIuXG4gICAgICAgIC8vIGluc2VydCB3aXRoIHVwZGF0ZWQgc3RhZ2dlciBpbmRleC5cbiAgICAgICAgdGhpcy5pbnNlcnQoZnJhZywgaW5zZXJ0aW9uSW5kZXgrKywgcHJldkVsLCBpbkRvYylcbiAgICAgIH1cbiAgICAgIGZyYWcucmV1c2VkID0gZnJhZy5mcmVzaCA9IGZhbHNlXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFsaWFzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAgICogQHJldHVybiB7RnJhZ21lbnR9XG4gICAqL1xuXG4gIGNyZWF0ZTogZnVuY3Rpb24gKHZhbHVlLCBhbGlhcywgaW5kZXgsIGtleSkge1xuICAgIHZhciBob3N0ID0gdGhpcy5faG9zdFxuICAgIC8vIGNyZWF0ZSBpdGVyYXRpb24gc2NvcGVcbiAgICB2YXIgcGFyZW50U2NvcGUgPSB0aGlzLl9zY29wZSB8fCB0aGlzLnZtXG4gICAgdmFyIHNjb3BlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZSlcbiAgICAvLyByZWYgaG9sZGVyIGZvciB0aGUgc2NvcGVcbiAgICBzY29wZS4kcmVmcyA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUuJHJlZnMpXG4gICAgc2NvcGUuJGVscyA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUuJGVscylcbiAgICAvLyBtYWtlIHN1cmUgcG9pbnQgJHBhcmVudCB0byBwYXJlbnQgc2NvcGVcbiAgICBzY29wZS4kcGFyZW50ID0gcGFyZW50U2NvcGVcbiAgICAvLyBmb3IgdHdvLXdheSBiaW5kaW5nIG9uIGFsaWFzXG4gICAgc2NvcGUuJGZvckNvbnRleHQgPSB0aGlzXG4gICAgLy8gZGVmaW5lIHNjb3BlIHByb3BlcnRpZXNcbiAgICBfLmRlZmluZVJlYWN0aXZlKHNjb3BlLCBhbGlhcywgdmFsdWUpXG4gICAgXy5kZWZpbmVSZWFjdGl2ZShzY29wZSwgJyRpbmRleCcsIGluZGV4KVxuICAgIGlmIChrZXkpIHtcbiAgICAgIF8uZGVmaW5lUmVhY3RpdmUoc2NvcGUsICcka2V5Jywga2V5KVxuICAgIH0gZWxzZSBpZiAoc2NvcGUuJGtleSkge1xuICAgICAgLy8gYXZvaWQgYWNjaWRlbnRhbCBmYWxsYmFja1xuICAgICAgXy5kZWZpbmUoc2NvcGUsICcka2V5JywgbnVsbClcbiAgICB9XG4gICAgaWYgKHRoaXMuaXRlcmF0b3IpIHtcbiAgICAgIF8uZGVmaW5lUmVhY3RpdmUoc2NvcGUsIHRoaXMuaXRlcmF0b3IsIGtleSAhPT0gbnVsbCA/IGtleSA6IGluZGV4KVxuICAgIH1cbiAgICB2YXIgZnJhZyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUoaG9zdCwgc2NvcGUsIHRoaXMuX2ZyYWcpXG4gICAgZnJhZy5mb3JJZCA9IHRoaXMuaWRcbiAgICB0aGlzLmNhY2hlRnJhZyh2YWx1ZSwgZnJhZywgaW5kZXgsIGtleSlcbiAgICByZXR1cm4gZnJhZ1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHYtcmVmIG9uIG93bmVyIHZtLlxuICAgKi9cblxuICB1cGRhdGVSZWY6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5yZWZcbiAgICBpZiAoIXJlZikgcmV0dXJuXG4gICAgdmFyIGhhc2ggPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJHJlZnNcbiAgICB2YXIgcmVmc1xuICAgIGlmICghdGhpcy5mcm9tT2JqZWN0KSB7XG4gICAgICByZWZzID0gdGhpcy5mcmFncy5tYXAoZmluZFZtRnJvbUZyYWcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnMgPSB7fVxuICAgICAgdGhpcy5mcmFncy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgIHJlZnNbZnJhZy5zY29wZS4ka2V5XSA9IGZpbmRWbUZyb21GcmFnKGZyYWcpXG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAoIWhhc2guaGFzT3duUHJvcGVydHkocmVmKSkge1xuICAgICAgXy5kZWZpbmVSZWFjdGl2ZShoYXNoLCByZWYsIHJlZnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc2hbcmVmXSA9IHJlZnNcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBvcHRpb24gbGlzdHMsIHVwZGF0ZSB0aGUgY29udGFpbmluZyB2LW1vZGVsIG9uXG4gICAqIHBhcmVudCA8c2VsZWN0Pi5cbiAgICovXG5cbiAgdXBkYXRlTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc09wdGlvbikge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuc3RhcnQucGFyZW50Tm9kZVxuICAgICAgdmFyIG1vZGVsID0gcGFyZW50ICYmIHBhcmVudC5fX3ZfbW9kZWxcbiAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICBtb2RlbC5mb3JjZVVwZGF0ZSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnNlcnQgYSBmcmFnbWVudC4gSGFuZGxlcyBzdGFnZ2VyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge05vZGV9IHByZXZFbFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluRG9jXG4gICAqL1xuXG4gIGluc2VydDogZnVuY3Rpb24gKGZyYWcsIGluZGV4LCBwcmV2RWwsIGluRG9jKSB7XG4gICAgaWYgKGZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICBmcmFnLnN0YWdnZXJDYi5jYW5jZWwoKVxuICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsXG4gICAgfVxuICAgIHZhciBzdGFnZ2VyQW1vdW50ID0gdGhpcy5nZXRTdGFnZ2VyKGZyYWcsIGluZGV4LCBudWxsLCAnZW50ZXInKVxuICAgIGlmIChpbkRvYyAmJiBzdGFnZ2VyQW1vdW50KSB7XG4gICAgICAvLyBjcmVhdGUgYW4gYW5jaG9yIGFuZCBpbnNlcnQgaXQgc3luY2hyb25vdXNseSxcbiAgICAgIC8vIHNvIHRoYXQgd2UgY2FuIHJlc29sdmUgdGhlIGNvcnJlY3Qgb3JkZXIgd2l0aG91dFxuICAgICAgLy8gd29ycnlpbmcgYWJvdXQgc29tZSBlbGVtZW50cyBub3QgaW5zZXJ0ZWQgeWV0XG4gICAgICB2YXIgYW5jaG9yID0gZnJhZy5zdGFnZ2VyQW5jaG9yXG4gICAgICBpZiAoIWFuY2hvcikge1xuICAgICAgICBhbmNob3IgPSBmcmFnLnN0YWdnZXJBbmNob3IgPSBfLmNyZWF0ZUFuY2hvcignc3RhZ2dlci1hbmNob3InKVxuICAgICAgICBhbmNob3IuX192ZnJhZ19fID0gZnJhZ1xuICAgICAgfVxuICAgICAgXy5hZnRlcihhbmNob3IsIHByZXZFbClcbiAgICAgIHZhciBvcCA9IGZyYWcuc3RhZ2dlckNiID0gXy5jYW5jZWxsYWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbFxuICAgICAgICBmcmFnLmJlZm9yZShhbmNob3IpXG4gICAgICAgIF8ucmVtb3ZlKGFuY2hvcilcbiAgICAgIH0pXG4gICAgICBzZXRUaW1lb3V0KG9wLCBzdGFnZ2VyQW1vdW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnLmJlZm9yZShwcmV2RWwubmV4dFNpYmxpbmcpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmcmFnbWVudC4gSGFuZGxlcyBzdGFnZ2VyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gdG90YWxcbiAgICogQHBhcmFtIHtCb29sZWFufSBpbkRvY1xuICAgKi9cblxuICByZW1vdmU6IGZ1bmN0aW9uIChmcmFnLCBpbmRleCwgdG90YWwsIGluRG9jKSB7XG4gICAgaWYgKGZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICBmcmFnLnN0YWdnZXJDYi5jYW5jZWwoKVxuICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsXG4gICAgICAvLyBpdCdzIG5vdCBwb3NzaWJsZSBmb3IgdGhlIHNhbWUgZnJhZyB0byBiZSByZW1vdmVkXG4gICAgICAvLyB0d2ljZSwgc28gaWYgd2UgaGF2ZSBhIHBlbmRpbmcgc3RhZ2dlciBjYWxsYmFjayxcbiAgICAgIC8vIGl0IG1lYW5zIHRoaXMgZnJhZyBpcyBxdWV1ZWQgZm9yIGVudGVyIGJ1dCByZW1vdmVkXG4gICAgICAvLyBiZWZvcmUgaXRzIHRyYW5zaXRpb24gc3RhcnRlZC4gU2luY2UgaXQgaXMgYWxyZWFkeVxuICAgICAgLy8gZGVzdHJveWVkLCB3ZSBjYW4ganVzdCBsZWF2ZSBpdCBpbiBkZXRhY2hlZCBzdGF0ZS5cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgc3RhZ2dlckFtb3VudCA9IHRoaXMuZ2V0U3RhZ2dlcihmcmFnLCBpbmRleCwgdG90YWwsICdsZWF2ZScpXG4gICAgaWYgKGluRG9jICYmIHN0YWdnZXJBbW91bnQpIHtcbiAgICAgIHZhciBvcCA9IGZyYWcuc3RhZ2dlckNiID0gXy5jYW5jZWxsYWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbFxuICAgICAgICBmcmFnLnJlbW92ZSh0cnVlKVxuICAgICAgfSlcbiAgICAgIHNldFRpbWVvdXQob3AsIHN0YWdnZXJBbW91bnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcucmVtb3ZlKHRydWUpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlIGEgZnJhZ21lbnQgdG8gYSBuZXcgcG9zaXRpb24uXG4gICAqIEZvcmNlIG5vIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOb2RlfSBwcmV2RWxcbiAgICovXG5cbiAgbW92ZTogZnVuY3Rpb24gKGZyYWcsIHByZXZFbCkge1xuICAgIGZyYWcuYmVmb3JlKHByZXZFbC5uZXh0U2libGluZywgZmFsc2UpXG4gIH0sXG5cbiAgLyoqXG4gICAqIENhY2hlIGEgZnJhZ21lbnQgdXNpbmcgdHJhY2stYnkgb3IgdGhlIG9iamVjdCBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gICAqL1xuXG4gIGNhY2hlRnJhZzogZnVuY3Rpb24gKHZhbHVlLCBmcmFnLCBpbmRleCwga2V5KSB7XG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZVxuICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpXG4gICAgdmFyIGlkXG4gICAgaWYgKGtleSB8fCB0cmFja0J5S2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgaWQgPSB0cmFja0J5S2V5XG4gICAgICAgID8gdHJhY2tCeUtleSA9PT0gJyRpbmRleCdcbiAgICAgICAgICA/IGluZGV4XG4gICAgICAgICAgOiB2YWx1ZVt0cmFja0J5S2V5XVxuICAgICAgICA6IChrZXkgfHwgdmFsdWUpXG4gICAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgICBjYWNoZVtpZF0gPSBmcmFnXG4gICAgICB9IGVsc2UgaWYgKHRyYWNrQnlLZXkgIT09ICckaW5kZXgnKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgdGhpcy53YXJuRHVwbGljYXRlKHZhbHVlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IHRoaXMuaWRcbiAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgaWYgKHZhbHVlW2lkXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlW2lkXSA9IGZyYWdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgdGhpcy53YXJuRHVwbGljYXRlKHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfLmRlZmluZSh2YWx1ZSwgaWQsIGZyYWcpXG4gICAgICB9XG4gICAgfVxuICAgIGZyYWcucmF3ID0gdmFsdWVcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgY2FjaGVkIGZyYWdtZW50IGZyb20gdGhlIHZhbHVlL2luZGV4L2tleVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge0ZyYWdtZW50fVxuICAgKi9cblxuICBnZXRDYWNoZWRGcmFnOiBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBrZXkpIHtcbiAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnlcbiAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKVxuICAgIHZhciBmcmFnXG4gICAgaWYgKGtleSB8fCB0cmFja0J5S2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgdmFyIGlkID0gdHJhY2tCeUtleVxuICAgICAgICA/IHRyYWNrQnlLZXkgPT09ICckaW5kZXgnXG4gICAgICAgICAgPyBpbmRleFxuICAgICAgICAgIDogdmFsdWVbdHJhY2tCeUtleV1cbiAgICAgICAgOiAoa2V5IHx8IHZhbHVlKVxuICAgICAgZnJhZyA9IHRoaXMuY2FjaGVbaWRdXG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcgPSB2YWx1ZVt0aGlzLmlkXVxuICAgIH1cbiAgICBpZiAoZnJhZyAmJiAoZnJhZy5yZXVzZWQgfHwgZnJhZy5mcmVzaCkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHRoaXMud2FybkR1cGxpY2F0ZSh2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlIGEgZnJhZ21lbnQgZnJvbSBjYWNoZS5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKi9cblxuICBkZWxldGVDYWNoZWRGcmFnOiBmdW5jdGlvbiAoZnJhZykge1xuICAgIHZhciB2YWx1ZSA9IGZyYWcucmF3XG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5XG4gICAgdmFyIHNjb3BlID0gZnJhZy5zY29wZVxuICAgIHZhciBpbmRleCA9IHNjb3BlLiRpbmRleFxuICAgIC8vIGZpeCAjOTQ4OiBhdm9pZCBhY2NpZGVudGFsbHkgZmFsbCB0aHJvdWdoIHRvXG4gICAgLy8gYSBwYXJlbnQgcmVwZWF0ZXIgd2hpY2ggaGFwcGVucyB0byBoYXZlICRrZXkuXG4gICAgdmFyIGtleSA9IHNjb3BlLmhhc093blByb3BlcnR5KCcka2V5JykgJiYgc2NvcGUuJGtleVxuICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpXG4gICAgaWYgKHRyYWNrQnlLZXkgfHwga2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgdmFyIGlkID0gdHJhY2tCeUtleVxuICAgICAgICA/IHRyYWNrQnlLZXkgPT09ICckaW5kZXgnXG4gICAgICAgICAgPyBpbmRleFxuICAgICAgICAgIDogdmFsdWVbdHJhY2tCeUtleV1cbiAgICAgICAgOiAoa2V5IHx8IHZhbHVlKVxuICAgICAgdGhpcy5jYWNoZVtpZF0gPSBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlW3RoaXMuaWRdID0gbnVsbFxuICAgICAgZnJhZy5yYXcgPSBudWxsXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YWdnZXIgYW1vdW50IGZvciBhbiBpbnNlcnRpb24vcmVtb3ZhbC5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqL1xuXG4gIGdldFN0YWdnZXI6IGZ1bmN0aW9uIChmcmFnLCBpbmRleCwgdG90YWwsIHR5cGUpIHtcbiAgICB0eXBlID0gdHlwZSArICdTdGFnZ2VyJ1xuICAgIHZhciB0cmFucyA9IGZyYWcubm9kZS5fX3ZfdHJhbnNcbiAgICB2YXIgaG9va3MgPSB0cmFucyAmJiB0cmFucy5ob29rc1xuICAgIHZhciBob29rID0gaG9va3MgJiYgKGhvb2tzW3R5cGVdIHx8IGhvb2tzLnN0YWdnZXIpXG4gICAgcmV0dXJuIGhvb2tcbiAgICAgID8gaG9vay5jYWxsKGZyYWcsIGluZGV4LCB0b3RhbClcbiAgICAgIDogaW5kZXggKiBwYXJzZUludCh0aGlzLnBhcmFtc1t0eXBlXSB8fCB0aGlzLnBhcmFtcy5zdGFnZ2VyLCAxMClcbiAgfSxcblxuICAvKipcbiAgICogUHJlLXByb2Nlc3MgdGhlIHZhbHVlIGJlZm9yZSBwaXBpbmcgaXQgdGhyb3VnaCB0aGVcbiAgICogZmlsdGVycy4gVGhpcyBpcyBwYXNzZWQgdG8gYW5kIGNhbGxlZCBieSB0aGUgd2F0Y2hlci5cbiAgICovXG5cbiAgX3ByZVByb2Nlc3M6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHJlZ2FyZGxlc3Mgb2YgdHlwZSwgc3RvcmUgdGhlIHVuLWZpbHRlcmVkIHJhdyB2YWx1ZS5cbiAgICB0aGlzLnJhd1ZhbHVlID0gdmFsdWVcbiAgICByZXR1cm4gdmFsdWVcbiAgfSxcblxuICAvKipcbiAgICogUG9zdC1wcm9jZXNzIHRoZSB2YWx1ZSBhZnRlciBpdCBoYXMgYmVlbiBwaXBlZCB0aHJvdWdoXG4gICAqIHRoZSBmaWx0ZXJzLiBUaGlzIGlzIHBhc3NlZCB0byBhbmQgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyLlxuICAgKlxuICAgKiBJdCBpcyBuZWNlc3NhcnkgZm9yIHRoaXMgdG8gYmUgY2FsbGVkIGR1cmluZyB0aGVcbiAgICogd2F0aGNlcidzIGRlcGVuZGVuY3kgY29sbGVjdGlvbiBwaGFzZSBiZWNhdXNlIHdlIHdhbnRcbiAgICogdGhlIHYtZm9yIHRvIHVwZGF0ZSB3aGVuIHRoZSBzb3VyY2UgT2JqZWN0IGlzIG11dGF0ZWQuXG4gICAqL1xuXG4gIF9wb3N0UHJvY2VzczogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgLy8gY29udmVydCBwbGFpbiBvYmplY3QgdG8gYXJyYXkuXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKVxuICAgICAgdmFyIGkgPSBrZXlzLmxlbmd0aFxuICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShpKVxuICAgICAgdmFyIGtleVxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2ldXG4gICAgICAgIHJlc1tpXSA9IHtcbiAgICAgICAgICAka2V5OiBrZXksXG4gICAgICAgICAgJHZhbHVlOiB2YWx1ZVtrZXldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWVcbiAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YWx1ZSA9IHJhbmdlKHZhbHVlKVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWx1ZSA9IF8udG9BcnJheSh2YWx1ZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSB8fCBbXVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kcmVmc1t0aGlzLnJlZl0gPSBudWxsXG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdzKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuZnJhZ3MubGVuZ3RoXG4gICAgICB2YXIgZnJhZ1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBmcmFnID0gdGhpcy5mcmFnc1tpXVxuICAgICAgICB0aGlzLmRlbGV0ZUNhY2hlZEZyYWcoZnJhZylcbiAgICAgICAgZnJhZy5kZXN0cm95KClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZmluZCB0aGUgcHJldmlvdXMgZWxlbWVudCB0aGF0IGlzIGEgZnJhZ21lbnRcbiAqIGFuY2hvci4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBhIGRlc3Ryb3llZCBmcmFnJ3NcbiAqIGVsZW1lbnQgY291bGQgc3RpbGwgYmUgbGluZ2VyaW5nIGluIHRoZSBET00gYmVmb3JlIGl0c1xuICogbGVhdmluZyB0cmFuc2l0aW9uIGZpbmlzaGVzLCBidXQgaXRzIGluc2VydGVkIGZsYWdcbiAqIHNob3VsZCBoYXZlIGJlZW4gc2V0IHRvIGZhbHNlIHNvIHdlIGNhbiBza2lwIHRoZW0uXG4gKlxuICogSWYgdGhpcyBpcyBhIGJsb2NrIHJlcGVhdCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2Ugb25seVxuICogcmV0dXJuIGZyYWcgdGhhdCBpcyBib3VuZCB0byB0aGlzIHYtZm9yLiAoc2VlICM5MjkpXG4gKlxuICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICogQHBhcmFtIHtDb21tZW50fFRleHR9IGFuY2hvclxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcmV0dXJuIHtGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBmaW5kUHJldkZyYWcgKGZyYWcsIGFuY2hvciwgaWQpIHtcbiAgdmFyIGVsID0gZnJhZy5ub2RlLnByZXZpb3VzU2libGluZ1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFlbCkgcmV0dXJuXG4gIGZyYWcgPSBlbC5fX3ZmcmFnX19cbiAgd2hpbGUgKFxuICAgICghZnJhZyB8fCBmcmFnLmZvcklkICE9PSBpZCB8fCAhZnJhZy5pbnNlcnRlZCkgJiZcbiAgICBlbCAhPT0gYW5jaG9yXG4gICkge1xuICAgIGVsID0gZWwucHJldmlvdXNTaWJsaW5nXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFlbCkgcmV0dXJuXG4gICAgZnJhZyA9IGVsLl9fdmZyYWdfX1xuICB9XG4gIHJldHVybiBmcmFnXG59XG5cbi8qKlxuICogRmluZCBhIHZtIGZyb20gYSBmcmFnbWVudC5cbiAqXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gKiBAcmV0dXJuIHtWdWV8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGZpbmRWbUZyb21GcmFnIChmcmFnKSB7XG4gIHJldHVybiBmcmFnLm5vZGUuX192dWVfXyB8fCBmcmFnLm5vZGUubmV4dFNpYmxpbmcuX192dWVfX1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJhbmdlIGFycmF5IGZyb20gZ2l2ZW4gbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiByYW5nZSAobikge1xuICB2YXIgaSA9IC0xXG4gIHZhciByZXQgPSBuZXcgQXJyYXkobilcbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICByZXRbaV0gPSBpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cy53YXJuRHVwbGljYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgXy53YXJuKFxuICAgICAgJ0R1cGxpY2F0ZSB2YWx1ZSBmb3VuZCBpbiB2LWZvcj1cIicgKyB0aGlzLmRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICcuIFVzZSB0cmFjay1ieT1cIiRpbmRleFwiIGlmICcgK1xuICAgICAgJ3lvdSBhcmUgZXhwZWN0aW5nIGR1cGxpY2F0ZSB2YWx1ZXMuJ1xuICAgIClcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbnZhciB0ZW1wbGF0ZVBhcnNlciA9IHJlcXVpcmUoJy4uLy4uL3BhcnNlcnMvdGVtcGxhdGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gYSBjb21tZW50IG5vZGUgbWVhbnMgdGhpcyBpcyBhIGJpbmRpbmcgZm9yXG4gICAgLy8ge3t7IGlubGluZSB1bmVzY2FwZWQgaHRtbCB9fX1cbiAgICBpZiAodGhpcy5lbC5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgLy8gaG9sZCBub2Rlc1xuICAgICAgdGhpcy5ub2RlcyA9IFtdXG4gICAgICAvLyByZXBsYWNlIHRoZSBwbGFjZWhvbGRlciB3aXRoIHByb3BlciBhbmNob3JcbiAgICAgIHRoaXMuYW5jaG9yID0gXy5jcmVhdGVBbmNob3IoJ3YtaHRtbCcpXG4gICAgICBfLnJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpXG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBfLnRvU3RyaW5nKHZhbHVlKVxuICAgIGlmICh0aGlzLm5vZGVzKSB7XG4gICAgICB0aGlzLnN3YXAodmFsdWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gdmFsdWVcbiAgICB9XG4gIH0sXG5cbiAgc3dhcDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gcmVtb3ZlIG9sZCBub2Rlc1xuICAgIHZhciBpID0gdGhpcy5ub2Rlcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBfLnJlbW92ZSh0aGlzLm5vZGVzW2ldKVxuICAgIH1cbiAgICAvLyBjb252ZXJ0IG5ldyB2YWx1ZSB0byBhIGZyYWdtZW50XG4gICAgLy8gZG8gbm90IGF0dGVtcHQgdG8gcmV0cmlldmUgZnJvbSBpZCBzZWxlY3RvclxuICAgIHZhciBmcmFnID0gdGVtcGxhdGVQYXJzZXIucGFyc2UodmFsdWUsIHRydWUsIHRydWUpXG4gICAgLy8gc2F2ZSBhIHJlZmVyZW5jZSB0byB0aGVzZSBub2RlcyBzbyB3ZSBjYW4gcmVtb3ZlIGxhdGVyXG4gICAgdGhpcy5ub2RlcyA9IF8udG9BcnJheShmcmFnLmNoaWxkTm9kZXMpXG4gICAgXy5iZWZvcmUoZnJhZywgdGhpcy5hbmNob3IpXG4gIH1cbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG52YXIgRnJhZ21lbnRGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vZnJhZ21lbnQvZmFjdG9yeScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIHByaW9yaXR5OiAyMDAwLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsXG4gICAgaWYgKCFlbC5fX3Z1ZV9fKSB7XG4gICAgICAvLyBjaGVjayBlbHNlIGJsb2NrXG4gICAgICB2YXIgbmV4dCA9IGVsLm5leHRFbGVtZW50U2libGluZ1xuICAgICAgaWYgKG5leHQgJiYgXy5hdHRyKG5leHQsICd2LWVsc2UnKSAhPT0gbnVsbCkge1xuICAgICAgICBfLnJlbW92ZShuZXh0KVxuICAgICAgICB0aGlzLmVsc2VGYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCBuZXh0KVxuICAgICAgfVxuICAgICAgLy8gY2hlY2sgbWFpbiBibG9ja1xuICAgICAgdGhpcy5hbmNob3IgPSBfLmNyZWF0ZUFuY2hvcigndi1pZicpXG4gICAgICBfLnJlcGxhY2UoZWwsIHRoaXMuYW5jaG9yKVxuICAgICAgdGhpcy5mYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCBlbClcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICd2LWlmPVwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiBjYW5ub3QgYmUgJyArXG4gICAgICAgICd1c2VkIG9uIGFuIGluc3RhbmNlIHJvb3QgZWxlbWVudC4nXG4gICAgICApXG4gICAgICB0aGlzLmludmFsaWQgPSB0cnVlXG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkgcmV0dXJuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuZnJhZykge1xuICAgICAgICB0aGlzLmluc2VydCgpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlKClcbiAgICB9XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZWxzZUZyYWcpIHtcbiAgICAgIHRoaXMuZWxzZUZyYWcucmVtb3ZlKHRydWUpXG4gICAgICB0aGlzLmVsc2VGcmFnID0gbnVsbFxuICAgIH1cbiAgICB0aGlzLmZyYWcgPSB0aGlzLmZhY3RvcnkuY3JlYXRlKHRoaXMuX2hvc3QsIHRoaXMuX3Njb3BlLCB0aGlzLl9mcmFnKVxuICAgIHRoaXMuZnJhZy5iZWZvcmUodGhpcy5hbmNob3IpXG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZnJhZykge1xuICAgICAgdGhpcy5mcmFnLnJlbW92ZSh0cnVlKVxuICAgICAgdGhpcy5mcmFnID0gbnVsbFxuICAgIH1cbiAgICBpZiAodGhpcy5lbHNlRmFjdG9yeSkge1xuICAgICAgdGhpcy5lbHNlRnJhZyA9IHRoaXMuZWxzZUZhY3RvcnkuY3JlYXRlKHRoaXMuX2hvc3QsIHRoaXMuX3Njb3BlLCB0aGlzLl9mcmFnKVxuICAgICAgdGhpcy5lbHNlRnJhZy5iZWZvcmUodGhpcy5hbmNob3IpXG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZy5kZXN0cm95KClcbiAgICB9XG4gIH1cbn1cbiIsIi8vIHRleHQgJiBodG1sXG5leHBvcnRzLnRleHQgPSByZXF1aXJlKCcuL3RleHQnKVxuZXhwb3J0cy5odG1sID0gcmVxdWlyZSgnLi9odG1sJylcblxuLy8gbG9naWMgY29udHJvbFxuZXhwb3J0c1snZm9yJ10gPSByZXF1aXJlKCcuL2ZvcicpXG5leHBvcnRzWydpZiddID0gcmVxdWlyZSgnLi9pZicpXG5leHBvcnRzLnNob3cgPSByZXF1aXJlKCcuL3Nob3cnKVxuXG4vLyB0d28td2F5IGJpbmRpbmdcbmV4cG9ydHMubW9kZWwgPSByZXF1aXJlKCcuL21vZGVsJylcblxuLy8gZXZlbnQgaGFuZGxpbmdcbmV4cG9ydHMub24gPSByZXF1aXJlKCcuL29uJylcblxuLy8gYXR0cmlidXRlc1xuZXhwb3J0cy5iaW5kID0gcmVxdWlyZSgnLi9iaW5kJylcblxuLy8gcmVmICYgZWxcbmV4cG9ydHMuZWwgPSByZXF1aXJlKCcuL2VsJylcbmV4cG9ydHMucmVmID0gcmVxdWlyZSgnLi9yZWYnKVxuXG4vLyBjbG9ha1xuZXhwb3J0cy5jbG9hayA9IHJlcXVpcmUoJy4vY2xvYWsnKVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBlbCA9IHRoaXMuZWxcblxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZWwuaGFzT3duUHJvcGVydHkoJ192YWx1ZScpXG4gICAgICAgID8gZWwuX3ZhbHVlXG4gICAgICAgIDogc2VsZi5wYXJhbXMubnVtYmVyXG4gICAgICAgICAgPyBfLnRvTnVtYmVyKGVsLnZhbHVlKVxuICAgICAgICAgIDogZWwudmFsdWVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb29sZWFuVmFsdWUgKCkge1xuICAgICAgdmFyIHZhbCA9IGVsLmNoZWNrZWRcbiAgICAgIGlmICh2YWwgJiYgZWwuaGFzT3duUHJvcGVydHkoJ190cnVlVmFsdWUnKSkge1xuICAgICAgICByZXR1cm4gZWwuX3RydWVWYWx1ZVxuICAgICAgfVxuICAgICAgaWYgKCF2YWwgJiYgZWwuaGFzT3duUHJvcGVydHkoJ19mYWxzZVZhbHVlJykpIHtcbiAgICAgICAgcmV0dXJuIGVsLl9mYWxzZVZhbHVlXG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtb2RlbCA9IHNlbGYuX3dhdGNoZXIudmFsdWVcbiAgICAgIGlmIChfLmlzQXJyYXkobW9kZWwpKSB7XG4gICAgICAgIHZhciB2YWwgPSBzZWxmLmdldFZhbHVlKClcbiAgICAgICAgaWYgKGVsLmNoZWNrZWQpIHtcbiAgICAgICAgICBpZiAoXy5pbmRleE9mKG1vZGVsLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgbW9kZWwucHVzaCh2YWwpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGVsLiRyZW1vdmUodmFsKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNldChnZXRCb29sZWFuVmFsdWUoKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKVxuICAgIGlmIChlbC5jaGVja2VkKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXJcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsXG4gICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSBfLmluZGV4T2YodmFsdWUsIHRoaXMuZ2V0VmFsdWUoKSkgPiAtMVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWwuaGFzT3duUHJvcGVydHkoJ190cnVlVmFsdWUnKSkge1xuICAgICAgICBlbC5jaGVja2VkID0gXy5sb29zZUVxdWFsKHZhbHVlLCBlbC5fdHJ1ZVZhbHVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9ICEhdmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpXG5cbnZhciBoYW5kbGVycyA9IHtcbiAgdGV4dDogcmVxdWlyZSgnLi90ZXh0JyksXG4gIHJhZGlvOiByZXF1aXJlKCcuL3JhZGlvJyksXG4gIHNlbGVjdDogcmVxdWlyZSgnLi9zZWxlY3QnKSxcbiAgY2hlY2tib3g6IHJlcXVpcmUoJy4vY2hlY2tib3gnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBwcmlvcml0eTogODAwLFxuICB0d29XYXk6IHRydWUsXG4gIGhhbmRsZXJzOiBoYW5kbGVycyxcbiAgcGFyYW1zOiBbJ2xhenknLCAnbnVtYmVyJywgJ2RlYm91bmNlJ10sXG5cbiAgLyoqXG4gICAqIFBvc3NpYmxlIGVsZW1lbnRzOlxuICAgKiAgIDxzZWxlY3Q+XG4gICAqICAgPHRleHRhcmVhPlxuICAgKiAgIDxpbnB1dCB0eXBlPVwiKlwiPlxuICAgKiAgICAgLSB0ZXh0XG4gICAqICAgICAtIGNoZWNrYm94XG4gICAqICAgICAtIHJhZGlvXG4gICAqICAgICAtIG51bWJlclxuICAgKi9cblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZnJpZW5kbHkgd2FybmluZy4uLlxuICAgIHRoaXMuY2hlY2tGaWx0ZXJzKClcbiAgICBpZiAodGhpcy5oYXNSZWFkICYmICF0aGlzLmhhc1dyaXRlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgYSByZWFkLW9ubHkgZmlsdGVyIHdpdGggJyArXG4gICAgICAgICd2LW1vZGVsLiBZb3UgbWlnaHQgd2FudCB0byB1c2UgYSB0d28td2F5IGZpbHRlciAnICtcbiAgICAgICAgJ3RvIGVuc3VyZSBjb3JyZWN0IGJlaGF2aW9yLidcbiAgICAgIClcbiAgICB9XG4gICAgdmFyIGVsID0gdGhpcy5lbFxuICAgIHZhciB0YWcgPSBlbC50YWdOYW1lXG4gICAgdmFyIGhhbmRsZXJcbiAgICBpZiAodGFnID09PSAnSU5QVVQnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnNbZWwudHlwZV0gfHwgaGFuZGxlcnMudGV4dFxuICAgIH0gZWxzZSBpZiAodGFnID09PSAnU0VMRUNUJykge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXJzLnNlbGVjdFxuICAgIH0gZWxzZSBpZiAodGFnID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnMudGV4dFxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgJ3YtbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBlbGVtZW50IHR5cGU6ICcgKyB0YWdcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbC5fX3ZfbW9kZWwgPSB0aGlzXG4gICAgaGFuZGxlci5iaW5kLmNhbGwodGhpcylcbiAgICB0aGlzLnVwZGF0ZSA9IGhhbmRsZXIudXBkYXRlXG4gICAgdGhpcy5fdW5iaW5kID0gaGFuZGxlci51bmJpbmRcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgcmVhZC93cml0ZSBmaWx0ZXIgc3RhdHMuXG4gICAqL1xuXG4gIGNoZWNrRmlsdGVyczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzXG4gICAgaWYgKCFmaWx0ZXJzKSByZXR1cm5cbiAgICB2YXIgaSA9IGZpbHRlcnMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGZpbHRlciA9IF8ucmVzb2x2ZUFzc2V0KHRoaXMudm0uJG9wdGlvbnMsICdmaWx0ZXJzJywgZmlsdGVyc1tpXS5uYW1lKVxuICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgfHwgZmlsdGVyLnJlYWQpIHtcbiAgICAgICAgdGhpcy5oYXNSZWFkID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKGZpbHRlci53cml0ZSkge1xuICAgICAgICB0aGlzLmhhc1dyaXRlID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsLl9fdl9tb2RlbCA9IG51bGxcbiAgICB0aGlzLl91bmJpbmQgJiYgdGhpcy5fdW5iaW5kKClcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBlbCA9IHRoaXMuZWxcblxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB2YWx1ZSBvdmVyd3JpdGUgdmlhIHYtYmluZDp2YWx1ZVxuICAgICAgaWYgKGVsLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSkge1xuICAgICAgICByZXR1cm4gZWwuX3ZhbHVlXG4gICAgICB9XG4gICAgICB2YXIgdmFsID0gZWwudmFsdWVcbiAgICAgIGlmIChzZWxmLnBhcmFtcy5udW1iZXIpIHtcbiAgICAgICAgdmFsID0gXy50b051bWJlcih2YWwpXG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuc2V0KHNlbGYuZ2V0VmFsdWUoKSlcbiAgICB9XG4gICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcilcblxuICAgIGlmIChlbC5jaGVja2VkKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXJcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmVsLmNoZWNrZWQgPSBfLmxvb3NlRXF1YWwodmFsdWUsIHRoaXMuZ2V0VmFsdWUoKSlcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBlbCA9IHRoaXMuZWxcblxuICAgIC8vIG1ldGhvZCB0byBmb3JjZSB1cGRhdGUgRE9NIHVzaW5nIGxhdGVzdCB2YWx1ZS5cbiAgICB0aGlzLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuX3dhdGNoZXIpIHtcbiAgICAgICAgc2VsZi51cGRhdGUoc2VsZi5fd2F0Y2hlci5nZXQoKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB0aGlzIGlzIGEgbXVsdGlwbGUgc2VsZWN0XG4gICAgdmFyIG11bHRpcGxlID0gdGhpcy5tdWx0aXBsZSA9IGVsLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKVxuXG4gICAgLy8gYXR0YWNoIGxpc3RlbmVyXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKGVsLCBtdWx0aXBsZSlcbiAgICAgIHZhbHVlID0gc2VsZi5wYXJhbXMubnVtYmVyXG4gICAgICAgID8gXy5pc0FycmF5KHZhbHVlKVxuICAgICAgICAgID8gdmFsdWUubWFwKF8udG9OdW1iZXIpXG4gICAgICAgICAgOiBfLnRvTnVtYmVyKHZhbHVlKVxuICAgICAgICA6IHZhbHVlXG4gICAgICBzZWxmLnNldCh2YWx1ZSlcbiAgICB9XG4gICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcilcblxuICAgIC8vIGlmIGhhcyBpbml0aWFsIHZhbHVlLCBzZXQgYWZ0ZXJCaW5kXG4gICAgdmFyIGluaXRWYWx1ZSA9IGdldFZhbHVlKGVsLCBtdWx0aXBsZSwgdHJ1ZSlcbiAgICBpZiAoKG11bHRpcGxlICYmIGluaXRWYWx1ZS5sZW5ndGgpIHx8XG4gICAgICAgICghbXVsdGlwbGUgJiYgaW5pdFZhbHVlICE9PSBudWxsKSkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyXG4gICAgfVxuXG4gICAgLy8gQWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBGaXJlZm94IHJlc2V0c1xuICAgIC8vIHNlbGVjdGVkSW5kZXggd2l0aCB2YWx1ZSAtMSB0byAwIHdoZW4gdGhlIGVsZW1lbnRcbiAgICAvLyBpcyBhcHBlbmRlZCB0byBhIG5ldyBwYXJlbnQsIHRoZXJlZm9yZSB3ZSBoYXZlIHRvXG4gICAgLy8gZm9yY2UgYSBET00gdXBkYXRlIHdoZW5ldmVyIHRoYXQgaGFwcGVucy4uLlxuICAgIHRoaXMudm0uJG9uKCdob29rOmF0dGFjaGVkJywgdGhpcy5mb3JjZVVwZGF0ZSlcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWxcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTFcbiAgICB2YXIgbXVsdGkgPSB0aGlzLm11bHRpcGxlICYmIF8uaXNBcnJheSh2YWx1ZSlcbiAgICB2YXIgb3B0aW9ucyA9IGVsLm9wdGlvbnNcbiAgICB2YXIgaSA9IG9wdGlvbnMubGVuZ3RoXG4gICAgdmFyIG9wLCB2YWxcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBvcCA9IG9wdGlvbnNbaV1cbiAgICAgIHZhbCA9IG9wLmhhc093blByb3BlcnR5KCdfdmFsdWUnKVxuICAgICAgICA/IG9wLl92YWx1ZVxuICAgICAgICA6IG9wLnZhbHVlXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgICAgIG9wLnNlbGVjdGVkID0gbXVsdGlcbiAgICAgICAgPyBpbmRleE9mKHZhbHVlLCB2YWwpID4gLTFcbiAgICAgICAgOiBfLmxvb3NlRXF1YWwodmFsdWUsIHZhbClcbiAgICAgIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhpcy52bS4kb2ZmKCdob29rOmF0dGFjaGVkJywgdGhpcy5mb3JjZVVwZGF0ZSlcbiAgfVxufVxuXG4vKipcbiAqIEdldCBzZWxlY3QgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge1NlbGVjdEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG11bHRpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXRcbiAqIEByZXR1cm4ge0FycmF5fCp9XG4gKi9cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKGVsLCBtdWx0aSwgaW5pdCkge1xuICB2YXIgcmVzID0gbXVsdGkgPyBbXSA6IG51bGxcbiAgdmFyIG9wLCB2YWwsIHNlbGVjdGVkXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcCA9IGVsLm9wdGlvbnNbaV1cbiAgICBzZWxlY3RlZCA9IGluaXRcbiAgICAgID8gb3AuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpXG4gICAgICA6IG9wLnNlbGVjdGVkXG4gICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICB2YWwgPSBvcC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJylcbiAgICAgICAgPyBvcC5fdmFsdWVcbiAgICAgICAgOiBvcC52YWx1ZVxuICAgICAgaWYgKG11bHRpKSB7XG4gICAgICAgIHJlcy5wdXNoKHZhbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIE5hdGl2ZSBBcnJheS5pbmRleE9mIHVzZXMgc3RyaWN0IGVxdWFsLCBidXQgaW4gdGhpc1xuICogY2FzZSB3ZSBuZWVkIHRvIG1hdGNoIHN0cmluZy9udW1iZXJzIHdpdGggY3VzdG9tIGVxdWFsLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBpbmRleE9mIChhcnIsIHZhbCkge1xuICB2YXIgaSA9IGFyci5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChfLmxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICB2YXIgZWwgPSB0aGlzLmVsXG4gICAgdmFyIGlzUmFuZ2UgPSBlbC50eXBlID09PSAncmFuZ2UnXG4gICAgdmFyIGxhenkgPSB0aGlzLnBhcmFtcy5sYXp5XG4gICAgdmFyIG51bWJlciA9IHRoaXMucGFyYW1zLm51bWJlclxuICAgIHZhciBkZWJvdW5jZSA9IHRoaXMucGFyYW1zLmRlYm91bmNlXG5cbiAgICAvLyBoYW5kbGUgY29tcG9zaXRpb24gZXZlbnRzLlxuICAgIC8vICAgaHR0cDovL2Jsb2cuZXZhbnlvdS5tZS8yMDE0LzAxLzAzL2NvbXBvc2l0aW9uLWV2ZW50L1xuICAgIC8vIHNraXAgdGhpcyBmb3IgQW5kcm9pZCBiZWNhdXNlIGl0IGhhbmRsZXMgY29tcG9zaXRpb25cbiAgICAvLyBldmVudHMgcXVpdGUgZGlmZmVyZW50bHkuIEFuZHJvaWQgZG9lc24ndCB0cmlnZ2VyXG4gICAgLy8gY29tcG9zaXRpb24gZXZlbnRzIGZvciBsYW5ndWFnZSBpbnB1dCBtZXRob2RzIGUuZy5cbiAgICAvLyBDaGluZXNlLCBidXQgaW5zdGVhZCB0cmlnZ2VycyB0aGVtIGZvciBzcGVsbGluZ1xuICAgIC8vIHN1Z2dlc3Rpb25zLi4uIChzZWUgRGlzY3Vzc2lvbi8jMTYyKVxuICAgIHZhciBjb21wb3NpbmcgPSBmYWxzZVxuICAgIGlmICghXy5pc0FuZHJvaWQgJiYgIWlzUmFuZ2UpIHtcbiAgICAgIHRoaXMub24oJ2NvbXBvc2l0aW9uc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXBvc2luZyA9IHRydWVcbiAgICAgIH0pXG4gICAgICB0aGlzLm9uKCdjb21wb3NpdGlvbmVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tcG9zaW5nID0gZmFsc2VcbiAgICAgICAgLy8gaW4gSUUxMSB0aGUgXCJjb21wb3NpdGlvbmVuZFwiIGV2ZW50IGZpcmVzIEFGVEVSXG4gICAgICAgIC8vIHRoZSBcImlucHV0XCIgZXZlbnQsIHNvIHRoZSBpbnB1dCBoYW5kbGVyIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gYXQgdGhlIGVuZC4uLiBoYXZlIHRvIGNhbGwgaXQgaGVyZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gIzEzMjc6IGluIGxhenkgbW9kZSB0aGlzIGlzIHVuZWNlc3NhcnkuXG4gICAgICAgIGlmICghbGF6eSkge1xuICAgICAgICAgIHNlbGYubGlzdGVuZXIoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIHByZXZlbnQgbWVzc2luZyB3aXRoIHRoZSBpbnB1dCB3aGVuIHVzZXIgaXMgdHlwaW5nLFxuICAgIC8vIGFuZCBmb3JjZSB1cGRhdGUgb24gYmx1ci5cbiAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZVxuICAgIGlmICghaXNSYW5nZSkge1xuICAgICAgdGhpcy5vbignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZm9jdXNlZCA9IHRydWVcbiAgICAgIH0pXG4gICAgICB0aGlzLm9uKCdibHVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmZvY3VzZWQgPSBmYWxzZVxuICAgICAgICBzZWxmLmxpc3RlbmVyKClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gTm93IGF0dGFjaCB0aGUgbWFpbiBsaXN0ZW5lclxuICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY29tcG9zaW5nKSByZXR1cm5cbiAgICAgIHZhciB2YWwgPSBudW1iZXIgfHwgaXNSYW5nZVxuICAgICAgICA/IF8udG9OdW1iZXIoZWwudmFsdWUpXG4gICAgICAgIDogZWwudmFsdWVcbiAgICAgIHNlbGYuc2V0KHZhbClcbiAgICAgIC8vIGZvcmNlIHVwZGF0ZSBvbiBuZXh0IHRpY2sgdG8gYXZvaWQgbG9jayAmIHNhbWUgdmFsdWVcbiAgICAgIC8vIGFsc28gb25seSB1cGRhdGUgd2hlbiB1c2VyIGlzIG5vdCB0eXBpbmdcbiAgICAgIF8ubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi5fYm91bmQgJiYgIXNlbGYuZm9jdXNlZCkge1xuICAgICAgICAgIHNlbGYudXBkYXRlKHNlbGYuX3dhdGNoZXIudmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgZGVib3VuY2VcbiAgICBpZiAoZGVib3VuY2UpIHtcbiAgICAgIHRoaXMubGlzdGVuZXIgPSBfLmRlYm91bmNlKHRoaXMubGlzdGVuZXIsIGRlYm91bmNlKVxuICAgIH1cblxuICAgIC8vIFN1cHBvcnQgalF1ZXJ5IGV2ZW50cywgc2luY2UgalF1ZXJ5LnRyaWdnZXIoKSBkb2Vzbid0XG4gICAgLy8gdHJpZ2dlciBuYXRpdmUgZXZlbnRzIGluIHNvbWUgY2FzZXMgYW5kIHNvbWUgcGx1Z2luc1xuICAgIC8vIHJlbHkgb24gJC50cmlnZ2VyKClcbiAgICAvL1xuICAgIC8vIFdlIHdhbnQgdG8gbWFrZSBzdXJlIGlmIGEgbGlzdGVuZXIgaXMgYXR0YWNoZWQgdXNpbmdcbiAgICAvLyBqUXVlcnksIGl0IGlzIGFsc28gcmVtb3ZlZCB3aXRoIGpRdWVyeSwgdGhhdCdzIHdoeVxuICAgIC8vIHdlIGRvIHRoZSBjaGVjayBmb3IgZWFjaCBkaXJlY3RpdmUgaW5zdGFuY2UgYW5kXG4gICAgLy8gc3RvcmUgdGhhdCBjaGVjayByZXN1bHQgb24gaXRzZWxmLiBUaGlzIGFsc28gYWxsb3dzXG4gICAgLy8gZWFzaWVyIHRlc3QgY292ZXJhZ2UgY29udHJvbCBieSB1bnNldHRpbmcgdGhlIGdsb2JhbFxuICAgIC8vIGpRdWVyeSB2YXJpYWJsZSBpbiB0ZXN0cy5cbiAgICB0aGlzLmhhc2pRdWVyeSA9IHR5cGVvZiBqUXVlcnkgPT09ICdmdW5jdGlvbidcbiAgICBpZiAodGhpcy5oYXNqUXVlcnkpIHtcbiAgICAgIGpRdWVyeShlbCkub24oJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpXG4gICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgalF1ZXJ5KGVsKS5vbignaW5wdXQnLCB0aGlzLmxpc3RlbmVyKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKVxuICAgICAgaWYgKCFsYXp5KSB7XG4gICAgICAgIHRoaXMub24oJ2lucHV0JywgdGhpcy5saXN0ZW5lcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJRTkgZG9lc24ndCBmaXJlIGlucHV0IGV2ZW50IG9uIGJhY2tzcGFjZS9kZWwvY3V0XG4gICAgaWYgKCFsYXp5ICYmIF8uaXNJRTkpIHtcbiAgICAgIHRoaXMub24oJ2N1dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgXy5uZXh0VGljayhzZWxmLmxpc3RlbmVyKVxuICAgICAgfSlcbiAgICAgIHRoaXMub24oJ2tleXVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gNDYgfHwgZS5rZXlDb2RlID09PSA4KSB7XG4gICAgICAgICAgc2VsZi5saXN0ZW5lcigpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gc2V0IGluaXRpYWwgdmFsdWUgaWYgcHJlc2VudFxuICAgIGlmIChcbiAgICAgIGVsLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSB8fFxuICAgICAgKGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiYgZWwudmFsdWUudHJpbSgpKVxuICAgICkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyXG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5lbC52YWx1ZSA9IF8udG9TdHJpbmcodmFsdWUpXG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbFxuICAgIGlmICh0aGlzLmhhc2pRdWVyeSkge1xuICAgICAgalF1ZXJ5KGVsKS5vZmYoJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpXG4gICAgICBqUXVlcnkoZWwpLm9mZignaW5wdXQnLCB0aGlzLmxpc3RlbmVyKVxuICAgIH1cbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi91dGlsJylcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gICdkZWxldGUnOiA0NixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MFxufVxuXG5mdW5jdGlvbiBrZXlGaWx0ZXIgKGhhbmRsZXIsIGtleXMpIHtcbiAgdmFyIGNvZGVzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjb2RlID0ga2V5Q29kZXNba2V5XVxuICAgIGlmICghY29kZSkge1xuICAgICAgY29kZSA9IHBhcnNlSW50KGtleSwgMTApXG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH0pXG4gIHJldHVybiBmdW5jdGlvbiBrZXlIYW5kbGVyIChlKSB7XG4gICAgaWYgKGNvZGVzLmluZGV4T2YoZS5rZXlDb2RlKSA+IC0xKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BGaWx0ZXIgKGhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0b3BIYW5kbGVyIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmV2ZW50RmlsdGVyIChoYW5kbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50SGFuZGxlciAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBhY2NlcHRTdGF0ZW1lbnQ6IHRydWUsXG4gIHByaW9yaXR5OiA3MDAsXG5cbiAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgIC8vIGRlYWwgd2l0aCBpZnJhbWVzXG4gICAgaWYgKFxuICAgICAgdGhpcy5lbC50YWdOYW1lID09PSAnSUZSQU1FJyAmJlxuICAgICAgdGhpcy5hcmcgIT09ICdsb2FkJ1xuICAgICkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICB0aGlzLmlmcmFtZUJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF8ub24oc2VsZi5lbC5jb250ZW50V2luZG93LCBzZWxmLmFyZywgc2VsZi5oYW5kbGVyKVxuICAgICAgfVxuICAgICAgdGhpcy5vbignbG9hZCcsIHRoaXMuaWZyYW1lQmluZClcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIC8vIHN0dWIgYSBub29wIGZvciB2LW9uIHdpdGggbm8gdmFsdWUsXG4gICAgLy8gZS5nLiBAbW91c2Vkb3duLnByZXZlbnRcbiAgICBpZiAoIXRoaXMuZGVzY3JpcHRvci5yYXcpIHtcbiAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7fVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICd2LW9uOicgKyB0aGlzLmFyZyArICc9XCInICtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uICsgJ1wiIGV4cGVjdHMgYSBmdW5jdGlvbiB2YWx1ZSwgJyArXG4gICAgICAgICdnb3QgJyArIGhhbmRsZXJcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGFwcGx5IG1vZGlmaWVyc1xuICAgIGlmICh0aGlzLm1vZGlmaWVycy5zdG9wKSB7XG4gICAgICBoYW5kbGVyID0gc3RvcEZpbHRlcihoYW5kbGVyKVxuICAgIH1cbiAgICBpZiAodGhpcy5tb2RpZmllcnMucHJldmVudCkge1xuICAgICAgaGFuZGxlciA9IHByZXZlbnRGaWx0ZXIoaGFuZGxlcilcbiAgICB9XG4gICAgLy8ga2V5IGZpbHRlclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5tb2RpZmllcnMpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSAhPT0gJ3N0b3AnICYmIGtleSAhPT0gJ3ByZXZlbnQnXG4gICAgICB9KVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgaGFuZGxlciA9IGtleUZpbHRlcihoYW5kbGVyLCBrZXlzKVxuICAgIH1cblxuICAgIHRoaXMucmVzZXQoKVxuICAgIHZhciBzY29wZSA9IHRoaXMuX3Njb3BlIHx8IHRoaXMudm1cbiAgICB0aGlzLmhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgc2NvcGUuJGV2ZW50ID0gZVxuICAgICAgdmFyIHJlcyA9IGhhbmRsZXIoZSlcbiAgICAgIHNjb3BlLiRldmVudCA9IG51bGxcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gICAgaWYgKHRoaXMuaWZyYW1lQmluZCkge1xuICAgICAgdGhpcy5pZnJhbWVCaW5kKClcbiAgICB9IGVsc2Uge1xuICAgICAgXy5vbih0aGlzLmVsLCB0aGlzLmFyZywgdGhpcy5oYW5kbGVyKVxuICAgIH1cbiAgfSxcblxuICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IHRoaXMuaWZyYW1lQmluZFxuICAgICAgPyB0aGlzLmVsLmNvbnRlbnRXaW5kb3dcbiAgICAgIDogdGhpcy5lbFxuICAgIGlmICh0aGlzLmhhbmRsZXIpIHtcbiAgICAgIF8ub2ZmKGVsLCB0aGlzLmFyZywgdGhpcy5oYW5kbGVyKVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2V0KClcbiAgfVxufVxuIiwiaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmVxdWlyZSgnLi4vLi4vdXRpbCcpLndhcm4oXG4gICAgICAgICd2LXJlZjonICsgdGhpcy5hcmcgKyAnIG11c3QgYmUgdXNlZCBvbiBhIGNoaWxkICcgK1xuICAgICAgICAnY29tcG9uZW50LiBGb3VuZCBvbiA8JyArIHRoaXMuZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgJz4uJ1xuICAgICAgKVxuICAgIH1cbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbnZhciB0cmFuc2l0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHJhbnNpdGlvbicpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjaGVjayBlbHNlIGJsb2NrXG4gICAgdmFyIG5leHQgPSB0aGlzLmVsLm5leHRFbGVtZW50U2libGluZ1xuICAgIGlmIChuZXh0ICYmIF8uYXR0cihuZXh0LCAndi1lbHNlJykgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZWxzZUVsID0gbmV4dFxuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWxcbiAgICB0cmFuc2l0aW9uLmFwcGx5KGVsLCB2YWx1ZSA/IDEgOiAtMSwgZnVuY3Rpb24gKCkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gJycgOiAnbm9uZSdcbiAgICB9LCB0aGlzLnZtKVxuICAgIHZhciBlbHNlRWwgPSB0aGlzLmVsc2VFbFxuICAgIGlmIChlbHNlRWwpIHtcbiAgICAgIHRyYW5zaXRpb24uYXBwbHkoZWxzZUVsLCB2YWx1ZSA/IC0xIDogMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbHNlRWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gJ25vbmUnIDogJydcbiAgICAgIH0sIHRoaXMudm0pXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hdHRyID0gdGhpcy5lbC5ub2RlVHlwZSA9PT0gM1xuICAgICAgPyAnZGF0YSdcbiAgICAgIDogJ3RleHRDb250ZW50J1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5lbFt0aGlzLmF0dHJdID0gXy50b1N0cmluZyh2YWx1ZSlcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBQYXRoID0gcmVxdWlyZSgnLi4vcGFyc2Vycy9wYXRoJylcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgnLi4vZGlyZWN0aXZlcy9wdWJsaWMvZm9yJykuX3Bvc3RQcm9jZXNzXG5cbi8qKlxuICogTGltaXQgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICovXG5cbmV4cG9ydHMubGltaXRCeSA9IGZ1bmN0aW9uIChhcnIsIG4pIHtcbiAgcmV0dXJuIHR5cGVvZiBuID09PSAnbnVtYmVyJ1xuICAgID8gYXJyLnNsaWNlKDAsIG4pXG4gICAgOiBhcnJcbn1cblxuLyoqXG4gKiBGaWx0ZXIgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoS2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gW2RlbGltaXRlcl1cbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhS2V5XG4gKi9cblxuZXhwb3J0cy5maWx0ZXJCeSA9IGZ1bmN0aW9uIChhcnIsIHNlYXJjaCwgZGVsaW1pdGVyIC8qIC4uLmRhdGFLZXlzICovKSB7XG4gIGFyciA9IHRvQXJyYXkoYXJyKVxuICBpZiAoc2VhcmNoID09IG51bGwpIHtcbiAgICByZXR1cm4gYXJyXG4gIH1cbiAgaWYgKHR5cGVvZiBzZWFyY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYXJyLmZpbHRlcihzZWFyY2gpXG4gIH1cbiAgLy8gY2FzdCB0byBsb3dlcmNhc2Ugc3RyaW5nXG4gIHNlYXJjaCA9ICgnJyArIHNlYXJjaCkudG9Mb3dlckNhc2UoKVxuICAvLyBhbGxvdyBvcHRpb25hbCBgaW5gIGRlbGltaXRlclxuICAvLyBiZWNhdXNlIHdoeSBub3RcbiAgdmFyIG4gPSBkZWxpbWl0ZXIgPT09ICdpbicgPyAzIDogMlxuICAvLyBleHRyYWN0IGFuZCBmbGF0dGVuIGtleXNcbiAgdmFyIGtleXMgPSBfLnRvQXJyYXkoYXJndW1lbnRzLCBuKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xuICAgIHJldHVybiBwcmV2LmNvbmNhdChjdXIpXG4gIH0sIFtdKVxuICB2YXIgcmVzID0gW11cbiAgdmFyIGl0ZW0sIGtleSwgdmFsLCBqXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGl0ZW0gPSBhcnJbaV1cbiAgICB2YWwgPSAoaXRlbSAmJiBpdGVtLiR2YWx1ZSkgfHwgaXRlbVxuICAgIGogPSBrZXlzLmxlbmd0aFxuICAgIGlmIChqKSB7XG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGtleSA9IGtleXNbal1cbiAgICAgICAgaWYgKChrZXkgPT09ICcka2V5JyAmJiBjb250YWlucyhpdGVtLiRrZXksIHNlYXJjaCkpIHx8XG4gICAgICAgICAgICBjb250YWlucyhQYXRoLmdldCh2YWwsIGtleSksIHNlYXJjaCkpIHtcbiAgICAgICAgICByZXMucHVzaChpdGVtKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5zKGl0ZW0sIHNlYXJjaCkpIHtcbiAgICAgIHJlcy5wdXNoKGl0ZW0pXG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBGaWx0ZXIgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc29ydEtleVxuICogQHBhcmFtIHtTdHJpbmd9IHJldmVyc2VcbiAqL1xuXG5leHBvcnRzLm9yZGVyQnkgPSBmdW5jdGlvbiAoYXJyLCBzb3J0S2V5LCByZXZlcnNlKSB7XG4gIGFyciA9IHRvQXJyYXkoYXJyKVxuICBpZiAoIXNvcnRLZXkpIHtcbiAgICByZXR1cm4gYXJyXG4gIH1cbiAgdmFyIG9yZGVyID0gKHJldmVyc2UgJiYgcmV2ZXJzZSA8IDApID8gLTEgOiAxXG4gIC8vIHNvcnQgb24gYSBjb3B5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGFycmF5XG4gIHJldHVybiBhcnIuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKHNvcnRLZXkgIT09ICcka2V5Jykge1xuICAgICAgaWYgKF8uaXNPYmplY3QoYSkgJiYgJyR2YWx1ZScgaW4gYSkgYSA9IGEuJHZhbHVlXG4gICAgICBpZiAoXy5pc09iamVjdChiKSAmJiAnJHZhbHVlJyBpbiBiKSBiID0gYi4kdmFsdWVcbiAgICB9XG4gICAgYSA9IF8uaXNPYmplY3QoYSkgPyBQYXRoLmdldChhLCBzb3J0S2V5KSA6IGFcbiAgICBiID0gXy5pc09iamVjdChiKSA/IFBhdGguZ2V0KGIsIHNvcnRLZXkpIDogYlxuICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gb3JkZXIgOiAtb3JkZXJcbiAgfSlcbn1cblxuLyoqXG4gKiBTdHJpbmcgY29udGFpbiBoZWxwZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFxuICovXG5cbmZ1bmN0aW9uIGNvbnRhaW5zICh2YWwsIHNlYXJjaCkge1xuICB2YXIgaVxuICBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbClcbiAgICBpID0ga2V5cy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoY29udGFpbnModmFsW2tleXNbaV1dLCBzZWFyY2gpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKF8uaXNBcnJheSh2YWwpKSB7XG4gICAgaSA9IHZhbC5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoY29udGFpbnModmFsW2ldLCBzZWFyY2gpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2gpID4gLTFcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcblxuLyoqXG4gKiBTdHJpbmdpZnkgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGVudFxuICovXG5cbmV4cG9ydHMuanNvbiA9IHtcbiAgcmVhZDogZnVuY3Rpb24gKHZhbHVlLCBpbmRlbnQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJ1xuICAgICAgPyB2YWx1ZVxuICAgICAgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgTnVtYmVyKGluZGVudCkgfHwgMilcbiAgfSxcbiAgd3JpdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiAnYWJjJyA9PiAnQWJjJ1xuICovXG5cbmV4cG9ydHMuY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSByZXR1cm4gJydcbiAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpXG4gIHJldHVybiB2YWx1ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbHVlLnNsaWNlKDEpXG59XG5cbi8qKlxuICogJ2FiYycgPT4gJ0FCQydcbiAqL1xuXG5leHBvcnRzLnVwcGVyY2FzZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlIHx8IHZhbHVlID09PSAwKVxuICAgID8gdmFsdWUudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpXG4gICAgOiAnJ1xufVxuXG4vKipcbiAqICdBYkMnID0+ICdhYmMnXG4gKi9cblxuZXhwb3J0cy5sb3dlcmNhc2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMClcbiAgICA/IHZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKVxuICAgIDogJydcbn1cblxuLyoqXG4gKiAxMjM0NSA9PiAkMTIsMzQ1LjAwXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ25cbiAqL1xuXG52YXIgZGlnaXRzUkUgPSAvKFxcZHszfSkoPz1cXGQpL2dcbmV4cG9ydHMuY3VycmVuY3kgPSBmdW5jdGlvbiAodmFsdWUsIGN1cnJlbmN5KSB7XG4gIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSlcbiAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkgfHwgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkpIHJldHVybiAnJ1xuICBjdXJyZW5jeSA9IGN1cnJlbmN5ICE9IG51bGwgPyBjdXJyZW5jeSA6ICckJ1xuICB2YXIgc3RyaW5naWZpZWQgPSBNYXRoLmFicyh2YWx1ZSkudG9GaXhlZCgyKVxuICB2YXIgX2ludCA9IHN0cmluZ2lmaWVkLnNsaWNlKDAsIC0zKVxuICB2YXIgaSA9IF9pbnQubGVuZ3RoICUgM1xuICB2YXIgaGVhZCA9IGkgPiAwXG4gICAgPyAoX2ludC5zbGljZSgwLCBpKSArIChfaW50Lmxlbmd0aCA+IDMgPyAnLCcgOiAnJykpXG4gICAgOiAnJ1xuICB2YXIgX2Zsb2F0ID0gc3RyaW5naWZpZWQuc2xpY2UoLTMpXG4gIHZhciBzaWduID0gdmFsdWUgPCAwID8gJy0nIDogJydcbiAgcmV0dXJuIGN1cnJlbmN5ICsgc2lnbiArIGhlYWQgK1xuICAgIF9pbnQuc2xpY2UoaSkucmVwbGFjZShkaWdpdHNSRSwgJyQxLCcpICtcbiAgICBfZmxvYXRcbn1cblxuLyoqXG4gKiAnaXRlbScgPT4gJ2l0ZW1zJ1xuICpcbiAqIEBwYXJhbXNcbiAqICBhbiBhcnJheSBvZiBzdHJpbmdzIGNvcnJlc3BvbmRpbmcgdG9cbiAqICB0aGUgc2luZ2xlLCBkb3VibGUsIHRyaXBsZSAuLi4gZm9ybXMgb2YgdGhlIHdvcmQgdG9cbiAqICBiZSBwbHVyYWxpemVkLiBXaGVuIHRoZSBudW1iZXIgdG8gYmUgcGx1cmFsaXplZFxuICogIGV4Y2VlZHMgdGhlIGxlbmd0aCBvZiB0aGUgYXJncywgaXQgd2lsbCB1c2UgdGhlIGxhc3RcbiAqICBlbnRyeSBpbiB0aGUgYXJyYXkuXG4gKlxuICogIGUuZy4gWydzaW5nbGUnLCAnZG91YmxlJywgJ3RyaXBsZScsICdtdWx0aXBsZSddXG4gKi9cblxuZXhwb3J0cy5wbHVyYWxpemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIGFyZ3MgPSBfLnRvQXJyYXkoYXJndW1lbnRzLCAxKVxuICByZXR1cm4gYXJncy5sZW5ndGggPiAxXG4gICAgPyAoYXJnc1t2YWx1ZSAlIDEwIC0gMV0gfHwgYXJnc1thcmdzLmxlbmd0aCAtIDFdKVxuICAgIDogKGFyZ3NbMF0gKyAodmFsdWUgPT09IDEgPyAnJyA6ICdzJykpXG59XG5cbi8qKlxuICogRGVib3VuY2UgYSBoYW5kbGVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSA9IDMwMFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZXhwb3J0cy5kZWJvdW5jZSA9IGZ1bmN0aW9uIChoYW5kbGVyLCBkZWxheSkge1xuICBpZiAoIWhhbmRsZXIpIHJldHVyblxuICBpZiAoIWRlbGF5KSB7XG4gICAgZGVsYXkgPSAzMDBcbiAgfVxuICByZXR1cm4gXy5kZWJvdW5jZShoYW5kbGVyLCBkZWxheSlcbn1cblxuLyoqXG4gKiBJbnN0YWxsIHNwZWNpYWwgYXJyYXkgZmlsdGVyc1xuICovXG5cbl8uZXh0ZW5kKGV4cG9ydHMsIHJlcXVpcmUoJy4vYXJyYXktZmlsdGVycycpKVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBjb21waWxlciA9IHJlcXVpcmUoJy4uL2NvbXBpbGVyJylcbnZhciB0ZW1wbGF0ZVBhcnNlciA9IHJlcXVpcmUoJy4uL3BhcnNlcnMvdGVtcGxhdGUnKVxudmFyIEZyYWdtZW50ID0gcmVxdWlyZSgnLi9mcmFnbWVudCcpXG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZScpXG52YXIgbGlua2VyQ2FjaGUgPSBuZXcgQ2FjaGUoNTAwMClcblxuLyoqXG4gKiBBIGZhY3RvcnkgdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgaW5zdGFuY2VzIG9mIGFcbiAqIGZyYWdtZW50LiBDYWNoZXMgdGhlIGNvbXBpbGVkIGxpbmtlciBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsXG4gKi9cblxuZnVuY3Rpb24gRnJhZ21lbnRGYWN0b3J5ICh2bSwgZWwpIHtcbiAgdGhpcy52bSA9IHZtXG4gIHZhciB0ZW1wbGF0ZVxuICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgZWwgPT09ICdzdHJpbmcnXG4gIGlmIChpc1N0cmluZyB8fCBfLmlzVGVtcGxhdGUoZWwpKSB7XG4gICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZVBhcnNlci5wYXJzZShlbCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKGVsKVxuICB9XG4gIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZVxuICAvLyBsaW5rZXIgY2FuIGJlIGNhY2hlZCwgYnV0IG9ubHkgZm9yIGNvbXBvbmVudHNcbiAgdmFyIGxpbmtlclxuICB2YXIgY2lkID0gdm0uY29uc3RydWN0b3IuY2lkXG4gIGlmIChjaWQgPiAwKSB7XG4gICAgdmFyIGNhY2hlSWQgPSBjaWQgKyAoaXNTdHJpbmcgPyBlbCA6IGVsLm91dGVySFRNTClcbiAgICBsaW5rZXIgPSBsaW5rZXJDYWNoZS5nZXQoY2FjaGVJZClcbiAgICBpZiAoIWxpbmtlcikge1xuICAgICAgbGlua2VyID0gY29tcGlsZXIuY29tcGlsZSh0ZW1wbGF0ZSwgdm0uJG9wdGlvbnMsIHRydWUpXG4gICAgICBsaW5rZXJDYWNoZS5wdXQoY2FjaGVJZCwgbGlua2VyKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsaW5rZXIgPSBjb21waWxlci5jb21waWxlKHRlbXBsYXRlLCB2bS4kb3B0aW9ucywgdHJ1ZSlcbiAgfVxuICB0aGlzLmxpbmtlciA9IGxpbmtlclxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGZyYWdtZW50IGluc3RhbmNlIHdpdGggZ2l2ZW4gaG9zdCBhbmQgc2NvcGUuXG4gKlxuICogQHBhcmFtIHtWdWV9IGhvc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICogQHBhcmFtIHtGcmFnbWVudH0gcGFyZW50RnJhZ1xuICovXG5cbkZyYWdtZW50RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKSB7XG4gIHZhciBmcmFnID0gdGVtcGxhdGVQYXJzZXIuY2xvbmUodGhpcy50ZW1wbGF0ZSlcbiAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmxpbmtlciwgdGhpcy52bSwgZnJhZywgaG9zdCwgc2NvcGUsIHBhcmVudEZyYWcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRnJhZ21lbnRGYWN0b3J5XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIHRyYW5zaXRpb24gPSByZXF1aXJlKCcuLi90cmFuc2l0aW9uJylcblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBmb3IgYSBwYXJ0aWFsbHktY29tcGlsZWQgZnJhZ21lbnQuXG4gKiBDYW4gb3B0aW9uYWxseSBjb21waWxlIGNvbnRlbnQgd2l0aCBhIGNoaWxkIHNjb3BlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpbmtlclxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7VnVlfSBbaG9zdF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdXG4gKi9cblxuZnVuY3Rpb24gRnJhZ21lbnQgKGxpbmtlciwgdm0sIGZyYWcsIGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXVxuICB0aGlzLmNoaWxkRnJhZ3MgPSBbXVxuICB0aGlzLnZtID0gdm1cbiAgdGhpcy5zY29wZSA9IHNjb3BlXG4gIHRoaXMuaW5zZXJ0ZWQgPSBmYWxzZVxuICB0aGlzLnBhcmVudEZyYWcgPSBwYXJlbnRGcmFnXG4gIGlmIChwYXJlbnRGcmFnKSB7XG4gICAgcGFyZW50RnJhZy5jaGlsZEZyYWdzLnB1c2godGhpcylcbiAgfVxuICB0aGlzLnVubGluayA9IGxpbmtlcih2bSwgZnJhZywgaG9zdCwgc2NvcGUsIHRoaXMpXG4gIHZhciBzaW5nbGUgPSB0aGlzLnNpbmdsZSA9IGZyYWcuY2hpbGROb2Rlcy5sZW5ndGggPT09IDFcbiAgaWYgKHNpbmdsZSkge1xuICAgIHRoaXMubm9kZSA9IGZyYWcuY2hpbGROb2Rlc1swXVxuICAgIHRoaXMuYmVmb3JlID0gc2luZ2xlQmVmb3JlXG4gICAgdGhpcy5yZW1vdmUgPSBzaW5nbGVSZW1vdmVcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5vZGUgPSBfLmNyZWF0ZUFuY2hvcignZnJhZ21lbnQtc3RhcnQnKVxuICAgIHRoaXMuZW5kID0gXy5jcmVhdGVBbmNob3IoJ2ZyYWdtZW50LWVuZCcpXG4gICAgdGhpcy5mcmFnID0gZnJhZ1xuICAgIF8ucHJlcGVuZCh0aGlzLm5vZGUsIGZyYWcpXG4gICAgZnJhZy5hcHBlbmRDaGlsZCh0aGlzLmVuZClcbiAgICB0aGlzLmJlZm9yZSA9IG11bHRpQmVmb3JlXG4gICAgdGhpcy5yZW1vdmUgPSBtdWx0aVJlbW92ZVxuICB9XG4gIHRoaXMubm9kZS5fX3ZmcmFnX18gPSB0aGlzXG59XG5cbi8qKlxuICogQ2FsbCBhdHRhY2gvZGV0YWNoIGZvciBhbGwgY29tcG9uZW50cyBjb250YWluZWQgd2l0aGluXG4gKiB0aGlzIGZyYWdtZW50LiBBbHNvIGRvIHNvIHJlY3Vyc2l2ZWx5IGZvciBhbGwgY2hpbGRcbiAqIGZyYWdtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gKi9cblxuRnJhZ21lbnQucHJvdG90eXBlLmNhbGxIb29rID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgdmFyIGksIGxcbiAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaG9vayh0aGlzLmNoaWxkcmVuW2ldKVxuICB9XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkRnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdGhpcy5jaGlsZEZyYWdzW2ldLmNhbGxIb29rKGhvb2spXG4gIH1cbn1cblxuLyoqXG4gKiBEZXN0cm95IHRoZSBmcmFnbWVudC5cbiAqL1xuXG5GcmFnbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGFyZW50RnJhZykge1xuICAgIHRoaXMucGFyZW50RnJhZy5jaGlsZEZyYWdzLiRyZW1vdmUodGhpcylcbiAgfVxuICB0aGlzLnVubGluaygpXG59XG5cbi8qKlxuICogSW5zZXJ0IGZyYWdtZW50IGJlZm9yZSB0YXJnZXQsIHNpbmdsZSBub2RlIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtCb29sZWFufSB3aXRoVHJhbnNpdGlvblxuICovXG5cbmZ1bmN0aW9uIHNpbmdsZUJlZm9yZSAodGFyZ2V0LCB3aXRoVHJhbnNpdGlvbikge1xuICB0aGlzLmluc2VydGVkID0gdHJ1ZVxuICB2YXIgbWV0aG9kID0gd2l0aFRyYW5zaXRpb24gIT09IGZhbHNlXG4gICAgPyB0cmFuc2l0aW9uLmJlZm9yZVxuICAgIDogXy5iZWZvcmVcbiAgbWV0aG9kKHRoaXMubm9kZSwgdGFyZ2V0LCB0aGlzLnZtKVxuICBpZiAoXy5pbkRvYyh0aGlzLm5vZGUpKSB7XG4gICAgdGhpcy5jYWxsSG9vayhhdHRhY2gpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZnJhZ21lbnQsIHNpbmdsZSBub2RlIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtkZXN0cm95XVxuICovXG5cbmZ1bmN0aW9uIHNpbmdsZVJlbW92ZSAoZGVzdHJveSkge1xuICB0aGlzLmluc2VydGVkID0gZmFsc2VcbiAgdmFyIHNob3VsZENhbGxSZW1vdmUgPSBfLmluRG9jKHRoaXMubm9kZSlcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRyYW5zaXRpb24ucmVtb3ZlKHRoaXMubm9kZSwgdGhpcy52bSwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzaG91bGRDYWxsUmVtb3ZlKSB7XG4gICAgICBzZWxmLmNhbGxIb29rKGRldGFjaClcbiAgICB9XG4gICAgaWYgKGRlc3Ryb3kpIHtcbiAgICAgIHNlbGYuZGVzdHJveSgpXG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIEluc2VydCBmcmFnbWVudCBiZWZvcmUgdGFyZ2V0LCBtdWx0aS1ub2RlcyB2ZXJzaW9uXG4gKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFRyYW5zaXRpb25cbiAqL1xuXG5mdW5jdGlvbiBtdWx0aUJlZm9yZSAodGFyZ2V0LCB3aXRoVHJhbnNpdGlvbikge1xuICB0aGlzLmluc2VydGVkID0gdHJ1ZVxuICB2YXIgdm0gPSB0aGlzLnZtXG4gIHZhciBtZXRob2QgPSB3aXRoVHJhbnNpdGlvbiAhPT0gZmFsc2VcbiAgICA/IHRyYW5zaXRpb24uYmVmb3JlXG4gICAgOiBfLmJlZm9yZVxuICBfLm1hcE5vZGVSYW5nZSh0aGlzLm5vZGUsIHRoaXMuZW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIG1ldGhvZChub2RlLCB0YXJnZXQsIHZtKVxuICB9KVxuICBpZiAoXy5pbkRvYyh0aGlzLm5vZGUpKSB7XG4gICAgdGhpcy5jYWxsSG9vayhhdHRhY2gpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZnJhZ21lbnQsIG11bHRpLW5vZGVzIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtkZXN0cm95XVxuICovXG5cbmZ1bmN0aW9uIG11bHRpUmVtb3ZlIChkZXN0cm95KSB7XG4gIHRoaXMuaW5zZXJ0ZWQgPSBmYWxzZVxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHNob3VsZENhbGxSZW1vdmUgPSBfLmluRG9jKHRoaXMubm9kZSlcbiAgXy5yZW1vdmVOb2RlUmFuZ2UodGhpcy5ub2RlLCB0aGlzLmVuZCwgdGhpcy52bSwgdGhpcy5mcmFnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNob3VsZENhbGxSZW1vdmUpIHtcbiAgICAgIHNlbGYuY2FsbEhvb2soZGV0YWNoKVxuICAgIH1cbiAgICBpZiAoZGVzdHJveSkge1xuICAgICAgc2VsZi5kZXN0cm95KClcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogQ2FsbCBhdHRhY2ggaG9vayBmb3IgYSBWdWUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtWdWV9IGNoaWxkXG4gKi9cblxuZnVuY3Rpb24gYXR0YWNoIChjaGlsZCkge1xuICBpZiAoIWNoaWxkLl9pc0F0dGFjaGVkKSB7XG4gICAgY2hpbGQuX2NhbGxIb29rKCdhdHRhY2hlZCcpXG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsIGRldGFjaCBob29rIGZvciBhIFZ1ZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAqL1xuXG5mdW5jdGlvbiBkZXRhY2ggKGNoaWxkKSB7XG4gIGlmIChjaGlsZC5faXNBdHRhY2hlZCkge1xuICAgIGNoaWxkLl9jYWxsSG9vaygnZGV0YWNoZWQnKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRnJhZ21lbnRcbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgaW5Eb2MgPSBfLmluRG9jXG52YXIgZXZlbnRSRSA9IC9edi1vbjp8XkAvXG5cbi8qKlxuICogU2V0dXAgdGhlIGluc3RhbmNlJ3Mgb3B0aW9uIGV2ZW50cyAmIHdhdGNoZXJzLlxuICogSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCB3ZSBwdWxsIGl0IGZyb20gdGhlXG4gKiBpbnN0YW5jZSdzIG1ldGhvZHMgYnkgbmFtZS5cbiAqL1xuXG5leHBvcnRzLl9pbml0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50KSB7XG4gICAgcmVnaXN0ZXJDb21wb25lbnRFdmVudHModGhpcywgb3B0aW9ucy5lbClcbiAgfVxuICByZWdpc3RlckNhbGxiYWNrcyh0aGlzLCAnJG9uJywgb3B0aW9ucy5ldmVudHMpXG4gIHJlZ2lzdGVyQ2FsbGJhY2tzKHRoaXMsICckd2F0Y2gnLCBvcHRpb25zLndhdGNoKVxufVxuXG4vKipcbiAqIFJlZ2lzdGVyIHYtb24gZXZlbnRzIG9uIGEgY2hpbGQgY29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJDb21wb25lbnRFdmVudHMgKHZtLCBlbCkge1xuICB2YXIgYXR0cnMgPSBlbC5hdHRyaWJ1dGVzXG4gIHZhciBuYW1lLCBoYW5kbGVyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IGF0dHJzW2ldLm5hbWVcbiAgICBpZiAoZXZlbnRSRS50ZXN0KG5hbWUpKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGV2ZW50UkUsICcnKVxuICAgICAgaGFuZGxlciA9ICh2bS5fc2NvcGUgfHwgdm0uX2NvbnRleHQpLiRldmFsKGF0dHJzW2ldLnZhbHVlLCB0cnVlKVxuICAgICAgdm0uJG9uKG5hbWUucmVwbGFjZShldmVudFJFKSwgaGFuZGxlcilcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlciBjYWxsYmFja3MgZm9yIG9wdGlvbiBldmVudHMgYW5kIHdhdGNoZXJzLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGhhc2hcbiAqL1xuXG5mdW5jdGlvbiByZWdpc3RlckNhbGxiYWNrcyAodm0sIGFjdGlvbiwgaGFzaCkge1xuICBpZiAoIWhhc2gpIHJldHVyblxuICB2YXIgaGFuZGxlcnMsIGtleSwgaSwgalxuICBmb3IgKGtleSBpbiBoYXNoKSB7XG4gICAgaGFuZGxlcnMgPSBoYXNoW2tleV1cbiAgICBpZiAoXy5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgICAgZm9yIChpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXJzW2ldKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXJzKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB0byByZWdpc3RlciBhbiBldmVudC93YXRjaCBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfE9iamVjdH0gaGFuZGxlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICovXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyICh2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgaGFuZGxlclxuICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZtW2FjdGlvbl0oa2V5LCBoYW5kbGVyLCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzXG4gICAgdmFyIG1ldGhvZCA9IG1ldGhvZHMgJiYgbWV0aG9kc1toYW5kbGVyXVxuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIHZtW2FjdGlvbl0oa2V5LCBtZXRob2QsIG9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAnVW5rbm93biBtZXRob2Q6IFwiJyArIGhhbmRsZXIgKyAnXCIgd2hlbiAnICtcbiAgICAgICAgJ3JlZ2lzdGVyaW5nIGNhbGxiYWNrIGZvciAnICsgYWN0aW9uICtcbiAgICAgICAgJzogXCInICsga2V5ICsgJ1wiLidcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAoaGFuZGxlciAmJiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHJlZ2lzdGVyKHZtLCBhY3Rpb24sIGtleSwgaGFuZGxlci5oYW5kbGVyLCBoYW5kbGVyKVxuICB9XG59XG5cbi8qKlxuICogU2V0dXAgcmVjdXJzaXZlIGF0dGFjaGVkL2RldGFjaGVkIGNhbGxzXG4gKi9cblxuZXhwb3J0cy5faW5pdERPTUhvb2tzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLiRvbignaG9vazphdHRhY2hlZCcsIG9uQXR0YWNoZWQpXG4gIHRoaXMuJG9uKCdob29rOmRldGFjaGVkJywgb25EZXRhY2hlZClcbn1cblxuLyoqXG4gKiBDYWxsYmFjayB0byByZWN1cnNpdmVseSBjYWxsIGF0dGFjaGVkIGhvb2sgb24gY2hpbGRyZW5cbiAqL1xuXG5mdW5jdGlvbiBvbkF0dGFjaGVkICgpIHtcbiAgaWYgKCF0aGlzLl9pc0F0dGFjaGVkKSB7XG4gICAgdGhpcy5faXNBdHRhY2hlZCA9IHRydWVcbiAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNhbGxBdHRhY2gpXG4gIH1cbn1cblxuLyoqXG4gKiBJdGVyYXRvciB0byBjYWxsIGF0dGFjaGVkIGhvb2tcbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAqL1xuXG5mdW5jdGlvbiBjYWxsQXR0YWNoIChjaGlsZCkge1xuICBpZiAoIWNoaWxkLl9pc0F0dGFjaGVkICYmIGluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICBjaGlsZC5fY2FsbEhvb2soJ2F0dGFjaGVkJylcbiAgfVxufVxuXG4vKipcbiAqIENhbGxiYWNrIHRvIHJlY3Vyc2l2ZWx5IGNhbGwgZGV0YWNoZWQgaG9vayBvbiBjaGlsZHJlblxuICovXG5cbmZ1bmN0aW9uIG9uRGV0YWNoZWQgKCkge1xuICBpZiAodGhpcy5faXNBdHRhY2hlZCkge1xuICAgIHRoaXMuX2lzQXR0YWNoZWQgPSBmYWxzZVxuICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goY2FsbERldGFjaClcbiAgfVxufVxuXG4vKipcbiAqIEl0ZXJhdG9yIHRvIGNhbGwgZGV0YWNoZWQgaG9va1xuICpcbiAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICovXG5cbmZ1bmN0aW9uIGNhbGxEZXRhY2ggKGNoaWxkKSB7XG4gIGlmIChjaGlsZC5faXNBdHRhY2hlZCAmJiAhaW5Eb2MoY2hpbGQuJGVsKSkge1xuICAgIGNoaWxkLl9jYWxsSG9vaygnZGV0YWNoZWQnKVxuICB9XG59XG5cbi8qKlxuICogVHJpZ2dlciBhbGwgaGFuZGxlcnMgZm9yIGEgaG9va1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBob29rXG4gKi9cblxuZXhwb3J0cy5fY2FsbEhvb2sgPSBmdW5jdGlvbiAoaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB0aGlzLiRvcHRpb25zW2hvb2tdXG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBoYW5kbGVyc1tpXS5jYWxsKHRoaXMpXG4gICAgfVxuICB9XG4gIHRoaXMuJGVtaXQoJ2hvb2s6JyArIGhvb2spXG59XG4iLCJ2YXIgbWVyZ2VPcHRpb25zID0gcmVxdWlyZSgnLi4vdXRpbCcpLm1lcmdlT3B0aW9uc1xudmFyIHVpZCA9IDBcblxuLyoqXG4gKiBUaGUgbWFpbiBpbml0IHNlcXVlbmNlLiBUaGlzIGlzIGNhbGxlZCBmb3IgZXZlcnlcbiAqIGluc3RhbmNlLCBpbmNsdWRpbmcgb25lcyB0aGF0IGFyZSBjcmVhdGVkIGZyb20gZXh0ZW5kZWRcbiAqIGNvbnN0cnVjdG9ycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoaXMgb3B0aW9ucyBvYmplY3Qgc2hvdWxkIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSByZXN1bHQgb2YgbWVyZ2luZyBjbGFzc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zIGFuZCB0aGUgb3B0aW9ucyBwYXNzZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdG8gdGhlIGNvbnN0cnVjdG9yLlxuICovXG5cbmV4cG9ydHMuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgdGhpcy4kZWwgPSBudWxsXG4gIHRoaXMuJHBhcmVudCA9IG9wdGlvbnMucGFyZW50XG4gIHRoaXMuJHJvb3QgPSB0aGlzLiRwYXJlbnRcbiAgICA/IHRoaXMuJHBhcmVudC4kcm9vdFxuICAgIDogdGhpc1xuICB0aGlzLiRjaGlsZHJlbiA9IFtdXG4gIHRoaXMuJHJlZnMgPSB7fSAgICAgICAvLyBjaGlsZCB2bSByZWZlcmVuY2VzXG4gIHRoaXMuJGVscyA9IHt9ICAgICAgICAvLyBlbGVtZW50IHJlZmVyZW5jZXNcbiAgdGhpcy5fd2F0Y2hlcnMgPSBbXSAgIC8vIGFsbCB3YXRjaGVycyBhcyBhbiBhcnJheVxuICB0aGlzLl9kaXJlY3RpdmVzID0gW10gLy8gYWxsIGRpcmVjdGl2ZXNcblxuICAvLyBhIHVpZFxuICB0aGlzLl91aWQgPSB1aWQrK1xuXG4gIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gIHRoaXMuX2lzVnVlID0gdHJ1ZVxuXG4gIC8vIGV2ZW50cyBib29ra2VlcGluZ1xuICB0aGlzLl9ldmVudHMgPSB7fSAgICAgICAgICAgIC8vIHJlZ2lzdGVyZWQgY2FsbGJhY2tzXG4gIHRoaXMuX2V2ZW50c0NvdW50ID0ge30gICAgICAgLy8gZm9yICRicm9hZGNhc3Qgb3B0aW1pemF0aW9uXG4gIHRoaXMuX3Nob3VsZFByb3BhZ2F0ZSA9IGZhbHNlIC8vIGZvciBldmVudCBwcm9wYWdhdGlvblxuXG4gIC8vIGZyYWdtZW50IGluc3RhbmNlIHByb3BlcnRpZXNcbiAgdGhpcy5faXNGcmFnbWVudCA9IGZhbHNlXG4gIHRoaXMuX2ZyYWdtZW50ID0gICAgICAgICAvLyBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH1cbiAgdGhpcy5fZnJhZ21lbnRTdGFydCA9ICAgIC8vIEB0eXBlIHtUZXh0fENvbW1lbnR9XG4gIHRoaXMuX2ZyYWdtZW50RW5kID0gbnVsbCAvLyBAdHlwZSB7VGV4dHxDb21tZW50fVxuXG4gIC8vIGxpZmVjeWNsZSBzdGF0ZVxuICB0aGlzLl9pc0NvbXBpbGVkID1cbiAgdGhpcy5faXNEZXN0cm95ZWQgPVxuICB0aGlzLl9pc1JlYWR5ID1cbiAgdGhpcy5faXNBdHRhY2hlZCA9XG4gIHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZVxuICB0aGlzLl91bmxpbmtGbiA9IG51bGxcblxuICAvLyBjb250ZXh0OlxuICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNjbHVkZWQgY29tcG9uZW50LCBjb250ZXh0XG4gIC8vIHdpbGwgYmUgdGhlIGNvbW1vbiBwYXJlbnQgdm0gb2YgdGhpcyBpbnN0YW5jZVxuICAvLyBhbmQgaXRzIGhvc3QuXG4gIHRoaXMuX2NvbnRleHQgPSBvcHRpb25zLl9jb250ZXh0IHx8IHRoaXMuJHBhcmVudFxuXG4gIC8vIHNjb3BlOlxuICAvLyBpZiB0aGlzIGlzIGluc2lkZSBhbiBpbmxpbmUgdi1mb3IsIHRoZSBzY29wZVxuICAvLyB3aWxsIGJlIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgY3JlYXRlZCBmb3IgdGhpc1xuICAvLyByZXBlYXQgZnJhZ21lbnQuIHRoaXMgaXMgdXNlZCBmb3IgbGlua2luZyBwcm9wc1xuICAvLyBhbmQgY29udGFpbmVyIGRpcmVjdGl2ZXMuXG4gIHRoaXMuX3Njb3BlID0gb3B0aW9ucy5fc2NvcGVcblxuICAvLyBmcmFnbWVudDpcbiAgLy8gaWYgdGhpcyBpbnN0YW5jZSBpcyBjb21waWxlZCBpbnNpZGUgYSBGcmFnbWVudCwgaXRcbiAgLy8gbmVlZHMgdG8gcmVpZ3N0ZXIgaXRzZWxmIGFzIGEgY2hpbGQgb2YgdGhhdCBmcmFnbWVudFxuICAvLyBmb3IgYXR0YWNoL2RldGFjaCB0byB3b3JrIHByb3Blcmx5LlxuICB0aGlzLl9mcmFnID0gb3B0aW9ucy5fZnJhZ1xuICBpZiAodGhpcy5fZnJhZykge1xuICAgIHRoaXMuX2ZyYWcuY2hpbGRyZW4ucHVzaCh0aGlzKVxuICB9XG5cbiAgLy8gcHVzaCBzZWxmIGludG8gcGFyZW50IC8gdHJhbnNjbHVzaW9uIGhvc3RcbiAgaWYgKHRoaXMuJHBhcmVudCkge1xuICAgIHRoaXMuJHBhcmVudC4kY2hpbGRyZW4ucHVzaCh0aGlzKVxuICB9XG5cbiAgLy8gc2V0IHJlZlxuICBpZiAob3B0aW9ucy5fcmVmKSB7XG4gICAgKHRoaXMuX3Njb3BlIHx8IHRoaXMuX2NvbnRleHQpLiRyZWZzW29wdGlvbnMuX3JlZl0gPSB0aGlzXG4gIH1cblxuICAvLyBtZXJnZSBvcHRpb25zLlxuICBvcHRpb25zID0gdGhpcy4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICB0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnMsXG4gICAgb3B0aW9ucyxcbiAgICB0aGlzXG4gIClcblxuICAvLyBpbml0aWFsaXplIGRhdGEgYXMgZW1wdHkgb2JqZWN0LlxuICAvLyBpdCB3aWxsIGJlIGZpbGxlZCB1cCBpbiBfaW5pdFNjb3BlKCkuXG4gIHRoaXMuX2RhdGEgPSB7fVxuXG4gIC8vIGNhbGwgaW5pdCBob29rXG4gIHRoaXMuX2NhbGxIb29rKCdpbml0JylcblxuICAvLyBpbml0aWFsaXplIGRhdGEgb2JzZXJ2YXRpb24gYW5kIHNjb3BlIGluaGVyaXRhbmNlLlxuICB0aGlzLl9pbml0U3RhdGUoKVxuXG4gIC8vIHNldHVwIGV2ZW50IHN5c3RlbSBhbmQgb3B0aW9uIGV2ZW50cy5cbiAgdGhpcy5faW5pdEV2ZW50cygpXG5cbiAgLy8gY2FsbCBjcmVhdGVkIGhvb2tcbiAgdGhpcy5fY2FsbEhvb2soJ2NyZWF0ZWQnKVxuXG4gIC8vIGlmIGBlbGAgb3B0aW9uIGlzIHBhc3NlZCwgc3RhcnQgY29tcGlsYXRpb24uXG4gIGlmIChvcHRpb25zLmVsKSB7XG4gICAgdGhpcy4kbW91bnQob3B0aW9ucy5lbClcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBEaXJlY3RpdmUgPSByZXF1aXJlKCcuLi9kaXJlY3RpdmUnKVxudmFyIGNvbXBpbGVyID0gcmVxdWlyZSgnLi4vY29tcGlsZXInKVxuXG4vKipcbiAqIFRyYW5zY2x1ZGUsIGNvbXBpbGUgYW5kIGxpbmsgZWxlbWVudC5cbiAqXG4gKiBJZiBhIHByZS1jb21waWxlZCBsaW5rZXIgaXMgYXZhaWxhYmxlLCB0aGF0IG1lYW5zIHRoZVxuICogcGFzc2VkIGluIGVsZW1lbnQgd2lsbCBiZSBwcmUtdHJhbnNjbHVkZWQgYW5kIGNvbXBpbGVkXG4gKiBhcyB3ZWxsIC0gYWxsIHdlIG5lZWQgdG8gZG8gaXMgdG8gY2FsbCB0aGUgbGlua2VyLlxuICpcbiAqIE90aGVyd2lzZSB3ZSBuZWVkIHRvIGNhbGwgdHJhbnNjbHVkZS9jb21waWxlL2xpbmsgaGVyZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5cbmV4cG9ydHMuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zXG5cbiAgLy8gdHJhbnNjbHVkZSBhbmQgaW5pdCBlbGVtZW50XG4gIC8vIHRyYW5zY2x1ZGUgY2FuIHBvdGVudGlhbGx5IHJlcGxhY2Ugb3JpZ2luYWxcbiAgLy8gc28gd2UgbmVlZCB0byBrZWVwIHJlZmVyZW5jZTsgdGhpcyBzdGVwIGFsc28gaW5qZWN0c1xuICAvLyB0aGUgdGVtcGxhdGUgYW5kIGNhY2hlcyB0aGUgb3JpZ2luYWwgYXR0cmlidXRlc1xuICAvLyBvbiB0aGUgY29udGFpbmVyIG5vZGUgYW5kIHJlcGxhY2VyIG5vZGUuXG4gIHZhciBvcmlnaW5hbCA9IGVsXG4gIGVsID0gY29tcGlsZXIudHJhbnNjbHVkZShlbCwgb3B0aW9ucylcbiAgdGhpcy5faW5pdEVsZW1lbnQoZWwpXG5cbiAgLy8gcm9vdCBpcyBhbHdheXMgY29tcGlsZWQgcGVyLWluc3RhbmNlLCBiZWNhdXNlXG4gIC8vIGNvbnRhaW5lciBhdHRycyBhbmQgcHJvcHMgY2FuIGJlIGRpZmZlcmVudCBldmVyeSB0aW1lLlxuICB2YXIgY29udGV4dE9wdGlvbnMgPSB0aGlzLl9jb250ZXh0ICYmIHRoaXMuX2NvbnRleHQuJG9wdGlvbnNcbiAgdmFyIHJvb3RMaW5rZXIgPSBjb21waWxlci5jb21waWxlUm9vdChlbCwgb3B0aW9ucywgY29udGV4dE9wdGlvbnMpXG5cbiAgLy8gY29tcGlsZSBhbmQgbGluayB0aGUgcmVzdFxuICB2YXIgY29udGVudExpbmtGblxuICB2YXIgY3RvciA9IHRoaXMuY29uc3RydWN0b3JcbiAgLy8gY29tcG9uZW50IGNvbXBpbGF0aW9uIGNhbiBiZSBjYWNoZWRcbiAgLy8gYXMgbG9uZyBhcyBpdCdzIG5vdCB1c2luZyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKG9wdGlvbnMuX2xpbmtlckNhY2hhYmxlKSB7XG4gICAgY29udGVudExpbmtGbiA9IGN0b3IubGlua2VyXG4gICAgaWYgKCFjb250ZW50TGlua0ZuKSB7XG4gICAgICBjb250ZW50TGlua0ZuID0gY3Rvci5saW5rZXIgPSBjb21waWxlci5jb21waWxlKGVsLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIC8vIGxpbmsgcGhhc2VcbiAgLy8gbWFrZSBzdXJlIHRvIGxpbmsgcm9vdCB3aXRoIHByb3Agc2NvcGUhXG4gIHZhciByb290VW5saW5rRm4gPSByb290TGlua2VyKHRoaXMsIGVsLCB0aGlzLl9zY29wZSlcbiAgdmFyIGNvbnRlbnRVbmxpbmtGbiA9IGNvbnRlbnRMaW5rRm5cbiAgICA/IGNvbnRlbnRMaW5rRm4odGhpcywgZWwpXG4gICAgOiBjb21waWxlci5jb21waWxlKGVsLCBvcHRpb25zKSh0aGlzLCBlbClcblxuICAvLyByZWdpc3RlciBjb21wb3NpdGUgdW5saW5rIGZ1bmN0aW9uXG4gIC8vIHRvIGJlIGNhbGxlZCBkdXJpbmcgaW5zdGFuY2UgZGVzdHJ1Y3Rpb25cbiAgdGhpcy5fdW5saW5rRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgcm9vdFVubGlua0ZuKClcbiAgICAvLyBwYXNzaW5nIGRlc3Ryb3lpbmc6IHRydWUgdG8gYXZvaWQgc2VhcmNoaW5nIGFuZFxuICAgIC8vIHNwbGljaW5nIHRoZSBkaXJlY3RpdmVzXG4gICAgY29udGVudFVubGlua0ZuKHRydWUpXG4gIH1cblxuICAvLyBmaW5hbGx5IHJlcGxhY2Ugb3JpZ2luYWxcbiAgaWYgKG9wdGlvbnMucmVwbGFjZSkge1xuICAgIF8ucmVwbGFjZShvcmlnaW5hbCwgZWwpXG4gIH1cblxuICB0aGlzLl9pc0NvbXBpbGVkID0gdHJ1ZVxuICB0aGlzLl9jYWxsSG9vaygnY29tcGlsZWQnKVxuICByZXR1cm4gZWxcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGluc3RhbmNlIGVsZW1lbnQuIENhbGxlZCBpbiB0aGUgcHVibGljXG4gKiAkbW91bnQoKSBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICovXG5cbmV4cG9ydHMuX2luaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gIGlmIChlbCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICB0aGlzLl9pc0ZyYWdtZW50ID0gdHJ1ZVxuICAgIHRoaXMuJGVsID0gdGhpcy5fZnJhZ21lbnRTdGFydCA9IGVsLmZpcnN0Q2hpbGRcbiAgICB0aGlzLl9mcmFnbWVudEVuZCA9IGVsLmxhc3RDaGlsZFxuICAgIC8vIHNldCBwZXJzaXN0ZWQgdGV4dCBhbmNob3JzIHRvIGVtcHR5XG4gICAgaWYgKHRoaXMuX2ZyYWdtZW50U3RhcnQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIHRoaXMuX2ZyYWdtZW50U3RhcnQuZGF0YSA9IHRoaXMuX2ZyYWdtZW50RW5kLmRhdGEgPSAnJ1xuICAgIH1cbiAgICB0aGlzLl9mcmFnbWVudCA9IGVsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy4kZWwgPSBlbFxuICB9XG4gIHRoaXMuJGVsLl9fdnVlX18gPSB0aGlzXG4gIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVDb21waWxlJylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW5kIGJpbmQgYSBkaXJlY3RpdmUgdG8gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIGRpcmVjdGl2ZSBuYW1lXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgICAtIHRhcmdldCBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzYyAtIHBhcnNlZCBkaXJlY3RpdmUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtPYmplY3R9IGRlZiAgLSBkaXJlY3RpdmUgZGVmaW5pdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7VnVlfSBbaG9zdF0gLSB0cmFuc2NsdXNpb24gaG9zdCBjb21wb25lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIC0gdi1mb3Igc2NvcGVcbiAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXSAtIG93bmVyIGZyYWdtZW50XG4gKi9cblxuZXhwb3J0cy5fYmluZERpciA9IGZ1bmN0aW9uIChkZXNjcmlwdG9yLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZykge1xuICB0aGlzLl9kaXJlY3RpdmVzLnB1c2goXG4gICAgbmV3IERpcmVjdGl2ZShkZXNjcmlwdG9yLCB0aGlzLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZylcbiAgKVxufVxuXG4vKipcbiAqIFRlYXJkb3duIGFuIGluc3RhbmNlLCB1bm9ic2VydmVzIHRoZSBkYXRhLCB1bmJpbmQgYWxsIHRoZVxuICogZGlyZWN0aXZlcywgdHVybiBvZmYgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMsIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZSAtIHdoZXRoZXIgdG8gcmVtb3ZlIHRoZSBET00gbm9kZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVmZXJDbGVhbnVwIC0gaWYgdHJ1ZSwgZGVmZXIgY2xlYW51cCB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBjYWxsZWQgbGF0ZXJcbiAqL1xuXG5leHBvcnRzLl9kZXN0cm95ID0gZnVuY3Rpb24gKHJlbW92ZSwgZGVmZXJDbGVhbnVwKSB7XG4gIGlmICh0aGlzLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5fY2FsbEhvb2soJ2JlZm9yZURlc3Ryb3knKVxuICB0aGlzLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZVxuICB2YXIgaVxuICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudC4gb25seSBuZWNlc3NhcnlcbiAgLy8gaWYgcGFyZW50IGlzIG5vdCBiZWluZyBkZXN0cm95ZWQgYXMgd2VsbC5cbiAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudFxuICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICBwYXJlbnQuJGNoaWxkcmVuLiRyZW1vdmUodGhpcylcbiAgICAvLyB1bnJlZ2lzdGVyIHJlZlxuICAgIHZhciByZWYgPSB0aGlzLiRvcHRpb25zLl9yZWZcbiAgICBpZiAocmVmKSB7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLl9zY29wZSB8fCB0aGlzLl9jb250ZXh0XG4gICAgICBpZiAoc2NvcGUuJHJlZnNbcmVmXSA9PT0gdGhpcykge1xuICAgICAgICBzY29wZS4kcmVmc1tyZWZdID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyByZW1vdmUgc2VsZiBmcm9tIG93bmVyIGZyYWdtZW50XG4gIGlmICh0aGlzLl9mcmFnKSB7XG4gICAgdGhpcy5fZnJhZy5jaGlsZHJlbi4kcmVtb3ZlKHRoaXMpXG4gIH1cbiAgLy8gZGVzdHJveSBhbGwgY2hpbGRyZW4uXG4gIGkgPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuJGNoaWxkcmVuW2ldLiRkZXN0cm95KClcbiAgfVxuICAvLyB0ZWFyZG93biBwcm9wc1xuICBpZiAodGhpcy5fcHJvcHNVbmxpbmtGbikge1xuICAgIHRoaXMuX3Byb3BzVW5saW5rRm4oKVxuICB9XG4gIC8vIHRlYXJkb3duIGFsbCBkaXJlY3RpdmVzLiB0aGlzIGFsc28gdGVhcnNkb3duIGFsbFxuICAvLyBkaXJlY3RpdmUtb3duZWQgd2F0Y2hlcnMuXG4gIGlmICh0aGlzLl91bmxpbmtGbikge1xuICAgIHRoaXMuX3VubGlua0ZuKClcbiAgfVxuICBpID0gdGhpcy5fd2F0Y2hlcnMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzLl93YXRjaGVyc1tpXS50ZWFyZG93bigpXG4gIH1cbiAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBzZWxmIG9uICRlbFxuICBpZiAodGhpcy4kZWwpIHtcbiAgICB0aGlzLiRlbC5fX3Z1ZV9fID0gbnVsbFxuICB9XG4gIC8vIHJlbW92ZSBET00gZWxlbWVudFxuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHJlbW92ZSAmJiB0aGlzLiRlbCkge1xuICAgIHRoaXMuJHJlbW92ZShmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9jbGVhbnVwKClcbiAgICB9KVxuICB9IGVsc2UgaWYgKCFkZWZlckNsZWFudXApIHtcbiAgICB0aGlzLl9jbGVhbnVwKClcbiAgfVxufVxuXG4vKipcbiAqIENsZWFuIHVwIHRvIGVuc3VyZSBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gKiBUaGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgbGVhdmUgdHJhbnNpdGlvbiBpZiB0aGVyZVxuICogaXMgYW55LlxuICovXG5cbmV4cG9ydHMuX2NsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICBpZiAodGhpcy5fZGF0YS5fX29iX18pIHtcbiAgICB0aGlzLl9kYXRhLl9fb2JfXy5yZW1vdmVWbSh0aGlzKVxuICB9XG4gIC8vIENsZWFuIHVwIHJlZmVyZW5jZXMgdG8gcHJpdmF0ZSBwcm9wZXJ0aWVzIGFuZCBvdGhlclxuICAvLyBpbnN0YW5jZXMuIHByZXNlcnZlIHJlZmVyZW5jZSB0byBfZGF0YSBzbyB0aGF0IHByb3h5XG4gIC8vIGFjY2Vzc29ycyBzdGlsbCB3b3JrLiBUaGUgb25seSBwb3RlbnRpYWwgc2lkZSBlZmZlY3RcbiAgLy8gaGVyZSBpcyB0aGF0IG11dGF0aW5nIHRoZSBpbnN0YW5jZSBhZnRlciBpdCdzIGRlc3Ryb3llZFxuICAvLyBtYXkgYWZmZWN0IHRoZSBzdGF0ZSBvZiBvdGhlciBjb21wb25lbnRzIHRoYXQgYXJlIHN0aWxsXG4gIC8vIG9ic2VydmluZyB0aGUgc2FtZSBvYmplY3QsIGJ1dCB0aGF0IHNlZW1zIHRvIGJlIGFcbiAgLy8gcmVhc29uYWJsZSByZXNwb25zaWJpbGl0eSBmb3IgdGhlIHVzZXIgcmF0aGVyIHRoYW5cbiAgLy8gYWx3YXlzIHRocm93aW5nIGFuIGVycm9yIG9uIHRoZW0uXG4gIHRoaXMuJGVsID1cbiAgdGhpcy4kcGFyZW50ID1cbiAgdGhpcy4kcm9vdCA9XG4gIHRoaXMuJGNoaWxkcmVuID1cbiAgdGhpcy5fd2F0Y2hlcnMgPVxuICB0aGlzLl9jb250ZXh0ID1cbiAgdGhpcy5fc2NvcGUgPVxuICB0aGlzLl9kaXJlY3RpdmVzID0gbnVsbFxuICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgdGhpcy5faXNEZXN0cm95ZWQgPSB0cnVlXG4gIHRoaXMuX2NhbGxIb29rKCdkZXN0cm95ZWQnKVxuICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICB0aGlzLiRvZmYoKVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcblxuLyoqXG4gKiBBcHBseSBhIGxpc3Qgb2YgZmlsdGVyIChkZXNjcmlwdG9ycykgdG8gYSB2YWx1ZS5cbiAqIFVzaW5nIHBsYWluIGZvciBsb29wcyBoZXJlIGJlY2F1c2UgdGhpcyB3aWxsIGJlIGNhbGxlZCBpblxuICogdGhlIGdldHRlciBvZiBhbnkgd2F0Y2hlciB3aXRoIGZpbHRlcnMgc28gaXQgaXMgdmVyeVxuICogcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7Kn0gW29sZFZhbHVlXVxuICogQHBhcmFtIHtBcnJheX0gZmlsdGVyc1xuICogQHBhcmFtIHtCb29sZWFufSB3cml0ZVxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5leHBvcnRzLl9hcHBseUZpbHRlcnMgPSBmdW5jdGlvbiAodmFsdWUsIG9sZFZhbHVlLCBmaWx0ZXJzLCB3cml0ZSkge1xuICB2YXIgZmlsdGVyLCBmbiwgYXJncywgYXJnLCBvZmZzZXQsIGksIGwsIGosIGtcbiAgZm9yIChpID0gMCwgbCA9IGZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZmlsdGVyID0gZmlsdGVyc1tpXVxuICAgIGZuID0gXy5yZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBmaWx0ZXIubmFtZSlcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgXy5hc3NlcnRBc3NldChmbiwgJ2ZpbHRlcicsIGZpbHRlci5uYW1lKVxuICAgIH1cbiAgICBpZiAoIWZuKSBjb250aW51ZVxuICAgIGZuID0gd3JpdGUgPyBmbi53cml0ZSA6IChmbi5yZWFkIHx8IGZuKVxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIGNvbnRpbnVlXG4gICAgYXJncyA9IHdyaXRlID8gW3ZhbHVlLCBvbGRWYWx1ZV0gOiBbdmFsdWVdXG4gICAgb2Zmc2V0ID0gd3JpdGUgPyAyIDogMVxuICAgIGlmIChmaWx0ZXIuYXJncykge1xuICAgICAgZm9yIChqID0gMCwgayA9IGZpbHRlci5hcmdzLmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICBhcmcgPSBmaWx0ZXIuYXJnc1tqXVxuICAgICAgICBhcmdzW2ogKyBvZmZzZXRdID0gYXJnLmR5bmFtaWNcbiAgICAgICAgICA/IHRoaXMuJGdldChhcmcudmFsdWUpXG4gICAgICAgICAgOiBhcmcudmFsdWVcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIFJlc29sdmUgYSBjb21wb25lbnQsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBjb21wb25lbnRcbiAqIGlzIGRlZmluZWQgbm9ybWFsbHkgb3IgdXNpbmcgYW4gYXN5bmMgZmFjdG9yeSBmdW5jdGlvbi5cbiAqIFJlc29sdmVzIHN5bmNocm9ub3VzbHkgaWYgYWxyZWFkeSByZXNvbHZlZCwgb3RoZXJ3aXNlXG4gKiByZXNvbHZlcyBhc3luY2hyb25vdXNseSBhbmQgY2FjaGVzIHRoZSByZXNvbHZlZFxuICogY29uc3RydWN0b3Igb24gdGhlIGZhY3RvcnkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbmV4cG9ydHMuX3Jlc29sdmVDb21wb25lbnQgPSBmdW5jdGlvbiAoaWQsIGNiKSB7XG4gIHZhciBmYWN0b3J5ID0gXy5yZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCBpZClcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBfLmFzc2VydEFzc2V0KGZhY3RvcnksICdjb21wb25lbnQnLCBpZClcbiAgfVxuICBpZiAoIWZhY3RvcnkpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvLyBhc3luYyBjb21wb25lbnQgZmFjdG9yeVxuICBpZiAoIWZhY3Rvcnkub3B0aW9ucykge1xuICAgIGlmIChmYWN0b3J5LnJlc29sdmVkKSB7XG4gICAgICAvLyBjYWNoZWRcbiAgICAgIGNiKGZhY3RvcnkucmVzb2x2ZWQpXG4gICAgfSBlbHNlIGlmIChmYWN0b3J5LnJlcXVlc3RlZCkge1xuICAgICAgLy8gcG9vbCBjYWxsYmFja3NcbiAgICAgIGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICBmYWN0b3J5LnJlcXVlc3RlZCA9IHRydWVcbiAgICAgIHZhciBjYnMgPSBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MgPSBbY2JdXG4gICAgICBmYWN0b3J5KGZ1bmN0aW9uIHJlc29sdmUgKHJlcykge1xuICAgICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHJlcykpIHtcbiAgICAgICAgICByZXMgPSBfLlZ1ZS5leHRlbmQocmVzKVxuICAgICAgICB9XG4gICAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSByZXNcbiAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrc1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjYnNbaV0ocmVzKVxuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiByZWplY3QgKHJlYXNvbikge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiAnICsgaWQgKyAnLiAnICtcbiAgICAgICAgICAocmVhc29uID8gJ1xcblJlYXNvbjogJyArIHJlYXNvbiA6ICcnKVxuICAgICAgICApXG4gICAgICB9KVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBub3JtYWwgY29tcG9uZW50XG4gICAgY2IoZmFjdG9yeSlcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBjb21waWxlciA9IHJlcXVpcmUoJy4uL2NvbXBpbGVyJylcbnZhciBPYnNlcnZlciA9IHJlcXVpcmUoJy4uL29ic2VydmVyJylcbnZhciBEZXAgPSByZXF1aXJlKCcuLi9vYnNlcnZlci9kZXAnKVxudmFyIFdhdGNoZXIgPSByZXF1aXJlKCcuLi93YXRjaGVyJylcblxuLyoqXG4gKiBTZXR1cCB0aGUgc2NvcGUgb2YgYW4gaW5zdGFuY2UsIHdoaWNoIGNvbnRhaW5zOlxuICogLSBvYnNlcnZlZCBkYXRhXG4gKiAtIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAqIC0gdXNlciBtZXRob2RzXG4gKiAtIG1ldGEgcHJvcGVydGllc1xuICovXG5cbmV4cG9ydHMuX2luaXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5faW5pdFByb3BzKClcbiAgdGhpcy5faW5pdE1ldGEoKVxuICB0aGlzLl9pbml0TWV0aG9kcygpXG4gIHRoaXMuX2luaXREYXRhKClcbiAgdGhpcy5faW5pdENvbXB1dGVkKClcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHByb3BzLlxuICovXG5cbmV4cG9ydHMuX2luaXRQcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zXG4gIHZhciBlbCA9IG9wdGlvbnMuZWxcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wc1xuICBpZiAocHJvcHMgJiYgIWVsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnUHJvcHMgd2lsbCBub3QgYmUgY29tcGlsZWQgaWYgbm8gYGVsYCBvcHRpb24gaXMgJyArXG4gICAgICAncHJvdmlkZWQgYXQgaW5zdGFudGlhdGlvbi4nXG4gICAgKVxuICB9XG4gIC8vIG1ha2Ugc3VyZSB0byBjb252ZXJ0IHN0cmluZyBzZWxlY3RvcnMgaW50byBlbGVtZW50IG5vd1xuICBlbCA9IG9wdGlvbnMuZWwgPSBfLnF1ZXJ5KGVsKVxuICB0aGlzLl9wcm9wc1VubGlua0ZuID0gZWwgJiYgZWwubm9kZVR5cGUgPT09IDEgJiYgcHJvcHNcbiAgICAvLyBwcm9wcyBtdXN0IGJlIGxpbmtlZCBpbiBwcm9wZXIgc2NvcGUgaWYgaW5zaWRlIHYtZm9yXG4gICAgPyBjb21waWxlci5jb21waWxlQW5kTGlua1Byb3BzKHRoaXMsIGVsLCBwcm9wcywgdGhpcy5fc2NvcGUpXG4gICAgOiBudWxsXG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgZGF0YS5cbiAqL1xuXG5leHBvcnRzLl9pbml0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHRoaXMuX2RhdGFcbiAgdmFyIG9wdGlvbnNEYXRhRm4gPSB0aGlzLiRvcHRpb25zLmRhdGFcbiAgdmFyIG9wdGlvbnNEYXRhID0gb3B0aW9uc0RhdGFGbiAmJiBvcHRpb25zRGF0YUZuKClcbiAgaWYgKG9wdGlvbnNEYXRhKSB7XG4gICAgdGhpcy5fZGF0YSA9IG9wdGlvbnNEYXRhXG4gICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wc0RhdGEpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgb3B0aW9uc0RhdGEuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgXy53YXJuKFxuICAgICAgICAgICdEYXRhIGZpZWxkIFwiJyArIHByb3AgKyAnXCIgaXMgYWxyZWFkeSBkZWZpbmVkICcgK1xuICAgICAgICAgICdhcyBhIHByb3AuIFVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC4nXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9wcm9wc1twcm9wXS5yYXcgIT09IG51bGwgfHxcbiAgICAgICAgICAhb3B0aW9uc0RhdGEuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgXy5zZXQob3B0aW9uc0RhdGEsIHByb3AsIHByb3BzRGF0YVtwcm9wXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhXG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKVxuICB2YXIgaSwga2V5XG4gIGkgPSBrZXlzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAga2V5ID0ga2V5c1tpXVxuICAgIHRoaXMuX3Byb3h5KGtleSlcbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgT2JzZXJ2ZXIuY3JlYXRlKGRhdGEsIHRoaXMpXG59XG5cbi8qKlxuICogU3dhcCB0aGUgaXNudGFuY2UncyAkZGF0YS4gQ2FsbGVkIGluICRkYXRhJ3Mgc2V0dGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXdEYXRhXG4gKi9cblxuZXhwb3J0cy5fc2V0RGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gIG5ld0RhdGEgPSBuZXdEYXRhIHx8IHt9XG4gIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YVxuICB0aGlzLl9kYXRhID0gbmV3RGF0YVxuICB2YXIga2V5cywga2V5LCBpXG4gIC8vIHVucHJveHkga2V5cyBub3QgcHJlc2VudCBpbiBuZXcgZGF0YVxuICBrZXlzID0gT2JqZWN0LmtleXMob2xkRGF0YSlcbiAgaSA9IGtleXMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICBrZXkgPSBrZXlzW2ldXG4gICAgaWYgKCEoa2V5IGluIG5ld0RhdGEpKSB7XG4gICAgICB0aGlzLl91bnByb3h5KGtleSlcbiAgICB9XG4gIH1cbiAgLy8gcHJveHkga2V5cyBub3QgYWxyZWFkeSBwcm94aWVkLFxuICAvLyBhbmQgdHJpZ2dlciBjaGFuZ2UgZm9yIGNoYW5nZWQgdmFsdWVzXG4gIGtleXMgPSBPYmplY3Qua2V5cyhuZXdEYXRhKVxuICBpID0ga2V5cy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGtleXNbaV1cbiAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gbmV3IHByb3BlcnR5XG4gICAgICB0aGlzLl9wcm94eShrZXkpXG4gICAgfVxuICB9XG4gIG9sZERhdGEuX19vYl9fLnJlbW92ZVZtKHRoaXMpXG4gIE9ic2VydmVyLmNyZWF0ZShuZXdEYXRhLCB0aGlzKVxuICB0aGlzLl9kaWdlc3QoKVxufVxuXG4vKipcbiAqIFByb3h5IGEgcHJvcGVydHksIHNvIHRoYXRcbiAqIHZtLnByb3AgPT09IHZtLl9kYXRhLnByb3BcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKi9cblxuZXhwb3J0cy5fcHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICghXy5pc1Jlc2VydmVkKGtleSkpIHtcbiAgICAvLyBuZWVkIHRvIHN0b3JlIHJlZiB0byBzZWxmIGhlcmVcbiAgICAvLyBiZWNhdXNlIHRoZXNlIGdldHRlci9zZXR0ZXJzIG1pZ2h0XG4gICAgLy8gYmUgY2FsbGVkIGJ5IGNoaWxkIHNjb3BlcyB2aWFcbiAgICAvLyBwcm90b3R5cGUgaW5oZXJpdGFuY2UuXG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5fZGF0YVtrZXldXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgICAgIHNlbGYuX2RhdGFba2V5XSA9IHZhbFxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBVbnByb3h5IGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICovXG5cbmV4cG9ydHMuX3VucHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICghXy5pc1Jlc2VydmVkKGtleSkpIHtcbiAgICBkZWxldGUgdGhpc1trZXldXG4gIH1cbn1cblxuLyoqXG4gKiBGb3JjZSB1cGRhdGUgb24gZXZlcnkgd2F0Y2hlciBpbiBzY29wZS5cbiAqL1xuXG5leHBvcnRzLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fd2F0Y2hlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdGhpcy5fd2F0Y2hlcnNbaV0udXBkYXRlKHRydWUpIC8vIHNoYWxsb3cgdXBkYXRlc1xuICB9XG59XG5cbi8qKlxuICogU2V0dXAgY29tcHV0ZWQgcHJvcGVydGllcy4gVGhleSBhcmUgZXNzZW50aWFsbHlcbiAqIHNwZWNpYWwgZ2V0dGVyL3NldHRlcnNcbiAqL1xuXG5mdW5jdGlvbiBub29wICgpIHt9XG5leHBvcnRzLl9pbml0Q29tcHV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb21wdXRlZCA9IHRoaXMuJG9wdGlvbnMuY29tcHV0ZWRcbiAgaWYgKGNvbXB1dGVkKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV1cbiAgICAgIHZhciBkZWYgPSB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRlZi5nZXQgPSBtYWtlQ29tcHV0ZWRHZXR0ZXIodXNlckRlZiwgdGhpcylcbiAgICAgICAgZGVmLnNldCA9IG5vb3BcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgICAgID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgICAgID8gbWFrZUNvbXB1dGVkR2V0dGVyKHVzZXJEZWYuZ2V0LCB0aGlzKVxuICAgICAgICAgICAgOiBfLmJpbmQodXNlckRlZi5nZXQsIHRoaXMpXG4gICAgICAgICAgOiBub29wXG4gICAgICAgIGRlZi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgICAgID8gXy5iaW5kKHVzZXJEZWYuc2V0LCB0aGlzKVxuICAgICAgICAgIDogbm9vcFxuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwgZGVmKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQ29tcHV0ZWRHZXR0ZXIgKGdldHRlciwgb3duZXIpIHtcbiAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcihvd25lciwgZ2V0dGVyLCBudWxsLCB7XG4gICAgbGF6eTogdHJ1ZVxuICB9KVxuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICB3YXRjaGVyLmV2YWx1YXRlKClcbiAgICB9XG4gICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgIHdhdGNoZXIuZGVwZW5kKClcbiAgICB9XG4gICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgfVxufVxuXG4vKipcbiAqIFNldHVwIGluc3RhbmNlIG1ldGhvZHMuIE1ldGhvZHMgbXVzdCBiZSBib3VuZCB0byB0aGVcbiAqIGluc3RhbmNlIHNpbmNlIHRoZXkgbWlnaHQgYmUgcGFzc2VkIGRvd24gYXMgYSBwcm9wIHRvXG4gKiBjaGlsZCBjb21wb25lbnRzLlxuICovXG5cbmV4cG9ydHMuX2luaXRNZXRob2RzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWV0aG9kcyA9IHRoaXMuJG9wdGlvbnMubWV0aG9kc1xuICBpZiAobWV0aG9kcykge1xuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgICB0aGlzW2tleV0gPSBfLmJpbmQobWV0aG9kc1trZXldLCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgbWV0YSBpbmZvcm1hdGlvbiBsaWtlICRpbmRleCwgJGtleSAmICR2YWx1ZS5cbiAqL1xuXG5leHBvcnRzLl9pbml0TWV0YSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1ldGFzID0gdGhpcy4kb3B0aW9ucy5fbWV0YVxuICBpZiAobWV0YXMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWV0YXMpIHtcbiAgICAgIF8uZGVmaW5lUmVhY3RpdmUodGhpcywga2V5LCBtZXRhc1trZXldKVxuICAgIH1cbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlXG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKVxuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5cbjtbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dXG4uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF1cbiAgXy5kZWZpbmUoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpKVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgdmFyIG9iID0gdGhpcy5fX29iX19cbiAgICB2YXIgaW5zZXJ0ZWRcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgIGluc2VydGVkID0gYXJnc1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJnc1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pXG59KVxuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGggYSBuZXcgdmFsdWVcbiAqIGFuZCBlbWl0cyBjb3JyZXNwb25kaW5nIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4geyp9IC0gcmVwbGFjZWQgZWxlbWVudFxuICovXG5cbl8uZGVmaW5lKFxuICBhcnJheVByb3RvLFxuICAnJHNldCcsXG4gIGZ1bmN0aW9uICRzZXQgKGluZGV4LCB2YWwpIHtcbiAgICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gaW5kZXggKyAxXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMSwgdmFsKVswXVxuICB9XG4pXG5cbi8qKlxuICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSB0aGUgZWxlbWVudCBhdCBnaXZlbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuXy5kZWZpbmUoXG4gIGFycmF5UHJvdG8sXG4gICckcmVtb3ZlJyxcbiAgZnVuY3Rpb24gJHJlbW92ZSAoaXRlbSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdGhpcy5sZW5ndGgpIHJldHVyblxuICAgIHZhciBpbmRleCA9IF8uaW5kZXhPZih0aGlzLCBpdGVtKVxuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG4pXG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNZXRob2RzXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIHVpZCA9IDBcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrXG4gIHRoaXMuc3VicyA9IFtdXG59XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGxcblxuLyoqXG4gKiBBZGQgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gc3ViXG4gKi9cblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yilcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gc3ViXG4gKi9cblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiAoc3ViKSB7XG4gIHRoaXMuc3Vicy4kcmVtb3ZlKHN1Yilcbn1cblxuLyoqXG4gKiBBZGQgc2VsZiBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRhcmdldCB3YXRjaGVyLlxuICovXG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKVxufVxuXG4vKipcbiAqIE5vdGlmeSBhbGwgc3Vic2NyaWJlcnMgb2YgYSBuZXcgdmFsdWUuXG4gKi9cblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHN0YWJsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSBfLnRvQXJyYXkodGhpcy5zdWJzKVxuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGVwXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIERlcCA9IHJlcXVpcmUoJy4vZGVwJylcbnZhciBhcnJheU1ldGhvZHMgPSByZXF1aXJlKCcuL2FycmF5JylcbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpXG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gdmFsdWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKClcbiAgXy5kZWZpbmUodmFsdWUsICdfX29iX18nLCB0aGlzKVxuICBpZiAoXy5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gXy5oYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnRcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cylcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpXG4gIH1cbn1cblxuLy8gU3RhdGljIG1ldGhvZHNcblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICogQHJldHVybiB7T2JzZXJ2ZXJ8dW5kZWZpbmVkfVxuICogQHN0YXRpY1xuICovXG5cbk9ic2VydmVyLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdm0pIHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iXG4gIGlmIChcbiAgICB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnX19vYl9fJykgJiZcbiAgICB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlclxuICApIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfX1xuICB9IGVsc2UgaWYgKFxuICAgIChfLmlzQXJyYXkodmFsdWUpIHx8IF8uaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgIU9iamVjdC5pc0Zyb3plbih2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKVxuICB9XG4gIGlmIChvYiAmJiB2bSkge1xuICAgIG9iLmFkZFZtKHZtKVxuICB9XG4gIHJldHVybiBvYlxufVxuXG4vLyBJbnN0YW5jZSBtZXRob2RzXG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG4gIHZhciBpID0ga2V5cy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuY29udmVydChrZXlzW2ldLCBvYmpba2V5c1tpXV0pXG4gIH1cbn1cblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgdmFyIGkgPSBpdGVtcy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIE9ic2VydmVyLmNyZWF0ZShpdGVtc1tpXSlcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBwcm9wZXJ0eSBpbnRvIGdldHRlci9zZXR0ZXIgc28gd2UgY2FuIGVtaXRcbiAqIHRoZSBldmVudHMgd2hlbiB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQvY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gIGRlZmluZVJlYWN0aXZlKHRoaXMudmFsdWUsIGtleSwgdmFsKVxufVxuXG4vKipcbiAqIEFkZCBhbiBvd25lciB2bSwgc28gdGhhdCB3aGVuICRzZXQvJGRlbGV0ZSBtdXRhdGlvbnNcbiAqIGhhcHBlbiB3ZSBjYW4gbm90aWZ5IG93bmVyIHZtcyB0byBwcm94eSB0aGUga2V5cyBhbmRcbiAqIGRpZ2VzdCB0aGUgd2F0Y2hlcnMuIFRoaXMgaXMgb25seSBjYWxsZWQgd2hlbiB0aGUgb2JqZWN0XG4gKiBpcyBvYnNlcnZlZCBhcyBhbiBpbnN0YW5jZSdzIHJvb3QgJGRhdGEuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLmFkZFZtID0gZnVuY3Rpb24gKHZtKSB7XG4gICh0aGlzLnZtcyB8fCAodGhpcy52bXMgPSBbXSkpLnB1c2godm0pXG59XG5cbi8qKlxuICogUmVtb3ZlIGFuIG93bmVyIHZtLiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBvYmplY3QgaXNcbiAqIHN3YXBwZWQgb3V0IGFzIGFuIGluc3RhbmNlJ3MgJGRhdGEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5yZW1vdmVWbSA9IGZ1bmN0aW9uICh2bSkge1xuICB0aGlzLnZtcy4kcmVtb3ZlKHZtKVxufVxuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG9cbiAqL1xuXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmNcbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1xuICovXG5cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICB2YXIgaSA9IGtleXMubGVuZ3RoXG4gIHZhciBrZXlcbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGtleXNbaV1cbiAgICBfLmRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pXG4gIH1cbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSAob2JqLCBrZXksIHZhbCkge1xuICB2YXIgZGVwID0gbmV3IERlcCgpXG4gIHZhciBjaGlsZE9iID0gT2JzZXJ2ZXIuY3JlYXRlKHZhbClcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBtZXRhR2V0dGVyICgpIHtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKVxuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8uaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgZm9yICh2YXIgZSwgaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBlID0gdmFsW2ldXG4gICAgICAgICAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbFxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBtZXRhU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbCkgcmV0dXJuXG4gICAgICB2YWwgPSBuZXdWYWxcbiAgICAgIGNoaWxkT2IgPSBPYnNlcnZlci5jcmVhdGUobmV3VmFsKVxuICAgICAgZGVwLm5vdGlmeSgpXG4gICAgfVxuICB9KVxufVxuXG4vLyBBdHRhY2ggdG8gdGhlIHV0aWwgb2JqZWN0IHNvIGl0IGNhbiBiZSB1c2VkIGVsc2V3aGVyZS5cbl8uZGVmaW5lUmVhY3RpdmUgPSBkZWZpbmVSZWFjdGl2ZVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9ic2VydmVyXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIENhY2hlID0gcmVxdWlyZSgnLi4vY2FjaGUnKVxudmFyIGNhY2hlID0gbmV3IENhY2hlKDEwMDApXG52YXIgZmlsdGVyVG9rZW5SRSA9IC9bXlxccydcIl0rfCdbXiddKid8XCJbXlwiXSpcIi9nXG52YXIgcmVzZXJ2ZWRBcmdSRSA9IC9eaW4kfF4tP1xcZCsvXG5cbi8qKlxuICogUGFyc2VyIHN0YXRlXG4gKi9cblxudmFyIHN0ciwgZGlyXG52YXIgYywgaSwgbCwgbGFzdEZpbHRlckluZGV4XG52YXIgaW5TaW5nbGUsIGluRG91YmxlLCBjdXJseSwgc3F1YXJlLCBwYXJlblxuXG4vKipcbiAqIFB1c2ggYSBmaWx0ZXIgdG8gdGhlIGN1cnJlbnQgZGlyZWN0aXZlIG9iamVjdFxuICovXG5cbmZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICB2YXIgZXhwID0gc3RyLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpXG4gIHZhciBmaWx0ZXJcbiAgaWYgKGV4cCkge1xuICAgIGZpbHRlciA9IHt9XG4gICAgdmFyIHRva2VucyA9IGV4cC5tYXRjaChmaWx0ZXJUb2tlblJFKVxuICAgIGZpbHRlci5uYW1lID0gdG9rZW5zWzBdXG4gICAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgICBmaWx0ZXIuYXJncyA9IHRva2Vucy5zbGljZSgxKS5tYXAocHJvY2Vzc0ZpbHRlckFyZylcbiAgICB9XG4gIH1cbiAgaWYgKGZpbHRlcikge1xuICAgIChkaXIuZmlsdGVycyA9IGRpci5maWx0ZXJzIHx8IFtdKS5wdXNoKGZpbHRlcilcbiAgfVxuICBsYXN0RmlsdGVySW5kZXggPSBpICsgMVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGFyZ3VtZW50IGlzIGR5bmFtaWMgYW5kIHN0cmlwIHF1b3Rlcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYXJnXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gcHJvY2Vzc0ZpbHRlckFyZyAoYXJnKSB7XG4gIGlmIChyZXNlcnZlZEFyZ1JFLnRlc3QoYXJnKSkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogXy50b051bWJlcihhcmcpLFxuICAgICAgZHluYW1pYzogZmFsc2VcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0cmlwcGVkID0gXy5zdHJpcFF1b3RlcyhhcmcpXG4gICAgdmFyIGR5bmFtaWMgPSBzdHJpcHBlZCA9PT0gYXJnXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBkeW5hbWljID8gYXJnIDogc3RyaXBwZWQsXG4gICAgICBkeW5hbWljOiBkeW5hbWljXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYSBkaXJlY3RpdmUgdmFsdWUgYW5kIGV4dHJhY3QgdGhlIGV4cHJlc3Npb25cbiAqIGFuZCBpdHMgZmlsdGVycyBpbnRvIGEgZGVzY3JpcHRvci5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIFwiYSArIDEgfCB1cHBlcmNhc2VcIiB3aWxsIHlpZWxkOlxuICoge1xuICogICBleHByZXNzaW9uOiAnYSArIDEnLFxuICogICBmaWx0ZXJzOiBbXG4gKiAgICAgeyBuYW1lOiAndXBwZXJjYXNlJywgYXJnczogbnVsbCB9XG4gKiAgIF1cbiAqIH1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzKSB7XG5cbiAgdmFyIGhpdCA9IGNhY2hlLmdldChzKVxuICBpZiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdFxuICB9XG5cbiAgLy8gcmVzZXQgcGFyc2VyIHN0YXRlXG4gIHN0ciA9IHNcbiAgaW5TaW5nbGUgPSBpbkRvdWJsZSA9IGZhbHNlXG4gIGN1cmx5ID0gc3F1YXJlID0gcGFyZW4gPSAwXG4gIGxhc3RGaWx0ZXJJbmRleCA9IDBcbiAgZGlyID0ge31cblxuICBmb3IgKGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgLy8gY2hlY2sgc2luZ2xlIHF1b3RlXG4gICAgICBpZiAoYyA9PT0gMHgyNykgaW5TaW5nbGUgPSAhaW5TaW5nbGVcbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICAvLyBjaGVjayBkb3VibGUgcXVvdGVcbiAgICAgIGlmIChjID09PSAweDIyKSBpbkRvdWJsZSA9ICFpbkRvdWJsZVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIHN0ci5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgc3RyLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDXG4gICAgKSB7XG4gICAgICBpZiAoZGlyLmV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxXG4gICAgICAgIGRpci5leHByZXNzaW9uID0gc3RyLnNsaWNlKDAsIGkpLnRyaW0oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWxyZWFkeSBoYXMgZmlsdGVyXG4gICAgICAgIHB1c2hGaWx0ZXIoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAvLyAnXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpci5leHByZXNzaW9uID09IG51bGwpIHtcbiAgICBkaXIuZXhwcmVzc2lvbiA9IHN0ci5zbGljZSgwLCBpKS50cmltKClcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKClcbiAgfVxuXG4gIGNhY2hlLnB1dChzLCBkaXIpXG4gIHJldHVybiBkaXJcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgUGF0aCA9IHJlcXVpcmUoJy4vcGF0aCcpXG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZScpXG52YXIgZXhwcmVzc2lvbkNhY2hlID0gbmV3IENhY2hlKDEwMDApXG5cbnZhciBhbGxvd2VkS2V5d29yZHMgPVxuICAnTWF0aCxEYXRlLHRoaXMsdHJ1ZSxmYWxzZSxudWxsLHVuZGVmaW5lZCxJbmZpbml0eSxOYU4sJyArXG4gICdpc05hTixpc0Zpbml0ZSxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSwnICtcbiAgJ2VuY29kZVVSSUNvbXBvbmVudCxwYXJzZUludCxwYXJzZUZsb2F0J1xudmFyIGFsbG93ZWRLZXl3b3Jkc1JFID1cbiAgbmV3IFJlZ0V4cCgnXignICsgYWxsb3dlZEtleXdvcmRzLnJlcGxhY2UoLywvZywgJ1xcXFxifCcpICsgJ1xcXFxiKScpXG5cbi8vIGtleXdvcmRzIHRoYXQgZG9uJ3QgbWFrZSBzZW5zZSBpbnNpZGUgZXhwcmVzc2lvbnNcbnZhciBpbXByb3BlcktleXdvcmRzID1cbiAgJ2JyZWFrLGNhc2UsY2xhc3MsY2F0Y2gsY29uc3QsY29udGludWUsZGVidWdnZXIsZGVmYXVsdCwnICtcbiAgJ2RlbGV0ZSxkbyxlbHNlLGV4cG9ydCxleHRlbmRzLGZpbmFsbHksZm9yLGZ1bmN0aW9uLGlmLCcgK1xuICAnaW1wb3J0LGluLGluc3RhbmNlb2YsbGV0LHJldHVybixzdXBlcixzd2l0Y2gsdGhyb3csdHJ5LCcgK1xuICAndmFyLHdoaWxlLHdpdGgseWllbGQsZW51bSxhd2FpdCxpbXBsZW1lbnRzLHBhY2thZ2UsJyArXG4gICdwcm9jdGVjdGVkLHN0YXRpYyxpbnRlcmZhY2UscHJpdmF0ZSxwdWJsaWMnXG52YXIgaW1wcm9wZXJLZXl3b3Jkc1JFID1cbiAgbmV3IFJlZ0V4cCgnXignICsgaW1wcm9wZXJLZXl3b3Jkcy5yZXBsYWNlKC8sL2csICdcXFxcYnwnKSArICdcXFxcYiknKVxuXG52YXIgd3NSRSA9IC9cXHMvZ1xudmFyIG5ld2xpbmVSRSA9IC9cXG4vZ1xudmFyIHNhdmVSRSA9IC9bXFx7LF1cXHMqW1xcd1xcJF9dK1xccyo6fCgnW14nXSonfFwiW15cIl0qXCIpfG5ldyB8dHlwZW9mIHx2b2lkIC9nXG52YXIgcmVzdG9yZVJFID0gL1wiKFxcZCspXCIvZ1xudmFyIHBhdGhUZXN0UkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKFxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXFxdfFxcW1wiLio/XCJcXF18XFxbXFxkK1xcXXxcXFtbQS1aYS16XyRdW1xcdyRdKlxcXSkqJC9cbnZhciBwYXRoUmVwbGFjZVJFID0gL1teXFx3JFxcLl0oW0EtWmEtel8kXVtcXHckXSooXFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPydcXF18XFxbXCIuKj9cIlxcXSkqKS9nXG52YXIgYm9vbGVhbkxpdGVyYWxSRSA9IC9eKHRydWV8ZmFsc2UpJC9cblxuLyoqXG4gKiBTYXZlIC8gUmV3cml0ZSAvIFJlc3RvcmVcbiAqXG4gKiBXaGVuIHJld3JpdGluZyBwYXRocyBmb3VuZCBpbiBhbiBleHByZXNzaW9uLCBpdCBpc1xuICogcG9zc2libGUgZm9yIHRoZSBzYW1lIGxldHRlciBzZXF1ZW5jZXMgdG8gYmUgZm91bmQgaW5cbiAqIHN0cmluZ3MgYW5kIE9iamVjdCBsaXRlcmFsIHByb3BlcnR5IGtleXMuIFRoZXJlZm9yZSB3ZVxuICogcmVtb3ZlIGFuZCBzdG9yZSB0aGVzZSBwYXJ0cyBpbiBhIHRlbXBvcmFyeSBhcnJheSwgYW5kXG4gKiByZXN0b3JlIHRoZW0gYWZ0ZXIgdGhlIHBhdGggcmV3cml0ZS5cbiAqL1xuXG52YXIgc2F2ZWQgPSBbXVxuXG4vKipcbiAqIFNhdmUgcmVwbGFjZXJcbiAqXG4gKiBUaGUgc2F2ZSByZWdleCBjYW4gbWF0Y2ggdHdvIHBvc3NpYmxlIGNhc2VzOlxuICogMS4gQW4gb3BlbmluZyBvYmplY3QgbGl0ZXJhbFxuICogMi4gQSBzdHJpbmdcbiAqIElmIG1hdGNoZWQgYXMgYSBwbGFpbiBzdHJpbmcsIHdlIG5lZWQgdG8gZXNjYXBlIGl0c1xuICogbmV3bGluZXMsIHNpbmNlIHRoZSBzdHJpbmcgbmVlZHMgdG8gYmUgcHJlc2VydmVkIHdoZW5cbiAqIGdlbmVyYXRpbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGlzU3RyaW5nIC0gc3RyIGlmIG1hdGNoZWQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ30gLSBwbGFjZWhvbGRlciB3aXRoIGluZGV4XG4gKi9cblxuZnVuY3Rpb24gc2F2ZSAoc3RyLCBpc1N0cmluZykge1xuICB2YXIgaSA9IHNhdmVkLmxlbmd0aFxuICBzYXZlZFtpXSA9IGlzU3RyaW5nXG4gICAgPyBzdHIucmVwbGFjZShuZXdsaW5lUkUsICdcXFxcbicpXG4gICAgOiBzdHJcbiAgcmV0dXJuICdcIicgKyBpICsgJ1wiJ1xufVxuXG4vKipcbiAqIFBhdGggcmV3cml0ZSByZXBsYWNlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiByZXdyaXRlIChyYXcpIHtcbiAgdmFyIGMgPSByYXcuY2hhckF0KDApXG4gIHZhciBwYXRoID0gcmF3LnNsaWNlKDEpXG4gIGlmIChhbGxvd2VkS2V5d29yZHNSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuIHJhd1xuICB9IGVsc2Uge1xuICAgIHBhdGggPSBwYXRoLmluZGV4T2YoJ1wiJykgPiAtMVxuICAgICAgPyBwYXRoLnJlcGxhY2UocmVzdG9yZVJFLCByZXN0b3JlKVxuICAgICAgOiBwYXRoXG4gICAgcmV0dXJuIGMgKyAnc2NvcGUuJyArIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIFJlc3RvcmUgcmVwbGFjZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gaSAtIG1hdGNoZWQgc2F2ZSBpbmRleFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHJlc3RvcmUgKHN0ciwgaSkge1xuICByZXR1cm4gc2F2ZWRbaV1cbn1cblxuLyoqXG4gKiBSZXdyaXRlIGFuIGV4cHJlc3Npb24sIHByZWZpeGluZyBhbGwgcGF0aCBhY2Nlc3NvcnMgd2l0aFxuICogYHNjb3BlLmAgYW5kIGdlbmVyYXRlIGdldHRlci9zZXR0ZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbmVlZFNldFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZUV4cEZucyAoZXhwLCBuZWVkU2V0KSB7XG4gIGlmIChpbXByb3BlcktleXdvcmRzUkUudGVzdChleHApKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnQXZvaWQgdXNpbmcgcmVzZXJ2ZWQga2V5d29yZHMgaW4gZXhwcmVzc2lvbjogJyArIGV4cFxuICAgIClcbiAgfVxuICAvLyByZXNldCBzdGF0ZVxuICBzYXZlZC5sZW5ndGggPSAwXG4gIC8vIHNhdmUgc3RyaW5ncyBhbmQgb2JqZWN0IGxpdGVyYWwga2V5c1xuICB2YXIgYm9keSA9IGV4cFxuICAgIC5yZXBsYWNlKHNhdmVSRSwgc2F2ZSlcbiAgICAucmVwbGFjZSh3c1JFLCAnJylcbiAgLy8gcmV3cml0ZSBhbGwgcGF0aHNcbiAgLy8gcGFkIDEgc3BhY2UgaGVyZSBiZWNhdWUgdGhlIHJlZ2V4IG1hdGNoZXMgMSBleHRyYSBjaGFyXG4gIGJvZHkgPSAoJyAnICsgYm9keSlcbiAgICAucmVwbGFjZShwYXRoUmVwbGFjZVJFLCByZXdyaXRlKVxuICAgIC5yZXBsYWNlKHJlc3RvcmVSRSwgcmVzdG9yZSlcbiAgdmFyIGdldHRlciA9IG1ha2VHZXR0ZXIoYm9keSlcbiAgaWYgKGdldHRlcikge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQ6IGdldHRlcixcbiAgICAgIGJvZHk6IGJvZHksXG4gICAgICBzZXQ6IG5lZWRTZXRcbiAgICAgICAgPyBtYWtlU2V0dGVyKGJvZHkpXG4gICAgICAgIDogbnVsbFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgZ2V0dGVyIHNldHRlcnMgZm9yIGEgc2ltcGxlIHBhdGguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVBhdGhGbnMgKGV4cCkge1xuICB2YXIgZ2V0dGVyLCBwYXRoXG4gIGlmIChleHAuaW5kZXhPZignWycpIDwgMCkge1xuICAgIC8vIHJlYWxseSBzaW1wbGUgcGF0aFxuICAgIHBhdGggPSBleHAuc3BsaXQoJy4nKVxuICAgIHBhdGgucmF3ID0gZXhwXG4gICAgZ2V0dGVyID0gUGF0aC5jb21waWxlR2V0dGVyKHBhdGgpXG4gIH0gZWxzZSB7XG4gICAgLy8gZG8gdGhlIHJlYWwgcGFyc2luZ1xuICAgIHBhdGggPSBQYXRoLnBhcnNlKGV4cClcbiAgICBnZXR0ZXIgPSBwYXRoLmdldFxuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0OiBnZXR0ZXIsXG4gICAgLy8gYWx3YXlzIGdlbmVyYXRlIHNldHRlciBmb3Igc2ltcGxlIHBhdGhzXG4gICAgc2V0OiBmdW5jdGlvbiAob2JqLCB2YWwpIHtcbiAgICAgIFBhdGguc2V0KG9iaiwgcGF0aCwgdmFsKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJ1aWxkIGEgZ2V0dGVyIGZ1bmN0aW9uLiBSZXF1aXJlcyBldmFsLlxuICpcbiAqIFdlIGlzb2xhdGUgdGhlIHRyeS9jYXRjaCBzbyBpdCBkb2Vzbid0IGFmZmVjdCB0aGVcbiAqIG9wdGltaXphdGlvbiBvZiB0aGUgcGFyc2UgZnVuY3Rpb24gd2hlbiBpdCBpcyBub3QgY2FsbGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBib2R5XG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gbWFrZUdldHRlciAoYm9keSkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3Njb3BlJywgJ3JldHVybiAnICsgYm9keSArICc7JylcbiAgfSBjYXRjaCAoZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgJ0ludmFsaWQgZXhwcmVzc2lvbi4gJyArXG4gICAgICAnR2VuZXJhdGVkIGZ1bmN0aW9uIGJvZHk6ICcgKyBib2R5XG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQnVpbGQgYSBzZXR0ZXIgZnVuY3Rpb24uXG4gKlxuICogVGhpcyBpcyBvbmx5IG5lZWRlZCBpbiByYXJlIHNpdHVhdGlvbnMgbGlrZSBcImFbYl1cIiB3aGVyZVxuICogYSBzZXR0YWJsZSBwYXRoIHJlcXVpcmVzIGR5bmFtaWMgZXZhbHVhdGlvbi5cbiAqXG4gKiBUaGlzIHNldHRlciBmdW5jdGlvbiBtYXkgdGhyb3cgZXJyb3Igd2hlbiBjYWxsZWQgaWYgdGhlXG4gKiBleHByZXNzaW9uIGJvZHkgaXMgbm90IGEgdmFsaWQgbGVmdC1oYW5kIGV4cHJlc3Npb24gaW5cbiAqIGFzc2lnbm1lbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJvZHlcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlU2V0dGVyIChib2R5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbignc2NvcGUnLCAndmFsdWUnLCBib2R5ICsgJz12YWx1ZTsnKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnSW52YWxpZCBzZXR0ZXIgZnVuY3Rpb24gYm9keTogJyArIGJvZHlcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBmb3Igc2V0dGVyIGV4aXN0ZW5jZSBvbiBhIGNhY2hlIGhpdC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoaXRcbiAqL1xuXG5mdW5jdGlvbiBjaGVja1NldHRlciAoaGl0KSB7XG4gIGlmICghaGl0LnNldCkge1xuICAgIGhpdC5zZXQgPSBtYWtlU2V0dGVyKGhpdC5ib2R5KVxuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYW4gZXhwcmVzc2lvbiBpbnRvIHJlLXdyaXR0ZW4gZ2V0dGVyL3NldHRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHBhcmFtIHtCb29sZWFufSBuZWVkU2V0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKGV4cCwgbmVlZFNldCkge1xuICBleHAgPSBleHAudHJpbSgpXG4gIC8vIHRyeSBjYWNoZVxuICB2YXIgaGl0ID0gZXhwcmVzc2lvbkNhY2hlLmdldChleHApXG4gIGlmIChoaXQpIHtcbiAgICBpZiAobmVlZFNldCkge1xuICAgICAgY2hlY2tTZXR0ZXIoaGl0KVxuICAgIH1cbiAgICByZXR1cm4gaGl0XG4gIH1cbiAgLy8gd2UgZG8gYSBzaW1wbGUgcGF0aCBjaGVjayB0byBvcHRpbWl6ZSBmb3IgdGhlbS5cbiAgLy8gdGhlIGNoZWNrIGZhaWxzIHZhbGlkIHBhdGhzIHdpdGggdW51c2FsIHdoaXRlc3BhY2VzLFxuICAvLyBidXQgdGhhdCdzIHRvbyByYXJlIGFuZCB3ZSBkb24ndCBjYXJlLlxuICAvLyBhbHNvIHNraXAgYm9vbGVhbiBsaXRlcmFscyBhbmQgcGF0aHMgdGhhdCBzdGFydCB3aXRoXG4gIC8vIGdsb2JhbCBcIk1hdGhcIlxuICB2YXIgcmVzID0gZXhwb3J0cy5pc1NpbXBsZVBhdGgoZXhwKVxuICAgID8gY29tcGlsZVBhdGhGbnMoZXhwKVxuICAgIDogY29tcGlsZUV4cEZucyhleHAsIG5lZWRTZXQpXG4gIGV4cHJlc3Npb25DYWNoZS5wdXQoZXhwLCByZXMpXG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBleHByZXNzaW9uIGlzIGEgc2ltcGxlIHBhdGguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzU2ltcGxlUGF0aCA9IGZ1bmN0aW9uIChleHApIHtcbiAgcmV0dXJuIHBhdGhUZXN0UkUudGVzdChleHApICYmXG4gICAgLy8gZG9uJ3QgdHJlYXQgdHJ1ZS9mYWxzZSBhcyBwYXRoc1xuICAgICFib29sZWFuTGl0ZXJhbFJFLnRlc3QoZXhwKSAmJlxuICAgIC8vIE1hdGggY29uc3RhbnRzIGUuZy4gTWF0aC5QSSwgTWF0aC5FIGV0Yy5cbiAgICBleHAuc2xpY2UoMCwgNSkgIT09ICdNYXRoLidcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZScpXG52YXIgcGF0aENhY2hlID0gbmV3IENhY2hlKDEwMDApXG52YXIgaWRlbnRSRSA9IGV4cG9ydHMuaWRlbnRSRSA9IC9eWyRfYS16QS1aXStbXFx3JF0qJC9cblxuLy8gYWN0aW9uc1xudmFyIEFQUEVORCA9IDBcbnZhciBQVVNIID0gMVxuXG4vLyBzdGF0ZXNcbnZhciBCRUZPUkVfUEFUSCA9IDBcbnZhciBJTl9QQVRIID0gMVxudmFyIEJFRk9SRV9JREVOVCA9IDJcbnZhciBJTl9JREVOVCA9IDNcbnZhciBCRUZPUkVfRUxFTUVOVCA9IDRcbnZhciBBRlRFUl9aRVJPID0gNVxudmFyIElOX0lOREVYID0gNlxudmFyIElOX1NJTkdMRV9RVU9URSA9IDdcbnZhciBJTl9ET1VCTEVfUVVPVEUgPSA4XG52YXIgSU5fU1VCX1BBVEggPSA5XG52YXIgQUZURVJfRUxFTUVOVCA9IDEwXG52YXIgQUZURVJfUEFUSCA9IDExXG52YXIgRVJST1IgPSAxMlxuXG52YXIgcGF0aFN0YXRlTWFjaGluZSA9IFtdXG5cbnBhdGhTdGF0ZU1hY2hpbmVbQkVGT1JFX1BBVEhdID0ge1xuICAnd3MnOiBbQkVGT1JFX1BBVEhdLFxuICAnaWRlbnQnOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICdbJzogW0JFRk9SRV9FTEVNRU5UXSxcbiAgJ2VvZic6IFtBRlRFUl9QQVRIXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1BBVEhdID0ge1xuICAnd3MnOiBbSU5fUEFUSF0sXG4gICcuJzogW0JFRk9SRV9JREVOVF0sXG4gICdbJzogW0JFRk9SRV9FTEVNRU5UXSxcbiAgJ2VvZic6IFtBRlRFUl9QQVRIXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0JFRk9SRV9JREVOVF0gPSB7XG4gICd3cyc6IFtCRUZPUkVfSURFTlRdLFxuICAnaWRlbnQnOiBbSU5fSURFTlQsIEFQUEVORF1cbn1cblxucGF0aFN0YXRlTWFjaGluZVtJTl9JREVOVF0gPSB7XG4gICdpZGVudCc6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJzAnOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICdudW1iZXInOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICd3cyc6IFtJTl9QQVRILCBQVVNIXSxcbiAgJy4nOiBbQkVGT1JFX0lERU5ULCBQVVNIXSxcbiAgJ1snOiBbQkVGT1JFX0VMRU1FTlQsIFBVU0hdLFxuICAnZW9mJzogW0FGVEVSX1BBVEgsIFBVU0hdXG59XG5cbnBhdGhTdGF0ZU1hY2hpbmVbQkVGT1JFX0VMRU1FTlRdID0ge1xuICAnd3MnOiBbQkVGT1JFX0VMRU1FTlRdLFxuICAnMCc6IFtBRlRFUl9aRVJPLCBBUFBFTkRdLFxuICAnbnVtYmVyJzogW0lOX0lOREVYLCBBUFBFTkRdLFxuICBcIidcIjogW0lOX1NJTkdMRV9RVU9URSwgQVBQRU5ELCAnJ10sXG4gICdcIic6IFtJTl9ET1VCTEVfUVVPVEUsIEFQUEVORCwgJyddLFxuICAnaWRlbnQnOiBbSU5fU1VCX1BBVEgsIEFQUEVORCwgJyonXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0FGVEVSX1pFUk9dID0ge1xuICAnd3MnOiBbQUZURVJfRUxFTUVOVCwgUFVTSF0sXG4gICddJzogW0lOX1BBVEgsIFBVU0hdXG59XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fSU5ERVhdID0ge1xuICAnMCc6IFtJTl9JTkRFWCwgQVBQRU5EXSxcbiAgJ251bWJlcic6IFtJTl9JTkRFWCwgQVBQRU5EXSxcbiAgJ3dzJzogW0FGVEVSX0VMRU1FTlRdLFxuICAnXSc6IFtJTl9QQVRILCBQVVNIXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1NJTkdMRV9RVU9URV0gPSB7XG4gIFwiJ1wiOiBbQUZURVJfRUxFTUVOVF0sXG4gICdlb2YnOiBFUlJPUixcbiAgJ2Vsc2UnOiBbSU5fU0lOR0xFX1FVT1RFLCBBUFBFTkRdXG59XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fRE9VQkxFX1FVT1RFXSA9IHtcbiAgJ1wiJzogW0FGVEVSX0VMRU1FTlRdLFxuICAnZW9mJzogRVJST1IsXG4gICdlbHNlJzogW0lOX0RPVUJMRV9RVU9URSwgQVBQRU5EXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1NVQl9QQVRIXSA9IHtcbiAgJ2lkZW50JzogW0lOX1NVQl9QQVRILCBBUFBFTkRdLFxuICAnMCc6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXSxcbiAgJ251bWJlcic6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXSxcbiAgJ3dzJzogW0FGVEVSX0VMRU1FTlRdLFxuICAnXSc6IFtJTl9QQVRILCBQVVNIXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0FGVEVSX0VMRU1FTlRdID0ge1xuICAnd3MnOiBbQUZURVJfRUxFTUVOVF0sXG4gICddJzogW0lOX1BBVEgsIFBVU0hdXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgY2hhcmFjdGVyIGluIGEga2V5cGF0aC5cbiAqXG4gKiBAcGFyYW0ge0NoYXJ9IGNoXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRQYXRoQ2hhclR5cGUgKGNoKSB7XG4gIGlmIChjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICdlb2YnXG4gIH1cblxuICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMClcblxuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4NUI6IC8vIFtcbiAgICBjYXNlIDB4NUQ6IC8vIF1cbiAgICBjYXNlIDB4MkU6IC8vIC5cbiAgICBjYXNlIDB4MjI6IC8vIFwiXG4gICAgY2FzZSAweDI3OiAvLyAnXG4gICAgY2FzZSAweDMwOiAvLyAwXG4gICAgICByZXR1cm4gY2hcblxuICAgIGNhc2UgMHg1RjogLy8gX1xuICAgIGNhc2UgMHgyNDogLy8gJFxuICAgICAgcmV0dXJuICdpZGVudCdcblxuICAgIGNhc2UgMHgyMDogLy8gU3BhY2VcbiAgICBjYXNlIDB4MDk6IC8vIFRhYlxuICAgIGNhc2UgMHgwQTogLy8gTmV3bGluZVxuICAgIGNhc2UgMHgwRDogLy8gUmV0dXJuXG4gICAgY2FzZSAweEEwOiAgLy8gTm8tYnJlYWsgc3BhY2VcbiAgICBjYXNlIDB4RkVGRjogIC8vIEJ5dGUgT3JkZXIgTWFya1xuICAgIGNhc2UgMHgyMDI4OiAgLy8gTGluZSBTZXBhcmF0b3JcbiAgICBjYXNlIDB4MjAyOTogIC8vIFBhcmFncmFwaCBTZXBhcmF0b3JcbiAgICAgIHJldHVybiAnd3MnXG4gIH1cblxuICAvLyBhLXosIEEtWlxuICBpZiAoXG4gICAgKGNvZGUgPj0gMHg2MSAmJiBjb2RlIDw9IDB4N0EpIHx8XG4gICAgKGNvZGUgPj0gMHg0MSAmJiBjb2RlIDw9IDB4NUEpXG4gICkge1xuICAgIHJldHVybiAnaWRlbnQnXG4gIH1cblxuICAvLyAxLTlcbiAgaWYgKGNvZGUgPj0gMHgzMSAmJiBjb2RlIDw9IDB4MzkpIHtcbiAgICByZXR1cm4gJ251bWJlcidcbiAgfVxuXG4gIHJldHVybiAnZWxzZSdcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBwYXRoIGludG8gYW4gYXJyYXkgb2Ygc2VnbWVudHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICB2YXIga2V5cyA9IFtdXG4gIHZhciBpbmRleCA9IC0xXG4gIHZhciBtb2RlID0gQkVGT1JFX1BBVEhcbiAgdmFyIGMsIG5ld0NoYXIsIGtleSwgdHlwZSwgdHJhbnNpdGlvbiwgYWN0aW9uLCB0eXBlTWFwXG5cbiAgdmFyIGFjdGlvbnMgPSBbXVxuICBhY3Rpb25zW1BVU0hdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGtleXMucHVzaChrZXkpXG4gICAga2V5ID0gdW5kZWZpbmVkXG4gIH1cbiAgYWN0aW9uc1tBUFBFTkRdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gbmV3Q2hhclxuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgKz0gbmV3Q2hhclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlVW5lc2NhcGVRdW90ZSAoKSB7XG4gICAgdmFyIG5leHRDaGFyID0gcGF0aFtpbmRleCArIDFdXG4gICAgaWYgKChtb2RlID09PSBJTl9TSU5HTEVfUVVPVEUgJiYgbmV4dENoYXIgPT09IFwiJ1wiKSB8fFxuICAgICAgICAobW9kZSA9PT0gSU5fRE9VQkxFX1FVT1RFICYmIG5leHRDaGFyID09PSAnXCInKSkge1xuICAgICAgaW5kZXgrK1xuICAgICAgbmV3Q2hhciA9IG5leHRDaGFyXG4gICAgICBhY3Rpb25zW0FQUEVORF0oKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICB3aGlsZSAobW9kZSAhPSBudWxsKSB7XG4gICAgaW5kZXgrK1xuICAgIGMgPSBwYXRoW2luZGV4XVxuXG4gICAgaWYgKGMgPT09ICdcXFxcJyAmJiBtYXliZVVuZXNjYXBlUXVvdGUoKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB0eXBlID0gZ2V0UGF0aENoYXJUeXBlKGMpXG4gICAgdHlwZU1hcCA9IHBhdGhTdGF0ZU1hY2hpbmVbbW9kZV1cbiAgICB0cmFuc2l0aW9uID0gdHlwZU1hcFt0eXBlXSB8fCB0eXBlTWFwWydlbHNlJ10gfHwgRVJST1JcblxuICAgIGlmICh0cmFuc2l0aW9uID09PSBFUlJPUikge1xuICAgICAgcmV0dXJuIC8vIHBhcnNlIGVycm9yXG4gICAgfVxuXG4gICAgbW9kZSA9IHRyYW5zaXRpb25bMF1cbiAgICBhY3Rpb24gPSBhY3Rpb25zW3RyYW5zaXRpb25bMV1dXG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgbmV3Q2hhciA9IHRyYW5zaXRpb25bMl1cbiAgICAgIG5ld0NoYXIgPSBuZXdDaGFyID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBjXG4gICAgICAgIDogbmV3Q2hhciA9PT0gJyonXG4gICAgICAgICAgPyBuZXdDaGFyICsgY1xuICAgICAgICAgIDogbmV3Q2hhclxuICAgICAgYWN0aW9uKClcbiAgICB9XG5cbiAgICBpZiAobW9kZSA9PT0gQUZURVJfUEFUSCkge1xuICAgICAga2V5cy5yYXcgPSBwYXRoXG4gICAgICByZXR1cm4ga2V5c1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEZvcm1hdCBhIGFjY2Vzc29yIHNlZ21lbnQgYmFzZWQgb24gaXRzIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBY2Nlc3NvciAoa2V5KSB7XG4gIGlmIChpZGVudFJFLnRlc3Qoa2V5KSkgeyAvLyBpZGVudGlmaWVyXG4gICAgcmV0dXJuICcuJyArIGtleVxuICB9IGVsc2UgaWYgKCtrZXkgPT09IGtleSA+Pj4gMCkgeyAvLyBicmFja2V0IGluZGV4XG4gICAgcmV0dXJuICdbJyArIGtleSArICddJ1xuICB9IGVsc2UgaWYgKGtleS5jaGFyQXQoMCkgPT09ICcqJykge1xuICAgIHJldHVybiAnW28nICsgZm9ybWF0QWNjZXNzb3Ioa2V5LnNsaWNlKDEpKSArICddJ1xuICB9IGVsc2UgeyAvLyBicmFja2V0IHN0cmluZ1xuICAgIHJldHVybiAnW1wiJyArIGtleS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgKyAnXCJdJ1xuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZXMgYSBnZXR0ZXIgZnVuY3Rpb24gd2l0aCBhIGZpeGVkIHBhdGguXG4gKiBUaGUgZml4ZWQgcGF0aCBnZXR0ZXIgc3VwcmVzc2VzIGVycm9ycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5leHBvcnRzLmNvbXBpbGVHZXR0ZXIgPSBmdW5jdGlvbiAocGF0aCkge1xuICB2YXIgYm9keSA9ICdyZXR1cm4gbycgKyBwYXRoLm1hcChmb3JtYXRBY2Nlc3Nvcikuam9pbignJylcbiAgcmV0dXJuIG5ldyBGdW5jdGlvbignbycsIGJvZHkpXG59XG5cbi8qKlxuICogRXh0ZXJuYWwgcGFyc2UgdGhhdCBjaGVjayBmb3IgYSBjYWNoZSBoaXQgZmlyc3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl8dW5kZWZpbmVkfVxuICovXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAocGF0aCkge1xuICB2YXIgaGl0ID0gcGF0aENhY2hlLmdldChwYXRoKVxuICBpZiAoIWhpdCkge1xuICAgIGhpdCA9IHBhcnNlUGF0aChwYXRoKVxuICAgIGlmIChoaXQpIHtcbiAgICAgIGhpdC5nZXQgPSBleHBvcnRzLmNvbXBpbGVHZXR0ZXIoaGl0KVxuICAgICAgcGF0aENhY2hlLnB1dChwYXRoLCBoaXQpXG4gICAgfVxuICB9XG4gIHJldHVybiBoaXRcbn1cblxuLyoqXG4gKiBHZXQgZnJvbSBhbiBvYmplY3QgZnJvbSBhIHBhdGggc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqL1xuXG5leHBvcnRzLmdldCA9IGZ1bmN0aW9uIChvYmosIHBhdGgpIHtcbiAgcGF0aCA9IGV4cG9ydHMucGFyc2UocGF0aClcbiAgaWYgKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5nZXQob2JqKVxuICB9XG59XG5cbi8qKlxuICogV2FybiBhZ2FpbnN0IHNldHRpbmcgbm9uLWV4aXN0ZW50IHJvb3QgcGF0aCBvbiBhIHZtLlxuICovXG5cbnZhciB3YXJuTm9uRXhpc3RlbnRcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5Ob25FeGlzdGVudCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgXy53YXJuKFxuICAgICAgJ1lvdSBhcmUgc2V0dGluZyBhIG5vbi1leGlzdGVudCBwYXRoIFwiJyArIHBhdGgucmF3ICsgJ1wiICcgK1xuICAgICAgJ29uIGEgdm0gaW5zdGFuY2UuIENvbnNpZGVyIHByZS1pbml0aWFsaXppbmcgdGhlIHByb3BlcnR5ICcgK1xuICAgICAgJ3dpdGggdGhlIFwiZGF0YVwiIG9wdGlvbiBmb3IgbW9yZSByZWxpYWJsZSByZWFjdGl2aXR5ICcgK1xuICAgICAgJ2FuZCBiZXR0ZXIgcGVyZm9ybWFuY2UuJ1xuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIFNldCBvbiBhbiBvYmplY3QgZnJvbSBhIHBhdGhcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBwYXRoXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmV4cG9ydHMuc2V0ID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgdmFsKSB7XG4gIHZhciBvcmlnaW5hbCA9IG9ialxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aCA9IGV4cG9ydHMucGFyc2UocGF0aClcbiAgfVxuICBpZiAoIXBhdGggfHwgIV8uaXNPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBsYXN0LCBrZXlcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxhc3QgPSBvYmpcbiAgICBrZXkgPSBwYXRoW2ldXG4gICAgaWYgKGtleS5jaGFyQXQoMCkgPT09ICcqJykge1xuICAgICAga2V5ID0gb3JpZ2luYWxba2V5LnNsaWNlKDEpXVxuICAgIH1cbiAgICBpZiAoaSA8IGwgLSAxKSB7XG4gICAgICBvYmogPSBvYmpba2V5XVxuICAgICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgb2JqID0ge31cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbGFzdC5faXNWdWUpIHtcbiAgICAgICAgICB3YXJuTm9uRXhpc3RlbnQocGF0aClcbiAgICAgICAgfVxuICAgICAgICBfLnNldChsYXN0LCBrZXksIG9iailcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKF8uaXNBcnJheShvYmopKSB7XG4gICAgICAgIG9iai4kc2V0KGtleSwgdmFsKVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvYmouX2lzVnVlKSB7XG4gICAgICAgICAgd2Fybk5vbkV4aXN0ZW50KHBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgXy5zZXQob2JqLCBrZXksIHZhbClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZScpXG52YXIgdGVtcGxhdGVDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKVxudmFyIGlkU2VsZWN0b3JDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKVxuXG52YXIgbWFwID0ge1xuICBfZGVmYXVsdDogWzAsICcnLCAnJ10sXG4gIGxlZ2VuZDogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gIHRyOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcbiAgY29sOiBbXG4gICAgMixcbiAgICAnPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD4nLFxuICAgICc8L2NvbGdyb3VwPjwvdGFibGU+J1xuICBdXG59XG5cbm1hcC50ZCA9XG5tYXAudGggPSBbXG4gIDMsXG4gICc8dGFibGU+PHRib2R5Pjx0cj4nLFxuICAnPC90cj48L3Rib2R5PjwvdGFibGU+J1xuXVxuXG5tYXAub3B0aW9uID1cbm1hcC5vcHRncm91cCA9IFtcbiAgMSxcbiAgJzxzZWxlY3QgbXVsdGlwbGU9XCJtdWx0aXBsZVwiPicsXG4gICc8L3NlbGVjdD4nXG5dXG5cbm1hcC50aGVhZCA9XG5tYXAudGJvZHkgPVxubWFwLmNvbGdyb3VwID1cbm1hcC5jYXB0aW9uID1cbm1hcC50Zm9vdCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddXG5cbm1hcC5nID1cbm1hcC5kZWZzID1cbm1hcC5zeW1ib2wgPVxubWFwLnVzZSA9XG5tYXAuaW1hZ2UgPVxubWFwLnRleHQgPVxubWFwLmNpcmNsZSA9XG5tYXAuZWxsaXBzZSA9XG5tYXAubGluZSA9XG5tYXAucGF0aCA9XG5tYXAucG9seWdvbiA9XG5tYXAucG9seWxpbmUgPVxubWFwLnJlY3QgPSBbXG4gIDEsXG4gICc8c3ZnICcgK1xuICAgICd4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJyArXG4gICAgJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiICcgK1xuICAgICd4bWxuczpldj1cImh0dHA6Ly93d3cudzMub3JnLzIwMDEveG1sLWV2ZW50c1wiJyArXG4gICAgJ3ZlcnNpb249XCIxLjFcIj4nLFxuICAnPC9zdmc+J1xuXVxuXG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBpcyBhIHN1cHBvcnRlZCB0ZW1wbGF0ZSBub2RlIHdpdGggYVxuICogRG9jdW1lbnRGcmFnbWVudCBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1JlYWxUZW1wbGF0ZSAobm9kZSkge1xuICByZXR1cm4gXy5pc1RlbXBsYXRlKG5vZGUpICYmXG4gICAgbm9kZS5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudFxufVxuXG52YXIgdGFnUkUgPSAvPChbXFx3Ol0rKS9cbnZhciBlbnRpdHlSRSA9IC8mXFx3Kzt8JiNcXGQrO3wmI3hbXFxkQS1GXSs7L1xuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgdGVtcGxhdGUgdG8gYSBEb2N1bWVudEZyYWdtZW50LlxuICogRGV0ZXJtaW5lcyBjb3JyZWN0IHdyYXBwaW5nIGJ5IHRhZyB0eXBlcy4gV3JhcHBpbmdcbiAqIHN0cmF0ZWd5IGZvdW5kIGluIGpRdWVyeSAmIGNvbXBvbmVudC9kb21pZnkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlU3RyaW5nXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ1RvRnJhZ21lbnQgKHRlbXBsYXRlU3RyaW5nKSB7XG4gIC8vIHRyeSBhIGNhY2hlIGhpdCBmaXJzdFxuICB2YXIgaGl0ID0gdGVtcGxhdGVDYWNoZS5nZXQodGVtcGxhdGVTdHJpbmcpXG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0XG4gIH1cblxuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICB2YXIgdGFnTWF0Y2ggPSB0ZW1wbGF0ZVN0cmluZy5tYXRjaCh0YWdSRSlcbiAgdmFyIGVudGl0eU1hdGNoID0gZW50aXR5UkUudGVzdCh0ZW1wbGF0ZVN0cmluZylcblxuICBpZiAoIXRhZ01hdGNoICYmICFlbnRpdHlNYXRjaCkge1xuICAgIC8vIHRleHQgb25seSwgcmV0dXJuIGEgc2luZ2xlIHRleHQgbm9kZS5cbiAgICBmcmFnLmFwcGVuZENoaWxkKFxuICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGVtcGxhdGVTdHJpbmcpXG4gICAgKVxuICB9IGVsc2Uge1xuXG4gICAgdmFyIHRhZyA9IHRhZ01hdGNoICYmIHRhZ01hdGNoWzFdXG4gICAgdmFyIHdyYXAgPSBtYXBbdGFnXSB8fCBtYXAuX2RlZmF1bHRcbiAgICB2YXIgZGVwdGggPSB3cmFwWzBdXG4gICAgdmFyIHByZWZpeCA9IHdyYXBbMV1cbiAgICB2YXIgc3VmZml4ID0gd3JhcFsyXVxuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICAgIG5vZGUuaW5uZXJIVE1MID0gcHJlZml4ICsgdGVtcGxhdGVTdHJpbmcudHJpbSgpICsgc3VmZml4XG4gICAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZFxuICAgIH1cblxuICAgIHZhciBjaGlsZFxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgd2hpbGUgKGNoaWxkID0gbm9kZS5maXJzdENoaWxkKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgZnJhZy5hcHBlbmRDaGlsZChjaGlsZClcbiAgICB9XG4gIH1cblxuICB0ZW1wbGF0ZUNhY2hlLnB1dCh0ZW1wbGF0ZVN0cmluZywgZnJhZylcbiAgcmV0dXJuIGZyYWdcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdGVtcGxhdGUgbm9kZSB0byBhIERvY3VtZW50RnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIG5vZGVUb0ZyYWdtZW50IChub2RlKSB7XG4gIC8vIGlmIGl0cyBhIHRlbXBsYXRlIHRhZyBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQsXG4gIC8vIGl0cyBjb250ZW50IGlzIGFscmVhZHkgYSBkb2N1bWVudCBmcmFnbWVudC5cbiAgaWYgKGlzUmVhbFRlbXBsYXRlKG5vZGUpKSB7XG4gICAgXy50cmltTm9kZShub2RlLmNvbnRlbnQpXG4gICAgcmV0dXJuIG5vZGUuY29udGVudFxuICB9XG4gIC8vIHNjcmlwdCB0ZW1wbGF0ZVxuICBpZiAobm9kZS50YWdOYW1lID09PSAnU0NSSVBUJykge1xuICAgIHJldHVybiBzdHJpbmdUb0ZyYWdtZW50KG5vZGUudGV4dENvbnRlbnQpXG4gIH1cbiAgLy8gbm9ybWFsIG5vZGUsIGNsb25lIGl0IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbFxuICB2YXIgY2xvbmUgPSBleHBvcnRzLmNsb25lKG5vZGUpXG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gIHZhciBjaGlsZFxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICB3aGlsZSAoY2hpbGQgPSBjbG9uZS5maXJzdENoaWxkKSB7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICBmcmFnLmFwcGVuZENoaWxkKGNoaWxkKVxuICB9XG4gIF8udHJpbU5vZGUoZnJhZylcbiAgcmV0dXJuIGZyYWdcbn1cblxuLy8gVGVzdCBmb3IgdGhlIHByZXNlbmNlIG9mIHRoZSBTYWZhcmkgdGVtcGxhdGUgY2xvbmluZyBidWdcbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzc3NTVcbnZhciBoYXNCcm9rZW5UZW1wbGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChfLmluQnJvd3Nlcikge1xuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBhLmlubmVySFRNTCA9ICc8dGVtcGxhdGU+MTwvdGVtcGxhdGU+J1xuICAgIHJldHVybiAhYS5jbG9uZU5vZGUodHJ1ZSkuZmlyc3RDaGlsZC5pbm5lckhUTUxcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vLyBUZXN0IGZvciBJRTEwLzExIHRleHRhcmVhIHBsYWNlaG9sZGVyIGNsb25lIGJ1Z1xudmFyIGhhc1RleHRhcmVhQ2xvbmVCdWcgPSAoZnVuY3Rpb24gKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoXy5pbkJyb3dzZXIpIHtcbiAgICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJylcbiAgICB0LnBsYWNlaG9sZGVyID0gJ3QnXG4gICAgcmV0dXJuIHQuY2xvbmVOb2RlKHRydWUpLnZhbHVlID09PSAndCdcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIDEuIERlYWwgd2l0aCBTYWZhcmkgY2xvbmluZyBuZXN0ZWQgPHRlbXBsYXRlPiBidWcgYnlcbiAqICAgIG1hbnVhbGx5IGNsb25pbmcgYWxsIHRlbXBsYXRlIGluc3RhbmNlcy5cbiAqIDIuIERlYWwgd2l0aCBJRTEwLzExIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1ZyBieSBzZXR0aW5nXG4gKiAgICB0aGUgY29ycmVjdCB2YWx1ZSBhZnRlciBjbG9uaW5nLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICghbm9kZS5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKClcbiAgfVxuICB2YXIgcmVzID0gbm9kZS5jbG9uZU5vZGUodHJ1ZSlcbiAgdmFyIGksIG9yaWdpbmFsLCBjbG9uZWRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChoYXNCcm9rZW5UZW1wbGF0ZSkge1xuICAgIHZhciBjbG9uZSA9IHJlc1xuICAgIGlmIChpc1JlYWxUZW1wbGF0ZShub2RlKSkge1xuICAgICAgbm9kZSA9IG5vZGUuY29udGVudFxuICAgICAgY2xvbmUgPSByZXMuY29udGVudFxuICAgIH1cbiAgICBvcmlnaW5hbCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgndGVtcGxhdGUnKVxuICAgIGlmIChvcmlnaW5hbC5sZW5ndGgpIHtcbiAgICAgIGNsb25lZCA9IGNsb25lLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RlbXBsYXRlJylcbiAgICAgIGkgPSBjbG9uZWQubGVuZ3RoXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNsb25lZFtpXS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChcbiAgICAgICAgICBleHBvcnRzLmNsb25lKG9yaWdpbmFsW2ldKSxcbiAgICAgICAgICBjbG9uZWRbaV1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGhhc1RleHRhcmVhQ2xvbmVCdWcpIHtcbiAgICBpZiAobm9kZS50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICByZXMudmFsdWUgPSBub2RlLnZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIG9yaWdpbmFsID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZXh0YXJlYScpXG4gICAgICBpZiAob3JpZ2luYWwubGVuZ3RoKSB7XG4gICAgICAgIGNsb25lZCA9IHJlcy5xdWVyeVNlbGVjdG9yQWxsKCd0ZXh0YXJlYScpXG4gICAgICAgIGkgPSBjbG9uZWQubGVuZ3RoXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjbG9uZWRbaV0udmFsdWUgPSBvcmlnaW5hbFtpXS52YWx1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHRoZSB0ZW1wbGF0ZSBvcHRpb24gYW5kIG5vcm1hbGl6ZXMgaXQgaW50byBhXG4gKiBhIERvY3VtZW50RnJhZ21lbnQgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHBhcnRpYWwgb3IgYVxuICogaW5zdGFuY2UgdGVtcGxhdGUuXG4gKlxuICogQHBhcmFtIHsqfSB0ZW1wbGF0ZVxuICogICAgUG9zc2libGUgdmFsdWVzIGluY2x1ZGU6XG4gKiAgICAtIERvY3VtZW50RnJhZ21lbnQgb2JqZWN0XG4gKiAgICAtIE5vZGUgb2JqZWN0IG9mIHR5cGUgVGVtcGxhdGVcbiAqICAgIC0gaWQgc2VsZWN0b3I6ICcjc29tZS10ZW1wbGF0ZS1pZCdcbiAqICAgIC0gdGVtcGxhdGUgc3RyaW5nOiAnPGRpdj48c3Bhbj57e21zZ319PC9zcGFuPjwvZGl2PidcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xvbmVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9TZWxlY3RvclxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudHx1bmRlZmluZWR9XG4gKi9cblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgY2xvbmUsIG5vU2VsZWN0b3IpIHtcbiAgdmFyIG5vZGUsIGZyYWdcblxuICAvLyBpZiB0aGUgdGVtcGxhdGUgaXMgYWxyZWFkeSBhIGRvY3VtZW50IGZyYWdtZW50LFxuICAvLyBkbyBub3RoaW5nXG4gIGlmICh0ZW1wbGF0ZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICBfLnRyaW1Ob2RlKHRlbXBsYXRlKVxuICAgIHJldHVybiBjbG9uZVxuICAgICAgPyBleHBvcnRzLmNsb25lKHRlbXBsYXRlKVxuICAgICAgOiB0ZW1wbGF0ZVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBpZCBzZWxlY3RvclxuICAgIGlmICghbm9TZWxlY3RvciAmJiB0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgLy8gaWQgc2VsZWN0b3IgY2FuIGJlIGNhY2hlZCB0b29cbiAgICAgIGZyYWcgPSBpZFNlbGVjdG9yQ2FjaGUuZ2V0KHRlbXBsYXRlKVxuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0ZW1wbGF0ZS5zbGljZSgxKSlcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBmcmFnID0gbm9kZVRvRnJhZ21lbnQobm9kZSlcbiAgICAgICAgICAvLyBzYXZlIHNlbGVjdG9yIHRvIGNhY2hlXG4gICAgICAgICAgaWRTZWxlY3RvckNhY2hlLnB1dCh0ZW1wbGF0ZSwgZnJhZylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3JtYWwgc3RyaW5nIHRlbXBsYXRlXG4gICAgICBmcmFnID0gc3RyaW5nVG9GcmFnbWVudCh0ZW1wbGF0ZSlcbiAgICB9XG4gIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAvLyBhIGRpcmVjdCBub2RlXG4gICAgZnJhZyA9IG5vZGVUb0ZyYWdtZW50KHRlbXBsYXRlKVxuICB9XG5cbiAgcmV0dXJuIGZyYWcgJiYgY2xvbmVcbiAgICA/IGV4cG9ydHMuY2xvbmUoZnJhZylcbiAgICA6IGZyYWdcbn1cbiIsInZhciBDYWNoZSA9IHJlcXVpcmUoJy4uL2NhY2hlJylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxudmFyIGRpclBhcnNlciA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlJylcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZ1xudmFyIGNhY2hlLCB0YWdSRSwgaHRtbFJFXG5cbi8qKlxuICogRXNjYXBlIGEgc3RyaW5nIHNvIGl0IGNhbiBiZSB1c2VkIGluIGEgUmVnRXhwXG4gKiBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlUmVnZXggKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpXG59XG5cbmV4cG9ydHMuY29tcGlsZVJlZ2V4ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3BlbiA9IGVzY2FwZVJlZ2V4KGNvbmZpZy5kZWxpbWl0ZXJzWzBdKVxuICB2YXIgY2xvc2UgPSBlc2NhcGVSZWdleChjb25maWcuZGVsaW1pdGVyc1sxXSlcbiAgdmFyIHVuc2FmZU9wZW4gPSBlc2NhcGVSZWdleChjb25maWcudW5zYWZlRGVsaW1pdGVyc1swXSlcbiAgdmFyIHVuc2FmZUNsb3NlID0gZXNjYXBlUmVnZXgoY29uZmlnLnVuc2FmZURlbGltaXRlcnNbMV0pXG4gIHRhZ1JFID0gbmV3IFJlZ0V4cChcbiAgICB1bnNhZmVPcGVuICsgJyguKz8pJyArIHVuc2FmZUNsb3NlICsgJ3wnICtcbiAgICBvcGVuICsgJyguKz8pJyArIGNsb3NlLFxuICAgICdnJ1xuICApXG4gIGh0bWxSRSA9IG5ldyBSZWdFeHAoXG4gICAgJ14nICsgdW5zYWZlT3BlbiArICcuKicgKyB1bnNhZmVDbG9zZSArICckJ1xuICApXG4gIC8vIHJlc2V0IGNhY2hlXG4gIGNhY2hlID0gbmV3IENhY2hlKDEwMDApXG59XG5cbi8qKlxuICogUGFyc2UgYSB0ZW1wbGF0ZSB0ZXh0IHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHRva2Vucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHJldHVybiB7QXJyYXk8T2JqZWN0PiB8IG51bGx9XG4gKiAgICAgICAgICAgICAgIC0ge1N0cmluZ30gdHlwZVxuICogICAgICAgICAgICAgICAtIHtTdHJpbmd9IHZhbHVlXG4gKiAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IFtodG1sXVxuICogICAgICAgICAgICAgICAtIHtCb29sZWFufSBbb25lVGltZV1cbiAqL1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGV4cG9ydHMuY29tcGlsZVJlZ2V4KClcbiAgfVxuICB2YXIgaGl0ID0gY2FjaGUuZ2V0KHRleHQpXG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0XG4gIH1cbiAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxuL2csICcnKVxuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZhciB0b2tlbnMgPSBbXVxuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMFxuICB2YXIgbWF0Y2gsIGluZGV4LCBodG1sLCB2YWx1ZSwgZmlyc3QsIG9uZVRpbWVcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgd2hpbGUgKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkge1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgaW5kZXggPSBtYXRjaC5pbmRleFxuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB2YWx1ZTogdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KVxuICAgICAgfSlcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgaHRtbCA9IGh0bWxSRS50ZXN0KG1hdGNoWzBdKVxuICAgIHZhbHVlID0gaHRtbCA/IG1hdGNoWzFdIDogbWF0Y2hbMl1cbiAgICBmaXJzdCA9IHZhbHVlLmNoYXJDb2RlQXQoMClcbiAgICBvbmVUaW1lID0gZmlyc3QgPT09IDQyIC8vICpcbiAgICB2YWx1ZSA9IG9uZVRpbWVcbiAgICAgID8gdmFsdWUuc2xpY2UoMSlcbiAgICAgIDogdmFsdWVcbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICB0YWc6IHRydWUsXG4gICAgICB2YWx1ZTogdmFsdWUudHJpbSgpLFxuICAgICAgaHRtbDogaHRtbCxcbiAgICAgIG9uZVRpbWU6IG9uZVRpbWVcbiAgICB9KVxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoXG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgdmFsdWU6IHRleHQuc2xpY2UobGFzdEluZGV4KVxuICAgIH0pXG4gIH1cbiAgY2FjaGUucHV0KHRleHQsIHRva2VucylcbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIGxpc3Qgb2YgdG9rZW5zIGludG8gYW4gZXhwcmVzc2lvbi5cbiAqIGUuZy4gdG9rZW5zIHBhcnNlZCBmcm9tICdhIHt7Yn19IGMnIGNhbiBiZSBzZXJpYWxpemVkXG4gKiBpbnRvIG9uZSBzaW5nbGUgZXhwcmVzc2lvbiBhcyAnXCJhIFwiICsgYiArIFwiIGNcIicuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdG9rZW5zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZXhwb3J0cy50b2tlbnNUb0V4cCA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcbiAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICByZXR1cm4gZm9ybWF0VG9rZW4odG9rZW4pXG4gICAgfSkuam9pbignKycpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZvcm1hdFRva2VuKHRva2Vuc1swXSwgdHJ1ZSlcbiAgfVxufVxuXG4vKipcbiAqIEZvcm1hdCBhIHNpbmdsZSB0b2tlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2luZ2xlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0VG9rZW4gKHRva2VuLCBzaW5nbGUpIHtcbiAgcmV0dXJuIHRva2VuLnRhZ1xuICAgID8gaW5saW5lRmlsdGVycyh0b2tlbi52YWx1ZSwgc2luZ2xlKVxuICAgIDogJ1wiJyArIHRva2VuLnZhbHVlICsgJ1wiJ1xufVxuXG4vKipcbiAqIEZvciBhbiBhdHRyaWJ1dGUgd2l0aCBtdWx0aXBsZSBpbnRlcnBvbGF0aW9uIHRhZ3MsXG4gKiBlLmcuIGF0dHI9XCJzb21lLXt7dGhpbmcgfCBmaWx0ZXJ9fVwiLCBpbiBvcmRlciB0byBjb21iaW5lXG4gKiB0aGUgd2hvbGUgdGhpbmcgaW50byBhIHNpbmdsZSB3YXRjaGFibGUgZXhwcmVzc2lvbiwgd2VcbiAqIGhhdmUgdG8gaW5saW5lIHRob3NlIGZpbHRlcnMuIFRoaXMgZnVuY3Rpb24gZG9lcyBleGFjdGx5XG4gKiB0aGF0LiBUaGlzIGlzIGEgYml0IGhhY2t5IGJ1dCBpdCBhdm9pZHMgaGVhdnkgY2hhbmdlc1xuICogdG8gZGlyZWN0aXZlIHBhcnNlciBhbmQgd2F0Y2hlciBtZWNoYW5pc20uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHBhcmFtIHtCb29sZWFufSBzaW5nbGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgZmlsdGVyUkUgPSAvW158XVxcfFtefF0vXG5mdW5jdGlvbiBpbmxpbmVGaWx0ZXJzIChleHAsIHNpbmdsZSkge1xuICBpZiAoIWZpbHRlclJFLnRlc3QoZXhwKSkge1xuICAgIHJldHVybiBzaW5nbGVcbiAgICAgID8gZXhwXG4gICAgICA6ICcoJyArIGV4cCArICcpJ1xuICB9IGVsc2Uge1xuICAgIHZhciBkaXIgPSBkaXJQYXJzZXIucGFyc2UoZXhwKVxuICAgIGlmICghZGlyLmZpbHRlcnMpIHtcbiAgICAgIHJldHVybiAnKCcgKyBleHAgKyAnKSdcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICd0aGlzLl9hcHBseUZpbHRlcnMoJyArXG4gICAgICAgIGRpci5leHByZXNzaW9uICsgLy8gdmFsdWVcbiAgICAgICAgJyxudWxsLCcgKyAgICAgICAvLyBvbGRWYWx1ZSAobnVsbCBmb3IgcmVhZClcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoZGlyLmZpbHRlcnMpICsgLy8gZmlsdGVyIGRlc2NyaXB0b3JzXG4gICAgICAgICcsZmFsc2UpJyAgICAgICAgLy8gd3JpdGU/XG4gICAgfVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuXG4vKipcbiAqIEFwcGVuZCB3aXRoIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmV4cG9ydHMuYXBwZW5kID0gZnVuY3Rpb24gKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICBhcHBseShlbCwgMSwgZnVuY3Rpb24gKCkge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbClcbiAgfSwgdm0sIGNiKVxufVxuXG4vKipcbiAqIEluc2VydEJlZm9yZSB3aXRoIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmV4cG9ydHMuYmVmb3JlID0gZnVuY3Rpb24gKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICBhcHBseShlbCwgMSwgZnVuY3Rpb24gKCkge1xuICAgIF8uYmVmb3JlKGVsLCB0YXJnZXQpXG4gIH0sIHZtLCBjYilcbn1cblxuLyoqXG4gKiBSZW1vdmUgd2l0aCB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmV4cG9ydHMucmVtb3ZlID0gZnVuY3Rpb24gKGVsLCB2bSwgY2IpIHtcbiAgYXBwbHkoZWwsIC0xLCBmdW5jdGlvbiAoKSB7XG4gICAgXy5yZW1vdmUoZWwpXG4gIH0sIHZtLCBjYilcbn1cblxuLyoqXG4gKiBBcHBseSB0cmFuc2l0aW9ucyB3aXRoIGFuIG9wZXJhdGlvbiBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uXG4gKiAgICAgICAgICAgICAgICAgIDE6IGVudGVyXG4gKiAgICAgICAgICAgICAgICAgLTE6IGxlYXZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIHRoZSBhY3R1YWwgRE9NIG9wZXJhdGlvblxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxudmFyIGFwcGx5ID0gZXhwb3J0cy5hcHBseSA9IGZ1bmN0aW9uIChlbCwgZGlyZWN0aW9uLCBvcCwgdm0sIGNiKSB7XG4gIHZhciB0cmFuc2l0aW9uID0gZWwuX192X3RyYW5zXG4gIGlmIChcbiAgICAhdHJhbnNpdGlvbiB8fFxuICAgIC8vIHNraXAgaWYgdGhlcmUgYXJlIG5vIGpzIGhvb2tzIGFuZCBDU1MgdHJhbnNpdGlvbiBpc1xuICAgIC8vIG5vdCBzdXBwb3J0ZWRcbiAgICAoIXRyYW5zaXRpb24uaG9va3MgJiYgIV8udHJhbnNpdGlvbkVuZEV2ZW50KSB8fFxuICAgIC8vIHNraXAgdHJhbnNpdGlvbnMgZm9yIGluaXRpYWwgY29tcGlsZVxuICAgICF2bS5faXNDb21waWxlZCB8fFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBtYW5pcHVsYXRlZCBieSBhIHBhcmVudCBkaXJlY3RpdmVcbiAgICAvLyBkdXJpbmcgdGhlIHBhcmVudCdzIGNvbXBpbGF0aW9uIHBoYXNlLCBza2lwIHRoZVxuICAgIC8vIGFuaW1hdGlvbi5cbiAgICAodm0uJHBhcmVudCAmJiAhdm0uJHBhcmVudC5faXNDb21waWxlZClcbiAgKSB7XG4gICAgb3AoKVxuICAgIGlmIChjYikgY2IoKVxuICAgIHJldHVyblxuICB9XG4gIHZhciBhY3Rpb24gPSBkaXJlY3Rpb24gPiAwID8gJ2VudGVyJyA6ICdsZWF2ZSdcbiAgdHJhbnNpdGlvblthY3Rpb25dKG9wLCBjYilcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgcXVldWUgPSBbXVxudmFyIHF1ZXVlZCA9IGZhbHNlXG5cbi8qKlxuICogUHVzaCBhIGpvYiBpbnRvIHRoZSBxdWV1ZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2JcbiAqL1xuXG5leHBvcnRzLnB1c2ggPSBmdW5jdGlvbiAoam9iKSB7XG4gIHF1ZXVlLnB1c2goam9iKVxuICBpZiAoIXF1ZXVlZCkge1xuICAgIHF1ZXVlZCA9IHRydWVcbiAgICBfLm5leHRUaWNrKGZsdXNoKVxuICB9XG59XG5cbi8qKlxuICogRmx1c2ggdGhlIHF1ZXVlLCBhbmQgZG8gb25lIGZvcmNlZCByZWZsb3cgYmVmb3JlXG4gKiB0cmlnZ2VyaW5nIHRyYW5zaXRpb25zLlxuICovXG5cbmZ1bmN0aW9uIGZsdXNoICgpIHtcbiAgLy8gRm9yY2UgbGF5b3V0XG4gIHZhciBmID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0oKVxuICB9XG4gIHF1ZXVlID0gW11cbiAgcXVldWVkID0gZmFsc2VcbiAgLy8gZHVtbXkgcmV0dXJuLCBzbyBqcyBsaW50ZXJzIGRvbid0IGNvbXBsYWluIGFib3V0XG4gIC8vIHVudXNlZCB2YXJpYWJsZSBmXG4gIHJldHVybiBmXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIHF1ZXVlID0gcmVxdWlyZSgnLi9xdWV1ZScpXG52YXIgYWRkQ2xhc3MgPSBfLmFkZENsYXNzXG52YXIgcmVtb3ZlQ2xhc3MgPSBfLnJlbW92ZUNsYXNzXG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gXy50cmFuc2l0aW9uRW5kRXZlbnRcbnZhciBhbmltYXRpb25FbmRFdmVudCA9IF8uYW5pbWF0aW9uRW5kRXZlbnRcbnZhciB0cmFuc0R1cmF0aW9uUHJvcCA9IF8udHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXG52YXIgYW5pbUR1cmF0aW9uUHJvcCA9IF8uYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbidcblxudmFyIFRZUEVfVFJBTlNJVElPTiA9IDFcbnZhciBUWVBFX0FOSU1BVElPTiA9IDJcblxuLyoqXG4gKiBBIFRyYW5zaXRpb24gb2JqZWN0IHRoYXQgZW5jYXBzdWxhdGVzIHRoZSBzdGF0ZSBhbmQgbG9naWNcbiAqIG9mIHRoZSB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IGhvb2tzXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5mdW5jdGlvbiBUcmFuc2l0aW9uIChlbCwgaWQsIGhvb2tzLCB2bSkge1xuICB0aGlzLmlkID0gaWRcbiAgdGhpcy5lbCA9IGVsXG4gIHRoaXMuZW50ZXJDbGFzcyA9IGlkICsgJy1lbnRlcidcbiAgdGhpcy5sZWF2ZUNsYXNzID0gaWQgKyAnLWxlYXZlJ1xuICB0aGlzLmhvb2tzID0gaG9va3NcbiAgdGhpcy52bSA9IHZtXG4gIC8vIGFzeW5jIHN0YXRlXG4gIHRoaXMucGVuZGluZ0Nzc0V2ZW50ID1cbiAgdGhpcy5wZW5kaW5nQ3NzQ2IgPVxuICB0aGlzLmNhbmNlbCA9XG4gIHRoaXMucGVuZGluZ0pzQ2IgPVxuICB0aGlzLm9wID1cbiAgdGhpcy5jYiA9IG51bGxcbiAgdGhpcy5qdXN0RW50ZXJlZCA9IGZhbHNlXG4gIHRoaXMuZW50ZXJlZCA9IHRoaXMubGVmdCA9IGZhbHNlXG4gIHRoaXMudHlwZUNhY2hlID0ge31cbiAgLy8gYmluZFxuICB2YXIgc2VsZiA9IHRoaXNcbiAgO1snZW50ZXJOZXh0VGljaycsICdlbnRlckRvbmUnLCAnbGVhdmVOZXh0VGljaycsICdsZWF2ZURvbmUnXVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICBzZWxmW21dID0gXy5iaW5kKHNlbGZbbV0sIHNlbGYpXG4gICAgfSlcbn1cblxudmFyIHAgPSBUcmFuc2l0aW9uLnByb3RvdHlwZVxuXG4vKipcbiAqIFN0YXJ0IGFuIGVudGVyaW5nIHRyYW5zaXRpb24uXG4gKlxuICogMS4gZW50ZXIgdHJhbnNpdGlvbiB0cmlnZ2VyZWRcbiAqIDIuIGNhbGwgYmVmb3JlRW50ZXIgaG9va1xuICogMy4gYWRkIGVudGVyIGNsYXNzXG4gKiA0LiBpbnNlcnQvc2hvdyBlbGVtZW50XG4gKiA1LiBjYWxsIGVudGVyIGhvb2sgKHdpdGggcG9zc2libGUgZXhwbGljaXQganMgY2FsbGJhY2spXG4gKiA2LiByZWZsb3dcbiAqIDcuIGJhc2VkIG9uIHRyYW5zaXRpb24gdHlwZTpcbiAqICAgIC0gdHJhbnNpdGlvbjpcbiAqICAgICAgICByZW1vdmUgY2xhc3Mgbm93LCB3YWl0IGZvciB0cmFuc2l0aW9uZW5kLFxuICogICAgICAgIHRoZW4gZG9uZSBpZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogICAgLSBhbmltYXRpb246XG4gKiAgICAgICAgd2FpdCBmb3IgYW5pbWF0aW9uZW5kLCByZW1vdmUgY2xhc3MsXG4gKiAgICAgICAgdGhlbiBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIG5vIGNzcyB0cmFuc2l0aW9uOlxuICogICAgICAgIGRvbmUgbm93IGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiA4LiB3YWl0IGZvciBlaXRoZXIgZG9uZSBvciBqcyBjYWxsYmFjaywgdGhlbiBjYWxsXG4gKiAgICBhZnRlckVudGVyIGhvb2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3AgLSBpbnNlcnQvc2hvdyB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbnAuZW50ZXIgPSBmdW5jdGlvbiAob3AsIGNiKSB7XG4gIHRoaXMuY2FuY2VsUGVuZGluZygpXG4gIHRoaXMuY2FsbEhvb2soJ2JlZm9yZUVudGVyJylcbiAgdGhpcy5jYiA9IGNiXG4gIGFkZENsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcylcbiAgb3AoKVxuICB0aGlzLmVudGVyZWQgPSBmYWxzZVxuICB0aGlzLmNhbGxIb29rV2l0aENiKCdlbnRlcicpXG4gIGlmICh0aGlzLmVudGVyZWQpIHtcbiAgICByZXR1cm4gLy8gdXNlciBjYWxsZWQgZG9uZSBzeW5jaHJvbm91c2x5LlxuICB9XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmVudGVyQ2FuY2VsbGVkXG4gIHF1ZXVlLnB1c2godGhpcy5lbnRlck5leHRUaWNrKVxufVxuXG4vKipcbiAqIFRoZSBcIm5leHRUaWNrXCIgcGhhc2Ugb2YgYW4gZW50ZXJpbmcgdHJhbnNpdGlvbiwgd2hpY2ggaXNcbiAqIHRvIGJlIHB1c2hlZCBpbnRvIGEgcXVldWUgYW5kIGV4ZWN1dGVkIGFmdGVyIGEgcmVmbG93IHNvXG4gKiB0aGF0IHJlbW92aW5nIHRoZSBjbGFzcyBjYW4gdHJpZ2dlciBhIENTUyB0cmFuc2l0aW9uLlxuICovXG5cbnAuZW50ZXJOZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcblxuICAvLyBJbXBvcnRhbnQgaGFjazpcbiAgLy8gaW4gQ2hyb21lLCBpZiBhIGp1c3QtZW50ZXJlZCBlbGVtZW50IGlzIGFwcGxpZWQgdGhlXG4gIC8vIGxlYXZlIGNsYXNzIHdoaWxlIGl0cyBpbnRlcnBvbGF0ZWQgcHJvcGVydHkgc3RpbGwgaGFzXG4gIC8vIGEgdmVyeSBzbWFsbCB2YWx1ZSAod2l0aGluIG9uZSBmcmFtZSksIENocm9tZSB3aWxsXG4gIC8vIHNraXAgdGhlIGxlYXZlIHRyYW5zaXRpb24gZW50aXJlbHkgYW5kIG5vdCBmaXJpbmcgdGhlXG4gIC8vIHRyYW5zdGlvbmVuZCBldmVudC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gcHJvdGVjdGVkXG4gIC8vIGFnYWluc3Qgc3VjaCBjYXNlcyB1c2luZyBhIG9uZS1mcmFtZSB0aW1lb3V0LlxuICB0aGlzLmp1c3RFbnRlcmVkID0gdHJ1ZVxuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5qdXN0RW50ZXJlZCA9IGZhbHNlXG4gIH0sIDE3KVxuXG4gIHZhciBlbnRlckRvbmUgPSB0aGlzLmVudGVyRG9uZVxuICB2YXIgdHlwZSA9IHRoaXMuZ2V0Q3NzVHJhbnNpdGlvblR5cGUodGhpcy5lbnRlckNsYXNzKVxuICBpZiAoIXRoaXMucGVuZGluZ0pzQ2IpIHtcbiAgICBpZiAodHlwZSA9PT0gVFlQRV9UUkFOU0lUSU9OKSB7XG4gICAgICAvLyB0cmlnZ2VyIHRyYW5zaXRpb24gYnkgcmVtb3ZpbmcgZW50ZXIgY2xhc3Mgbm93XG4gICAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpXG4gICAgICB0aGlzLnNldHVwQ3NzQ2IodHJhbnNpdGlvbkVuZEV2ZW50LCBlbnRlckRvbmUpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBUWVBFX0FOSU1BVElPTikge1xuICAgICAgdGhpcy5zZXR1cENzc0NiKGFuaW1hdGlvbkVuZEV2ZW50LCBlbnRlckRvbmUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyRG9uZSgpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IFRZUEVfVFJBTlNJVElPTikge1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcylcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBcImNsZWFudXBcIiBwaGFzZSBvZiBhbiBlbnRlcmluZyB0cmFuc2l0aW9uLlxuICovXG5cbnAuZW50ZXJEb25lID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVudGVyZWQgPSB0cnVlXG4gIHRoaXMuY2FuY2VsID0gdGhpcy5wZW5kaW5nSnNDYiA9IG51bGxcbiAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKVxuICB0aGlzLmNhbGxIb29rKCdhZnRlckVudGVyJylcbiAgaWYgKHRoaXMuY2IpIHRoaXMuY2IoKVxufVxuXG4vKipcbiAqIFN0YXJ0IGEgbGVhdmluZyB0cmFuc2l0aW9uLlxuICpcbiAqIDEuIGxlYXZlIHRyYW5zaXRpb24gdHJpZ2dlcmVkLlxuICogMi4gY2FsbCBiZWZvcmVMZWF2ZSBob29rXG4gKiAzLiBhZGQgbGVhdmUgY2xhc3MgKHRyaWdnZXIgY3NzIHRyYW5zaXRpb24pXG4gKiA0LiBjYWxsIGxlYXZlIGhvb2sgKHdpdGggcG9zc2libGUgZXhwbGljaXQganMgY2FsbGJhY2spXG4gKiA1LiByZWZsb3cgaWYgbm8gZXhwbGljaXQganMgY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAqIDYuIGJhc2VkIG9uIHRyYW5zaXRpb24gdHlwZTpcbiAqICAgIC0gdHJhbnNpdGlvbiBvciBhbmltYXRpb246XG4gKiAgICAgICAgd2FpdCBmb3IgZW5kIGV2ZW50LCByZW1vdmUgY2xhc3MsIHRoZW4gZG9uZSBpZlxuICogICAgICAgIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIG5vIGNzcyB0cmFuc2l0aW9uOlxuICogICAgICAgIGRvbmUgaWYgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqIDcuIHdhaXQgZm9yIGVpdGhlciBkb25lIG9yIGpzIGNhbGxiYWNrLCB0aGVuIGNhbGxcbiAqICAgIGFmdGVyTGVhdmUgaG9vay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIHJlbW92ZS9oaWRlIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxucC5sZWF2ZSA9IGZ1bmN0aW9uIChvcCwgY2IpIHtcbiAgdGhpcy5jYW5jZWxQZW5kaW5nKClcbiAgdGhpcy5jYWxsSG9vaygnYmVmb3JlTGVhdmUnKVxuICB0aGlzLm9wID0gb3BcbiAgdGhpcy5jYiA9IGNiXG4gIGFkZENsYXNzKHRoaXMuZWwsIHRoaXMubGVhdmVDbGFzcylcbiAgdGhpcy5sZWZ0ID0gZmFsc2VcbiAgdGhpcy5jYWxsSG9va1dpdGhDYignbGVhdmUnKVxuICBpZiAodGhpcy5sZWZ0KSB7XG4gICAgcmV0dXJuIC8vIHVzZXIgY2FsbGVkIGRvbmUgc3luY2hyb25vdXNseS5cbiAgfVxuICB0aGlzLmNhbmNlbCA9IHRoaXMuaG9va3MgJiYgdGhpcy5ob29rcy5sZWF2ZUNhbmNlbGxlZFxuICAvLyBvbmx5IG5lZWQgdG8gaGFuZGxlIGxlYXZlRG9uZSBpZlxuICAvLyAxLiB0aGUgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IGRvbmUgKHN5bmNocm9ub3VzbHkgY2FsbGVkXG4gIC8vICAgIGJ5IHRoZSB1c2VyLCB3aGljaCBjYXVzZXMgdGhpcy5vcCBzZXQgdG8gbnVsbClcbiAgLy8gMi4gdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFja1xuICBpZiAodGhpcy5vcCAmJiAhdGhpcy5wZW5kaW5nSnNDYikge1xuICAgIC8vIGlmIGEgQ1NTIHRyYW5zaXRpb24gbGVhdmVzIGltbWVkaWF0ZWx5IGFmdGVyIGVudGVyLFxuICAgIC8vIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50IG5ldmVyIGZpcmVzLiB0aGVyZWZvcmUgd2VcbiAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZW5kIHRoZSBsZWF2ZSBpbW1lZGlhdGVseS5cbiAgICBpZiAodGhpcy5qdXN0RW50ZXJlZCkge1xuICAgICAgdGhpcy5sZWF2ZURvbmUoKVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZS5wdXNoKHRoaXMubGVhdmVOZXh0VGljaylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgXCJuZXh0VGlja1wiIHBoYXNlIG9mIGEgbGVhdmluZyB0cmFuc2l0aW9uLlxuICovXG5cbnAubGVhdmVOZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHR5cGUgPSB0aGlzLmdldENzc1RyYW5zaXRpb25UeXBlKHRoaXMubGVhdmVDbGFzcylcbiAgaWYgKHR5cGUpIHtcbiAgICB2YXIgZXZlbnQgPSB0eXBlID09PSBUWVBFX1RSQU5TSVRJT05cbiAgICAgID8gdHJhbnNpdGlvbkVuZEV2ZW50XG4gICAgICA6IGFuaW1hdGlvbkVuZEV2ZW50XG4gICAgdGhpcy5zZXR1cENzc0NiKGV2ZW50LCB0aGlzLmxlYXZlRG9uZSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxlYXZlRG9uZSgpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgXCJjbGVhbnVwXCIgcGhhc2Ugb2YgYSBsZWF2aW5nIHRyYW5zaXRpb24uXG4gKi9cblxucC5sZWF2ZURvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGVmdCA9IHRydWVcbiAgdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbFxuICB0aGlzLm9wKClcbiAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKVxuICB0aGlzLmNhbGxIb29rKCdhZnRlckxlYXZlJylcbiAgaWYgKHRoaXMuY2IpIHRoaXMuY2IoKVxuICB0aGlzLm9wID0gbnVsbFxufVxuXG4vKipcbiAqIENhbmNlbCBhbnkgcGVuZGluZyBjYWxsYmFja3MgZnJvbSBhIHByZXZpb3VzbHkgcnVubmluZ1xuICogYnV0IG5vdCBmaW5pc2hlZCB0cmFuc2l0aW9uLlxuICovXG5cbnAuY2FuY2VsUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5vcCA9IHRoaXMuY2IgPSBudWxsXG4gIHZhciBoYXNQZW5kaW5nID0gZmFsc2VcbiAgaWYgKHRoaXMucGVuZGluZ0Nzc0NiKSB7XG4gICAgaGFzUGVuZGluZyA9IHRydWVcbiAgICBfLm9mZih0aGlzLmVsLCB0aGlzLnBlbmRpbmdDc3NFdmVudCwgdGhpcy5wZW5kaW5nQ3NzQ2IpXG4gICAgdGhpcy5wZW5kaW5nQ3NzRXZlbnQgPSB0aGlzLnBlbmRpbmdDc3NDYiA9IG51bGxcbiAgfVxuICBpZiAodGhpcy5wZW5kaW5nSnNDYikge1xuICAgIGhhc1BlbmRpbmcgPSB0cnVlXG4gICAgdGhpcy5wZW5kaW5nSnNDYi5jYW5jZWwoKVxuICAgIHRoaXMucGVuZGluZ0pzQ2IgPSBudWxsXG4gIH1cbiAgaWYgKGhhc1BlbmRpbmcpIHtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpXG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKVxuICB9XG4gIGlmICh0aGlzLmNhbmNlbCkge1xuICAgIHRoaXMuY2FuY2VsLmNhbGwodGhpcy52bSwgdGhpcy5lbClcbiAgICB0aGlzLmNhbmNlbCA9IG51bGxcbiAgfVxufVxuXG4vKipcbiAqIENhbGwgYSB1c2VyLXByb3ZpZGVkIHN5bmNocm9ub3VzIGhvb2sgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5wLmNhbGxIb29rID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgaWYgKHRoaXMuaG9va3MgJiYgdGhpcy5ob29rc1t0eXBlXSkge1xuICAgIHRoaXMuaG9va3NbdHlwZV0uY2FsbCh0aGlzLnZtLCB0aGlzLmVsKVxuICB9XG59XG5cbi8qKlxuICogQ2FsbCBhIHVzZXItcHJvdmlkZWQsIHBvdGVudGlhbGx5LWFzeW5jIGhvb2sgZnVuY3Rpb24uXG4gKiBXZSBjaGVjayBmb3IgdGhlIGxlbmd0aCBvZiBhcmd1bWVudHMgdG8gc2VlIGlmIHRoZSBob29rXG4gKiBleHBlY3RzIGEgYGRvbmVgIGNhbGxiYWNrLiBJZiB0cnVlLCB0aGUgdHJhbnNpdGlvbidzIGVuZFxuICogd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IHdoZW4gdGhlIHVzZXIgY2FsbHMgdGhhdCBjYWxsYmFjaztcbiAqIG90aGVyd2lzZSwgdGhlIGVuZCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBDU1MgdHJhbnNpdGlvbiBvclxuICogYW5pbWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cblxucC5jYWxsSG9va1dpdGhDYiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBob29rID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzW3R5cGVdXG4gIGlmIChob29rKSB7XG4gICAgaWYgKGhvb2subGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5wZW5kaW5nSnNDYiA9IF8uY2FuY2VsbGFibGUodGhpc1t0eXBlICsgJ0RvbmUnXSlcbiAgICB9XG4gICAgaG9vay5jYWxsKHRoaXMudm0sIHRoaXMuZWwsIHRoaXMucGVuZGluZ0pzQ2IpXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIHRyYW5zaXRpb24gdHlwZSBiYXNlZCBvbiB0aGVcbiAqIGNhbGN1bGF0ZWQgc3R5bGVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuXG5wLmdldENzc1RyYW5zaXRpb25UeXBlID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgICF0cmFuc2l0aW9uRW5kRXZlbnQgfHxcbiAgICAvLyBza2lwIENTUyB0cmFuc2l0aW9ucyBpZiBwYWdlIGlzIG5vdCB2aXNpYmxlIC1cbiAgICAvLyB0aGlzIHNvbHZlcyB0aGUgaXNzdWUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHMgbm90XG4gICAgLy8gZmlyaW5nIHVudGlsIHRoZSBwYWdlIGlzIHZpc2libGUgYWdhaW4uXG4gICAgLy8gcGFnZVZpc2liaWxpdHkgQVBJIGlzIHN1cHBvcnRlZCBpbiBJRTEwKywgc2FtZSBhc1xuICAgIC8vIENTUyB0cmFuc2l0aW9ucy5cbiAgICBkb2N1bWVudC5oaWRkZW4gfHxcbiAgICAvLyBleHBsaWNpdCBqcy1vbmx5IHRyYW5zaXRpb25cbiAgICAodGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmNzcyA9PT0gZmFsc2UpIHx8XG4gICAgLy8gZWxlbWVudCBpcyBoaWRkZW5cbiAgICBpc0hpZGRlbih0aGlzLmVsKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHRoaXMudHlwZUNhY2hlW2NsYXNzTmFtZV1cbiAgaWYgKHR5cGUpIHJldHVybiB0eXBlXG4gIHZhciBpbmxpbmVTdHlsZXMgPSB0aGlzLmVsLnN0eWxlXG4gIHZhciBjb21wdXRlZFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWwpXG4gIHZhciB0cmFuc0R1cmF0aW9uID1cbiAgICBpbmxpbmVTdHlsZXNbdHJhbnNEdXJhdGlvblByb3BdIHx8XG4gICAgY29tcHV0ZWRTdHlsZXNbdHJhbnNEdXJhdGlvblByb3BdXG4gIGlmICh0cmFuc0R1cmF0aW9uICYmIHRyYW5zRHVyYXRpb24gIT09ICcwcycpIHtcbiAgICB0eXBlID0gVFlQRV9UUkFOU0lUSU9OXG4gIH0gZWxzZSB7XG4gICAgdmFyIGFuaW1EdXJhdGlvbiA9XG4gICAgICBpbmxpbmVTdHlsZXNbYW5pbUR1cmF0aW9uUHJvcF0gfHxcbiAgICAgIGNvbXB1dGVkU3R5bGVzW2FuaW1EdXJhdGlvblByb3BdXG4gICAgaWYgKGFuaW1EdXJhdGlvbiAmJiBhbmltRHVyYXRpb24gIT09ICcwcycpIHtcbiAgICAgIHR5cGUgPSBUWVBFX0FOSU1BVElPTlxuICAgIH1cbiAgfVxuICBpZiAodHlwZSkge1xuICAgIHRoaXMudHlwZUNhY2hlW2NsYXNzTmFtZV0gPSB0eXBlXG4gIH1cbiAgcmV0dXJuIHR5cGVcbn1cblxuLyoqXG4gKiBTZXR1cCBhIENTUyB0cmFuc2l0aW9uZW5kL2FuaW1hdGlvbmVuZCBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxucC5zZXR1cENzc0NiID0gZnVuY3Rpb24gKGV2ZW50LCBjYikge1xuICB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IGV2ZW50XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgZWwgPSB0aGlzLmVsXG4gIHZhciBvbkVuZCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBfLm9mZihlbCwgZXZlbnQsIG9uRW5kKVxuICAgICAgc2VsZi5wZW5kaW5nQ3NzRXZlbnQgPSBzZWxmLnBlbmRpbmdDc3NDYiA9IG51bGxcbiAgICAgIGlmICghc2VsZi5wZW5kaW5nSnNDYiAmJiBjYikge1xuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIF8ub24oZWwsIGV2ZW50LCBvbkVuZClcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGhpZGRlbiAtIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdFxuICogc2tpcCB0aGUgdHJhbnNpdGlvbiBhbGx0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzSGlkZGVuIChlbCkge1xuICByZXR1cm4gIShcbiAgICBlbC5vZmZzZXRXaWR0aCAmJlxuICAgIGVsLm9mZnNldEhlaWdodCAmJlxuICAgIGVsLmdldENsaWVudFJlY3RzKCkubGVuZ3RoXG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4vaW5kZXgnKVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSBjb21wb25lbnQsIGlmIHllcyByZXR1cm4gaXRzXG4gKiBjb21wb25lbnQgaWQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKi9cblxuZXhwb3J0cy5jb21tb25UYWdSRSA9IC9eKGRpdnxwfHNwYW58aW1nfGF8YnxpfGJyfHVsfG9sfGxpfGgxfGgyfGgzfGg0fGg1fGg2fGNvZGV8cHJlfHRhYmxlfHRofHRkfHRyfGZvcm18bGFiZWx8aW5wdXR8c2VsZWN0fG9wdGlvbnxuYXZ8YXJ0aWNsZXxzZWN0aW9ufGhlYWRlcnxmb290ZXIpJC9cbmV4cG9ydHMuY2hlY2tDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICB2YXIgaGFzQXR0cnMgPSBlbC5oYXNBdHRyaWJ1dGVzKClcbiAgaWYgKCFleHBvcnRzLmNvbW1vblRhZ1JFLnRlc3QodGFnKSAmJiB0YWcgIT09ICdjb21wb25lbnQnKSB7XG4gICAgaWYgKF8ucmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkge1xuICAgICAgcmV0dXJuIHsgaWQ6IHRhZyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpcyA9IGhhc0F0dHJzICYmIGdldElzQmluZGluZyhlbClcbiAgICAgIGlmIChpcykge1xuICAgICAgICByZXR1cm4gaXNcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdGFnLmluZGV4T2YoJy0nKSA+IC0xIHx8XG4gICAgICAgICAgKFxuICAgICAgICAgICAgL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSAmJlxuICAgICAgICAgICAgLy8gQ2hyb21lIHJldHVybnMgdW5rbm93biBmb3Igc2V2ZXJhbCBIVE1MNSBlbGVtZW50cy5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01NDA1MjZcbiAgICAgICAgICAgICEvXihkYXRhfHRpbWV8cnRjfHJiKSQvLnRlc3QodGFnKVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgXy53YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PydcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaGFzQXR0cnMpIHtcbiAgICByZXR1cm4gZ2V0SXNCaW5kaW5nKGVsKVxuICB9XG59XG5cbi8qKlxuICogR2V0IFwiaXNcIiBiaW5kaW5nIGZyb20gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGdldElzQmluZGluZyAoZWwpIHtcbiAgLy8gZHluYW1pYyBzeW50YXhcbiAgdmFyIGV4cCA9IF8uYXR0cihlbCwgJ2lzJylcbiAgaWYgKGV4cCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHsgaWQ6IGV4cCB9XG4gIH0gZWxzZSB7XG4gICAgZXhwID0gXy5nZXRCaW5kQXR0cihlbCwgJ2lzJylcbiAgICBpZiAoZXhwICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGlkOiBleHAsIGR5bmFtaWM6IHRydWUgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIHByb3AncyBpbml0aWFsIHZhbHVlIG9uIGEgdm0gYW5kIGl0cyBkYXRhIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuZXhwb3J0cy5pbml0UHJvcCA9IGZ1bmN0aW9uICh2bSwgcHJvcCwgdmFsdWUpIHtcbiAgaWYgKGV4cG9ydHMuYXNzZXJ0UHJvcChwcm9wLCB2YWx1ZSkpIHtcbiAgICB2YXIga2V5ID0gcHJvcC5wYXRoXG4gICAgdm1ba2V5XSA9IHZtLl9kYXRhW2tleV0gPSB2YWx1ZVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuZXhwb3J0cy5hc3NlcnRQcm9wID0gZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gIC8vIGlmIGEgcHJvcCBpcyBub3QgcHJvdmlkZWQgYW5kIGlzIG5vdCByZXF1aXJlZCxcbiAgLy8gc2tpcCB0aGUgY2hlY2suXG4gIGlmIChwcm9wLnJhdyA9PT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgdmFyIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnNcbiAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGVcbiAgdmFyIHZhbGlkID0gdHJ1ZVxuICB2YXIgZXhwZWN0ZWRUeXBlXG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IFN0cmluZykge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ3N0cmluZydcbiAgICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGVcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IE51bWJlcikge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ251bWJlcidcbiAgICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gQm9vbGVhbikge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ2Jvb2xlYW4nXG4gICAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBGdW5jdGlvbikge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ2Z1bmN0aW9uJ1xuICAgICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IE9iamVjdCkge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ29iamVjdCdcbiAgICAgIHZhbGlkID0gXy5pc1BsYWluT2JqZWN0KHZhbHVlKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gQXJyYXkpIHtcbiAgICAgIGV4cGVjdGVkVHlwZSA9ICdhcnJheSdcbiAgICAgIHZhbGlkID0gXy5pc0FycmF5KHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZVxuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgJyArXG4gICAgICBwcm9wLnBhdGggKyAnPVwiJyArIHByb3AucmF3ICsgJ1wiLicgK1xuICAgICAgJyBFeHBlY3RlZCAnICsgZm9ybWF0VHlwZShleHBlY3RlZFR5cGUpICtcbiAgICAgICcsIGdvdCAnICsgZm9ybWF0VmFsdWUodmFsdWUpICsgJy4nXG4gICAgKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBvcHRpb25zLnZhbGlkYXRvclxuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IuY2FsbChudWxsLCB2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgJyArXG4gICAgICAgIHByb3AucGF0aCArICc9XCInICsgcHJvcC5yYXcgKyAnXCInXG4gICAgICApXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZm9ybWF0VHlwZSAodmFsKSB7XG4gIHJldHVybiB2YWxcbiAgICA/IHZhbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbC5zbGljZSgxKVxuICAgIDogJ2N1c3RvbSB0eXBlJ1xufVxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZSAodmFsKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSlcbn1cbiIsIi8qKlxuICogRW5hYmxlIGRlYnVnIHV0aWxpdGllcy5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXG4gIHZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuXG4gIC8qKlxuICAgKiBMb2cgYSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnXG4gICAqL1xuXG4gIGV4cG9ydHMubG9nID0gZnVuY3Rpb24gKG1zZykge1xuICAgIGlmIChoYXNDb25zb2xlICYmIGNvbmZpZy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coJ1tWdWUgaW5mb106ICcgKyBtc2cpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdlJ3ZlIGdvdCBhIHByb2JsZW0gaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZ1xuICAgKi9cblxuICBleHBvcnRzLndhcm4gPSBmdW5jdGlvbiAobXNnLCBlKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50IHx8IGNvbmZpZy5kZWJ1ZykpIHtcbiAgICAgIGNvbnNvbGUud2FybignW1Z1ZSB3YXJuXTogJyArIG1zZylcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLndhcm4oKGUgfHwgbmV3IEVycm9yKCdXYXJuaW5nIFN0YWNrIFRyYWNlJykpLnN0YWNrKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnQgYXNzZXQgZXhpc3RzXG4gICAqL1xuXG4gIGV4cG9ydHMuYXNzZXJ0QXNzZXQgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBpZCkge1xuICAgIGlmICghdmFsKSB7XG4gICAgICBleHBvcnRzLndhcm4oJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlICsgJzogJyArIGlkKVxuICAgIH1cbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuL2luZGV4JylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxudmFyIHRyYW5zaXRpb24gPSByZXF1aXJlKCcuLi90cmFuc2l0aW9uJylcblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuXG5leHBvcnRzLnF1ZXJ5ID0gZnVuY3Rpb24gKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gZWxcbiAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpXG4gICAgaWYgKCFlbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgc2VsZWN0b3JcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAqIE5vdGU6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyBzaG91bGQgd29yayBoZXJlXG4gKiBidXQgYWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGNvbW1lbnQgbm9kZXMgaW4gcGhhbnRvbWpzLFxuICogbWFraW5nIHVuaXQgdGVzdHMgZGlmZmljdWx0LiBUaGlzIGlzIGZpeGVkIGJ5IGRvaW5nIHRoZVxuICogY29udGFpbnMoKSBjaGVjayBvbiB0aGUgbm9kZSdzIHBhcmVudE5vZGUgaW5zdGVhZCBvZlxuICogdGhlIG5vZGUgaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmluRG9jID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICB2YXIgcGFyZW50ID0gbm9kZSAmJiBub2RlLnBhcmVudE5vZGVcbiAgcmV0dXJuIGRvYyA9PT0gbm9kZSB8fFxuICAgIGRvYyA9PT0gcGFyZW50IHx8XG4gICAgISEocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMSAmJiAoZG9jLmNvbnRhaW5zKHBhcmVudCkpKVxufVxuXG4vKipcbiAqIEdldCBhbmQgcmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyXG4gKi9cblxuZXhwb3J0cy5hdHRyID0gZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgdmFyIHZhbCA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHIpXG4gIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBHZXQgYW4gYXR0cmlidXRlIHdpdGggY29sb24gb3Igdi1iaW5kOiBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cblxuZXhwb3J0cy5nZXRCaW5kQXR0ciA9IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gIHZhciB2YWwgPSBleHBvcnRzLmF0dHIobm9kZSwgJzonICsgbmFtZSlcbiAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHZhbCA9IGV4cG9ydHMuYXR0cihub2RlLCAndi1iaW5kOicgKyBuYW1lKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBJbnNlcnQgZWwgYmVmb3JlIHRhcmdldFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cblxuZXhwb3J0cy5iZWZvcmUgPSBmdW5jdGlvbiAoZWwsIHRhcmdldCkge1xuICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIHRhcmdldClcbn1cblxuLyoqXG4gKiBJbnNlcnQgZWwgYWZ0ZXIgdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqL1xuXG5leHBvcnRzLmFmdGVyID0gZnVuY3Rpb24gKGVsLCB0YXJnZXQpIHtcbiAgaWYgKHRhcmdldC5uZXh0U2libGluZykge1xuICAgIGV4cG9ydHMuYmVmb3JlKGVsLCB0YXJnZXQubmV4dFNpYmxpbmcpXG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZWwgZnJvbSBET01cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKi9cblxuZXhwb3J0cy5yZW1vdmUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbClcbn1cblxuLyoqXG4gKiBQcmVwZW5kIGVsIHRvIHRhcmdldFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cblxuZXhwb3J0cy5wcmVwZW5kID0gZnVuY3Rpb24gKGVsLCB0YXJnZXQpIHtcbiAgaWYgKHRhcmdldC5maXJzdENoaWxkKSB7XG4gICAgZXhwb3J0cy5iZWZvcmUoZWwsIHRhcmdldC5maXJzdENoaWxkKVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbClcbiAgfVxufVxuXG4vKipcbiAqIFJlcGxhY2UgdGFyZ2V0IHdpdGggZWxcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICovXG5cbmV4cG9ydHMucmVwbGFjZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGVsKSB7XG4gIHZhciBwYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZVxuICBpZiAocGFyZW50KSB7XG4gICAgcGFyZW50LnJlcGxhY2VDaGlsZChlbCwgdGFyZ2V0KVxuICB9XG59XG5cbi8qKlxuICogQWRkIGV2ZW50IGxpc3RlbmVyIHNob3J0aGFuZC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuZXhwb3J0cy5vbiA9IGZ1bmN0aW9uIChlbCwgZXZlbnQsIGNiKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNiKVxufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lciBzaG9ydGhhbmQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbmV4cG9ydHMub2ZmID0gZnVuY3Rpb24gKGVsLCBldmVudCwgY2IpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2IpXG59XG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgSUUgJiBTVkdcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cm9uZ30gY2xzXG4gKi9cblxuZXhwb3J0cy5hZGRDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xzKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKGNscylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gJyAnICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyAnICdcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgSUUgJiBTVkdcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cm9uZ30gY2xzXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xzKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gJyAnICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyAnICdcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnXG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpXG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIudHJpbSgpKVxuICB9XG4gIGlmICghZWwuY2xhc3NOYW1lKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpXG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IHJhdyBjb250ZW50IGluc2lkZSBhbiBlbGVtZW50IGludG8gYSB0ZW1wb3JhcnlcbiAqIGNvbnRhaW5lciBkaXZcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFzRnJhZ21lbnRcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cblxuZXhwb3J0cy5leHRyYWN0Q29udGVudCA9IGZ1bmN0aW9uIChlbCwgYXNGcmFnbWVudCkge1xuICB2YXIgY2hpbGRcbiAgdmFyIHJhd0NvbnRlbnRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBleHBvcnRzLmlzVGVtcGxhdGUoZWwpICYmXG4gICAgZWwuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnRcbiAgKSB7XG4gICAgZWwgPSBlbC5jb250ZW50XG4gIH1cbiAgaWYgKGVsLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIGV4cG9ydHMudHJpbU5vZGUoZWwpXG4gICAgcmF3Q29udGVudCA9IGFzRnJhZ21lbnRcbiAgICAgID8gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICB3aGlsZSAoY2hpbGQgPSBlbC5maXJzdENoaWxkKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgcmF3Q29udGVudC5hcHBlbmRDaGlsZChjaGlsZClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJhd0NvbnRlbnRcbn1cblxuLyoqXG4gKiBUcmltIHBvc3NpYmxlIGVtcHR5IGhlYWQvdGFpbCB0ZXh0Tm9kZXMgaW5zaWRlIGEgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICovXG5cbmV4cG9ydHMudHJpbU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0cmltKG5vZGUsIG5vZGUuZmlyc3RDaGlsZClcbiAgdHJpbShub2RlLCBub2RlLmxhc3RDaGlsZClcbn1cblxuZnVuY3Rpb24gdHJpbSAocGFyZW50LCBub2RlKSB7XG4gIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IDMgJiYgIW5vZGUuZGF0YS50cmltKCkpIHtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSlcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSB0ZW1wbGF0ZSB0YWcuXG4gKiBOb3RlIGlmIHRoZSB0ZW1wbGF0ZSBhcHBlYXJzIGluc2lkZSBhbiBTVkcgaXRzIHRhZ05hbWVcbiAqIHdpbGwgYmUgaW4gbG93ZXJjYXNlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqL1xuXG5leHBvcnRzLmlzVGVtcGxhdGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZ05hbWUgJiZcbiAgICBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZW1wbGF0ZSdcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gXCJhbmNob3JcIiBmb3IgcGVyZm9ybWluZyBkb20gaW5zZXJ0aW9uL3JlbW92YWxzLlxuICogVGhpcyBpcyB1c2VkIGluIGEgbnVtYmVyIG9mIHNjZW5hcmlvczpcbiAqIC0gZnJhZ21lbnQgaW5zdGFuY2VcbiAqIC0gdi1odG1sXG4gKiAtIHYtaWZcbiAqIC0gdi1mb3JcbiAqIC0gY29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGVyc2lzdCAtIElFIHRyYXNoZXMgZW1wdHkgdGV4dE5vZGVzIG9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZU5vZGUodHJ1ZSksIHNvIGluIGNlcnRhaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VzIHRoZSBhbmNob3IgbmVlZHMgdG8gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbi1lbXB0eSB0byBiZSBwZXJzaXN0ZWQgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcy5cbiAqIEByZXR1cm4ge0NvbW1lbnR8VGV4dH1cbiAqL1xuXG5leHBvcnRzLmNyZWF0ZUFuY2hvciA9IGZ1bmN0aW9uIChjb250ZW50LCBwZXJzaXN0KSB7XG4gIHJldHVybiBjb25maWcuZGVidWdcbiAgICA/IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udGVudClcbiAgICA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBlcnNpc3QgPyAnICcgOiAnJylcbn1cblxuLyoqXG4gKiBGaW5kIGEgY29tcG9uZW50IHJlZiBhdHRyaWJ1dGUgdGhhdCBzdGFydHMgd2l0aCAkLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7U3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuXG52YXIgcmVmUkUgPSAvXnYtcmVmOi9cbmV4cG9ydHMuZmluZFJlZiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgIHZhciBhdHRycyA9IG5vZGUuYXR0cmlidXRlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGF0dHJzW2ldLm5hbWVcbiAgICAgIGlmIChyZWZSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpXG4gICAgICAgIHJldHVybiBfLmNhbWVsaXplKG5hbWUucmVwbGFjZShyZWZSRSwgJycpKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hcCBhIGZ1bmN0aW9uIHRvIGEgcmFuZ2Ugb2Ygbm9kZXMgLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtOb2RlfSBlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wXG4gKi9cblxuZXhwb3J0cy5tYXBOb2RlUmFuZ2UgPSBmdW5jdGlvbiAobm9kZSwgZW5kLCBvcCkge1xuICB2YXIgbmV4dFxuICB3aGlsZSAobm9kZSAhPT0gZW5kKSB7XG4gICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmdcbiAgICBvcChub2RlKVxuICAgIG5vZGUgPSBuZXh0XG4gIH1cbiAgb3AoZW5kKVxufVxuXG4vKipcbiAqIFJlbW92ZSBhIHJhbmdlIG9mIG5vZGVzIHdpdGggdHJhbnNpdGlvbiwgc3RvcmVcbiAqIHRoZSBub2RlcyBpbiBhIGZyYWdtZW50IHdpdGggY29ycmVjdCBvcmRlcmluZyxcbiAqIGFuZCBjYWxsIGNhbGxiYWNrIHdoZW4gZG9uZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHN0YXJ0XG4gKiBAcGFyYW0ge05vZGV9IGVuZFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVOb2RlUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdm0sIGZyYWcsIGNiKSB7XG4gIHZhciBkb25lID0gZmFsc2VcbiAgdmFyIHJlbW92ZWQgPSAwXG4gIHZhciBub2RlcyA9IFtdXG4gIGV4cG9ydHMubWFwTm9kZVJhbmdlKHN0YXJ0LCBlbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IGVuZCkgZG9uZSA9IHRydWVcbiAgICBub2Rlcy5wdXNoKG5vZGUpXG4gICAgdHJhbnNpdGlvbi5yZW1vdmUobm9kZSwgdm0sIG9uUmVtb3ZlZClcbiAgfSlcbiAgZnVuY3Rpb24gb25SZW1vdmVkICgpIHtcbiAgICByZW1vdmVkKytcbiAgICBpZiAoZG9uZSAmJiByZW1vdmVkID49IG5vZGVzLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmcmFnLmFwcGVuZENoaWxkKG5vZGVzW2ldKVxuICAgICAgfVxuICAgICAgY2IgJiYgY2IoKVxuICAgIH1cbiAgfVxufVxuIiwiLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG5leHBvcnRzLmhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge31cblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IGV4cG9ydHMuaW5Ccm93c2VyID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdykgIT09ICdbb2JqZWN0IE9iamVjdF0nXG5cbmV4cG9ydHMuaXNJRTkgPVxuICBpbkJyb3dzZXIgJiZcbiAgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwXG5cbmV4cG9ydHMuaXNBbmRyb2lkID1cbiAgaW5Ccm93c2VyICYmXG4gIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdhbmRyb2lkJykgPiAwXG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbmlmIChpbkJyb3dzZXIgJiYgIWV4cG9ydHMuaXNJRTkpIHtcbiAgdmFyIGlzV2Via2l0VHJhbnMgPVxuICAgIHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICB2YXIgaXNXZWJraXRBbmltID1cbiAgICB3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gIGV4cG9ydHMudHJhbnNpdGlvblByb3AgPSBpc1dlYmtpdFRyYW5zXG4gICAgPyAnV2Via2l0VHJhbnNpdGlvbidcbiAgICA6ICd0cmFuc2l0aW9uJ1xuICBleHBvcnRzLnRyYW5zaXRpb25FbmRFdmVudCA9IGlzV2Via2l0VHJhbnNcbiAgICA/ICd3ZWJraXRUcmFuc2l0aW9uRW5kJ1xuICAgIDogJ3RyYW5zaXRpb25lbmQnXG4gIGV4cG9ydHMuYW5pbWF0aW9uUHJvcCA9IGlzV2Via2l0QW5pbVxuICAgID8gJ1dlYmtpdEFuaW1hdGlvbidcbiAgICA6ICdhbmltYXRpb24nXG4gIGV4cG9ydHMuYW5pbWF0aW9uRW5kRXZlbnQgPSBpc1dlYmtpdEFuaW1cbiAgICA/ICd3ZWJraXRBbmltYXRpb25FbmQnXG4gICAgOiAnYW5pbWF0aW9uZW5kJ1xufVxuXG4vKipcbiAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LiBJZGVhbGx5IHRoaXNcbiAqIHNob3VsZCBiZSBleGVjdXRlZCBhcyBhIG1pY3JvdGFzaywgc28gd2UgbGV2ZXJhZ2VcbiAqIE11dGF0aW9uT2JzZXJ2ZXIgaWYgaXQncyBhdmFpbGFibGUsIGFuZCBmYWxsYmFjayB0b1xuICogc2V0VGltZW91dCgwKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IGN0eFxuICovXG5cbmV4cG9ydHMubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW11cbiAgdmFyIHBlbmRpbmcgPSBmYWxzZVxuICB2YXIgdGltZXJGdW5jXG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlciAoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlXG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKVxuICAgIGNhbGxiYWNrcyA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGNvdW50ZXIgPSAxXG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKVxuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvdW50ZXIpXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyXG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gY291bnRlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lckZ1bmMgPSBzZXRUaW1lb3V0XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChjYiwgY3R4KSB7XG4gICAgdmFyIGZ1bmMgPSBjdHhcbiAgICAgID8gZnVuY3Rpb24gKCkgeyBjYi5jYWxsKGN0eCkgfVxuICAgICAgOiBjYlxuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmMpXG4gICAgaWYgKHBlbmRpbmcpIHJldHVyblxuICAgIHBlbmRpbmcgPSB0cnVlXG4gICAgdGltZXJGdW5jKG5leHRUaWNrSGFuZGxlciwgMClcbiAgfVxufSkoKVxuIiwidmFyIGxhbmcgPSByZXF1aXJlKCcuL2xhbmcnKVxudmFyIGV4dGVuZCA9IGxhbmcuZXh0ZW5kXG5cbmV4dGVuZChleHBvcnRzLCBsYW5nKVxuZXh0ZW5kKGV4cG9ydHMsIHJlcXVpcmUoJy4vZW52JykpXG5leHRlbmQoZXhwb3J0cywgcmVxdWlyZSgnLi9kb20nKSlcbmV4dGVuZChleHBvcnRzLCByZXF1aXJlKCcuL29wdGlvbnMnKSlcbmV4dGVuZChleHBvcnRzLCByZXF1aXJlKCcuL2NvbXBvbmVudCcpKVxuZXh0ZW5kKGV4cG9ydHMsIHJlcXVpcmUoJy4vZGVidWcnKSlcbiIsIi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0cy5zZXQgPSBmdW5jdGlvbiBzZXQgKG9iaiwga2V5LCB2YWwpIHtcbiAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgb2JqW2tleV0gPSB2YWxcbiAgICByZXR1cm5cbiAgfVxuICBpZiAob2JqLl9pc1Z1ZSkge1xuICAgIHNldChvYmouX2RhdGEsIGtleSwgdmFsKVxuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9IG9iai5fX29iX19cbiAgaWYgKCFvYikge1xuICAgIG9ialtrZXldID0gdmFsXG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuY29udmVydChrZXksIHZhbClcbiAgb2IuZGVwLm5vdGlmeSgpXG4gIGlmIChvYi52bXMpIHtcbiAgICB2YXIgaSA9IG9iLnZtcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgdm0gPSBvYi52bXNbaV1cbiAgICAgIHZtLl9wcm94eShrZXkpXG4gICAgICB2bS5fZGlnZXN0KClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqL1xuXG5leHBvcnRzLmRlbGV0ZSA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIG9ialtrZXldXG4gIHZhciBvYiA9IG9iai5fX29iX19cbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKVxuICBpZiAob2Iudm1zKSB7XG4gICAgdmFyIGkgPSBvYi52bXMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHZtID0gb2Iudm1zW2ldXG4gICAgICB2bS5fdW5wcm94eShrZXkpXG4gICAgICB2bS5fZGlnZXN0KClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBleHByZXNzaW9uIGlzIGEgbGl0ZXJhbCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbnZhciBsaXRlcmFsVmFsdWVSRSA9IC9eXFxzPyh0cnVlfGZhbHNlfFtcXGRcXC5dK3wnW14nXSonfFwiW15cIl0qXCIpXFxzPyQvXG5leHBvcnRzLmlzTGl0ZXJhbCA9IGZ1bmN0aW9uIChleHApIHtcbiAgcmV0dXJuIGxpdGVyYWxWYWx1ZVJFLnRlc3QoZXhwKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5pc1Jlc2VydmVkID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKVxuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogR3VhcmQgdGV4dCBvdXRwdXQsIG1ha2Ugc3VyZSB1bmRlZmluZWQgb3V0cHV0c1xuICogZW1wdHkgc3RyaW5nXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmV4cG9ydHMudG9TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB2YWx1ZS50b1N0cmluZygpXG59XG5cbi8qKlxuICogQ2hlY2sgYW5kIGNvbnZlcnQgcG9zc2libGUgbnVtZXJpYyBzdHJpbmdzIHRvIG51bWJlcnNcbiAqIGJlZm9yZSBzZXR0aW5nIGJhY2sgdG8gZGF0YVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4geyp8TnVtYmVyfVxuICovXG5cbmV4cG9ydHMudG9OdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFyc2VkID0gTnVtYmVyKHZhbHVlKVxuICAgIHJldHVybiBpc05hTihwYXJzZWQpXG4gICAgICA/IHZhbHVlXG4gICAgICA6IHBhcnNlZFxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBzdHJpbmcgYm9vbGVhbiBsaXRlcmFscyBpbnRvIHJlYWwgYm9vbGVhbnMuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7KnxCb29sZWFufVxuICovXG5cbmV4cG9ydHMudG9Cb29sZWFuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gJ3RydWUnXG4gICAgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgICAgPyBmYWxzZVxuICAgICAgOiB2YWx1ZVxufVxuXG4vKipcbiAqIFN0cmlwIHF1b3RlcyBmcm9tIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nIHwgZmFsc2V9XG4gKi9cblxuZXhwb3J0cy5zdHJpcFF1b3RlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGEgPSBzdHIuY2hhckNvZGVBdCgwKVxuICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KHN0ci5sZW5ndGggLSAxKVxuICByZXR1cm4gYSA9PT0gYiAmJiAoYSA9PT0gMHgyMiB8fCBhID09PSAweDI3KVxuICAgID8gc3RyLnNsaWNlKDEsIC0xKVxuICAgIDogc3RyXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsbWl0ZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZ1xuZXhwb3J0cy5jYW1lbGl6ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIHRvVXBwZXIpXG59XG5cbmZ1bmN0aW9uIHRvVXBwZXIgKF8sIGMpIHtcbiAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJ1xufVxuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBoeXBoZW5hdGVSRSA9IC8oW2EtelxcZF0pKFtBLVpdKS9nXG5leHBvcnRzLmh5cGhlbmF0ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpXG59XG5cbi8qKlxuICogQ29udmVydHMgaHlwaGVuL3VuZGVyc2NvcmUvc2xhc2ggZGVsaW1pdGVyZWQgbmFtZXMgaW50b1xuICogY2FtZWxpemVkIGNsYXNzTmFtZXMuXG4gKlxuICogZS5nLiBteS1jb21wb25lbnQgPT4gTXlDb21wb25lbnRcbiAqICAgICAgc29tZV9lbHNlICAgID0+IFNvbWVFbHNlXG4gKiAgICAgIHNvbWUvY29tcCAgICA9PiBTb21lQ29tcFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX1xcL10pKFxcdykvZ1xuZXhwb3J0cy5jbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIHRvVXBwZXIpXG59XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5leHBvcnRzLmJpbmQgPSBmdW5jdGlvbiAoZm4sIGN0eCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXktbGlrZX0gbGlzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydF0gLSBzdGFydCBpbmRleFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZXhwb3J0cy50b0FycmF5ID0gZnVuY3Rpb24gKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMFxuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnRcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKVxuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tXG4gKi9cblxuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKVxuICB2YXIgaSA9IGtleXMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICB0b1trZXlzW2ldXSA9IGZyb21ba2V5c1tpXV1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG52YXIgT0JKRUNUX1NUUklORyA9ICdbb2JqZWN0IE9iamVjdF0nXG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkdcbn1cblxuLyoqXG4gKiBBcnJheSB0eXBlIGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmV4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXlcblxuLyoqXG4gKiBEZWZpbmUgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtlbnVtZXJhYmxlXVxuICovXG5cbmV4cG9ydHMuZGVmaW5lID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG59XG5cbi8qKlxuICogRGVib3VuY2UgYSBmdW5jdGlvbiBzbyBpdCBvbmx5IGdldHMgY2FsbGVkIGFmdGVyIHRoZVxuICogaW5wdXQgc3RvcHMgYXJyaXZpbmcgYWZ0ZXIgdGhlIGdpdmVuIHdhaXQgcGVyaW9kLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAqIEBwYXJhbSB7TnVtYmVyfSB3YWl0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0cy5kZWJvdW5jZSA9IGZ1bmN0aW9uIChmdW5jLCB3YWl0KSB7XG4gIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdFxuICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhc3QgPSBEYXRlLm5vdygpIC0gdGltZXN0YW1wXG4gICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbFxuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKVxuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb250ZXh0ID0gdGhpc1xuICAgIGFyZ3MgPSBhcmd1bWVudHNcbiAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpXG4gICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdClcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qKlxuICogTWFudWFsIGluZGV4T2YgYmVjYXVzZSBpdCdzIHNsaWdodGx5IGZhc3RlciB0aGFuXG4gKiBuYXRpdmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0geyp9IG9ialxuICovXG5cbmV4cG9ydHMuaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnIsIG9iaikge1xuICB2YXIgaSA9IGFyci5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGlcbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBNYWtlIGEgY2FuY2VsbGFibGUgdmVyc2lvbiBvZiBhbiBhc3luYyBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZXhwb3J0cy5jYW5jZWxsYWJsZSA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGNiLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYi5jYW5jZWxsZWQgPSB0cnVlXG4gIH1cbiAgcmV0dXJuIGNiXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKlxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5sb29zZUVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4gIHJldHVybiBhID09IGIgfHwgKFxuICAgIGV4cG9ydHMuaXNPYmplY3QoYSkgJiYgZXhwb3J0cy5pc09iamVjdChiKVxuICAgICAgPyBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYilcbiAgICAgIDogZmFsc2VcbiAgKVxuICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuL2luZGV4JylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxudmFyIGV4dGVuZCA9IF8uZXh0ZW5kXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICpcbiAqIEFsbCBzdHJhdGVneSBmdW5jdGlvbnMgZm9sbG93IHRoZSBzYW1lIHNpZ25hdHVyZTpcbiAqXG4gKiBAcGFyYW0geyp9IHBhcmVudFZhbFxuICogQHBhcmFtIHsqfSBjaGlsZFZhbFxuICogQHBhcmFtIHtWdWV9IFt2bV1cbiAqL1xuXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcyA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsXG4gIGZvciAoa2V5IGluIGZyb20pIHtcbiAgICB0b1ZhbCA9IHRvW2tleV1cbiAgICBmcm9tVmFsID0gZnJvbVtrZXldXG4gICAgaWYgKCF0by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBfLnNldCh0bywga2V5LCBmcm9tVmFsKVxuICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdCh0b1ZhbCkgJiYgXy5pc09iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJ1xuICAgICAgKVxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIGNoaWxkVmFsLmNhbGwodGhpcyksXG4gICAgICAgIHBhcmVudFZhbC5jYWxsKHRoaXMpXG4gICAgICApXG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0pXG4gICAgICAgIDogY2hpbGRWYWxcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRWxcbiAqL1xuXG5zdHJhdHMuZWwgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgaWYgKCF2bSAmJiBjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICdUaGUgXCJlbFwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgJ2RlZmluaXRpb25zLidcbiAgICApXG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJldCA9IGNoaWxkVmFsIHx8IHBhcmVudFZhbFxuICAvLyBpbnZva2UgdGhlIGVsZW1lbnQgZmFjdG9yeSBpZiB0aGlzIGlzIGluc3RhbmNlIG1lcmdlXG4gIHJldHVybiB2bSAmJiB0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nXG4gICAgPyByZXQuY2FsbCh2bSlcbiAgICA6IHJldFxufVxuXG4vKipcbiAqIEhvb2tzIGFuZCBwYXJhbSBhdHRyaWJ1dGVzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5cbnN0cmF0cy5pbml0ID1cbnN0cmF0cy5jcmVhdGVkID1cbnN0cmF0cy5yZWFkeSA9XG5zdHJhdHMuYXR0YWNoZWQgPVxuc3RyYXRzLmRldGFjaGVkID1cbnN0cmF0cy5iZWZvcmVDb21waWxlID1cbnN0cmF0cy5jb21waWxlZCA9XG5zdHJhdHMuYmVmb3JlRGVzdHJveSA9XG5zdHJhdHMuZGVzdHJveWVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogXy5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbi8qKlxuICogMC4xMSBkZXByZWNhdGlvbiB3YXJuaW5nXG4gKi9cblxuc3RyYXRzLnBhcmFtQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgJ1wicGFyYW1BdHRyaWJ1dGVzXCIgb3B0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gMC4xMi4gJyArXG4gICAgJ1VzZSBcInByb3BzXCIgaW5zdGVhZC4nXG4gIClcbn1cblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwpXG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgZ3VhcmRBcnJheUFzc2V0cyhjaGlsZFZhbCkpXG4gICAgOiByZXNcbn1cblxuY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHNcbn0pXG5cbi8qKlxuICogRXZlbnRzICYgV2F0Y2hlcnMuXG4gKlxuICogRXZlbnRzICYgd2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cblxuc3RyYXRzLndhdGNoID1cbnN0cmF0cy5ldmVudHMgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIWNoaWxkVmFsKSByZXR1cm4gcGFyZW50VmFsXG4gIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWxcbiAgdmFyIHJldCA9IHt9XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbClcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldXG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5XVxuICAgIGlmIChwYXJlbnQgJiYgIV8uaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XVxuICAgIH1cbiAgICByZXRba2V5XSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBbY2hpbGRdXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cblxuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWxcbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbFxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpXG4gIGV4dGVuZChyZXQsIGNoaWxkVmFsKVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xuXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn1cblxuLyoqXG4gKiBNYWtlIHN1cmUgY29tcG9uZW50IG9wdGlvbnMgZ2V0IGNvbnZlcnRlZCB0byBhY3R1YWxcbiAqIGNvbnN0cnVjdG9ycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGd1YXJkQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBvcHRpb25zLmNvbXBvbmVudHMgPVxuICAgICAgZ3VhcmRBcnJheUFzc2V0cyhvcHRpb25zLmNvbXBvbmVudHMpXG4gICAgdmFyIGRlZlxuICAgIHZhciBpZHMgPSBPYmplY3Qua2V5cyhjb21wb25lbnRzKVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaWRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGlkc1tpXVxuICAgICAgaWYgKF8uY29tbW9uVGFnUkUudGVzdChrZXkpKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAgICdpZDogJyArIGtleVxuICAgICAgICApXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBkZWYgPSBjb21wb25lbnRzW2tleV1cbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QoZGVmKSkge1xuICAgICAgICBjb21wb25lbnRzW2tleV0gPSBfLlZ1ZS5leHRlbmQoZGVmKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGd1YXJkUHJvcHMgKG9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wc1xuICB2YXIgaVxuICBpZiAoXy5pc0FycmF5KHByb3BzKSkge1xuICAgIG9wdGlvbnMucHJvcHMgPSB7fVxuICAgIGkgPSBwcm9wcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBvcHRpb25zLnByb3BzW3Byb3BzW2ldXSA9IG51bGxcbiAgICB9XG4gIH0gZWxzZSBpZiAoXy5pc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpXG4gICAgaSA9IGtleXMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHZhbCA9IHByb3BzW2tleXNbaV1dXG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9wc1trZXlzW2ldXSA9IHsgdHlwZTogdmFsIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHdWFyZCBhbiBBcnJheS1mb3JtYXQgYXNzZXRzIG9wdGlvbiBhbmQgY29udmVydGVkIGl0XG4gKiBpbnRvIHRoZSBrZXktdmFsdWUgT2JqZWN0IGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gYXNzZXRzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZ3VhcmRBcnJheUFzc2V0cyAoYXNzZXRzKSB7XG4gIGlmIChfLmlzQXJyYXkoYXNzZXRzKSkge1xuICAgIHZhciByZXMgPSB7fVxuICAgIHZhciBpID0gYXNzZXRzLmxlbmd0aFxuICAgIHZhciBhc3NldFxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFzc2V0ID0gYXNzZXRzW2ldXG4gICAgICB2YXIgaWQgPSB0eXBlb2YgYXNzZXQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyAoKGFzc2V0Lm9wdGlvbnMgJiYgYXNzZXQub3B0aW9ucy5uYW1lKSB8fCBhc3NldC5pZClcbiAgICAgICAgOiAoYXNzZXQubmFtZSB8fCBhc3NldC5pZClcbiAgICAgIGlmICghaWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICAgJ0FycmF5LXN5bnRheCBhc3NldHMgbXVzdCBwcm92aWRlIGEgXCJuYW1lXCIgb3IgXCJpZFwiIGZpZWxkLidcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzW2lkXSA9IGFzc2V0XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuICByZXR1cm4gYXNzZXRzXG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gKiBAcGFyYW0ge09iamVjdH0gY2hpbGRcbiAqIEBwYXJhbSB7VnVlfSBbdm1dIC0gaWYgdm0gaXMgcHJlc2VudCwgaW5kaWNhdGVzIHRoaXMgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgYW4gaW5zdGFudGlhdGlvbiBtZXJnZS5cbiAqL1xuXG5leHBvcnRzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIG1lcmdlIChwYXJlbnQsIGNoaWxkLCB2bSkge1xuICBndWFyZENvbXBvbmVudHMoY2hpbGQpXG4gIGd1YXJkUHJvcHMoY2hpbGQpXG4gIHZhciBvcHRpb25zID0ge31cbiAgdmFyIGtleVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZShwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pXG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KVxuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCEocGFyZW50Lmhhc093blByb3BlcnR5KGtleSkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSlcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpXG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEByZXR1cm4ge09iamVjdHxGdW5jdGlvbn1cbiAqL1xuXG5leHBvcnRzLnJlc29sdmVBc3NldCA9IGZ1bmN0aW9uIHJlc29sdmUgKG9wdGlvbnMsIHR5cGUsIGlkKSB7XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdXG4gIHZhciBjYW1lbGl6ZWRJZFxuICByZXR1cm4gYXNzZXRzW2lkXSB8fFxuICAgIC8vIGNhbWVsQ2FzZSBJRFxuICAgIGFzc2V0c1tjYW1lbGl6ZWRJZCA9IF8uY2FtZWxpemUoaWQpXSB8fFxuICAgIC8vIFBhc2NhbCBDYXNlIElEXG4gICAgYXNzZXRzW2NhbWVsaXplZElkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2FtZWxpemVkSWQuc2xpY2UoMSldXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4vdXRpbCcpXG52YXIgZXh0ZW5kID0gXy5leHRlbmRcblxuLyoqXG4gKiBUaGUgZXhwb3NlZCBWdWUgY29uc3RydWN0b3IuXG4gKlxuICogQVBJIGNvbnZlbnRpb25zOlxuICogLSBwdWJsaWMgQVBJIG1ldGhvZHMvcHJvcGVydGllcyBhcmUgcHJlZmlleGVkIHdpdGggYCRgXG4gKiAtIGludGVybmFsIG1ldGhvZHMvcHJvcGVydGllcyBhcmUgcHJlZml4ZWQgd2l0aCBgX2BcbiAqIC0gbm9uLXByZWZpeGVkIHByb3BlcnRpZXMgYXJlIGFzc3VtZWQgdG8gYmUgcHJveGllZCB1c2VyXG4gKiAgIGRhdGEuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gIHRoaXMuX2luaXQob3B0aW9ucylcbn1cblxuLyoqXG4gKiBNaXhpbiBnbG9iYWwgQVBJXG4gKi9cblxuZXh0ZW5kKFZ1ZSwgcmVxdWlyZSgnLi9hcGkvZ2xvYmFsJykpXG5cbi8qKlxuICogVnVlIGFuZCBldmVyeSBjb25zdHJ1Y3RvciB0aGF0IGV4dGVuZHMgVnVlIGhhcyBhblxuICogYXNzb2NpYXRlZCBvcHRpb25zIG9iamVjdCwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkIGR1cmluZ1xuICogY29tcGlsYXRpb24gc3RlcHMgYXMgYHRoaXMuY29uc3RydWN0b3Iub3B0aW9uc2AuXG4gKlxuICogVGhlc2UgY2FuIGJlIHNlZW4gYXMgdGhlIGRlZmF1bHQgb3B0aW9ucyBvZiBldmVyeVxuICogVnVlIGluc3RhbmNlLlxuICovXG5cblZ1ZS5vcHRpb25zID0ge1xuICByZXBsYWNlOiB0cnVlLFxuICBkaXJlY3RpdmVzOiByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvcHVibGljJyksXG4gIGVsZW1lbnREaXJlY3RpdmVzOiByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZWxlbWVudCcpLFxuICBmaWx0ZXJzOiByZXF1aXJlKCcuL2ZpbHRlcnMnKSxcbiAgdHJhbnNpdGlvbnM6IHt9LFxuICBjb21wb25lbnRzOiB7fSxcbiAgcGFydGlhbHM6IHt9XG59XG5cbi8qKlxuICogQnVpbGQgdXAgdGhlIHByb3RvdHlwZVxuICovXG5cbnZhciBwID0gVnVlLnByb3RvdHlwZVxuXG4vKipcbiAqICRkYXRhIGhhcyBhIHNldHRlciB3aGljaCBkb2VzIGEgYnVuY2ggb2ZcbiAqIHRlYXJkb3duL3NldHVwIHdvcmtcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocCwgJyRkYXRhJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgaWYgKG5ld0RhdGEgIT09IHRoaXMuX2RhdGEpIHtcbiAgICAgIHRoaXMuX3NldERhdGEobmV3RGF0YSlcbiAgICB9XG4gIH1cbn0pXG5cbi8qKlxuICogTWl4aW4gaW50ZXJuYWwgaW5zdGFuY2UgbWV0aG9kc1xuICovXG5cbmV4dGVuZChwLCByZXF1aXJlKCcuL2luc3RhbmNlL2luaXQnKSlcbmV4dGVuZChwLCByZXF1aXJlKCcuL2luc3RhbmNlL2V2ZW50cycpKVxuZXh0ZW5kKHAsIHJlcXVpcmUoJy4vaW5zdGFuY2Uvc3RhdGUnKSlcbmV4dGVuZChwLCByZXF1aXJlKCcuL2luc3RhbmNlL2xpZmVjeWNsZScpKVxuZXh0ZW5kKHAsIHJlcXVpcmUoJy4vaW5zdGFuY2UvbWlzYycpKVxuXG4vKipcbiAqIE1peGluIHB1YmxpYyBBUEkgbWV0aG9kc1xuICovXG5cbmV4dGVuZChwLCByZXF1aXJlKCcuL2FwaS9kYXRhJykpXG5leHRlbmQocCwgcmVxdWlyZSgnLi9hcGkvZG9tJykpXG5leHRlbmQocCwgcmVxdWlyZSgnLi9hcGkvZXZlbnRzJykpXG5leHRlbmQocCwgcmVxdWlyZSgnLi9hcGkvbGlmZWN5Y2xlJykpXG5cblZ1ZS52ZXJzaW9uID0gJzEuMC40J1xubW9kdWxlLmV4cG9ydHMgPSBfLlZ1ZSA9IFZ1ZVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlmIChfLmluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXykge1xuICAgIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fLmVtaXQoJ2luaXQnLCBWdWUpXG4gIH1cbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi91dGlsJylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpXG52YXIgRGVwID0gcmVxdWlyZSgnLi9vYnNlcnZlci9kZXAnKVxudmFyIGV4cFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2Vycy9leHByZXNzaW9uJylcbnZhciBiYXRjaGVyID0gcmVxdWlyZSgnLi9iYXRjaGVyJylcbnZhciB1aWQgPSAwXG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgLSB7QXJyYXl9IGZpbHRlcnNcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSB0d29XYXlcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBkZWVwXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gdXNlclxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHN5bmNcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBsYXp5XG4gKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IFtwcmVQcm9jZXNzXVxuICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBbcG9zdFByb2Nlc3NdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBXYXRjaGVyICh2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpIHtcbiAgLy8gbWl4IGluIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBfLmV4dGVuZCh0aGlzLCBvcHRpb25zKVxuICB9XG4gIHZhciBpc0ZuID0gdHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbidcbiAgdGhpcy52bSA9IHZtXG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpXG4gIHRoaXMuZXhwcmVzc2lvbiA9IGlzRm4gPyBleHBPckZuLnRvU3RyaW5nKCkgOiBleHBPckZuXG4gIHRoaXMuY2IgPSBjYlxuICB0aGlzLmlkID0gKyt1aWQgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWVcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eSAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHRoaXMubmV3RGVwcyA9IG51bGxcbiAgdGhpcy5wcmV2RXJyb3IgPSBudWxsIC8vIGZvciBhc3luYyBlcnJvciBzdGFja3NcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyL3NldHRlclxuICBpZiAoaXNGbikge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGblxuICAgIHRoaXMuc2V0dGVyID0gdW5kZWZpbmVkXG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlcyA9IGV4cFBhcnNlci5wYXJzZShleHBPckZuLCB0aGlzLnR3b1dheSlcbiAgICB0aGlzLmdldHRlciA9IHJlcy5nZXRcbiAgICB0aGlzLnNldHRlciA9IHJlcy5zZXRcbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KClcbiAgLy8gc3RhdGUgZm9yIGF2b2lkaW5nIGZhbHNlIHRyaWdnZXJzIGZvciBkZWVwIGFuZCBBcnJheVxuICAvLyB3YXRjaGVycyBkdXJpbmcgdm0uX2RpZ2VzdCgpXG4gIHRoaXMucXVldWVkID0gdGhpcy5zaGFsbG93ID0gZmFsc2Vcbn1cblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7RGVwfSBkZXBcbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZFxuICBpZiAoIXRoaXMubmV3RGVwc1tpZF0pIHtcbiAgICB0aGlzLm5ld0RlcHNbaWRdID0gZGVwXG4gICAgaWYgKCF0aGlzLmRlcHNbaWRdKSB7XG4gICAgICB0aGlzLmRlcHNbaWRdID0gZGVwXG4gICAgICBkZXAuYWRkU3ViKHRoaXMpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5iZWZvcmVHZXQoKVxuICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlIHx8IHRoaXMudm1cbiAgdmFyIHZhbHVlXG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHNjb3BlLCBzY29wZSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIGNvbmZpZy53YXJuRXhwcmVzc2lvbkVycm9yc1xuICAgICkge1xuICAgICAgXy53YXJuKFxuICAgICAgICAnRXJyb3Igd2hlbiBldmFsdWF0aW5nIGV4cHJlc3Npb24gXCInICtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uICsgJ1wiLiAnICtcbiAgICAgICAgKGNvbmZpZy5kZWJ1Z1xuICAgICAgICAgID8gJydcbiAgICAgICAgICA6ICdUdXJuIG9uIGRlYnVnIG1vZGUgdG8gc2VlIHN0YWNrIHRyYWNlLidcbiAgICAgICAgKSwgZVxuICAgICAgKVxuICAgIH1cbiAgfVxuICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gIGlmICh0aGlzLmRlZXApIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZSlcbiAgfVxuICBpZiAodGhpcy5wcmVQcm9jZXNzKSB7XG4gICAgdmFsdWUgPSB0aGlzLnByZVByb2Nlc3ModmFsdWUpXG4gIH1cbiAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgIHZhbHVlID0gc2NvcGUuX2FwcGx5RmlsdGVycyh2YWx1ZSwgbnVsbCwgdGhpcy5maWx0ZXJzLCBmYWxzZSlcbiAgfVxuICBpZiAodGhpcy5wb3N0UHJvY2Vzcykge1xuICAgIHZhbHVlID0gdGhpcy5wb3N0UHJvY2Vzcyh2YWx1ZSlcbiAgfVxuICB0aGlzLmFmdGVyR2V0KClcbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogU2V0IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIHdpdGggdGhlIHNldHRlci5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGUgfHwgdGhpcy52bVxuICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgdmFsdWUgPSBzY29wZS5fYXBwbHlGaWx0ZXJzKFxuICAgICAgdmFsdWUsIHRoaXMudmFsdWUsIHRoaXMuZmlsdGVycywgdHJ1ZSlcbiAgfVxuICB0cnkge1xuICAgIHRoaXMuc2V0dGVyLmNhbGwoc2NvcGUsIHNjb3BlLCB2YWx1ZSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIGNvbmZpZy53YXJuRXhwcmVzc2lvbkVycm9yc1xuICAgICkge1xuICAgICAgXy53YXJuKFxuICAgICAgICAnRXJyb3Igd2hlbiBldmFsdWF0aW5nIHNldHRlciBcIicgK1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gKyAnXCInLCBlXG4gICAgICApXG4gICAgfVxuICB9XG4gIC8vIHR3by13YXkgc3luYyBmb3Igdi1mb3IgYWxpYXNcbiAgdmFyIGZvckNvbnRleHQgPSBzY29wZS4kZm9yQ29udGV4dFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChcbiAgICAgIGZvckNvbnRleHQgJiZcbiAgICAgIGZvckNvbnRleHQuZmlsdGVycyAmJlxuICAgICAgKG5ldyBSZWdFeHAoZm9yQ29udGV4dC5hbGlhcyArICdcXFxcYicpKS50ZXN0KHRoaXMuZXhwcmVzc2lvbilcbiAgICApIHtcbiAgICAgIF8ud2FybihcbiAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdHdvLXdheSBiaW5kaW5nIG9uICcgK1xuICAgICAgICAnYSB2LWZvciBhbGlhcyAoJyArIHRoaXMuZXhwcmVzc2lvbiArICcpLCBhbmQgdGhlICcgK1xuICAgICAgICAndi1mb3IgaGFzIGZpbHRlcnMuIFRoaXMgd2lsbCBub3Qgd29yayBwcm9wZXJseS4gJyArXG4gICAgICAgICdFaXRoZXIgcmVtb3ZlIHRoZSBmaWx0ZXJzIG9yIHVzZSBhbiBhcnJheSBvZiAnICtcbiAgICAgICAgJ29iamVjdHMgYW5kIGJpbmQgdG8gb2JqZWN0IHByb3BlcnRpZXMgaW5zdGVhZC4nXG4gICAgICApXG4gICAgfVxuICB9XG4gIGlmIChcbiAgICBmb3JDb250ZXh0ICYmXG4gICAgZm9yQ29udGV4dC5hbGlhcyA9PT0gdGhpcy5leHByZXNzaW9uICYmXG4gICAgIWZvckNvbnRleHQuZmlsdGVyc1xuICApIHtcbiAgICBpZiAoc2NvcGUuJGtleSkgeyAvLyBvcmlnaW5hbCBpcyBhbiBvYmplY3RcbiAgICAgIGZvckNvbnRleHQucmF3VmFsdWVbc2NvcGUuJGtleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3JDb250ZXh0LnJhd1ZhbHVlLiRzZXQoc2NvcGUuJGluZGV4LCB2YWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQcmVwYXJlIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuYmVmb3JlR2V0ID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0ID0gdGhpc1xuICB0aGlzLm5ld0RlcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG59XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5hZnRlckdldCA9IGZ1bmN0aW9uICgpIHtcbiAgRGVwLnRhcmdldCA9IG51bGxcbiAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKHRoaXMuZGVwcylcbiAgdmFyIGkgPSBpZHMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgaWQgPSBpZHNbaV1cbiAgICBpZiAoIXRoaXMubmV3RGVwc1tpZF0pIHtcbiAgICAgIHRoaXMuZGVwc1tpZF0ucmVtb3ZlU3ViKHRoaXMpXG4gICAgfVxuICB9XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwc1xufVxuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNoYWxsb3dcbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoc2hhbGxvdykge1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWVcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMgfHwgIWNvbmZpZy5hc3luYykge1xuICAgIHRoaXMucnVuKClcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBxdWV1ZWQsIG9ubHkgb3ZlcndyaXRlIHNoYWxsb3cgd2l0aCBub24tc2hhbGxvdyxcbiAgICAvLyBidXQgbm90IHRoZSBvdGhlciB3YXkgYXJvdW5kLlxuICAgIHRoaXMuc2hhbGxvdyA9IHRoaXMucXVldWVkXG4gICAgICA/IHNoYWxsb3dcbiAgICAgICAgPyB0aGlzLnNoYWxsb3dcbiAgICAgICAgOiBmYWxzZVxuICAgICAgOiAhIXNoYWxsb3dcbiAgICB0aGlzLnF1ZXVlZCA9IHRydWVcbiAgICAvLyByZWNvcmQgYmVmb3JlLXB1c2ggZXJyb3Igc3RhY2sgaW4gZGVidWcgbW9kZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5kZWJ1Zykge1xuICAgICAgdGhpcy5wcmV2RXJyb3IgPSBuZXcgRXJyb3IoJ1t2dWVdIGFzeW5jIHN0YWNrIHRyYWNlJylcbiAgICB9XG4gICAgYmF0Y2hlci5wdXNoKHRoaXMpXG4gIH1cbn1cblxuLyoqXG4gKiBCYXRjaGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgYmF0Y2hlci5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KClcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgQXJyYXkgd2F0Y2hlcnMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkOyBidXQgb25seSBkbyBzbyBpZiB0aGlzIGlzIGFcbiAgICAgIC8vIG5vbi1zaGFsbG93IHVwZGF0ZSAoY2F1c2VkIGJ5IGEgdm0gZGlnZXN0KS5cbiAgICAgICgoXy5pc0FycmF5KHZhbHVlKSB8fCB0aGlzLmRlZXApICYmICF0aGlzLnNoYWxsb3cpXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlXG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICAgIC8vIGluIGRlYnVnICsgYXN5bmMgbW9kZSwgd2hlbiBhIHdhdGNoZXIgY2FsbGJhY2tzXG4gICAgICAvLyB0aHJvd3MsIHdlIGFsc28gdGhyb3cgdGhlIHNhdmVkIGJlZm9yZS1wdXNoIGVycm9yXG4gICAgICAvLyBzbyB0aGUgZnVsbCBjcm9zcy10aWNrIHN0YWNrIHRyYWNlIGlzIGF2YWlsYWJsZS5cbiAgICAgIHZhciBwcmV2RXJyb3IgPSB0aGlzLnByZXZFcnJvclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIGNvbmZpZy5kZWJ1ZyAmJiBwcmV2RXJyb3IpIHtcbiAgICAgICAgdGhpcy5wcmV2RXJyb3IgPSBudWxsXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIF8ubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgcHJldkVycm9yXG4gICAgICAgICAgfSwgMClcbiAgICAgICAgICB0aHJvdyBlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucXVldWVkID0gdGhpcy5zaGFsbG93ID0gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gYXZvaWQgb3ZlcndyaXRpbmcgYW5vdGhlciB3YXRjaGVyIHRoYXQgaXMgYmVpbmdcbiAgLy8gY29sbGVjdGVkLlxuICB2YXIgY3VycmVudCA9IERlcC50YXJnZXRcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KClcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlXG4gIERlcC50YXJnZXQgPSBjdXJyZW50XG59XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGVwSWRzID0gT2JqZWN0LmtleXModGhpcy5kZXBzKVxuICB2YXIgaSA9IGRlcElkcy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuZGVwc1tkZXBJZHNbaV1dLmRlcGVuZCgpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YmNyaWJlciBsaXN0LlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gd2UgY2FuIHNraXAgdGhpcyBpZiB0aGUgdm0gaWYgYmVpbmcgZGVzdHJveWVkXG4gICAgLy8gd2hpY2ggY2FuIGltcHJvdmUgdGVhcmRvd24gcGVyZm9ybWFuY2UuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICB0aGlzLnZtLl93YXRjaGVycy4kcmVtb3ZlKHRoaXMpXG4gICAgfVxuICAgIHZhciBkZXBJZHMgPSBPYmplY3Qua2V5cyh0aGlzLmRlcHMpXG4gICAgdmFyIGkgPSBkZXBJZHMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2RlcElkc1tpXV0ucmVtb3ZlU3ViKHRoaXMpXG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2VcbiAgICB0aGlzLnZtID0gdGhpcy5jYiA9IHRoaXMudmFsdWUgPSBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBSZWNydXNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKlxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIHZhciBpLCBrZXlzXG4gIGlmIChfLmlzQXJyYXkodmFsKSkge1xuICAgIGkgPSB2YWwubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkgdHJhdmVyc2UodmFsW2ldKVxuICB9IGVsc2UgaWYgKF8uaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpXG4gICAgaSA9IGtleXMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkgdHJhdmVyc2UodmFsW2tleXNbaV1dKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2F0Y2hlclxuIiwidmFyIGluc2VydGVkID0gZXhwb3J0cy5jYWNoZSA9IHt9XG5cbmV4cG9ydHMuaW5zZXJ0ID0gZnVuY3Rpb24gKGNzcykge1xuICBpZiAoaW5zZXJ0ZWRbY3NzXSkgcmV0dXJuXG4gIGluc2VydGVkW2Nzc10gPSB0cnVlXG5cbiAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIGVsZW0uc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJylcblxuICBpZiAoJ3RleHRDb250ZW50JyBpbiBlbGVtKSB7XG4gICAgZWxlbS50ZXh0Q29udGVudCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIGVsZW0uc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH1cblxuICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGVsZW0pXG4gIHJldHVybiBlbGVtXG59XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHR2YXIgbWFrZVByb21pc2UgPSByZXF1aXJlKCcuL21ha2VQcm9taXNlJyk7XG5cdHZhciBTY2hlZHVsZXIgPSByZXF1aXJlKCcuL1NjaGVkdWxlcicpO1xuXHR2YXIgYXN5bmMgPSByZXF1aXJlKCcuL2VudicpLmFzYXA7XG5cblx0cmV0dXJuIG1ha2VQcm9taXNlKHtcblx0XHRzY2hlZHVsZXI6IG5ldyBTY2hlZHVsZXIoYXN5bmMpXG5cdH0pO1xuXG59KTtcbn0pKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24oKSB7XG5cblx0Ly8gQ3JlZGl0IHRvIFR3aXNvbCAoaHR0cHM6Ly9naXRodWIuY29tL1R3aXNvbCkgZm9yIHN1Z2dlc3Rpbmdcblx0Ly8gdGhpcyB0eXBlIG9mIGV4dGVuc2libGUgcXVldWUgKyB0cmFtcG9saW5lIGFwcHJvYWNoIGZvciBuZXh0LXRpY2sgY29uZmxhdGlvbi5cblxuXHQvKipcblx0ICogQXN5bmMgdGFzayBzY2hlZHVsZXJcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gYXN5bmMgZnVuY3Rpb24gdG8gc2NoZWR1bGUgYSBzaW5nbGUgYXN5bmMgZnVuY3Rpb25cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBTY2hlZHVsZXIoYXN5bmMpIHtcblx0XHR0aGlzLl9hc3luYyA9IGFzeW5jO1xuXHRcdHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuX3F1ZXVlID0gdGhpcztcblx0XHR0aGlzLl9xdWV1ZUxlbiA9IDA7XG5cdFx0dGhpcy5fYWZ0ZXJRdWV1ZSA9IHt9O1xuXHRcdHRoaXMuX2FmdGVyUXVldWVMZW4gPSAwO1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHRoaXMuZHJhaW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYuX2RyYWluKCk7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbnF1ZXVlIGEgdGFza1xuXHQgKiBAcGFyYW0ge3sgcnVuOmZ1bmN0aW9uIH19IHRhc2tcblx0ICovXG5cdFNjaGVkdWxlci5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uKHRhc2spIHtcblx0XHR0aGlzLl9xdWV1ZVt0aGlzLl9xdWV1ZUxlbisrXSA9IHRhc2s7XG5cdFx0dGhpcy5ydW4oKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5xdWV1ZSBhIHRhc2sgdG8gcnVuIGFmdGVyIHRoZSBtYWluIHRhc2sgcXVldWVcblx0ICogQHBhcmFtIHt7IHJ1bjpmdW5jdGlvbiB9fSB0YXNrXG5cdCAqL1xuXHRTY2hlZHVsZXIucHJvdG90eXBlLmFmdGVyUXVldWUgPSBmdW5jdGlvbih0YXNrKSB7XG5cdFx0dGhpcy5fYWZ0ZXJRdWV1ZVt0aGlzLl9hZnRlclF1ZXVlTGVuKytdID0gdGFzaztcblx0XHR0aGlzLnJ1bigpO1xuXHR9O1xuXG5cdFNjaGVkdWxlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9ydW5uaW5nKSB7XG5cdFx0XHR0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblx0XHRcdHRoaXMuX2FzeW5jKHRoaXMuZHJhaW4pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRHJhaW4gdGhlIGhhbmRsZXIgcXVldWUgZW50aXJlbHksIGFuZCB0aGVuIHRoZSBhZnRlciBxdWV1ZVxuXHQgKi9cblx0U2NoZWR1bGVyLnByb3RvdHlwZS5fZHJhaW4gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaSA9IDA7XG5cdFx0Zm9yICg7IGkgPCB0aGlzLl9xdWV1ZUxlbjsgKytpKSB7XG5cdFx0XHR0aGlzLl9xdWV1ZVtpXS5ydW4oKTtcblx0XHRcdHRoaXMuX3F1ZXVlW2ldID0gdm9pZCAwO1xuXHRcdH1cblxuXHRcdHRoaXMuX3F1ZXVlTGVuID0gMDtcblx0XHR0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYWZ0ZXJRdWV1ZUxlbjsgKytpKSB7XG5cdFx0XHR0aGlzLl9hZnRlclF1ZXVlW2ldLnJ1bigpO1xuXHRcdFx0dGhpcy5fYWZ0ZXJRdWV1ZVtpXSA9IHZvaWQgMDtcblx0XHR9XG5cblx0XHR0aGlzLl9hZnRlclF1ZXVlTGVuID0gMDtcblx0fTtcblxuXHRyZXR1cm4gU2NoZWR1bGVyO1xuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKCkge1xuXG5cdC8qKlxuXHQgKiBDdXN0b20gZXJyb3IgdHlwZSBmb3IgcHJvbWlzZXMgcmVqZWN0ZWQgYnkgcHJvbWlzZS50aW1lb3V0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gVGltZW91dEVycm9yIChtZXNzYWdlKSB7XG5cdFx0RXJyb3IuY2FsbCh0aGlzKTtcblx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRcdHRoaXMubmFtZSA9IFRpbWVvdXRFcnJvci5uYW1lO1xuXHRcdGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFRpbWVvdXRFcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0VGltZW91dEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblx0VGltZW91dEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbWVvdXRFcnJvcjtcblxuXHRyZXR1cm4gVGltZW91dEVycm9yO1xufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7IH0pKTsiLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24oKSB7XG5cblx0bWFrZUFwcGx5LnRyeUNhdGNoUmVzb2x2ZSA9IHRyeUNhdGNoUmVzb2x2ZTtcblxuXHRyZXR1cm4gbWFrZUFwcGx5O1xuXG5cdGZ1bmN0aW9uIG1ha2VBcHBseShQcm9taXNlLCBjYWxsKSB7XG5cdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcblx0XHRcdGNhbGwgPSB0cnlDYXRjaFJlc29sdmU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFwcGx5O1xuXG5cdFx0ZnVuY3Rpb24gYXBwbHkoZiwgdGhpc0FyZywgYXJncykge1xuXHRcdFx0dmFyIHAgPSBQcm9taXNlLl9kZWZlcigpO1xuXHRcdFx0dmFyIGwgPSBhcmdzLmxlbmd0aDtcblx0XHRcdHZhciBwYXJhbXMgPSBuZXcgQXJyYXkobCk7XG5cdFx0XHRjYWxsQW5kUmVzb2x2ZSh7IGY6ZiwgdGhpc0FyZzp0aGlzQXJnLCBhcmdzOmFyZ3MsIHBhcmFtczpwYXJhbXMsIGk6bC0xLCBjYWxsOmNhbGwgfSwgcC5faGFuZGxlcik7XG5cblx0XHRcdHJldHVybiBwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNhbGxBbmRSZXNvbHZlKGMsIGgpIHtcblx0XHRcdGlmKGMuaSA8IDApIHtcblx0XHRcdFx0cmV0dXJuIGNhbGwoYy5mLCBjLnRoaXNBcmcsIGMucGFyYW1zLCBoKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGhhbmRsZXIgPSBQcm9taXNlLl9oYW5kbGVyKGMuYXJnc1tjLmldKTtcblx0XHRcdGhhbmRsZXIuZm9sZChjYWxsQW5kUmVzb2x2ZU5leHQsIGMsIHZvaWQgMCwgaCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2FsbEFuZFJlc29sdmVOZXh0KGMsIHgsIGgpIHtcblx0XHRcdGMucGFyYW1zW2MuaV0gPSB4O1xuXHRcdFx0Yy5pIC09IDE7XG5cdFx0XHRjYWxsQW5kUmVzb2x2ZShjLCBoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiB0cnlDYXRjaFJlc29sdmUoZiwgdGhpc0FyZywgYXJncywgcmVzb2x2ZXIpIHtcblx0XHR0cnkge1xuXHRcdFx0cmVzb2x2ZXIucmVzb2x2ZShmLmFwcGx5KHRoaXNBcmcsIGFyZ3MpKTtcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdHJlc29sdmVyLnJlamVjdChlKTtcblx0XHR9XG5cdH1cblxufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7IH0pKTtcblxuXG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuXG5cdHZhciBzdGF0ZSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XG5cdHZhciBhcHBsaWVyID0gcmVxdWlyZSgnLi4vYXBwbHknKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gYXJyYXkoUHJvbWlzZSkge1xuXG5cdFx0dmFyIGFwcGx5Rm9sZCA9IGFwcGxpZXIoUHJvbWlzZSk7XG5cdFx0dmFyIHRvUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZTtcblx0XHR2YXIgYWxsID0gUHJvbWlzZS5hbGw7XG5cblx0XHR2YXIgYXIgPSBBcnJheS5wcm90b3R5cGUucmVkdWNlO1xuXHRcdHZhciBhcnIgPSBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQ7XG5cdFx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5cdFx0Ly8gQWRkaXRpb25hbCBhcnJheSBjb21iaW5hdG9yc1xuXG5cdFx0UHJvbWlzZS5hbnkgPSBhbnk7XG5cdFx0UHJvbWlzZS5zb21lID0gc29tZTtcblx0XHRQcm9taXNlLnNldHRsZSA9IHNldHRsZTtcblxuXHRcdFByb21pc2UubWFwID0gbWFwO1xuXHRcdFByb21pc2UuZmlsdGVyID0gZmlsdGVyO1xuXHRcdFByb21pc2UucmVkdWNlID0gcmVkdWNlO1xuXHRcdFByb21pc2UucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gdGhpcyBwcm9taXNlIGZ1bGZpbGxzIHdpdGggYW4gYXJyYXksIGRvXG5cdFx0ICogb25GdWxmaWxsZWQuYXBwbHkodm9pZCAwLCBhcnJheSlcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkZ1bGZpbGxlZCBmdW5jdGlvbiB0byBhcHBseVxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIGZvciB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIG9uRnVsZmlsbGVkXG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24ob25GdWxmaWxsZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLnRoZW4oYWxsKS50aGVuKGZ1bmN0aW9uKGFycmF5KSB7XG5cdFx0XHRcdHJldHVybiBvbkZ1bGZpbGxlZC5hcHBseSh0aGlzLCBhcnJheSk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIFByb21pc2U7XG5cblx0XHQvKipcblx0XHQgKiBPbmUtd2lubmVyIGNvbXBldGl0aXZlIHJhY2UuXG5cdFx0ICogUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgZnVsZmlsbCB3aGVuIG9uZSBvZiB0aGUgcHJvbWlzZXNcblx0XHQgKiBpbiB0aGUgaW5wdXQgYXJyYXkgZnVsZmlsbHMsIG9yIHdpbGwgcmVqZWN0IHdoZW4gYWxsIHByb21pc2VzXG5cdFx0ICogaGF2ZSByZWplY3RlZC5cblx0XHQgKiBAcGFyYW0ge2FycmF5fSBwcm9taXNlc1xuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIGZvciB0aGUgZmlyc3QgZnVsZmlsbGVkIHZhbHVlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gYW55KHByb21pc2VzKSB7XG5cdFx0XHR2YXIgcCA9IFByb21pc2UuX2RlZmVyKCk7XG5cdFx0XHR2YXIgcmVzb2x2ZXIgPSBwLl9oYW5kbGVyO1xuXHRcdFx0dmFyIGwgPSBwcm9taXNlcy5sZW5ndGg+Pj4wO1xuXG5cdFx0XHR2YXIgcGVuZGluZyA9IGw7XG5cdFx0XHR2YXIgZXJyb3JzID0gW107XG5cblx0XHRcdGZvciAodmFyIGgsIHgsIGkgPSAwOyBpIDwgbDsgKytpKSB7XG5cdFx0XHRcdHggPSBwcm9taXNlc1tpXTtcblx0XHRcdFx0aWYoeCA9PT0gdm9pZCAwICYmICEoaSBpbiBwcm9taXNlcykpIHtcblx0XHRcdFx0XHQtLXBlbmRpbmc7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRoID0gUHJvbWlzZS5faGFuZGxlcih4KTtcblx0XHRcdFx0aWYoaC5zdGF0ZSgpID4gMCkge1xuXHRcdFx0XHRcdHJlc29sdmVyLmJlY29tZShoKTtcblx0XHRcdFx0XHRQcm9taXNlLl92aXNpdFJlbWFpbmluZyhwcm9taXNlcywgaSwgaCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aC52aXNpdChyZXNvbHZlciwgaGFuZGxlRnVsZmlsbCwgaGFuZGxlUmVqZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZihwZW5kaW5nID09PSAwKSB7XG5cdFx0XHRcdHJlc29sdmVyLnJlamVjdChuZXcgUmFuZ2VFcnJvcignYW55KCk6IGFycmF5IG11c3Qgbm90IGJlIGVtcHR5JykpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcDtcblxuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlRnVsZmlsbCh4KSB7XG5cdFx0XHRcdC8qanNoaW50IHZhbGlkdGhpczp0cnVlKi9cblx0XHRcdFx0ZXJyb3JzID0gbnVsbDtcblx0XHRcdFx0dGhpcy5yZXNvbHZlKHgpOyAvLyB0aGlzID09PSByZXNvbHZlclxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBoYW5kbGVSZWplY3QoZSkge1xuXHRcdFx0XHQvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSovXG5cdFx0XHRcdGlmKHRoaXMucmVzb2x2ZWQpIHsgLy8gdGhpcyA9PT0gcmVzb2x2ZXJcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlcnJvcnMucHVzaChlKTtcblx0XHRcdFx0aWYoLS1wZW5kaW5nID09PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5yZWplY3QoZXJyb3JzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIE4td2lubmVyIGNvbXBldGl0aXZlIHJhY2Vcblx0XHQgKiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBmdWxmaWxsIHdoZW4gbiBpbnB1dCBwcm9taXNlcyBoYXZlXG5cdFx0ICogZnVsZmlsbGVkLCBvciB3aWxsIHJlamVjdCB3aGVuIGl0IGJlY29tZXMgaW1wb3NzaWJsZSBmb3IgblxuXHRcdCAqIGlucHV0IHByb21pc2VzIHRvIGZ1bGZpbGwgKGllIHdoZW4gcHJvbWlzZXMubGVuZ3RoIC0gbiArIDFcblx0XHQgKiBoYXZlIHJlamVjdGVkKVxuXHRcdCAqIEBwYXJhbSB7YXJyYXl9IHByb21pc2VzXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IG5cblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSBmb3IgdGhlIGVhcmxpZXN0IG4gZnVsZmlsbG1lbnQgdmFsdWVzXG5cdFx0ICpcblx0XHQgKiBAZGVwcmVjYXRlZFxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHNvbWUocHJvbWlzZXMsIG4pIHtcblx0XHRcdC8qanNoaW50IG1heGNvbXBsZXhpdHk6NyovXG5cdFx0XHR2YXIgcCA9IFByb21pc2UuX2RlZmVyKCk7XG5cdFx0XHR2YXIgcmVzb2x2ZXIgPSBwLl9oYW5kbGVyO1xuXG5cdFx0XHR2YXIgcmVzdWx0cyA9IFtdO1xuXHRcdFx0dmFyIGVycm9ycyA9IFtdO1xuXG5cdFx0XHR2YXIgbCA9IHByb21pc2VzLmxlbmd0aD4+PjA7XG5cdFx0XHR2YXIgbkZ1bGZpbGwgPSAwO1xuXHRcdFx0dmFyIG5SZWplY3Q7XG5cdFx0XHR2YXIgeCwgaTsgLy8gcmV1c2VkIGluIGJvdGggZm9yKCkgbG9vcHNcblxuXHRcdFx0Ly8gRmlyc3QgcGFzczogY291bnQgYWN0dWFsIGFycmF5IGl0ZW1zXG5cdFx0XHRmb3IoaT0wOyBpPGw7ICsraSkge1xuXHRcdFx0XHR4ID0gcHJvbWlzZXNbaV07XG5cdFx0XHRcdGlmKHggPT09IHZvaWQgMCAmJiAhKGkgaW4gcHJvbWlzZXMpKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0KytuRnVsZmlsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcHV0ZSBhY3R1YWwgZ29hbHNcblx0XHRcdG4gPSBNYXRoLm1heChuLCAwKTtcblx0XHRcdG5SZWplY3QgPSAobkZ1bGZpbGwgLSBuICsgMSk7XG5cdFx0XHRuRnVsZmlsbCA9IE1hdGgubWluKG4sIG5GdWxmaWxsKTtcblxuXHRcdFx0aWYobiA+IG5GdWxmaWxsKSB7XG5cdFx0XHRcdHJlc29sdmVyLnJlamVjdChuZXcgUmFuZ2VFcnJvcignc29tZSgpOiBhcnJheSBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJ1xuXHRcdFx0XHQrIG4gKyAnIGl0ZW0ocyksIGJ1dCBoYWQgJyArIG5GdWxmaWxsKSk7XG5cdFx0XHR9IGVsc2UgaWYobkZ1bGZpbGwgPT09IDApIHtcblx0XHRcdFx0cmVzb2x2ZXIucmVzb2x2ZShyZXN1bHRzKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2Vjb25kIHBhc3M6IG9ic2VydmUgZWFjaCBhcnJheSBpdGVtLCBtYWtlIHByb2dyZXNzIHRvd2FyZCBnb2Fsc1xuXHRcdFx0Zm9yKGk9MDsgaTxsOyArK2kpIHtcblx0XHRcdFx0eCA9IHByb21pc2VzW2ldO1xuXHRcdFx0XHRpZih4ID09PSB2b2lkIDAgJiYgIShpIGluIHByb21pc2VzKSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0UHJvbWlzZS5faGFuZGxlcih4KS52aXNpdChyZXNvbHZlciwgZnVsZmlsbCwgcmVqZWN0LCByZXNvbHZlci5ub3RpZnkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcDtcblxuXHRcdFx0ZnVuY3Rpb24gZnVsZmlsbCh4KSB7XG5cdFx0XHRcdC8qanNoaW50IHZhbGlkdGhpczp0cnVlKi9cblx0XHRcdFx0aWYodGhpcy5yZXNvbHZlZCkgeyAvLyB0aGlzID09PSByZXNvbHZlclxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdHMucHVzaCh4KTtcblx0XHRcdFx0aWYoLS1uRnVsZmlsbCA9PT0gMCkge1xuXHRcdFx0XHRcdGVycm9ycyA9IG51bGw7XG5cdFx0XHRcdFx0dGhpcy5yZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHJlamVjdChlKSB7XG5cdFx0XHRcdC8qanNoaW50IHZhbGlkdGhpczp0cnVlKi9cblx0XHRcdFx0aWYodGhpcy5yZXNvbHZlZCkgeyAvLyB0aGlzID09PSByZXNvbHZlclxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVycm9ycy5wdXNoKGUpO1xuXHRcdFx0XHRpZigtLW5SZWplY3QgPT09IDApIHtcblx0XHRcdFx0XHRyZXN1bHRzID0gbnVsbDtcblx0XHRcdFx0XHR0aGlzLnJlamVjdChlcnJvcnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQXBwbHkgZiB0byB0aGUgdmFsdWUgb2YgZWFjaCBwcm9taXNlIGluIGEgbGlzdCBvZiBwcm9taXNlc1xuXHRcdCAqIGFuZCByZXR1cm4gYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSByZXN1bHRzLlxuXHRcdCAqIEBwYXJhbSB7YXJyYXl9IHByb21pc2VzXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbih4OiosIGluZGV4Ok51bWJlcik6Kn0gZiBtYXBwaW5nIGZ1bmN0aW9uXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gbWFwKHByb21pc2VzLCBmKSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5fdHJhdmVyc2UoZiwgcHJvbWlzZXMpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEZpbHRlciB0aGUgcHJvdmlkZWQgYXJyYXkgb2YgcHJvbWlzZXMgdXNpbmcgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZS4gIElucHV0IG1heVxuXHRcdCAqIGNvbnRhaW4gcHJvbWlzZXMgYW5kIHZhbHVlc1xuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIGFuZCB2YWx1ZXNcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uKHg6KiwgaW5kZXg6TnVtYmVyKTpib29sZWFufSBwcmVkaWNhdGUgZmlsdGVyaW5nIHByZWRpY2F0ZS5cblx0XHQgKiAgTXVzdCByZXR1cm4gdHJ1dGh5IChvciBwcm9taXNlIGZvciB0cnV0aHkpIGZvciBpdGVtcyB0byByZXRhaW4uXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgdGhhdCB3aWxsIGZ1bGZpbGwgd2l0aCBhbiBhcnJheSBjb250YWluaW5nIGFsbCBpdGVtc1xuXHRcdCAqICBmb3Igd2hpY2ggcHJlZGljYXRlIHJldHVybmVkIHRydXRoeS5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBmaWx0ZXIocHJvbWlzZXMsIHByZWRpY2F0ZSkge1xuXHRcdFx0dmFyIGEgPSBzbGljZS5jYWxsKHByb21pc2VzKTtcblx0XHRcdHJldHVybiBQcm9taXNlLl90cmF2ZXJzZShwcmVkaWNhdGUsIGEpLnRoZW4oZnVuY3Rpb24oa2VlcCkge1xuXHRcdFx0XHRyZXR1cm4gZmlsdGVyU3luYyhhLCBrZWVwKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpbHRlclN5bmMocHJvbWlzZXMsIGtlZXApIHtcblx0XHRcdC8vIFNhZmUgYmVjYXVzZSB3ZSBrbm93IGFsbCBwcm9taXNlcyBoYXZlIGZ1bGZpbGxlZCBpZiB3ZSd2ZSBtYWRlIGl0IHRoaXMgZmFyXG5cdFx0XHR2YXIgbCA9IGtlZXAubGVuZ3RoO1xuXHRcdFx0dmFyIGZpbHRlcmVkID0gbmV3IEFycmF5KGwpO1xuXHRcdFx0Zm9yKHZhciBpPTAsIGo9MDsgaTxsOyArK2kpIHtcblx0XHRcdFx0aWYoa2VlcFtpXSkge1xuXHRcdFx0XHRcdGZpbHRlcmVkW2orK10gPSBQcm9taXNlLl9oYW5kbGVyKHByb21pc2VzW2ldKS52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZmlsdGVyZWQubGVuZ3RoID0gajtcblx0XHRcdHJldHVybiBmaWx0ZXJlZDtcblxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGFsd2F5cyBmdWxmaWxsIHdpdGggYW4gYXJyYXkgY29udGFpbmluZ1xuXHRcdCAqIHRoZSBvdXRjb21lIHN0YXRlcyBvZiBhbGwgaW5wdXQgcHJvbWlzZXMuICBUaGUgcmV0dXJuZWQgcHJvbWlzZVxuXHRcdCAqIHdpbGwgbmV2ZXIgcmVqZWN0LlxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgZm9yIGFycmF5IG9mIHNldHRsZWQgc3RhdGUgZGVzY3JpcHRvcnNcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBzZXR0bGUocHJvbWlzZXMpIHtcblx0XHRcdHJldHVybiBhbGwocHJvbWlzZXMubWFwKHNldHRsZU9uZSkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldHRsZU9uZShwKSB7XG5cdFx0XHR2YXIgaCA9IFByb21pc2UuX2hhbmRsZXIocCk7XG5cdFx0XHRpZihoLnN0YXRlKCkgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIHRvUHJvbWlzZShwKS50aGVuKHN0YXRlLmZ1bGZpbGxlZCwgc3RhdGUucmVqZWN0ZWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRoLl91bnJlcG9ydCgpO1xuXHRcdFx0cmV0dXJuIHN0YXRlLmluc3BlY3QoaCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogVHJhZGl0aW9uYWwgcmVkdWNlIGZ1bmN0aW9uLCBzaW1pbGFyIHRvIGBBcnJheS5wcm90b3R5cGUucmVkdWNlKClgLCBidXRcblx0XHQgKiBpbnB1dCBtYXkgY29udGFpbiBwcm9taXNlcyBhbmQvb3IgdmFsdWVzLCBhbmQgcmVkdWNlRnVuY1xuXHRcdCAqIG1heSByZXR1cm4gZWl0aGVyIGEgdmFsdWUgb3IgYSBwcm9taXNlLCAqYW5kKiBpbml0aWFsVmFsdWUgbWF5XG5cdFx0ICogYmUgYSBwcm9taXNlIGZvciB0aGUgc3RhcnRpbmcgdmFsdWUuXG5cdFx0ICogQHBhcmFtIHtBcnJheXxQcm9taXNlfSBwcm9taXNlcyBhcnJheSBvciBwcm9taXNlIGZvciBhbiBhcnJheSBvZiBhbnl0aGluZyxcblx0XHQgKiAgICAgIG1heSBjb250YWluIGEgbWl4IG9mIHByb21pc2VzIGFuZCB2YWx1ZXMuXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbihhY2N1bXVsYXRlZDoqLCB4OiosIGluZGV4Ok51bWJlcik6Kn0gZiByZWR1Y2UgZnVuY3Rpb25cblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gdGhhdCB3aWxsIHJlc29sdmUgdG8gdGhlIGZpbmFsIHJlZHVjZWQgdmFsdWVcblx0XHQgKi9cblx0XHRmdW5jdGlvbiByZWR1Y2UocHJvbWlzZXMsIGYgLyosIGluaXRpYWxWYWx1ZSAqLykge1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXIuY2FsbChwcm9taXNlcywgbGlmdENvbWJpbmUoZiksIGFyZ3VtZW50c1syXSlcblx0XHRcdFx0XHQ6IGFyLmNhbGwocHJvbWlzZXMsIGxpZnRDb21iaW5lKGYpKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBUcmFkaXRpb25hbCByZWR1Y2UgZnVuY3Rpb24sIHNpbWlsYXIgdG8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodCgpYCwgYnV0XG5cdFx0ICogaW5wdXQgbWF5IGNvbnRhaW4gcHJvbWlzZXMgYW5kL29yIHZhbHVlcywgYW5kIHJlZHVjZUZ1bmNcblx0XHQgKiBtYXkgcmV0dXJuIGVpdGhlciBhIHZhbHVlIG9yIGEgcHJvbWlzZSwgKmFuZCogaW5pdGlhbFZhbHVlIG1heVxuXHRcdCAqIGJlIGEgcHJvbWlzZSBmb3IgdGhlIHN0YXJ0aW5nIHZhbHVlLlxuXHRcdCAqIEBwYXJhbSB7QXJyYXl8UHJvbWlzZX0gcHJvbWlzZXMgYXJyYXkgb3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgYW55dGhpbmcsXG5cdFx0ICogICAgICBtYXkgY29udGFpbiBhIG1peCBvZiBwcm9taXNlcyBhbmQgdmFsdWVzLlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb24oYWNjdW11bGF0ZWQ6KiwgeDoqLCBpbmRleDpOdW1iZXIpOip9IGYgcmVkdWNlIGZ1bmN0aW9uXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IHRoYXQgd2lsbCByZXNvbHZlIHRvIHRoZSBmaW5hbCByZWR1Y2VkIHZhbHVlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcmVkdWNlUmlnaHQocHJvbWlzZXMsIGYgLyosIGluaXRpYWxWYWx1ZSAqLykge1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJyLmNhbGwocHJvbWlzZXMsIGxpZnRDb21iaW5lKGYpLCBhcmd1bWVudHNbMl0pXG5cdFx0XHRcdFx0OiBhcnIuY2FsbChwcm9taXNlcywgbGlmdENvbWJpbmUoZikpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGxpZnRDb21iaW5lKGYpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbih6LCB4LCBpKSB7XG5cdFx0XHRcdHJldHVybiBhcHBseUZvbGQoZiwgdm9pZCAwLCBbeix4LGldKTtcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH0pKTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbigpIHtcblxuXHRyZXR1cm4gZnVuY3Rpb24gZmxvdyhQcm9taXNlKSB7XG5cblx0XHR2YXIgcmVzb2x2ZSA9IFByb21pc2UucmVzb2x2ZTtcblx0XHR2YXIgcmVqZWN0ID0gUHJvbWlzZS5yZWplY3Q7XG5cdFx0dmFyIG9yaWdDYXRjaCA9IFByb21pc2UucHJvdG90eXBlWydjYXRjaCddO1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlIHRoZSB1bHRpbWF0ZSBmdWxmaWxsbWVudCB2YWx1ZSBvciByZWplY3Rpb24gcmVhc29uLCBhbmQgYXNzdW1lXG5cdFx0ICogcmVzcG9uc2liaWxpdHkgZm9yIGFsbCBlcnJvcnMuICBJZiBhbiBlcnJvciBwcm9wYWdhdGVzIG91dCBvZiByZXN1bHRcblx0XHQgKiBvciBoYW5kbGVGYXRhbEVycm9yLCBpdCB3aWxsIGJlIHJldGhyb3duIHRvIHRoZSBob3N0LCByZXN1bHRpbmcgaW4gYVxuXHRcdCAqIGxvdWQgc3RhY2sgdHJhY2sgb24gbW9zdCBwbGF0Zm9ybXMgYW5kIGEgY3Jhc2ggb24gc29tZS5cblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uP30gb25SZXN1bHRcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uP30gb25FcnJvclxuXHRcdCAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uKG9uUmVzdWx0LCBvbkVycm9yKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVyLnZpc2l0KHRoaXMuX2hhbmRsZXIucmVjZWl2ZXIsIG9uUmVzdWx0LCBvbkVycm9yKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQWRkIEVycm9yLXR5cGUgYW5kIHByZWRpY2F0ZSBtYXRjaGluZyB0byBjYXRjaC4gIEV4YW1wbGVzOlxuXHRcdCAqIHByb21pc2UuY2F0Y2goVHlwZUVycm9yLCBoYW5kbGVUeXBlRXJyb3IpXG5cdFx0ICogICAuY2F0Y2gocHJlZGljYXRlLCBoYW5kbGVNYXRjaGVkRXJyb3JzKVxuXHRcdCAqICAgLmNhdGNoKGhhbmRsZVJlbWFpbmluZ0Vycm9ycylcblx0XHQgKiBAcGFyYW0gb25SZWplY3RlZFxuXHRcdCAqIEByZXR1cm5zIHsqfVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gUHJvbWlzZS5wcm90b3R5cGUub3RoZXJ3aXNlID0gZnVuY3Rpb24ob25SZWplY3RlZCkge1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG5cdFx0XHRcdHJldHVybiBvcmlnQ2F0Y2guY2FsbCh0aGlzLCBvblJlamVjdGVkKTtcblx0XHRcdH1cblxuXHRcdFx0aWYodHlwZW9mIG9uUmVqZWN0ZWQgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZW5zdXJlKHJlamVjdEludmFsaWRQcmVkaWNhdGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3JpZ0NhdGNoLmNhbGwodGhpcywgY3JlYXRlQ2F0Y2hGaWx0ZXIoYXJndW1lbnRzWzFdLCBvblJlamVjdGVkKSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFdyYXBzIHRoZSBwcm92aWRlZCBjYXRjaCBoYW5kbGVyLCBzbyB0aGF0IGl0IHdpbGwgb25seSBiZSBjYWxsZWRcblx0XHQgKiBpZiB0aGUgcHJlZGljYXRlIGV2YWx1YXRlcyB0cnV0aHlcblx0XHQgKiBAcGFyYW0gez9mdW5jdGlvbn0gaGFuZGxlclxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZVxuXHRcdCAqIEByZXR1cm5zIHtmdW5jdGlvbn0gY29uZGl0aW9uYWwgY2F0Y2ggaGFuZGxlclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNhdGNoRmlsdGVyKGhhbmRsZXIsIHByZWRpY2F0ZSkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0cmV0dXJuIGV2YWx1YXRlUHJlZGljYXRlKGUsIHByZWRpY2F0ZSlcblx0XHRcdFx0XHQ/IGhhbmRsZXIuY2FsbCh0aGlzLCBlKVxuXHRcdFx0XHRcdDogcmVqZWN0KGUpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBFbnN1cmVzIHRoYXQgb25GdWxmaWxsZWRPclJlamVjdGVkIHdpbGwgYmUgY2FsbGVkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlclxuXHRcdCAqIHRoaXMgcHJvbWlzZSBpcyBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuICBvbkZ1bGZpbGxlZE9yUmVqZWN0ZWQgV0lMTCBOT1Rcblx0XHQgKiByZWNlaXZlIHRoZSBwcm9taXNlcycgdmFsdWUgb3IgcmVhc29uLiAgQW55IHJldHVybmVkIHZhbHVlIHdpbGwgYmUgZGlzcmVnYXJkZWQuXG5cdFx0ICogb25GdWxmaWxsZWRPclJlamVjdGVkIG1heSB0aHJvdyBvciByZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIHRvIHNpZ25hbFxuXHRcdCAqIGFuIGFkZGl0aW9uYWwgZXJyb3IuXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBoYW5kbGVyIHRvIGJlIGNhbGxlZCByZWdhcmRsZXNzIG9mXG5cdFx0ICogIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvblxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlWydmaW5hbGx5J10gPSBQcm9taXNlLnByb3RvdHlwZS5lbnN1cmUgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG5cdFx0XHRpZih0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbih4KSB7XG5cdFx0XHRcdHJldHVybiBydW5TaWRlRWZmZWN0KGhhbmRsZXIsIHRoaXMsIGlkZW50aXR5LCB4KTtcblx0XHRcdH0sIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0cmV0dXJuIHJ1blNpZGVFZmZlY3QoaGFuZGxlciwgdGhpcywgcmVqZWN0LCBlKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBydW5TaWRlRWZmZWN0IChoYW5kbGVyLCB0aGlzQXJnLCBwcm9wYWdhdGUsIHZhbHVlKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gaGFuZGxlci5jYWxsKHRoaXNBcmcpO1xuXHRcdFx0cmV0dXJuIG1heWJlVGhlbmFibGUocmVzdWx0KVxuXHRcdFx0XHQ/IHByb3BhZ2F0ZVZhbHVlKHJlc3VsdCwgcHJvcGFnYXRlLCB2YWx1ZSlcblx0XHRcdFx0OiBwcm9wYWdhdGUodmFsdWUpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHByb3BhZ2F0ZVZhbHVlIChyZXN1bHQsIHByb3BhZ2F0ZSwgeCkge1xuXHRcdFx0cmV0dXJuIHJlc29sdmUocmVzdWx0KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHByb3BhZ2F0ZSh4KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJlY292ZXIgZnJvbSBhIGZhaWx1cmUgYnkgcmV0dXJuaW5nIGEgZGVmYXVsdFZhbHVlLiAgSWYgZGVmYXVsdFZhbHVlXG5cdFx0ICogaXMgYSBwcm9taXNlLCBpdCdzIGZ1bGZpbGxtZW50IHZhbHVlIHdpbGwgYmUgdXNlZC4gIElmIGRlZmF1bHRWYWx1ZSBpc1xuXHRcdCAqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMsIHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgcmVqZWN0IHdpdGggdGhlXG5cdFx0ICogc2FtZSByZWFzb24uXG5cdFx0ICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWVcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gbmV3IHByb21pc2Vcblx0XHQgKi9cblx0XHRQcm9taXNlLnByb3RvdHlwZVsnZWxzZSddID0gUHJvbWlzZS5wcm90b3R5cGUub3JFbHNlID0gZnVuY3Rpb24oZGVmYXVsdFZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBkZWZhdWx0VmFsdWU7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogU2hvcnRjdXQgZm9yIC50aGVuKGZ1bmN0aW9uKCkgeyByZXR1cm4gdmFsdWU7IH0pXG5cdFx0ICogQHBhcmFtICB7Kn0gdmFsdWVcblx0XHQgKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdDpcblx0XHQgKiAgLSBpcyBmdWxmaWxsZWQgaWYgdmFsdWUgaXMgbm90IGEgcHJvbWlzZSwgb3Jcblx0XHQgKiAgLSBpZiB2YWx1ZSBpcyBhIHByb21pc2UsIHdpbGwgZnVsZmlsbCB3aXRoIGl0cyB2YWx1ZSwgb3IgcmVqZWN0XG5cdFx0ICogICAgd2l0aCBpdHMgcmVhc29uLlxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlWyd5aWVsZCddID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSdW5zIGEgc2lkZSBlZmZlY3Qgd2hlbiB0aGlzIHByb21pc2UgZnVsZmlsbHMsIHdpdGhvdXQgY2hhbmdpbmcgdGhlXG5cdFx0ICogZnVsZmlsbG1lbnQgdmFsdWUuXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gb25GdWxmaWxsZWRTaWRlRWZmZWN0XG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGUudGFwID0gZnVuY3Rpb24ob25GdWxmaWxsZWRTaWRlRWZmZWN0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50aGVuKG9uRnVsZmlsbGVkU2lkZUVmZmVjdClbJ3lpZWxkJ10odGhpcyk7XG5cdFx0fTtcblxuXHRcdHJldHVybiBQcm9taXNlO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIHJlamVjdEludmFsaWRQcmVkaWNhdGUoKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignY2F0Y2ggcHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXZhbHVhdGVQcmVkaWNhdGUoZSwgcHJlZGljYXRlKSB7XG5cdFx0cmV0dXJuIGlzRXJyb3IocHJlZGljYXRlKSA/IGUgaW5zdGFuY2VvZiBwcmVkaWNhdGUgOiBwcmVkaWNhdGUoZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBpc0Vycm9yKHByZWRpY2F0ZSkge1xuXHRcdHJldHVybiBwcmVkaWNhdGUgPT09IEVycm9yXG5cdFx0XHR8fCAocHJlZGljYXRlICE9IG51bGwgJiYgcHJlZGljYXRlLnByb3RvdHlwZSBpbnN0YW5jZW9mIEVycm9yKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1heWJlVGhlbmFibGUoeCkge1xuXHRcdHJldHVybiAodHlwZW9mIHggPT09ICdvYmplY3QnIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nKSAmJiB4ICE9PSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuXHRcdHJldHVybiB4O1xuXHR9XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cbi8qKiBAYXV0aG9yIEplZmYgRXNjYWxhbnRlICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKCkge1xuXG5cdHJldHVybiBmdW5jdGlvbiBmb2xkKFByb21pc2UpIHtcblxuXHRcdFByb21pc2UucHJvdG90eXBlLmZvbGQgPSBmdW5jdGlvbihmLCB6KSB7XG5cdFx0XHR2YXIgcHJvbWlzZSA9IHRoaXMuX2JlZ2V0KCk7XG5cblx0XHRcdHRoaXMuX2hhbmRsZXIuZm9sZChmdW5jdGlvbih6LCB4LCB0bykge1xuXHRcdFx0XHRQcm9taXNlLl9oYW5kbGVyKHopLmZvbGQoZnVuY3Rpb24oeCwgeiwgdG8pIHtcblx0XHRcdFx0XHR0by5yZXNvbHZlKGYuY2FsbCh0aGlzLCB6LCB4KSk7XG5cdFx0XHRcdH0sIHgsIHRoaXMsIHRvKTtcblx0XHRcdH0sIHosIHByb21pc2UuX2hhbmRsZXIucmVjZWl2ZXIsIHByb21pc2UuX2hhbmRsZXIpO1xuXG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIFByb21pc2U7XG5cdH07XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuXG5cdHZhciBpbnNwZWN0ID0gcmVxdWlyZSgnLi4vc3RhdGUnKS5pbnNwZWN0O1xuXG5cdHJldHVybiBmdW5jdGlvbiBpbnNwZWN0aW9uKFByb21pc2UpIHtcblxuXHRcdFByb21pc2UucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBpbnNwZWN0KFByb21pc2UuX2hhbmRsZXIodGhpcykpO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gUHJvbWlzZTtcblx0fTtcblxufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24oKSB7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIGdlbmVyYXRlKFByb21pc2UpIHtcblxuXHRcdHZhciByZXNvbHZlID0gUHJvbWlzZS5yZXNvbHZlO1xuXG5cdFx0UHJvbWlzZS5pdGVyYXRlID0gaXRlcmF0ZTtcblx0XHRQcm9taXNlLnVuZm9sZCA9IHVuZm9sZDtcblxuXHRcdHJldHVybiBQcm9taXNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQGRlcHJlY2F0ZWQgVXNlIGdpdGh1Yi5jb20vY3Vqb2pzL21vc3Qgc3RyZWFtcyBhbmQgbW9zdC5pdGVyYXRlXG5cdFx0ICogR2VuZXJhdGUgYSAocG90ZW50aWFsbHkgaW5maW5pdGUpIHN0cmVhbSBvZiBwcm9taXNlZCB2YWx1ZXM6XG5cdFx0ICogeCwgZih4KSwgZihmKHgpKSwgZXRjLiB1bnRpbCBjb25kaXRpb24oeCkgcmV0dXJucyB0cnVlXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZiBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIG5ldyB4IGZyb20gdGhlIHByZXZpb3VzIHhcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25kaXRpb24gZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gdGhlIGN1cnJlbnQgeCwgcmV0dXJuc1xuXHRcdCAqICB0cnV0aHkgd2hlbiB0aGUgaXRlcmF0ZSBzaG91bGQgc3RvcFxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSB2YWx1ZSBwcm9kdWNlZCBieSBmXG5cdFx0ICogQHBhcmFtIHsqfFByb21pc2V9IHggc3RhcnRpbmcgdmFsdWUsIG1heSBiZSBhIHByb21pc2Vcblx0XHQgKiBAcmV0dXJuIHtQcm9taXNlfSB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGNhbGwgdG8gZiBiZWZvcmVcblx0XHQgKiAgY29uZGl0aW9uIHJldHVybnMgdHJ1ZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGl0ZXJhdGUoZiwgY29uZGl0aW9uLCBoYW5kbGVyLCB4KSB7XG5cdFx0XHRyZXR1cm4gdW5mb2xkKGZ1bmN0aW9uKHgpIHtcblx0XHRcdFx0cmV0dXJuIFt4LCBmKHgpXTtcblx0XHRcdH0sIGNvbmRpdGlvbiwgaGFuZGxlciwgeCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQGRlcHJlY2F0ZWQgVXNlIGdpdGh1Yi5jb20vY3Vqb2pzL21vc3Qgc3RyZWFtcyBhbmQgbW9zdC51bmZvbGRcblx0XHQgKiBHZW5lcmF0ZSBhIChwb3RlbnRpYWxseSBpbmZpbml0ZSkgc3RyZWFtIG9mIHByb21pc2VkIHZhbHVlc1xuXHRcdCAqIGJ5IGFwcGx5aW5nIGhhbmRsZXIoZ2VuZXJhdG9yKHNlZWQpKSBpdGVyYXRpdmVseSB1bnRpbFxuXHRcdCAqIGNvbmRpdGlvbihzZWVkKSByZXR1cm5zIHRydWUuXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gdW5zcG9vbCBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBhIFt2YWx1ZSwgbmV3U2VlZF1cblx0XHQgKiAgZ2l2ZW4gYSBzZWVkLlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbmRpdGlvbiBmdW5jdGlvbiB0aGF0LCBnaXZlbiB0aGUgY3VycmVudCBzZWVkLCByZXR1cm5zXG5cdFx0ICogIHRydXRoeSB3aGVuIHRoZSB1bmZvbGQgc2hvdWxkIHN0b3Bcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgdmFsdWUgcHJvZHVjZWQgYnkgdW5zcG9vbFxuXHRcdCAqIEBwYXJhbSB4IHsqfFByb21pc2V9IHN0YXJ0aW5nIHZhbHVlLCBtYXkgYmUgYSBwcm9taXNlXG5cdFx0ICogQHJldHVybiB7UHJvbWlzZX0gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCB2YWx1ZSBwcm9kdWNlZCBieSB1bnNwb29sIGJlZm9yZVxuXHRcdCAqICBjb25kaXRpb24gcmV0dXJucyB0cnVlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gdW5mb2xkKHVuc3Bvb2wsIGNvbmRpdGlvbiwgaGFuZGxlciwgeCkge1xuXHRcdFx0cmV0dXJuIHJlc29sdmUoeCkudGhlbihmdW5jdGlvbihzZWVkKSB7XG5cdFx0XHRcdHJldHVybiByZXNvbHZlKGNvbmRpdGlvbihzZWVkKSkudGhlbihmdW5jdGlvbihkb25lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRvbmUgPyBzZWVkIDogcmVzb2x2ZSh1bnNwb29sKHNlZWQpKS5zcHJlYWQobmV4dCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdGZ1bmN0aW9uIG5leHQoaXRlbSwgbmV3U2VlZCkge1xuXHRcdFx0XHRyZXR1cm4gcmVzb2x2ZShoYW5kbGVyKGl0ZW0pKS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB1bmZvbGQodW5zcG9vbCwgY29uZGl0aW9uLCBoYW5kbGVyLCBuZXdTZWVkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKCkge1xuXG5cdHJldHVybiBmdW5jdGlvbiBwcm9ncmVzcyhQcm9taXNlKSB7XG5cblx0XHQvKipcblx0XHQgKiBAZGVwcmVjYXRlZFxuXHRcdCAqIFJlZ2lzdGVyIGEgcHJvZ3Jlc3MgaGFuZGxlciBmb3IgdGhpcyBwcm9taXNlXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gb25Qcm9ncmVzc1xuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24ob25Qcm9ncmVzcykge1xuXHRcdFx0cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHZvaWQgMCwgb25Qcm9ncmVzcyk7XG5cdFx0fTtcblxuXHRcdHJldHVybiBQcm9taXNlO1xuXHR9O1xuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcblxuXHR2YXIgZW52ID0gcmVxdWlyZSgnLi4vZW52Jyk7XG5cdHZhciBUaW1lb3V0RXJyb3IgPSByZXF1aXJlKCcuLi9UaW1lb3V0RXJyb3InKTtcblxuXHRmdW5jdGlvbiBzZXRUaW1lb3V0KGYsIG1zLCB4LCB5KSB7XG5cdFx0cmV0dXJuIGVudi5zZXRUaW1lcihmdW5jdGlvbigpIHtcblx0XHRcdGYoeCwgeSwgbXMpO1xuXHRcdH0sIG1zKTtcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbiB0aW1lZChQcm9taXNlKSB7XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGEgbmV3IHByb21pc2Ugd2hvc2UgZnVsZmlsbG1lbnQgdmFsdWUgaXMgcmV2ZWFsZWQgb25seVxuXHRcdCAqIGFmdGVyIG1zIG1pbGxpc2Vjb25kc1xuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBtcyBtaWxsaXNlY29uZHNcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX1cblx0XHQgKi9cblx0XHRQcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uKG1zKSB7XG5cdFx0XHR2YXIgcCA9IHRoaXMuX2JlZ2V0KCk7XG5cdFx0XHR0aGlzLl9oYW5kbGVyLmZvbGQoaGFuZGxlRGVsYXksIG1zLCB2b2lkIDAsIHAuX2hhbmRsZXIpO1xuXHRcdFx0cmV0dXJuIHA7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZURlbGF5KG1zLCB4LCBoKSB7XG5cdFx0XHRzZXRUaW1lb3V0KHJlc29sdmVEZWxheSwgbXMsIHgsIGgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc29sdmVEZWxheSh4LCBoKSB7XG5cdFx0XHRoLnJlc29sdmUoeCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGEgbmV3IHByb21pc2UgdGhhdCByZWplY3RzIGFmdGVyIG1zIG1pbGxpc2Vjb25kcyB1bmxlc3Ncblx0XHQgKiB0aGlzIHByb21pc2UgZnVsZmlsbHMgZWFybGllciwgaW4gd2hpY2ggY2FzZSB0aGUgcmV0dXJuZWQgcHJvbWlzZVxuXHRcdCAqIGZ1bGZpbGxzIHdpdGggdGhlIHNhbWUgdmFsdWUuXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IG1zIG1pbGxpc2Vjb25kc1xuXHRcdCAqIEBwYXJhbSB7RXJyb3J8Kj19IHJlYXNvbiBvcHRpb25hbCByZWplY3Rpb24gcmVhc29uIHRvIHVzZSwgZGVmYXVsdHNcblx0XHQgKiAgIHRvIGEgVGltZW91dEVycm9yIGlmIG5vdCBwcm92aWRlZFxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbihtcywgcmVhc29uKSB7XG5cdFx0XHR2YXIgcCA9IHRoaXMuX2JlZ2V0KCk7XG5cdFx0XHR2YXIgaCA9IHAuX2hhbmRsZXI7XG5cblx0XHRcdHZhciB0ID0gc2V0VGltZW91dChvblRpbWVvdXQsIG1zLCByZWFzb24sIHAuX2hhbmRsZXIpO1xuXG5cdFx0XHR0aGlzLl9oYW5kbGVyLnZpc2l0KGgsXG5cdFx0XHRcdGZ1bmN0aW9uIG9uRnVsZmlsbCh4KSB7XG5cdFx0XHRcdFx0ZW52LmNsZWFyVGltZXIodCk7XG5cdFx0XHRcdFx0dGhpcy5yZXNvbHZlKHgpOyAvLyB0aGlzID0gaFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiBvblJlamVjdCh4KSB7XG5cdFx0XHRcdFx0ZW52LmNsZWFyVGltZXIodCk7XG5cdFx0XHRcdFx0dGhpcy5yZWplY3QoeCk7IC8vIHRoaXMgPSBoXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGgubm90aWZ5KTtcblxuXHRcdFx0cmV0dXJuIHA7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIG9uVGltZW91dChyZWFzb24sIGgsIG1zKSB7XG5cdFx0XHR2YXIgZSA9IHR5cGVvZiByZWFzb24gPT09ICd1bmRlZmluZWQnXG5cdFx0XHRcdD8gbmV3IFRpbWVvdXRFcnJvcigndGltZWQgb3V0IGFmdGVyICcgKyBtcyArICdtcycpXG5cdFx0XHRcdDogcmVhc29uO1xuXHRcdFx0aC5yZWplY3QoZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2U7XG5cdH07XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcblxuXHR2YXIgc2V0VGltZXIgPSByZXF1aXJlKCcuLi9lbnYnKS5zZXRUaW1lcjtcblx0dmFyIGZvcm1hdCA9IHJlcXVpcmUoJy4uL2Zvcm1hdCcpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1bmhhbmRsZWRSZWplY3Rpb24oUHJvbWlzZSkge1xuXG5cdFx0dmFyIGxvZ0Vycm9yID0gbm9vcDtcblx0XHR2YXIgbG9nSW5mbyA9IG5vb3A7XG5cdFx0dmFyIGxvY2FsQ29uc29sZTtcblxuXHRcdGlmKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0Ly8gQWxpYXMgY29uc29sZSB0byBwcmV2ZW50IHRoaW5ncyBsaWtlIHVnbGlmeSdzIGRyb3BfY29uc29sZSBvcHRpb24gZnJvbVxuXHRcdFx0Ly8gcmVtb3ZpbmcgY29uc29sZS5sb2cvZXJyb3IuIFVuaGFuZGxlZCByZWplY3Rpb25zIGZhbGwgaW50byB0aGUgc2FtZVxuXHRcdFx0Ly8gY2F0ZWdvcnkgYXMgdW5jYXVnaHQgZXhjZXB0aW9ucywgYW5kIGJ1aWxkIHRvb2xzIHNob3VsZG4ndCBzaWxlbmNlIHRoZW0uXG5cdFx0XHRsb2NhbENvbnNvbGUgPSBjb25zb2xlO1xuXHRcdFx0bG9nRXJyb3IgPSB0eXBlb2YgbG9jYWxDb25zb2xlLmVycm9yICE9PSAndW5kZWZpbmVkJ1xuXHRcdFx0XHQ/IGZ1bmN0aW9uIChlKSB7IGxvY2FsQ29uc29sZS5lcnJvcihlKTsgfVxuXHRcdFx0XHQ6IGZ1bmN0aW9uIChlKSB7IGxvY2FsQ29uc29sZS5sb2coZSk7IH07XG5cblx0XHRcdGxvZ0luZm8gPSB0eXBlb2YgbG9jYWxDb25zb2xlLmluZm8gIT09ICd1bmRlZmluZWQnXG5cdFx0XHRcdD8gZnVuY3Rpb24gKGUpIHsgbG9jYWxDb25zb2xlLmluZm8oZSk7IH1cblx0XHRcdFx0OiBmdW5jdGlvbiAoZSkgeyBsb2NhbENvbnNvbGUubG9nKGUpOyB9O1xuXHRcdH1cblxuXHRcdFByb21pc2Uub25Qb3RlbnRpYWxseVVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uKHJlamVjdGlvbikge1xuXHRcdFx0ZW5xdWV1ZShyZXBvcnQsIHJlamVjdGlvbik7XG5cdFx0fTtcblxuXHRcdFByb21pc2Uub25Qb3RlbnRpYWxseVVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQgPSBmdW5jdGlvbihyZWplY3Rpb24pIHtcblx0XHRcdGVucXVldWUodW5yZXBvcnQsIHJlamVjdGlvbik7XG5cdFx0fTtcblxuXHRcdFByb21pc2Uub25GYXRhbFJlamVjdGlvbiA9IGZ1bmN0aW9uKHJlamVjdGlvbikge1xuXHRcdFx0ZW5xdWV1ZSh0aHJvd2l0LCByZWplY3Rpb24udmFsdWUpO1xuXHRcdH07XG5cblx0XHR2YXIgdGFza3MgPSBbXTtcblx0XHR2YXIgcmVwb3J0ZWQgPSBbXTtcblx0XHR2YXIgcnVubmluZyA9IG51bGw7XG5cblx0XHRmdW5jdGlvbiByZXBvcnQocikge1xuXHRcdFx0aWYoIXIuaGFuZGxlZCkge1xuXHRcdFx0XHRyZXBvcnRlZC5wdXNoKHIpO1xuXHRcdFx0XHRsb2dFcnJvcignUG90ZW50aWFsbHkgdW5oYW5kbGVkIHJlamVjdGlvbiBbJyArIHIuaWQgKyAnXSAnICsgZm9ybWF0LmZvcm1hdEVycm9yKHIudmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bnJlcG9ydChyKSB7XG5cdFx0XHR2YXIgaSA9IHJlcG9ydGVkLmluZGV4T2Yocik7XG5cdFx0XHRpZihpID49IDApIHtcblx0XHRcdFx0cmVwb3J0ZWQuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRsb2dJbmZvKCdIYW5kbGVkIHByZXZpb3VzIHJlamVjdGlvbiBbJyArIHIuaWQgKyAnXSAnICsgZm9ybWF0LmZvcm1hdE9iamVjdChyLnZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZW5xdWV1ZShmLCB4KSB7XG5cdFx0XHR0YXNrcy5wdXNoKGYsIHgpO1xuXHRcdFx0aWYocnVubmluZyA9PT0gbnVsbCkge1xuXHRcdFx0XHRydW5uaW5nID0gc2V0VGltZXIoZmx1c2gsIDApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZsdXNoKCkge1xuXHRcdFx0cnVubmluZyA9IG51bGw7XG5cdFx0XHR3aGlsZSh0YXNrcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHRhc2tzLnNoaWZ0KCkodGFza3Muc2hpZnQoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2U7XG5cdH07XG5cblx0ZnVuY3Rpb24gdGhyb3dpdChlKSB7XG5cdFx0dGhyb3cgZTtcblx0fVxuXG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH0pKTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbigpIHtcblxuXHRyZXR1cm4gZnVuY3Rpb24gYWRkV2l0aChQcm9taXNlKSB7XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhIHByb21pc2Ugd2hvc2UgaGFuZGxlcnMgd2lsbCBiZSBjYWxsZWQgd2l0aCBgdGhpc2Agc2V0IHRvXG5cdFx0ICogdGhlIHN1cHBsaWVkIHJlY2VpdmVyLiAgU3Vic2VxdWVudCBwcm9taXNlcyBkZXJpdmVkIGZyb20gdGhlXG5cdFx0ICogcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGFsc28gaGF2ZSB0aGVpciBoYW5kbGVycyBjYWxsZWQgd2l0aCByZWNlaXZlclxuXHRcdCAqIGFzIGB0aGlzYC4gQ2FsbGluZyBgd2l0aGAgd2l0aCB1bmRlZmluZWQgb3Igbm8gYXJndW1lbnRzIHdpbGwgcmV0dXJuXG5cdFx0ICogYSBwcm9taXNlIHdob3NlIGhhbmRsZXJzIHdpbGwgYWdhaW4gYmUgY2FsbGVkIGluIHRoZSB1c3VhbCBQcm9taXNlcy9BK1xuXHRcdCAqIHdheSAobm8gYHRoaXNgKSB0aHVzIHNhZmVseSB1bmRvaW5nIGFueSBwcmV2aW91cyBgd2l0aGAgaW4gdGhlXG5cdFx0ICogcHJvbWlzZSBjaGFpbi5cblx0XHQgKlxuXHRcdCAqIFdBUk5JTkc6IFByb21pc2VzIHJldHVybmVkIGZyb20gYHdpdGhgL2B3aXRoVGhpc2AgYXJlIE5PVCBQcm9taXNlcy9BK1xuXHRcdCAqIGNvbXBsaWFudCwgc3BlY2lmaWNhbGx5IHZpb2xhdGluZyAyLjIuNSAoaHR0cDovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00MSlcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSByZWNlaXZlciBgdGhpc2AgdmFsdWUgZm9yIGFsbCBoYW5kbGVycyBhdHRhY2hlZCB0b1xuXHRcdCAqICB0aGUgcmV0dXJuZWQgcHJvbWlzZS5cblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX1cblx0XHQgKi9cblx0XHRQcm9taXNlLnByb3RvdHlwZVsnd2l0aCddID0gUHJvbWlzZS5wcm90b3R5cGUud2l0aFRoaXMgPSBmdW5jdGlvbihyZWNlaXZlcikge1xuXHRcdFx0dmFyIHAgPSB0aGlzLl9iZWdldCgpO1xuXHRcdFx0dmFyIGNoaWxkID0gcC5faGFuZGxlcjtcblx0XHRcdGNoaWxkLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG5cdFx0XHR0aGlzLl9oYW5kbGVyLmNoYWluKGNoaWxkLCByZWNlaXZlcik7XG5cdFx0XHRyZXR1cm4gcDtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIFByb21pc2U7XG5cdH07XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyB9KSk7XG5cbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4vKmdsb2JhbCBwcm9jZXNzLGRvY3VtZW50LHNldFRpbWVvdXQsY2xlYXJUaW1lb3V0LE11dGF0aW9uT2JzZXJ2ZXIsV2ViS2l0TXV0YXRpb25PYnNlcnZlciovXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG5cdC8qanNoaW50IG1heGNvbXBsZXhpdHk6NiovXG5cblx0Ly8gU25pZmYgXCJiZXN0XCIgYXN5bmMgc2NoZWR1bGluZyBvcHRpb25cblx0Ly8gUHJlZmVyIHByb2Nlc3MubmV4dFRpY2sgb3IgTXV0YXRpb25PYnNlcnZlciwgdGhlbiBjaGVjayBmb3Jcblx0Ly8gc2V0VGltZW91dCwgYW5kIGZpbmFsbHkgdmVydHgsIHNpbmNlIGl0cyB0aGUgb25seSBlbnYgdGhhdCBkb2Vzbid0XG5cdC8vIGhhdmUgc2V0VGltZW91dFxuXG5cdHZhciBNdXRhdGlvbk9icztcblx0dmFyIGNhcHR1cmVkU2V0VGltZW91dCA9IHR5cGVvZiBzZXRUaW1lb3V0ICE9PSAndW5kZWZpbmVkJyAmJiBzZXRUaW1lb3V0O1xuXG5cdC8vIERlZmF1bHQgZW52XG5cdHZhciBzZXRUaW1lciA9IGZ1bmN0aW9uKGYsIG1zKSB7IHJldHVybiBzZXRUaW1lb3V0KGYsIG1zKTsgfTtcblx0dmFyIGNsZWFyVGltZXIgPSBmdW5jdGlvbih0KSB7IHJldHVybiBjbGVhclRpbWVvdXQodCk7IH07XG5cdHZhciBhc2FwID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGNhcHR1cmVkU2V0VGltZW91dChmLCAwKTsgfTtcblxuXHQvLyBEZXRlY3Qgc3BlY2lmaWMgZW52XG5cdGlmIChpc05vZGUoKSkgeyAvLyBOb2RlXG5cdFx0YXNhcCA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGYpOyB9O1xuXG5cdH0gZWxzZSBpZiAoTXV0YXRpb25PYnMgPSBoYXNNdXRhdGlvbk9ic2VydmVyKCkpIHsgLy8gTW9kZXJuIGJyb3dzZXJcblx0XHRhc2FwID0gaW5pdE11dGF0aW9uT2JzZXJ2ZXIoTXV0YXRpb25PYnMpO1xuXG5cdH0gZWxzZSBpZiAoIWNhcHR1cmVkU2V0VGltZW91dCkgeyAvLyB2ZXJ0Lnhcblx0XHR2YXIgdmVydHhSZXF1aXJlID0gcmVxdWlyZTtcblx0XHR2YXIgdmVydHggPSB2ZXJ0eFJlcXVpcmUoJ3ZlcnR4Jyk7XG5cdFx0c2V0VGltZXIgPSBmdW5jdGlvbiAoZiwgbXMpIHsgcmV0dXJuIHZlcnR4LnNldFRpbWVyKG1zLCBmKTsgfTtcblx0XHRjbGVhclRpbWVyID0gdmVydHguY2FuY2VsVGltZXI7XG5cdFx0YXNhcCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHNldFRpbWVyOiBzZXRUaW1lcixcblx0XHRjbGVhclRpbWVyOiBjbGVhclRpbWVyLFxuXHRcdGFzYXA6IGFzYXBcblx0fTtcblxuXHRmdW5jdGlvbiBpc05vZGUgKCkge1xuXHRcdHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHRcdE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXHR9XG5cblx0ZnVuY3Rpb24gaGFzTXV0YXRpb25PYnNlcnZlciAoKSB7XG5cdFx0cmV0dXJuICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBNdXRhdGlvbk9ic2VydmVyKSB8fFxuXHRcdFx0KHR5cGVvZiBXZWJLaXRNdXRhdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nICYmIFdlYktpdE11dGF0aW9uT2JzZXJ2ZXIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdE11dGF0aW9uT2JzZXJ2ZXIoTXV0YXRpb25PYnNlcnZlcikge1xuXHRcdHZhciBzY2hlZHVsZWQ7XG5cdFx0dmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG5cdFx0dmFyIG8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcihydW4pO1xuXHRcdG8ub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cblx0XHRmdW5jdGlvbiBydW4oKSB7XG5cdFx0XHR2YXIgZiA9IHNjaGVkdWxlZDtcblx0XHRcdHNjaGVkdWxlZCA9IHZvaWQgMDtcblx0XHRcdGYoKTtcblx0XHR9XG5cblx0XHR2YXIgaSA9IDA7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChmKSB7XG5cdFx0XHRzY2hlZHVsZWQgPSBmO1xuXHRcdFx0bm9kZS5kYXRhID0gKGkgXj0gMSk7XG5cdFx0fTtcblx0fVxufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24oKSB7XG5cblx0cmV0dXJuIHtcblx0XHRmb3JtYXRFcnJvcjogZm9ybWF0RXJyb3IsXG5cdFx0Zm9ybWF0T2JqZWN0OiBmb3JtYXRPYmplY3QsXG5cdFx0dHJ5U3RyaW5naWZ5OiB0cnlTdHJpbmdpZnlcblx0fTtcblxuXHQvKipcblx0ICogRm9ybWF0IGFuIGVycm9yIGludG8gYSBzdHJpbmcuICBJZiBlIGlzIGFuIEVycm9yIGFuZCBoYXMgYSBzdGFjayBwcm9wZXJ0eSxcblx0ICogaXQncyByZXR1cm5lZC4gIE90aGVyd2lzZSwgZSBpcyBmb3JtYXR0ZWQgdXNpbmcgZm9ybWF0T2JqZWN0LCB3aXRoIGFcblx0ICogd2FybmluZyBhZGRlZCBhYm91dCBlIG5vdCBiZWluZyBhIHByb3BlciBFcnJvci5cblx0ICogQHBhcmFtIHsqfSBlXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IGZvcm1hdHRlZCBzdHJpbmcsIHN1aXRhYmxlIGZvciBvdXRwdXQgdG8gZGV2ZWxvcGVyc1xuXHQgKi9cblx0ZnVuY3Rpb24gZm9ybWF0RXJyb3IoZSkge1xuXHRcdHZhciBzID0gdHlwZW9mIGUgPT09ICdvYmplY3QnICYmIGUgIT09IG51bGwgJiYgKGUuc3RhY2sgfHwgZS5tZXNzYWdlKSA/IGUuc3RhY2sgfHwgZS5tZXNzYWdlIDogZm9ybWF0T2JqZWN0KGUpO1xuXHRcdHJldHVybiBlIGluc3RhbmNlb2YgRXJyb3IgPyBzIDogcyArICcgKFdBUk5JTkc6IG5vbi1FcnJvciB1c2VkKSc7XG5cdH1cblxuXHQvKipcblx0ICogRm9ybWF0IGFuIG9iamVjdCwgZGV0ZWN0aW5nIFwicGxhaW5cIiBvYmplY3RzIGFuZCBydW5uaW5nIHRoZW0gdGhyb3VnaFxuXHQgKiBKU09OLnN0cmluZ2lmeSBpZiBwb3NzaWJsZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIGZvcm1hdE9iamVjdChvKSB7XG5cdFx0dmFyIHMgPSBTdHJpbmcobyk7XG5cdFx0aWYocyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgdHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRzID0gdHJ5U3RyaW5naWZ5KG8sIHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gcztcblx0fVxuXG5cdC8qKlxuXHQgKiBUcnkgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2YgSlNPTi5zdHJpbmdpZnkoeCkuICBJZiB0aGF0IGZhaWxzLCByZXR1cm5cblx0ICogZGVmYXVsdFZhbHVlXG5cdCAqIEBwYXJhbSB7Kn0geFxuXHQgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZVxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfCp9IEpTT04uc3RyaW5naWZ5KHgpIG9yIGRlZmF1bHRWYWx1ZVxuXHQgKi9cblx0ZnVuY3Rpb24gdHJ5U3RyaW5naWZ5KHgsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoeCk7XG5cdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRyZXR1cm4gZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fVxuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKCkge1xuXG5cdHJldHVybiBmdW5jdGlvbiBtYWtlUHJvbWlzZShlbnZpcm9ubWVudCkge1xuXG5cdFx0dmFyIHRhc2tzID0gZW52aXJvbm1lbnQuc2NoZWR1bGVyO1xuXHRcdHZhciBlbWl0UmVqZWN0aW9uID0gaW5pdEVtaXRSZWplY3Rpb24oKTtcblxuXHRcdHZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8XG5cdFx0XHRmdW5jdGlvbihwcm90bykge1xuXHRcdFx0XHRmdW5jdGlvbiBDaGlsZCgpIHt9XG5cdFx0XHRcdENoaWxkLnByb3RvdHlwZSA9IHByb3RvO1xuXHRcdFx0XHRyZXR1cm4gbmV3IENoaWxkKCk7XG5cdFx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgcHJvbWlzZSB3aG9zZSBmYXRlIGlzIGRldGVybWluZWQgYnkgcmVzb2x2ZXJcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZVxuXHRcdCAqIEBuYW1lIFByb21pc2Vcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyLCBoYW5kbGVyKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVyID0gcmVzb2x2ZXIgPT09IEhhbmRsZXIgPyBoYW5kbGVyIDogaW5pdChyZXNvbHZlcik7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUnVuIHRoZSBzdXBwbGllZCByZXNvbHZlclxuXHRcdCAqIEBwYXJhbSByZXNvbHZlclxuXHRcdCAqIEByZXR1cm5zIHtQZW5kaW5nfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGluaXQocmVzb2x2ZXIpIHtcblx0XHRcdHZhciBoYW5kbGVyID0gbmV3IFBlbmRpbmcoKTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzb2x2ZXIocHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3QsIHByb21pc2VOb3RpZnkpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRwcm9taXNlUmVqZWN0KGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaGFuZGxlcjtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUcmFuc2l0aW9uIGZyb20gcHJlLXJlc29sdXRpb24gc3RhdGUgdG8gcG9zdC1yZXNvbHV0aW9uIHN0YXRlLCBub3RpZnlpbmdcblx0XHRcdCAqIGFsbCBsaXN0ZW5lcnMgb2YgdGhlIHVsdGltYXRlIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvblxuXHRcdFx0ICogQHBhcmFtIHsqfSB4IHJlc29sdXRpb24gdmFsdWVcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcHJvbWlzZVJlc29sdmUgKHgpIHtcblx0XHRcdFx0aGFuZGxlci5yZXNvbHZlKHgpO1xuXHRcdFx0fVxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZWplY3QgdGhpcyBwcm9taXNlIHdpdGggcmVhc29uLCB3aGljaCB3aWxsIGJlIHVzZWQgdmVyYmF0aW1cblx0XHRcdCAqIEBwYXJhbSB7RXJyb3J8Kn0gcmVhc29uIHJlamVjdGlvbiByZWFzb24sIHN0cm9uZ2x5IHN1Z2dlc3RlZFxuXHRcdFx0ICogICB0byBiZSBhbiBFcnJvciB0eXBlXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHByb21pc2VSZWplY3QgKHJlYXNvbikge1xuXHRcdFx0XHRoYW5kbGVyLnJlamVjdChyZWFzb24pO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBkZXByZWNhdGVkXG5cdFx0XHQgKiBJc3N1ZSBhIHByb2dyZXNzIGV2ZW50LCBub3RpZnlpbmcgYWxsIHByb2dyZXNzIGxpc3RlbmVyc1xuXHRcdFx0ICogQHBhcmFtIHsqfSB4IHByb2dyZXNzIGV2ZW50IHBheWxvYWQgdG8gcGFzcyB0byBhbGwgbGlzdGVuZXJzXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHByb21pc2VOb3RpZnkgKHgpIHtcblx0XHRcdFx0aGFuZGxlci5ub3RpZnkoeCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRpb25cblxuXHRcdFByb21pc2UucmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0UHJvbWlzZS5yZWplY3QgPSByZWplY3Q7XG5cdFx0UHJvbWlzZS5uZXZlciA9IG5ldmVyO1xuXG5cdFx0UHJvbWlzZS5fZGVmZXIgPSBkZWZlcjtcblx0XHRQcm9taXNlLl9oYW5kbGVyID0gZ2V0SGFuZGxlcjtcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYSB0cnVzdGVkIHByb21pc2UuIElmIHggaXMgYWxyZWFkeSBhIHRydXN0ZWQgcHJvbWlzZSwgaXQgaXNcblx0XHQgKiByZXR1cm5lZCwgb3RoZXJ3aXNlIHJldHVybnMgYSBuZXcgdHJ1c3RlZCBQcm9taXNlIHdoaWNoIGZvbGxvd3MgeC5cblx0XHQgKiBAcGFyYW0gIHsqfSB4XG5cdFx0ICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuXHRcdFx0cmV0dXJuIGlzUHJvbWlzZSh4KSA/IHhcblx0XHRcdFx0OiBuZXcgUHJvbWlzZShIYW5kbGVyLCBuZXcgQXN5bmMoZ2V0SGFuZGxlcih4KSkpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBhIHJlamVjdCBwcm9taXNlIHdpdGggeCBhcyBpdHMgcmVhc29uICh4IGlzIHVzZWQgdmVyYmF0aW0pXG5cdFx0ICogQHBhcmFtIHsqfSB4XG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IHJlamVjdGVkIHByb21pc2Vcblx0XHQgKi9cblx0XHRmdW5jdGlvbiByZWplY3QoeCkge1xuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKEhhbmRsZXIsIG5ldyBBc3luYyhuZXcgUmVqZWN0ZWQoeCkpKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVtYWlucyBwZW5kaW5nIGZvcmV2ZXJcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gZm9yZXZlci1wZW5kaW5nIHByb21pc2UuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gbmV2ZXIoKSB7XG5cdFx0XHRyZXR1cm4gZm9yZXZlclBlbmRpbmdQcm9taXNlOyAvLyBTaG91bGQgYmUgZnJvemVuXG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhbiBpbnRlcm5hbCB7cHJvbWlzZSwgcmVzb2x2ZXJ9IHBhaXJcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGRlZmVyKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKEhhbmRsZXIsIG5ldyBQZW5kaW5nKCkpO1xuXHRcdH1cblxuXHRcdC8vIFRyYW5zZm9ybWF0aW9uIGFuZCBmbG93IGNvbnRyb2xcblxuXHRcdC8qKlxuXHRcdCAqIFRyYW5zZm9ybSB0aGlzIHByb21pc2UncyBmdWxmaWxsbWVudCB2YWx1ZSwgcmV0dXJuaW5nIGEgbmV3IFByb21pc2Vcblx0XHQgKiBmb3IgdGhlIHRyYW5zZm9ybWVkIHJlc3VsdC4gIElmIHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQsIG9uUmVqZWN0ZWRcblx0XHQgKiBpcyBjYWxsZWQgd2l0aCB0aGUgcmVhc29uLiAgb25Qcm9ncmVzcyAqbWF5KiBiZSBjYWxsZWQgd2l0aCB1cGRhdGVzIHRvd2FyZFxuXHRcdCAqIHRoaXMgcHJvbWlzZSdzIGZ1bGZpbGxtZW50LlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb249fSBvbkZ1bGZpbGxlZCBmdWxmaWxsbWVudCBoYW5kbGVyXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbj19IG9uUmVqZWN0ZWQgcmVqZWN0aW9uIGhhbmRsZXJcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gb25Qcm9ncmVzcyBAZGVwcmVjYXRlZCBwcm9ncmVzcyBoYW5kbGVyXG5cdFx0ICogQHJldHVybiB7UHJvbWlzZX0gbmV3IHByb21pc2Vcblx0XHQgKi9cblx0XHRQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MpIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLl9oYW5kbGVyO1xuXHRcdFx0dmFyIHN0YXRlID0gcGFyZW50LmpvaW4oKS5zdGF0ZSgpO1xuXG5cdFx0XHRpZiAoKHR5cGVvZiBvbkZ1bGZpbGxlZCAhPT0gJ2Z1bmN0aW9uJyAmJiBzdGF0ZSA+IDApIHx8XG5cdFx0XHRcdCh0eXBlb2Ygb25SZWplY3RlZCAhPT0gJ2Z1bmN0aW9uJyAmJiBzdGF0ZSA8IDApKSB7XG5cdFx0XHRcdC8vIFNob3J0IGNpcmN1aXQ6IHZhbHVlIHdpbGwgbm90IGNoYW5nZSwgc2ltcGx5IHNoYXJlIGhhbmRsZXJcblx0XHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKEhhbmRsZXIsIHBhcmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwID0gdGhpcy5fYmVnZXQoKTtcblx0XHRcdHZhciBjaGlsZCA9IHAuX2hhbmRsZXI7XG5cblx0XHRcdHBhcmVudC5jaGFpbihjaGlsZCwgcGFyZW50LnJlY2VpdmVyLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyk7XG5cblx0XHRcdHJldHVybiBwO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBJZiB0aGlzIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZCBkdWUgdG8gYW4gZXJyb3IsIGNhbGwgb25SZWplY3RlZCB0b1xuXHRcdCAqIGhhbmRsZSB0aGUgZXJyb3IuIFNob3J0Y3V0IGZvciAudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbj99IG9uUmVqZWN0ZWRcblx0XHQgKiBAcmV0dXJuIHtQcm9taXNlfVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24ob25SZWplY3RlZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIG9uUmVqZWN0ZWQpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGEgbmV3LCBwZW5kaW5nIHByb21pc2Ugb2YgdGhlIHNhbWUgdHlwZSBhcyB0aGlzIHByb21pc2Vcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlLl9iZWdldCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGJlZ2V0RnJvbSh0aGlzLl9oYW5kbGVyLCB0aGlzLmNvbnN0cnVjdG9yKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gYmVnZXRGcm9tKHBhcmVudCwgUHJvbWlzZSkge1xuXHRcdFx0dmFyIGNoaWxkID0gbmV3IFBlbmRpbmcocGFyZW50LnJlY2VpdmVyLCBwYXJlbnQuam9pbigpLmNvbnRleHQpO1xuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKEhhbmRsZXIsIGNoaWxkKTtcblx0XHR9XG5cblx0XHQvLyBBcnJheSBjb21iaW5hdG9yc1xuXG5cdFx0UHJvbWlzZS5hbGwgPSBhbGw7XG5cdFx0UHJvbWlzZS5yYWNlID0gcmFjZTtcblx0XHRQcm9taXNlLl90cmF2ZXJzZSA9IHRyYXZlcnNlO1xuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgZnVsZmlsbCB3aGVuIGFsbCBwcm9taXNlcyBpbiB0aGVcblx0XHQgKiBpbnB1dCBhcnJheSBoYXZlIGZ1bGZpbGxlZCwgb3Igd2lsbCByZWplY3Qgd2hlbiBvbmUgb2YgdGhlXG5cdFx0ICogcHJvbWlzZXMgcmVqZWN0cy5cblx0XHQgKiBAcGFyYW0ge2FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlc1xuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIGZvciBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXNcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcblx0XHRcdHJldHVybiB0cmF2ZXJzZVdpdGgoc25kLCBudWxsLCBwcm9taXNlcyk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQXJyYXk8UHJvbWlzZTxYPj4gLT4gUHJvbWlzZTxBcnJheTxmKFgpPj5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGYgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBwcm9taXNlJ3MgdmFsdWVcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlc1xuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIGZvciB0cmFuc2Zvcm1lZCB2YWx1ZXNcblx0XHQgKi9cblx0XHRmdW5jdGlvbiB0cmF2ZXJzZShmLCBwcm9taXNlcykge1xuXHRcdFx0cmV0dXJuIHRyYXZlcnNlV2l0aCh0cnlDYXRjaDIsIGYsIHByb21pc2VzKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmF2ZXJzZVdpdGgodHJ5TWFwLCBmLCBwcm9taXNlcykge1xuXHRcdFx0dmFyIGhhbmRsZXIgPSB0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJyA/IG1hcEF0IDogc2V0dGxlQXQ7XG5cblx0XHRcdHZhciByZXNvbHZlciA9IG5ldyBQZW5kaW5nKCk7XG5cdFx0XHR2YXIgcGVuZGluZyA9IHByb21pc2VzLmxlbmd0aCA+Pj4gMDtcblx0XHRcdHZhciByZXN1bHRzID0gbmV3IEFycmF5KHBlbmRpbmcpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgeDsgaSA8IHByb21pc2VzLmxlbmd0aCAmJiAhcmVzb2x2ZXIucmVzb2x2ZWQ7ICsraSkge1xuXHRcdFx0XHR4ID0gcHJvbWlzZXNbaV07XG5cblx0XHRcdFx0aWYgKHggPT09IHZvaWQgMCAmJiAhKGkgaW4gcHJvbWlzZXMpKSB7XG5cdFx0XHRcdFx0LS1wZW5kaW5nO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJhdmVyc2VBdChwcm9taXNlcywgaGFuZGxlciwgaSwgeCwgcmVzb2x2ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihwZW5kaW5nID09PSAwKSB7XG5cdFx0XHRcdHJlc29sdmVyLmJlY29tZShuZXcgRnVsZmlsbGVkKHJlc3VsdHMpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKEhhbmRsZXIsIHJlc29sdmVyKTtcblxuXHRcdFx0ZnVuY3Rpb24gbWFwQXQoaSwgeCwgcmVzb2x2ZXIpIHtcblx0XHRcdFx0aWYoIXJlc29sdmVyLnJlc29sdmVkKSB7XG5cdFx0XHRcdFx0dHJhdmVyc2VBdChwcm9taXNlcywgc2V0dGxlQXQsIGksIHRyeU1hcChmLCB4LCBpKSwgcmVzb2x2ZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHNldHRsZUF0KGksIHgsIHJlc29sdmVyKSB7XG5cdFx0XHRcdHJlc3VsdHNbaV0gPSB4O1xuXHRcdFx0XHRpZigtLXBlbmRpbmcgPT09IDApIHtcblx0XHRcdFx0XHRyZXNvbHZlci5iZWNvbWUobmV3IEZ1bGZpbGxlZChyZXN1bHRzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmF2ZXJzZUF0KHByb21pc2VzLCBoYW5kbGVyLCBpLCB4LCByZXNvbHZlcikge1xuXHRcdFx0aWYgKG1heWJlVGhlbmFibGUoeCkpIHtcblx0XHRcdFx0dmFyIGggPSBnZXRIYW5kbGVyTWF5YmVUaGVuYWJsZSh4KTtcblx0XHRcdFx0dmFyIHMgPSBoLnN0YXRlKCk7XG5cblx0XHRcdFx0aWYgKHMgPT09IDApIHtcblx0XHRcdFx0XHRoLmZvbGQoaGFuZGxlciwgaSwgdm9pZCAwLCByZXNvbHZlcik7XG5cdFx0XHRcdH0gZWxzZSBpZiAocyA+IDApIHtcblx0XHRcdFx0XHRoYW5kbGVyKGksIGgudmFsdWUsIHJlc29sdmVyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlci5iZWNvbWUoaCk7XG5cdFx0XHRcdFx0dmlzaXRSZW1haW5pbmcocHJvbWlzZXMsIGkrMSwgaCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXIoaSwgeCwgcmVzb2x2ZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdFByb21pc2UuX3Zpc2l0UmVtYWluaW5nID0gdmlzaXRSZW1haW5pbmc7XG5cdFx0ZnVuY3Rpb24gdmlzaXRSZW1haW5pbmcocHJvbWlzZXMsIHN0YXJ0LCBoYW5kbGVyKSB7XG5cdFx0XHRmb3IodmFyIGk9c3RhcnQ7IGk8cHJvbWlzZXMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0bWFya0FzSGFuZGxlZChnZXRIYW5kbGVyKHByb21pc2VzW2ldKSwgaGFuZGxlcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWFya0FzSGFuZGxlZChoLCBoYW5kbGVyKSB7XG5cdFx0XHRpZihoID09PSBoYW5kbGVyKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHMgPSBoLnN0YXRlKCk7XG5cdFx0XHRpZihzID09PSAwKSB7XG5cdFx0XHRcdGgudmlzaXQoaCwgdm9pZCAwLCBoLl91bnJlcG9ydCk7XG5cdFx0XHR9IGVsc2UgaWYocyA8IDApIHtcblx0XHRcdFx0aC5fdW5yZXBvcnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBGdWxmaWxsLXJlamVjdCBjb21wZXRpdGl2ZSByYWNlLiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBzZXR0bGVcblx0XHQgKiB0byB0aGUgc2FtZSBzdGF0ZSBhcyB0aGUgZWFybGllc3QgaW5wdXQgcHJvbWlzZSB0byBzZXR0bGUuXG5cdFx0ICpcblx0XHQgKiBXQVJOSU5HOiBUaGUgRVM2IFByb21pc2Ugc3BlYyByZXF1aXJlcyB0aGF0IHJhY2UoKWluZyBhbiBlbXB0eSBhcnJheVxuXHRcdCAqIG11c3QgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlci4gIFRoaXMgaW1wbGVtZW50YXRpb25cblx0XHQgKiByZXR1cm5zIGEgc2luZ2xldG9uIGZvcmV2ZXItcGVuZGluZyBwcm9taXNlLCB0aGUgc2FtZSBzaW5nbGV0b24gdGhhdCBpc1xuXHRcdCAqIHJldHVybmVkIGJ5IFByb21pc2UubmV2ZXIoKSwgdGh1cyBjYW4gYmUgY2hlY2tlZCB3aXRoID09PVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHthcnJheX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgdG8gcmFjZVxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBpZiBpbnB1dCBpcyBub24tZW1wdHksIGEgcHJvbWlzZSB0aGF0IHdpbGwgc2V0dGxlXG5cdFx0ICogdG8gdGhlIHNhbWUgb3V0Y29tZSBhcyB0aGUgZWFybGllc3QgaW5wdXQgcHJvbWlzZSB0byBzZXR0bGUuIGlmIGVtcHR5XG5cdFx0ICogaXMgZW1wdHksIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBuZXZlciBzZXR0bGUuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcmFjZShwcm9taXNlcykge1xuXHRcdFx0aWYodHlwZW9mIHByb21pc2VzICE9PSAnb2JqZWN0JyB8fCBwcm9taXNlcyA9PT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ25vbi1pdGVyYWJsZSBwYXNzZWQgdG8gcmFjZSgpJykpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaWdoLCByYWNlKFtdKSBpcyB1bnRlc3RhYmxlIHVubGVzcyB3ZSByZXR1cm4gKnNvbWV0aGluZypcblx0XHRcdC8vIHRoYXQgaXMgcmVjb2duaXphYmxlIHdpdGhvdXQgY2FsbGluZyAudGhlbigpIG9uIGl0LlxuXHRcdFx0cmV0dXJuIHByb21pc2VzLmxlbmd0aCA9PT0gMCA/IG5ldmVyKClcblx0XHRcdFx0IDogcHJvbWlzZXMubGVuZ3RoID09PSAxID8gcmVzb2x2ZShwcm9taXNlc1swXSlcblx0XHRcdFx0IDogcnVuUmFjZShwcm9taXNlcyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcnVuUmFjZShwcm9taXNlcykge1xuXHRcdFx0dmFyIHJlc29sdmVyID0gbmV3IFBlbmRpbmcoKTtcblx0XHRcdHZhciBpLCB4LCBoO1xuXHRcdFx0Zm9yKGk9MDsgaTxwcm9taXNlcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR4ID0gcHJvbWlzZXNbaV07XG5cdFx0XHRcdGlmICh4ID09PSB2b2lkIDAgJiYgIShpIGluIHByb21pc2VzKSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aCA9IGdldEhhbmRsZXIoeCk7XG5cdFx0XHRcdGlmKGguc3RhdGUoKSAhPT0gMCkge1xuXHRcdFx0XHRcdHJlc29sdmVyLmJlY29tZShoKTtcblx0XHRcdFx0XHR2aXNpdFJlbWFpbmluZyhwcm9taXNlcywgaSsxLCBoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoLnZpc2l0KHJlc29sdmVyLCByZXNvbHZlci5yZXNvbHZlLCByZXNvbHZlci5yZWplY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoSGFuZGxlciwgcmVzb2x2ZXIpO1xuXHRcdH1cblxuXHRcdC8vIFByb21pc2UgaW50ZXJuYWxzXG5cdFx0Ly8gQmVsb3cgdGhpcywgZXZlcnl0aGluZyBpcyBAcHJpdmF0ZVxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IGFuIGFwcHJvcHJpYXRlIGhhbmRsZXIgZm9yIHgsIHdpdGhvdXQgY2hlY2tpbmcgZm9yIGN5Y2xlc1xuXHRcdCAqIEBwYXJhbSB7Kn0geFxuXHRcdCAqIEByZXR1cm5zIHtvYmplY3R9IGhhbmRsZXJcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBnZXRIYW5kbGVyKHgpIHtcblx0XHRcdGlmKGlzUHJvbWlzZSh4KSkge1xuXHRcdFx0XHRyZXR1cm4geC5faGFuZGxlci5qb2luKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF5YmVUaGVuYWJsZSh4KSA/IGdldEhhbmRsZXJVbnRydXN0ZWQoeCkgOiBuZXcgRnVsZmlsbGVkKHgpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEdldCBhIGhhbmRsZXIgZm9yIHRoZW5hYmxlIHguXG5cdFx0ICogTk9URTogWW91IG11c3Qgb25seSBjYWxsIHRoaXMgaWYgbWF5YmVUaGVuYWJsZSh4KSA9PSB0cnVlXG5cdFx0ICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb258UHJvbWlzZX0geFxuXHRcdCAqIEByZXR1cm5zIHtvYmplY3R9IGhhbmRsZXJcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBnZXRIYW5kbGVyTWF5YmVUaGVuYWJsZSh4KSB7XG5cdFx0XHRyZXR1cm4gaXNQcm9taXNlKHgpID8geC5faGFuZGxlci5qb2luKCkgOiBnZXRIYW5kbGVyVW50cnVzdGVkKHgpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEdldCBhIGhhbmRsZXIgZm9yIHBvdGVudGlhbGx5IHVudHJ1c3RlZCB0aGVuYWJsZSB4XG5cdFx0ICogQHBhcmFtIHsqfSB4XG5cdFx0ICogQHJldHVybnMge29iamVjdH0gaGFuZGxlclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGdldEhhbmRsZXJVbnRydXN0ZWQoeCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIHVudHJ1c3RlZFRoZW4gPSB4LnRoZW47XG5cdFx0XHRcdHJldHVybiB0eXBlb2YgdW50cnVzdGVkVGhlbiA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHRcdD8gbmV3IFRoZW5hYmxlKHVudHJ1c3RlZFRoZW4sIHgpXG5cdFx0XHRcdFx0OiBuZXcgRnVsZmlsbGVkKHgpO1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgUmVqZWN0ZWQoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciBmb3IgYSBwcm9taXNlIHRoYXQgaXMgcGVuZGluZyBmb3JldmVyXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gSGFuZGxlcigpIHt9XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS53aGVuXG5cdFx0XHQ9IEhhbmRsZXIucHJvdG90eXBlLmJlY29tZVxuXHRcdFx0PSBIYW5kbGVyLnByb3RvdHlwZS5ub3RpZnkgLy8gZGVwcmVjYXRlZFxuXHRcdFx0PSBIYW5kbGVyLnByb3RvdHlwZS5mYWlsXG5cdFx0XHQ9IEhhbmRsZXIucHJvdG90eXBlLl91bnJlcG9ydFxuXHRcdFx0PSBIYW5kbGVyLnByb3RvdHlwZS5fcmVwb3J0XG5cdFx0XHQ9IG5vb3A7XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS5fc3RhdGUgPSAwO1xuXG5cdFx0SGFuZGxlci5wcm90b3R5cGUuc3RhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9zdGF0ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVjdXJzaXZlbHkgY29sbGFwc2UgaGFuZGxlciBjaGFpbiB0byBmaW5kIHRoZSBoYW5kbGVyXG5cdFx0ICogbmVhcmVzdCB0byB0aGUgZnVsbHkgcmVzb2x2ZWQgdmFsdWUuXG5cdFx0ICogQHJldHVybnMge29iamVjdH0gaGFuZGxlciBuZWFyZXN0IHRoZSBmdWxseSByZXNvbHZlZCB2YWx1ZVxuXHRcdCAqL1xuXHRcdEhhbmRsZXIucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoID0gdGhpcztcblx0XHRcdHdoaWxlKGguaGFuZGxlciAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdGggPSBoLmhhbmRsZXI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaDtcblx0XHR9O1xuXG5cdFx0SGFuZGxlci5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbih0bywgcmVjZWl2ZXIsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG5cdFx0XHR0aGlzLndoZW4oe1xuXHRcdFx0XHRyZXNvbHZlcjogdG8sXG5cdFx0XHRcdHJlY2VpdmVyOiByZWNlaXZlcixcblx0XHRcdFx0ZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG5cdFx0XHRcdHJlamVjdGVkOiByZWplY3RlZCxcblx0XHRcdFx0cHJvZ3Jlc3M6IHByb2dyZXNzXG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0SGFuZGxlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbihyZWNlaXZlciwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcblx0XHRcdHRoaXMuY2hhaW4oZmFpbElmUmVqZWN0ZWQsIHJlY2VpdmVyLCBmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcyk7XG5cdFx0fTtcblxuXHRcdEhhbmRsZXIucHJvdG90eXBlLmZvbGQgPSBmdW5jdGlvbihmLCB6LCBjLCB0bykge1xuXHRcdFx0dGhpcy53aGVuKG5ldyBGb2xkKGYsIHosIGMsIHRvKSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgdGhhdCBpbnZva2VzIGZhaWwoKSBvbiBhbnkgaGFuZGxlciBpdCBiZWNvbWVzXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gRmFpbElmUmVqZWN0ZWQoKSB7fVxuXG5cdFx0aW5oZXJpdChIYW5kbGVyLCBGYWlsSWZSZWplY3RlZCk7XG5cblx0XHRGYWlsSWZSZWplY3RlZC5wcm90b3R5cGUuYmVjb21lID0gZnVuY3Rpb24oaCkge1xuXHRcdFx0aC5mYWlsKCk7XG5cdFx0fTtcblxuXHRcdHZhciBmYWlsSWZSZWplY3RlZCA9IG5ldyBGYWlsSWZSZWplY3RlZCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciB0aGF0IG1hbmFnZXMgYSBxdWV1ZSBvZiBjb25zdW1lcnMgd2FpdGluZyBvbiBhIHBlbmRpbmcgcHJvbWlzZVxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIFBlbmRpbmcocmVjZWl2ZXIsIGluaGVyaXRlZENvbnRleHQpIHtcblx0XHRcdFByb21pc2UuY3JlYXRlQ29udGV4dCh0aGlzLCBpbmhlcml0ZWRDb250ZXh0KTtcblxuXHRcdFx0dGhpcy5jb25zdW1lcnMgPSB2b2lkIDA7XG5cdFx0XHR0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG5cdFx0XHR0aGlzLmhhbmRsZXIgPSB2b2lkIDA7XG5cdFx0XHR0aGlzLnJlc29sdmVkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aW5oZXJpdChIYW5kbGVyLCBQZW5kaW5nKTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLl9zdGF0ZSA9IDA7XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0dGhpcy5iZWNvbWUoZ2V0SGFuZGxlcih4KSk7XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdGlmKHRoaXMucmVzb2x2ZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmJlY29tZShuZXcgUmVqZWN0ZWQoeCkpO1xuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBoID0gdGhpcztcblxuXHRcdFx0d2hpbGUgKGguaGFuZGxlciAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdGggPSBoLmhhbmRsZXI7XG5cdFx0XHRcdGlmIChoID09PSB0aGlzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuaGFuZGxlciA9IGN5Y2xlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGg7XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHEgPSB0aGlzLmNvbnN1bWVycztcblx0XHRcdHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyO1xuXHRcdFx0dGhpcy5oYW5kbGVyID0gdGhpcy5oYW5kbGVyLmpvaW4oKTtcblx0XHRcdHRoaXMuY29uc3VtZXJzID0gdm9pZCAwO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0aGFuZGxlci53aGVuKHFbaV0pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5iZWNvbWUgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG5cdFx0XHRpZih0aGlzLnJlc29sdmVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5yZXNvbHZlZCA9IHRydWU7XG5cdFx0XHR0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXHRcdFx0aWYodGhpcy5jb25zdW1lcnMgIT09IHZvaWQgMCkge1xuXHRcdFx0XHR0YXNrcy5lbnF1ZXVlKHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLmNvbnRleHQgIT09IHZvaWQgMCkge1xuXHRcdFx0XHRoYW5kbGVyLl9yZXBvcnQodGhpcy5jb250ZXh0KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUud2hlbiA9IGZ1bmN0aW9uKGNvbnRpbnVhdGlvbikge1xuXHRcdFx0aWYodGhpcy5yZXNvbHZlZCkge1xuXHRcdFx0XHR0YXNrcy5lbnF1ZXVlKG5ldyBDb250aW51YXRpb25UYXNrKGNvbnRpbnVhdGlvbiwgdGhpcy5oYW5kbGVyKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0aGlzLmNvbnN1bWVycyA9PT0gdm9pZCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5jb25zdW1lcnMgPSBbY29udGludWF0aW9uXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmNvbnN1bWVycy5wdXNoKGNvbnRpbnVhdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQGRlcHJlY2F0ZWRcblx0XHQgKi9cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRpZighdGhpcy5yZXNvbHZlZCkge1xuXHRcdFx0XHR0YXNrcy5lbnF1ZXVlKG5ldyBQcm9ncmVzc1Rhc2soeCwgdGhpcykpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0dmFyIGMgPSB0eXBlb2YgY29udGV4dCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmNvbnRleHQgOiBjb250ZXh0O1xuXHRcdFx0dGhpcy5yZXNvbHZlZCAmJiB0aGlzLmhhbmRsZXIuam9pbigpLmZhaWwoYyk7XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLl9yZXBvcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0XHR0aGlzLnJlc29sdmVkICYmIHRoaXMuaGFuZGxlci5qb2luKCkuX3JlcG9ydChjb250ZXh0KTtcblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUuX3VucmVwb3J0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlc29sdmVkICYmIHRoaXMuaGFuZGxlci5qb2luKCkuX3VucmVwb3J0KCk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFdyYXAgYW5vdGhlciBoYW5kbGVyIGFuZCBmb3JjZSBpdCBpbnRvIGEgZnV0dXJlIHN0YWNrXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZXJcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBBc3luYyhoYW5kbGVyKSB7XG5cdFx0XHR0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXHRcdH1cblxuXHRcdGluaGVyaXQoSGFuZGxlciwgQXN5bmMpO1xuXG5cdFx0QXN5bmMucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbihjb250aW51YXRpb24pIHtcblx0XHRcdHRhc2tzLmVucXVldWUobmV3IENvbnRpbnVhdGlvblRhc2soY29udGludWF0aW9uLCB0aGlzKSk7XG5cdFx0fTtcblxuXHRcdEFzeW5jLnByb3RvdHlwZS5fcmVwb3J0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0dGhpcy5qb2luKCkuX3JlcG9ydChjb250ZXh0KTtcblx0XHR9O1xuXG5cdFx0QXN5bmMucHJvdG90eXBlLl91bnJlcG9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5qb2luKCkuX3VucmVwb3J0KCk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgdGhhdCB3cmFwcyBhbiB1bnRydXN0ZWQgdGhlbmFibGUgYW5kIGFzc2ltaWxhdGVzIGl0IGluIGEgZnV0dXJlIHN0YWNrXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlblxuXHRcdCAqIEBwYXJhbSB7e3RoZW46IGZ1bmN0aW9ufX0gdGhlbmFibGVcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBUaGVuYWJsZSh0aGVuLCB0aGVuYWJsZSkge1xuXHRcdFx0UGVuZGluZy5jYWxsKHRoaXMpO1xuXHRcdFx0dGFza3MuZW5xdWV1ZShuZXcgQXNzaW1pbGF0ZVRhc2sodGhlbiwgdGhlbmFibGUsIHRoaXMpKTtcblx0XHR9XG5cblx0XHRpbmhlcml0KFBlbmRpbmcsIFRoZW5hYmxlKTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgZm9yIGEgZnVsZmlsbGVkIHByb21pc2Vcblx0XHQgKiBAcGFyYW0geyp9IHggZnVsZmlsbG1lbnQgdmFsdWVcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBGdWxmaWxsZWQoeCkge1xuXHRcdFx0UHJvbWlzZS5jcmVhdGVDb250ZXh0KHRoaXMpO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHg7XG5cdFx0fVxuXG5cdFx0aW5oZXJpdChIYW5kbGVyLCBGdWxmaWxsZWQpO1xuXG5cdFx0RnVsZmlsbGVkLnByb3RvdHlwZS5fc3RhdGUgPSAxO1xuXG5cdFx0RnVsZmlsbGVkLnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24oZiwgeiwgYywgdG8pIHtcblx0XHRcdHJ1bkNvbnRpbnVhdGlvbjMoZiwgeiwgdGhpcywgYywgdG8pO1xuXHRcdH07XG5cblx0XHRGdWxmaWxsZWQucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbihjb250KSB7XG5cdFx0XHRydW5Db250aW51YXRpb24xKGNvbnQuZnVsZmlsbGVkLCB0aGlzLCBjb250LnJlY2VpdmVyLCBjb250LnJlc29sdmVyKTtcblx0XHR9O1xuXG5cdFx0dmFyIGVycm9ySWQgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciBmb3IgYSByZWplY3RlZCBwcm9taXNlXG5cdFx0ICogQHBhcmFtIHsqfSB4IHJlamVjdGlvbiByZWFzb25cblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBSZWplY3RlZCh4KSB7XG5cdFx0XHRQcm9taXNlLmNyZWF0ZUNvbnRleHQodGhpcyk7XG5cblx0XHRcdHRoaXMuaWQgPSArK2Vycm9ySWQ7XG5cdFx0XHR0aGlzLnZhbHVlID0geDtcblx0XHRcdHRoaXMuaGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5yZXBvcnRlZCA9IGZhbHNlO1xuXG5cdFx0XHR0aGlzLl9yZXBvcnQoKTtcblx0XHR9XG5cblx0XHRpbmhlcml0KEhhbmRsZXIsIFJlamVjdGVkKTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS5fc3RhdGUgPSAtMTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24oZiwgeiwgYywgdG8pIHtcblx0XHRcdHRvLmJlY29tZSh0aGlzKTtcblx0XHR9O1xuXG5cdFx0UmVqZWN0ZWQucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbihjb250KSB7XG5cdFx0XHRpZih0eXBlb2YgY29udC5yZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aGlzLl91bnJlcG9ydCgpO1xuXHRcdFx0fVxuXHRcdFx0cnVuQ29udGludWF0aW9uMShjb250LnJlamVjdGVkLCB0aGlzLCBjb250LnJlY2VpdmVyLCBjb250LnJlc29sdmVyKTtcblx0XHR9O1xuXG5cdFx0UmVqZWN0ZWQucHJvdG90eXBlLl9yZXBvcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0XHR0YXNrcy5hZnRlclF1ZXVlKG5ldyBSZXBvcnRUYXNrKHRoaXMsIGNvbnRleHQpKTtcblx0XHR9O1xuXG5cdFx0UmVqZWN0ZWQucHJvdG90eXBlLl91bnJlcG9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYodGhpcy5oYW5kbGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGFuZGxlZCA9IHRydWU7XG5cdFx0XHR0YXNrcy5hZnRlclF1ZXVlKG5ldyBVbnJlcG9ydFRhc2sodGhpcykpO1xuXHRcdH07XG5cblx0XHRSZWplY3RlZC5wcm90b3R5cGUuZmFpbCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHRcdHRoaXMucmVwb3J0ZWQgPSB0cnVlO1xuXHRcdFx0ZW1pdFJlamVjdGlvbigndW5oYW5kbGVkUmVqZWN0aW9uJywgdGhpcyk7XG5cdFx0XHRQcm9taXNlLm9uRmF0YWxSZWplY3Rpb24odGhpcywgY29udGV4dCA9PT0gdm9pZCAwID8gdGhpcy5jb250ZXh0IDogY29udGV4dCk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIFJlcG9ydFRhc2socmVqZWN0aW9uLCBjb250ZXh0KSB7XG5cdFx0XHR0aGlzLnJlamVjdGlvbiA9IHJlamVjdGlvbjtcblx0XHRcdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cdFx0fVxuXG5cdFx0UmVwb3J0VGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZighdGhpcy5yZWplY3Rpb24uaGFuZGxlZCAmJiAhdGhpcy5yZWplY3Rpb24ucmVwb3J0ZWQpIHtcblx0XHRcdFx0dGhpcy5yZWplY3Rpb24ucmVwb3J0ZWQgPSB0cnVlO1xuXHRcdFx0XHRlbWl0UmVqZWN0aW9uKCd1bmhhbmRsZWRSZWplY3Rpb24nLCB0aGlzLnJlamVjdGlvbikgfHxcblx0XHRcdFx0XHRQcm9taXNlLm9uUG90ZW50aWFsbHlVbmhhbmRsZWRSZWplY3Rpb24odGhpcy5yZWplY3Rpb24sIHRoaXMuY29udGV4dCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIFVucmVwb3J0VGFzayhyZWplY3Rpb24pIHtcblx0XHRcdHRoaXMucmVqZWN0aW9uID0gcmVqZWN0aW9uO1xuXHRcdH1cblxuXHRcdFVucmVwb3J0VGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZih0aGlzLnJlamVjdGlvbi5yZXBvcnRlZCkge1xuXHRcdFx0XHRlbWl0UmVqZWN0aW9uKCdyZWplY3Rpb25IYW5kbGVkJywgdGhpcy5yZWplY3Rpb24pIHx8XG5cdFx0XHRcdFx0UHJvbWlzZS5vblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCh0aGlzLnJlamVjdGlvbik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIFVuaGFuZGxlZCByZWplY3Rpb24gaG9va3Ncblx0XHQvLyBCeSBkZWZhdWx0LCBldmVyeXRoaW5nIGlzIGEgbm9vcFxuXG5cdFx0UHJvbWlzZS5jcmVhdGVDb250ZXh0XG5cdFx0XHQ9IFByb21pc2UuZW50ZXJDb250ZXh0XG5cdFx0XHQ9IFByb21pc2UuZXhpdENvbnRleHRcblx0XHRcdD0gUHJvbWlzZS5vblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uXG5cdFx0XHQ9IFByb21pc2Uub25Qb3RlbnRpYWxseVVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWRcblx0XHRcdD0gUHJvbWlzZS5vbkZhdGFsUmVqZWN0aW9uXG5cdFx0XHQ9IG5vb3A7XG5cblx0XHQvLyBFcnJvcnMgYW5kIHNpbmdsZXRvbnNcblxuXHRcdHZhciBmb3JldmVyUGVuZGluZ0hhbmRsZXIgPSBuZXcgSGFuZGxlcigpO1xuXHRcdHZhciBmb3JldmVyUGVuZGluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZShIYW5kbGVyLCBmb3JldmVyUGVuZGluZ0hhbmRsZXIpO1xuXG5cdFx0ZnVuY3Rpb24gY3ljbGUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFJlamVjdGVkKG5ldyBUeXBlRXJyb3IoJ1Byb21pc2UgY3ljbGUnKSk7XG5cdFx0fVxuXG5cdFx0Ly8gVGFzayBydW5uZXJzXG5cblx0XHQvKipcblx0XHQgKiBSdW4gYSBzaW5nbGUgY29uc3VtZXJcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBDb250aW51YXRpb25UYXNrKGNvbnRpbnVhdGlvbiwgaGFuZGxlcikge1xuXHRcdFx0dGhpcy5jb250aW51YXRpb24gPSBjb250aW51YXRpb247XG5cdFx0XHR0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXHRcdH1cblxuXHRcdENvbnRpbnVhdGlvblRhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5oYW5kbGVyLmpvaW4oKS53aGVuKHRoaXMuY29udGludWF0aW9uKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUnVuIGEgcXVldWUgb2YgcHJvZ3Jlc3MgaGFuZGxlcnNcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBQcm9ncmVzc1Rhc2sodmFsdWUsIGhhbmRsZXIpIHtcblx0XHRcdHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG5cdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0UHJvZ3Jlc3NUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBxID0gdGhpcy5oYW5kbGVyLmNvbnN1bWVycztcblx0XHRcdGlmKHEgPT09IHZvaWQgMCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGMsIGkgPSAwOyBpIDwgcS5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRjID0gcVtpXTtcblx0XHRcdFx0cnVuTm90aWZ5KGMucHJvZ3Jlc3MsIHRoaXMudmFsdWUsIHRoaXMuaGFuZGxlciwgYy5yZWNlaXZlciwgYy5yZXNvbHZlcik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFzc2ltaWxhdGUgYSB0aGVuYWJsZSwgc2VuZGluZyBpdCdzIHZhbHVlIHRvIHJlc29sdmVyXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlblxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSB0aGVuYWJsZVxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSByZXNvbHZlclxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIEFzc2ltaWxhdGVUYXNrKHRoZW4sIHRoZW5hYmxlLCByZXNvbHZlcikge1xuXHRcdFx0dGhpcy5fdGhlbiA9IHRoZW47XG5cdFx0XHR0aGlzLnRoZW5hYmxlID0gdGhlbmFibGU7XG5cdFx0XHR0aGlzLnJlc29sdmVyID0gcmVzb2x2ZXI7XG5cdFx0fVxuXG5cdFx0QXNzaW1pbGF0ZVRhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGggPSB0aGlzLnJlc29sdmVyO1xuXHRcdFx0dHJ5QXNzaW1pbGF0ZSh0aGlzLl90aGVuLCB0aGlzLnRoZW5hYmxlLCBfcmVzb2x2ZSwgX3JlamVjdCwgX25vdGlmeSk7XG5cblx0XHRcdGZ1bmN0aW9uIF9yZXNvbHZlKHgpIHsgaC5yZXNvbHZlKHgpOyB9XG5cdFx0XHRmdW5jdGlvbiBfcmVqZWN0KHgpICB7IGgucmVqZWN0KHgpOyB9XG5cdFx0XHRmdW5jdGlvbiBfbm90aWZ5KHgpICB7IGgubm90aWZ5KHgpOyB9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHRyeUFzc2ltaWxhdGUodGhlbiwgdGhlbmFibGUsIHJlc29sdmUsIHJlamVjdCwgbm90aWZ5KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGVuLmNhbGwodGhlbmFibGUsIHJlc29sdmUsIHJlamVjdCwgbm90aWZ5KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmVqZWN0KGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEZvbGQgYSBoYW5kbGVyIHZhbHVlIHdpdGggelxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIEZvbGQoZiwgeiwgYywgdG8pIHtcblx0XHRcdHRoaXMuZiA9IGY7IHRoaXMueiA9IHo7IHRoaXMuYyA9IGM7IHRoaXMudG8gPSB0bztcblx0XHRcdHRoaXMucmVzb2x2ZXIgPSBmYWlsSWZSZWplY3RlZDtcblx0XHRcdHRoaXMucmVjZWl2ZXIgPSB0aGlzO1xuXHRcdH1cblxuXHRcdEZvbGQucHJvdG90eXBlLmZ1bGZpbGxlZCA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHRoaXMuZi5jYWxsKHRoaXMuYywgdGhpcy56LCB4LCB0aGlzLnRvKTtcblx0XHR9O1xuXG5cdFx0Rm9sZC5wcm90b3R5cGUucmVqZWN0ZWQgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHR0aGlzLnRvLnJlamVjdCh4KTtcblx0XHR9O1xuXG5cdFx0Rm9sZC5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHR0aGlzLnRvLm5vdGlmeSh4KTtcblx0XHR9O1xuXG5cdFx0Ly8gT3RoZXIgaGVscGVyc1xuXG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHsqfSB4XG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWZmIHggaXMgYSB0cnVzdGVkIFByb21pc2Vcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBpc1Byb21pc2UoeCkge1xuXHRcdFx0cmV0dXJuIHggaW5zdGFuY2VvZiBQcm9taXNlO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFRlc3QganVzdCBlbm91Z2ggdG8gcnVsZSBvdXQgcHJpbWl0aXZlcywgaW4gb3JkZXIgdG8gdGFrZSBmYXN0ZXJcblx0XHQgKiBwYXRocyBpbiBzb21lIGNvZGVcblx0XHQgKiBAcGFyYW0geyp9IHhcblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWZmIHggaXMgZ3VhcmFudGVlZCAqbm90KiB0byBiZSBhIHRoZW5hYmxlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gbWF5YmVUaGVuYWJsZSh4KSB7XG5cdFx0XHRyZXR1cm4gKHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJykgJiYgeCAhPT0gbnVsbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBydW5Db250aW51YXRpb24xKGYsIGgsIHJlY2VpdmVyLCBuZXh0KSB7XG5cdFx0XHRpZih0eXBlb2YgZiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gbmV4dC5iZWNvbWUoaCk7XG5cdFx0XHR9XG5cblx0XHRcdFByb21pc2UuZW50ZXJDb250ZXh0KGgpO1xuXHRcdFx0dHJ5Q2F0Y2hSZWplY3QoZiwgaC52YWx1ZSwgcmVjZWl2ZXIsIG5leHQpO1xuXHRcdFx0UHJvbWlzZS5leGl0Q29udGV4dCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJ1bkNvbnRpbnVhdGlvbjMoZiwgeCwgaCwgcmVjZWl2ZXIsIG5leHQpIHtcblx0XHRcdGlmKHR5cGVvZiBmICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJldHVybiBuZXh0LmJlY29tZShoKTtcblx0XHRcdH1cblxuXHRcdFx0UHJvbWlzZS5lbnRlckNvbnRleHQoaCk7XG5cdFx0XHR0cnlDYXRjaFJlamVjdDMoZiwgeCwgaC52YWx1ZSwgcmVjZWl2ZXIsIG5leHQpO1xuXHRcdFx0UHJvbWlzZS5leGl0Q29udGV4dCgpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEBkZXByZWNhdGVkXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcnVuTm90aWZ5KGYsIHgsIGgsIHJlY2VpdmVyLCBuZXh0KSB7XG5cdFx0XHRpZih0eXBlb2YgZiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gbmV4dC5ub3RpZnkoeCk7XG5cdFx0XHR9XG5cblx0XHRcdFByb21pc2UuZW50ZXJDb250ZXh0KGgpO1xuXHRcdFx0dHJ5Q2F0Y2hSZXR1cm4oZiwgeCwgcmVjZWl2ZXIsIG5leHQpO1xuXHRcdFx0UHJvbWlzZS5leGl0Q29udGV4dCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyeUNhdGNoMihmLCBhLCBiKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gZihhLCBiKTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRyZXR1cm4gcmVqZWN0KGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBmLmNhbGwodGhpc0FyZywgeCksIG9yIGlmIGl0IHRocm93cyByZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIGZvclxuXHRcdCAqIHRoZSB0aHJvd24gZXhjZXB0aW9uXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gdHJ5Q2F0Y2hSZWplY3QoZiwgeCwgdGhpc0FyZywgbmV4dCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bmV4dC5iZWNvbWUoZ2V0SGFuZGxlcihmLmNhbGwodGhpc0FyZywgeCkpKTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRuZXh0LmJlY29tZShuZXcgUmVqZWN0ZWQoZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBpbmNsdWRlcyB0aGUgZXh0cmEgYXJndW1lbnQgcGFyYW1ldGVyLlxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHRyeUNhdGNoUmVqZWN0MyhmLCB4LCB5LCB0aGlzQXJnLCBuZXh0KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmLmNhbGwodGhpc0FyZywgeCwgeSwgbmV4dCk7XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0bmV4dC5iZWNvbWUobmV3IFJlamVjdGVkKGUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAZGVwcmVjYXRlZFxuXHRcdCAqIFJldHVybiBmLmNhbGwodGhpc0FyZywgeCksIG9yIGlmIGl0IHRocm93cywgKnJldHVybiogdGhlIGV4Y2VwdGlvblxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHRyeUNhdGNoUmV0dXJuKGYsIHgsIHRoaXNBcmcsIG5leHQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdG5leHQubm90aWZ5KGYuY2FsbCh0aGlzQXJnLCB4KSk7XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0bmV4dC5ub3RpZnkoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5oZXJpdChQYXJlbnQsIENoaWxkKSB7XG5cdFx0XHRDaGlsZC5wcm90b3R5cGUgPSBvYmplY3RDcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG5cdFx0XHRDaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaGlsZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzbmQoeCwgeSkge1xuXHRcdFx0cmV0dXJuIHk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cblx0XHRmdW5jdGlvbiBpbml0RW1pdFJlamVjdGlvbigpIHtcblx0XHRcdC8qZ2xvYmFsIHByb2Nlc3MsIHNlbGYsIEN1c3RvbUV2ZW50Ki9cblx0XHRcdGlmKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzICE9PSBudWxsXG5cdFx0XHRcdCYmIHR5cGVvZiBwcm9jZXNzLmVtaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Ly8gUmV0dXJuaW5nIGZhbHN5IGhlcmUgbWVhbnMgdG8gY2FsbCB0aGUgZGVmYXVsdFxuXHRcdFx0XHQvLyBvblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uIEFQSS4gIFRoaXMgaXMgc2FmZSBldmVuIGluXG5cdFx0XHRcdC8vIGJyb3dzZXJpZnkgc2luY2UgcHJvY2Vzcy5lbWl0IGFsd2F5cyByZXR1cm5zIGZhbHN5IGluIGJyb3dzZXJpZnk6XG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWZ1bmN0em9tYmllL25vZGUtcHJvY2Vzcy9ibG9iL21hc3Rlci9icm93c2VyLmpzI0w0MC1MNDZcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHR5cGUsIHJlamVjdGlvbikge1xuXHRcdFx0XHRcdHJldHVybiB0eXBlID09PSAndW5oYW5kbGVkUmVqZWN0aW9uJ1xuXHRcdFx0XHRcdFx0PyBwcm9jZXNzLmVtaXQodHlwZSwgcmVqZWN0aW9uLnZhbHVlLCByZWplY3Rpb24pXG5cdFx0XHRcdFx0XHQ6IHByb2Nlc3MuZW1pdCh0eXBlLCByZWplY3Rpb24pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmV0dXJuIChmdW5jdGlvbihub29wLCBzZWxmLCBDdXN0b21FdmVudCkge1xuXHRcdFx0XHRcdHZhciBoYXNDdXN0b21FdmVudCA9IGZhbHNlO1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR2YXIgZXYgPSBuZXcgQ3VzdG9tRXZlbnQoJ3VuaGFuZGxlZFJlamVjdGlvbicpO1xuXHRcdFx0XHRcdFx0aGFzQ3VzdG9tRXZlbnQgPSBldiBpbnN0YW5jZW9mIEN1c3RvbUV2ZW50O1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cblx0XHRcdFx0XHRyZXR1cm4gIWhhc0N1c3RvbUV2ZW50ID8gbm9vcCA6IGZ1bmN0aW9uKHR5cGUsIHJlamVjdGlvbikge1xuXHRcdFx0XHRcdFx0dmFyIGV2ID0gbmV3IEN1c3RvbUV2ZW50KHR5cGUsIHtcblx0XHRcdFx0XHRcdFx0ZGV0YWlsOiB7XG5cdFx0XHRcdFx0XHRcdFx0cmVhc29uOiByZWplY3Rpb24udmFsdWUsXG5cdFx0XHRcdFx0XHRcdFx0a2V5OiByZWplY3Rpb25cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0YnViYmxlczogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdGNhbmNlbGFibGU6IHRydWVcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gIXNlbGYuZGlzcGF0Y2hFdmVudChldik7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fShub29wLCBzZWxmLCBDdXN0b21FdmVudCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbm9vcDtcblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZTtcblx0fTtcbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24oKSB7XG5cblx0cmV0dXJuIHtcblx0XHRwZW5kaW5nOiB0b1BlbmRpbmdTdGF0ZSxcblx0XHRmdWxmaWxsZWQ6IHRvRnVsZmlsbGVkU3RhdGUsXG5cdFx0cmVqZWN0ZWQ6IHRvUmVqZWN0ZWRTdGF0ZSxcblx0XHRpbnNwZWN0OiBpbnNwZWN0XG5cdH07XG5cblx0ZnVuY3Rpb24gdG9QZW5kaW5nU3RhdGUoKSB7XG5cdFx0cmV0dXJuIHsgc3RhdGU6ICdwZW5kaW5nJyB9O1xuXHR9XG5cblx0ZnVuY3Rpb24gdG9SZWplY3RlZFN0YXRlKGUpIHtcblx0XHRyZXR1cm4geyBzdGF0ZTogJ3JlamVjdGVkJywgcmVhc29uOiBlIH07XG5cdH1cblxuXHRmdW5jdGlvbiB0b0Z1bGZpbGxlZFN0YXRlKHgpIHtcblx0XHRyZXR1cm4geyBzdGF0ZTogJ2Z1bGZpbGxlZCcsIHZhbHVlOiB4IH07XG5cdH1cblxuXHRmdW5jdGlvbiBpbnNwZWN0KGhhbmRsZXIpIHtcblx0XHR2YXIgc3RhdGUgPSBoYW5kbGVyLnN0YXRlKCk7XG5cdFx0cmV0dXJuIHN0YXRlID09PSAwID8gdG9QZW5kaW5nU3RhdGUoKVxuXHRcdFx0IDogc3RhdGUgPiAwICAgPyB0b0Z1bGZpbGxlZFN0YXRlKGhhbmRsZXIudmFsdWUpXG5cdFx0XHQgICAgICAgICAgICAgICA6IHRvUmVqZWN0ZWRTdGF0ZShoYW5kbGVyLnZhbHVlKTtcblx0fVxuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG5cbi8qKlxuICogUHJvbWlzZXMvQSsgYW5kIHdoZW4oKSBpbXBsZW1lbnRhdGlvblxuICogd2hlbiBpcyBwYXJ0IG9mIHRoZSBjdWpvSlMgZmFtaWx5IG9mIGxpYnJhcmllcyAoaHR0cDovL2N1am9qcy5jb20vKVxuICogQGF1dGhvciBCcmlhbiBDYXZhbGllclxuICogQGF1dGhvciBKb2huIEhhbm5cbiAqL1xuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHR2YXIgdGltZWQgPSByZXF1aXJlKCcuL2xpYi9kZWNvcmF0b3JzL3RpbWVkJyk7XG5cdHZhciBhcnJheSA9IHJlcXVpcmUoJy4vbGliL2RlY29yYXRvcnMvYXJyYXknKTtcblx0dmFyIGZsb3cgPSByZXF1aXJlKCcuL2xpYi9kZWNvcmF0b3JzL2Zsb3cnKTtcblx0dmFyIGZvbGQgPSByZXF1aXJlKCcuL2xpYi9kZWNvcmF0b3JzL2ZvbGQnKTtcblx0dmFyIGluc3BlY3QgPSByZXF1aXJlKCcuL2xpYi9kZWNvcmF0b3JzL2luc3BlY3QnKTtcblx0dmFyIGdlbmVyYXRlID0gcmVxdWlyZSgnLi9saWIvZGVjb3JhdG9ycy9pdGVyYXRlJyk7XG5cdHZhciBwcm9ncmVzcyA9IHJlcXVpcmUoJy4vbGliL2RlY29yYXRvcnMvcHJvZ3Jlc3MnKTtcblx0dmFyIHdpdGhUaGlzID0gcmVxdWlyZSgnLi9saWIvZGVjb3JhdG9ycy93aXRoJyk7XG5cdHZhciB1bmhhbmRsZWRSZWplY3Rpb24gPSByZXF1aXJlKCcuL2xpYi9kZWNvcmF0b3JzL3VuaGFuZGxlZFJlamVjdGlvbicpO1xuXHR2YXIgVGltZW91dEVycm9yID0gcmVxdWlyZSgnLi9saWIvVGltZW91dEVycm9yJyk7XG5cblx0dmFyIFByb21pc2UgPSBbYXJyYXksIGZsb3csIGZvbGQsIGdlbmVyYXRlLCBwcm9ncmVzcyxcblx0XHRpbnNwZWN0LCB3aXRoVGhpcywgdGltZWQsIHVuaGFuZGxlZFJlamVjdGlvbl1cblx0XHQucmVkdWNlKGZ1bmN0aW9uKFByb21pc2UsIGZlYXR1cmUpIHtcblx0XHRcdHJldHVybiBmZWF0dXJlKFByb21pc2UpO1xuXHRcdH0sIHJlcXVpcmUoJy4vbGliL1Byb21pc2UnKSk7XG5cblx0dmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9saWIvYXBwbHknKShQcm9taXNlKTtcblxuXHQvLyBQdWJsaWMgQVBJXG5cblx0d2hlbi5wcm9taXNlICAgICA9IHByb21pc2U7ICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBwZW5kaW5nIHByb21pc2Vcblx0d2hlbi5yZXNvbHZlICAgICA9IFByb21pc2UucmVzb2x2ZTsgICAgICAvLyBDcmVhdGUgYSByZXNvbHZlZCBwcm9taXNlXG5cdHdoZW4ucmVqZWN0ICAgICAgPSBQcm9taXNlLnJlamVjdDsgICAgICAgLy8gQ3JlYXRlIGEgcmVqZWN0ZWQgcHJvbWlzZVxuXG5cdHdoZW4ubGlmdCAgICAgICAgPSBsaWZ0OyAgICAgICAgICAgICAgICAgLy8gbGlmdCBhIGZ1bmN0aW9uIHRvIHJldHVybiBwcm9taXNlc1xuXHR3aGVuWyd0cnknXSAgICAgID0gYXR0ZW1wdDsgICAgICAgICAgICAgIC8vIGNhbGwgYSBmdW5jdGlvbiBhbmQgcmV0dXJuIGEgcHJvbWlzZVxuXHR3aGVuLmF0dGVtcHQgICAgID0gYXR0ZW1wdDsgICAgICAgICAgICAgIC8vIGFsaWFzIGZvciB3aGVuLnRyeVxuXG5cdHdoZW4uaXRlcmF0ZSAgICAgPSBQcm9taXNlLml0ZXJhdGU7ICAgICAgLy8gREVQUkVDQVRFRCAodXNlIGN1am9qcy9tb3N0IHN0cmVhbXMpIEdlbmVyYXRlIGEgc3RyZWFtIG9mIHByb21pc2VzXG5cdHdoZW4udW5mb2xkICAgICAgPSBQcm9taXNlLnVuZm9sZDsgICAgICAgLy8gREVQUkVDQVRFRCAodXNlIGN1am9qcy9tb3N0IHN0cmVhbXMpIEdlbmVyYXRlIGEgc3RyZWFtIG9mIHByb21pc2VzXG5cblx0d2hlbi5qb2luICAgICAgICA9IGpvaW47ICAgICAgICAgICAgICAgICAvLyBKb2luIDIgb3IgbW9yZSBwcm9taXNlc1xuXG5cdHdoZW4uYWxsICAgICAgICAgPSBhbGw7ICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSBhIGxpc3Qgb2YgcHJvbWlzZXNcblx0d2hlbi5zZXR0bGUgICAgICA9IHNldHRsZTsgICAgICAgICAgICAgICAvLyBTZXR0bGUgYSBsaXN0IG9mIHByb21pc2VzXG5cblx0d2hlbi5hbnkgICAgICAgICA9IGxpZnQoUHJvbWlzZS5hbnkpOyAgICAvLyBPbmUtd2lubmVyIHJhY2Vcblx0d2hlbi5zb21lICAgICAgICA9IGxpZnQoUHJvbWlzZS5zb21lKTsgICAvLyBNdWx0aS13aW5uZXIgcmFjZVxuXHR3aGVuLnJhY2UgICAgICAgID0gbGlmdChQcm9taXNlLnJhY2UpOyAgIC8vIEZpcnN0LXRvLXNldHRsZSByYWNlXG5cblx0d2hlbi5tYXAgICAgICAgICA9IG1hcDsgICAgICAgICAgICAgICAgICAvLyBBcnJheS5tYXAoKSBmb3IgcHJvbWlzZXNcblx0d2hlbi5maWx0ZXIgICAgICA9IGZpbHRlcjsgICAgICAgICAgICAgICAvLyBBcnJheS5maWx0ZXIoKSBmb3IgcHJvbWlzZXNcblx0d2hlbi5yZWR1Y2UgICAgICA9IGxpZnQoUHJvbWlzZS5yZWR1Y2UpOyAgICAgICAvLyBBcnJheS5yZWR1Y2UoKSBmb3IgcHJvbWlzZXNcblx0d2hlbi5yZWR1Y2VSaWdodCA9IGxpZnQoUHJvbWlzZS5yZWR1Y2VSaWdodCk7ICAvLyBBcnJheS5yZWR1Y2VSaWdodCgpIGZvciBwcm9taXNlc1xuXG5cdHdoZW4uaXNQcm9taXNlTGlrZSA9IGlzUHJvbWlzZUxpa2U7ICAgICAgLy8gSXMgc29tZXRoaW5nIHByb21pc2UtbGlrZSwgYWthIHRoZW5hYmxlXG5cblx0d2hlbi5Qcm9taXNlICAgICA9IFByb21pc2U7ICAgICAgICAgICAgICAvLyBQcm9taXNlIGNvbnN0cnVjdG9yXG5cdHdoZW4uZGVmZXIgICAgICAgPSBkZWZlcjsgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEge3Byb21pc2UsIHJlc29sdmUsIHJlamVjdH0gdHVwbGVcblxuXHQvLyBFcnJvciB0eXBlc1xuXG5cdHdoZW4uVGltZW91dEVycm9yID0gVGltZW91dEVycm9yO1xuXG5cdC8qKlxuXHQgKiBHZXQgYSB0cnVzdGVkIHByb21pc2UgZm9yIHgsIG9yIGJ5IHRyYW5zZm9ybWluZyB4IHdpdGggb25GdWxmaWxsZWRcblx0ICpcblx0ICogQHBhcmFtIHsqfSB4XG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBvbkZ1bGZpbGxlZCBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiB4IGlzXG5cdCAqICAgc3VjY2Vzc2Z1bGx5IGZ1bGZpbGxlZC4gIElmIHByb21pc2VPclZhbHVlIGlzIGFuIGltbWVkaWF0ZSB2YWx1ZSwgY2FsbGJhY2tcblx0ICogICB3aWxsIGJlIGludm9rZWQgaW1tZWRpYXRlbHkuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBvblJlamVjdGVkIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuIHggaXNcblx0ICogICByZWplY3RlZC5cblx0ICogQHBhcmFtIHtmdW5jdGlvbj99IG9uUHJvZ3Jlc3MgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gcHJvZ3Jlc3MgdXBkYXRlc1xuXHQgKiAgIGFyZSBpc3N1ZWQgZm9yIHguIEBkZXByZWNhdGVkXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfSBhIG5ldyBwcm9taXNlIHRoYXQgd2lsbCBmdWxmaWxsIHdpdGggdGhlIHJldHVyblxuXHQgKiAgIHZhbHVlIG9mIGNhbGxiYWNrIG9yIGVycmJhY2sgb3IgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgcHJvbWlzZU9yVmFsdWUgaWZcblx0ICogICBjYWxsYmFjayBhbmQvb3IgZXJyYmFjayBpcyBub3Qgc3VwcGxpZWQuXG5cdCAqL1xuXHRmdW5jdGlvbiB3aGVuKHgsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzKSB7XG5cdFx0dmFyIHAgPSBQcm9taXNlLnJlc29sdmUoeCk7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG5cdFx0XHRyZXR1cm4gcDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcC50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHByb21pc2Ugd2hvc2UgZmF0ZSBpcyBkZXRlcm1pbmVkIGJ5IHJlc29sdmVyLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlciBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QsIG5vdGlmeSlcblx0ICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hvc2UgZmF0ZSBpcyBkZXRlcm1pbmUgYnkgcmVzb2x2ZXJcblx0ICovXG5cdGZ1bmN0aW9uIHByb21pc2UocmVzb2x2ZXIpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZnQgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uLCBjcmVhdGluZyBhIHZlcnNpb24gb2YgZiB0aGF0IHJldHVybnNcblx0ICogcHJvbWlzZXMsIGFuZCBhY2NlcHRzIHByb21pc2VzIGFzIGFyZ3VtZW50cy5cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IHZlcnNpb24gb2YgZiB0aGF0IHJldHVybnMgcHJvbWlzZXNcblx0ICovXG5cdGZ1bmN0aW9uIGxpZnQoZikge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGZvcih2YXIgaT0wLCBsPWFyZ3VtZW50cy5sZW5ndGgsIGE9bmV3IEFycmF5KGwpOyBpPGw7ICsraSkge1xuXHRcdFx0XHRhW2ldID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFwcGx5KGYsIHRoaXMsIGEpO1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbCBmIGluIGEgZnV0dXJlIHR1cm4sIHdpdGggdGhlIHN1cHBsaWVkIGFyZ3MsIGFuZCByZXR1cm4gYSBwcm9taXNlXG5cdCAqIGZvciB0aGUgcmVzdWx0LlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHQgKi9cblx0ZnVuY3Rpb24gYXR0ZW1wdChmIC8qLCBhcmdzLi4uICovKSB7XG5cdFx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cblx0XHRmb3IodmFyIGk9MCwgbD1hcmd1bWVudHMubGVuZ3RoLTEsIGE9bmV3IEFycmF5KGwpOyBpPGw7ICsraSkge1xuXHRcdFx0YVtpXSA9IGFyZ3VtZW50c1tpKzFdO1xuXHRcdH1cblx0XHRyZXR1cm4gYXBwbHkoZiwgdGhpcywgYSk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHtwcm9taXNlLCByZXNvbHZlcn0gcGFpciwgZWl0aGVyIG9yIGJvdGggb2Ygd2hpY2hcblx0ICogbWF5IGJlIGdpdmVuIG91dCBzYWZlbHkgdG8gY29uc3VtZXJzLlxuXHQgKiBAcmV0dXJuIHt7cHJvbWlzZTogUHJvbWlzZSwgcmVzb2x2ZTogZnVuY3Rpb24sIHJlamVjdDogZnVuY3Rpb24sIG5vdGlmeTogZnVuY3Rpb259fVxuXHQgKi9cblx0ZnVuY3Rpb24gZGVmZXIoKSB7XG5cdFx0cmV0dXJuIG5ldyBEZWZlcnJlZCgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gRGVmZXJyZWQoKSB7XG5cdFx0dmFyIHAgPSBQcm9taXNlLl9kZWZlcigpO1xuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZSh4KSB7IHAuX2hhbmRsZXIucmVzb2x2ZSh4KTsgfVxuXHRcdGZ1bmN0aW9uIHJlamVjdCh4KSB7IHAuX2hhbmRsZXIucmVqZWN0KHgpOyB9XG5cdFx0ZnVuY3Rpb24gbm90aWZ5KHgpIHsgcC5faGFuZGxlci5ub3RpZnkoeCk7IH1cblxuXHRcdHRoaXMucHJvbWlzZSA9IHA7XG5cdFx0dGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcblx0XHR0aGlzLnJlamVjdCA9IHJlamVjdDtcblx0XHR0aGlzLm5vdGlmeSA9IG5vdGlmeTtcblx0XHR0aGlzLnJlc29sdmVyID0geyByZXNvbHZlOiByZXNvbHZlLCByZWplY3Q6IHJlamVjdCwgbm90aWZ5OiBub3RpZnkgfTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHggaXMgcHJvbWlzZS1saWtlLCBpLmUuIGEgdGhlbmFibGUgb2JqZWN0XG5cdCAqIE5PVEU6IFdpbGwgcmV0dXJuIHRydWUgZm9yICphbnkgdGhlbmFibGUgb2JqZWN0KiwgYW5kIGlzbid0IHRydWx5XG5cdCAqIHNhZmUsIHNpbmNlIGl0IG1heSBhdHRlbXB0IHRvIGFjY2VzcyB0aGUgYHRoZW5gIHByb3BlcnR5IG9mIHggKGkuZS5cblx0ICogIGNsZXZlci9tYWxpY2lvdXMgZ2V0dGVycyBtYXkgZG8gd2VpcmQgdGhpbmdzKVxuXHQgKiBAcGFyYW0geyp9IHggYW55dGhpbmdcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgeCBpcyBwcm9taXNlLWxpa2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzUHJvbWlzZUxpa2UoeCkge1xuXHRcdHJldHVybiB4ICYmIHR5cGVvZiB4LnRoZW4gPT09ICdmdW5jdGlvbic7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBvbmx5IG9uY2UgYWxsIHRoZSBzdXBwbGllZCBhcmd1bWVudHNcblx0ICogaGF2ZSByZXNvbHZlZC4gVGhlIHJlc29sdXRpb24gdmFsdWUgb2YgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSBhbiBhcnJheVxuXHQgKiBjb250YWluaW5nIHRoZSByZXNvbHV0aW9uIHZhbHVlcyBvZiBlYWNoIG9mIHRoZSBhcmd1bWVudHMuXG5cdCAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzIG1heSBiZSBhIG1peCBvZiBwcm9taXNlcyBhbmQgdmFsdWVzXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHQgKi9cblx0ZnVuY3Rpb24gam9pbigvKiAuLi5wcm9taXNlcyAqLykge1xuXHRcdHJldHVybiBQcm9taXNlLmFsbChhcmd1bWVudHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGZ1bGZpbGwgb25jZSBhbGwgaW5wdXQgcHJvbWlzZXMgaGF2ZVxuXHQgKiBmdWxmaWxsZWQsIG9yIHJlamVjdCB3aGVuIGFueSBvbmUgaW5wdXQgcHJvbWlzZSByZWplY3RzLlxuXHQgKiBAcGFyYW0ge2FycmF5fFByb21pc2V9IHByb21pc2VzIGFycmF5IChvciBwcm9taXNlIGZvciBhbiBhcnJheSkgb2YgcHJvbWlzZXNcblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqL1xuXHRmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcblx0XHRyZXR1cm4gd2hlbihwcm9taXNlcywgUHJvbWlzZS5hbGwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGFsd2F5cyBmdWxmaWxsIHdpdGggYW4gYXJyYXkgY29udGFpbmluZ1xuXHQgKiB0aGUgb3V0Y29tZSBzdGF0ZXMgb2YgYWxsIGlucHV0IHByb21pc2VzLiAgVGhlIHJldHVybmVkIHByb21pc2Vcblx0ICogd2lsbCBvbmx5IHJlamVjdCBpZiBgcHJvbWlzZXNgIGl0c2VsZiBpcyBhIHJlamVjdGVkIHByb21pc2UuXG5cdCAqIEBwYXJhbSB7YXJyYXl8UHJvbWlzZX0gcHJvbWlzZXMgYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiBwcm9taXNlc1xuXHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSBmb3IgYXJyYXkgb2Ygc2V0dGxlZCBzdGF0ZSBkZXNjcmlwdG9yc1xuXHQgKi9cblx0ZnVuY3Rpb24gc2V0dGxlKHByb21pc2VzKSB7XG5cdFx0cmV0dXJuIHdoZW4ocHJvbWlzZXMsIFByb21pc2Uuc2V0dGxlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQcm9taXNlLWF3YXJlIGFycmF5IG1hcCBmdW5jdGlvbiwgc2ltaWxhciB0byBgQXJyYXkucHJvdG90eXBlLm1hcCgpYCxcblx0ICogYnV0IGlucHV0IGFycmF5IG1heSBjb250YWluIHByb21pc2VzIG9yIHZhbHVlcy5cblx0ICogQHBhcmFtIHtBcnJheXxQcm9taXNlfSBwcm9taXNlcyBhcnJheSBvZiBhbnl0aGluZywgbWF5IGNvbnRhaW4gcHJvbWlzZXMgYW5kIHZhbHVlc1xuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKHg6KiwgaW5kZXg6TnVtYmVyKToqfSBtYXBGdW5jIG1hcCBmdW5jdGlvbiB3aGljaCBtYXlcblx0ICogIHJldHVybiBhIHByb21pc2Ugb3IgdmFsdWVcblx0ICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgdGhhdCB3aWxsIGZ1bGZpbGwgd2l0aCBhbiBhcnJheSBvZiBtYXBwZWQgdmFsdWVzXG5cdCAqICBvciByZWplY3QgaWYgYW55IGlucHV0IHByb21pc2UgcmVqZWN0cy5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChwcm9taXNlcywgbWFwRnVuYykge1xuXHRcdHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbihwcm9taXNlcykge1xuXHRcdFx0cmV0dXJuIFByb21pc2UubWFwKHByb21pc2VzLCBtYXBGdW5jKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGaWx0ZXIgdGhlIHByb3ZpZGVkIGFycmF5IG9mIHByb21pc2VzIHVzaW5nIHRoZSBwcm92aWRlZCBwcmVkaWNhdGUuICBJbnB1dCBtYXlcblx0ICogY29udGFpbiBwcm9taXNlcyBhbmQgdmFsdWVzXG5cdCAqIEBwYXJhbSB7QXJyYXl8UHJvbWlzZX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgYW5kIHZhbHVlc1xuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKHg6KiwgaW5kZXg6TnVtYmVyKTpib29sZWFufSBwcmVkaWNhdGUgZmlsdGVyaW5nIHByZWRpY2F0ZS5cblx0ICogIE11c3QgcmV0dXJuIHRydXRoeSAob3IgcHJvbWlzZSBmb3IgdHJ1dGh5KSBmb3IgaXRlbXMgdG8gcmV0YWluLlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IHdpbGwgZnVsZmlsbCB3aXRoIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGl0ZW1zXG5cdCAqICBmb3Igd2hpY2ggcHJlZGljYXRlIHJldHVybmVkIHRydXRoeS5cblx0ICovXG5cdGZ1bmN0aW9uIGZpbHRlcihwcm9taXNlcywgcHJlZGljYXRlKSB7XG5cdFx0cmV0dXJuIHdoZW4ocHJvbWlzZXMsIGZ1bmN0aW9uKHByb21pc2VzKSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5maWx0ZXIocHJvbWlzZXMsIHByZWRpY2F0ZSk7XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gd2hlbjtcbn0pO1xufSkodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9KTtcbiIsIi8vIEltcG9ydCByZXF1aXJlbWVudHMgdXNpbmcgYnJvd3NlcmlmeVxud2luZG93LlZ1ZSA9IHJlcXVpcmUoJ3Z1ZScpXG53aW5kb3cuVnVlUm91dGVyID0gcmVxdWlyZSgndnVlLXJvdXRlcicpXG5cbi8vIEluc2VydCB2dWUtcm91dGVyIGFuZCB2dWUtcmVzb3VyY2UgaW50byBWdWVcblxuLy8gSW1wb3J0IHRoZSBhY3R1YWwgcm91dGVzLCBhbGlhc2VzLCAuLi5cbmltcG9ydCB7IGNvbmZpZ1JvdXRlciB9IGZyb20gJy4vcm91dGVzJ1xuXG4vLyBDcmVhdGUgb3VyIHJvdXRlciBvYmplY3QgYW5kIHNldCBvcHRpb25zIG9uIGl0XG5jb25zdCByb3V0ZXIgPSBuZXcgVnVlUm91dGVyKClcblxuLy8gSW5qZWN0IHRoZSByb3V0ZXMgaW50byB0aGUgVnVlUm91dGVyIG9iamVjdFxuY29uZmlnUm91dGVyKHJvdXRlcilcblxuLy8gQ29uZmlndXJlIHRoZSBhcHBsaWNhdGlvblxud2luZG93LmNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJylcblZ1ZS5jb25maWcuZGVidWcgPSB0cnVlXG5cbi8vIENvbmZpZ3VyZSBvdXIgSFRUUCBjbGllbnRcbnZhciByZXN0ID0gcmVxdWlyZSgncmVzdCcpXG52YXIgcGF0aFByZWZpeCA9IHJlcXVpcmUoJ3Jlc3QvaW50ZXJjZXB0b3IvcGF0aFByZWZpeCcpXG52YXIgbWltZSA9IHJlcXVpcmUoJ3Jlc3QvaW50ZXJjZXB0b3IvbWltZScpXG52YXIgZGVmYXVsdFJlcXVlc3QgPSByZXF1aXJlKCdyZXN0L2ludGVyY2VwdG9yL2RlZmF1bHRSZXF1ZXN0JylcbnZhciBlcnJvckNvZGUgPSByZXF1aXJlKCdyZXN0L2ludGVyY2VwdG9yL2Vycm9yQ29kZScpXG52YXIgaW50ZXJjZXB0b3IgPSByZXF1aXJlKCdyZXN0L2ludGVyY2VwdG9yJylcbnZhciBqd3RBdXRoID0gcmVxdWlyZSgnLi9pbnRlcmNlcHRvcnMvand0QXV0aCcpXG5cbndpbmRvdy5jbGllbnQgPSByZXN0LndyYXAocGF0aFByZWZpeCwgeyBwcmVmaXg6IGNvbmZpZy5hcGkuYmFzZV91cmwgfSlcbiAgICAgICAgICAgICAgICAgICAgLndyYXAobWltZSlcbiAgICAgICAgICAgICAgICAgICAgLndyYXAoZGVmYXVsdFJlcXVlc3QsIGNvbmZpZy5hcGkuZGVmYXVsdFJlcXVlc3QpXG4gICAgICAgICAgICAgICAgICAgIC53cmFwKGVycm9yQ29kZSwgeyBjb2RlOiA0MDAgfSlcbiAgICAgICAgICAgICAgICAgICAgLndyYXAoand0QXV0aCk7XG5cbi8vIEJvb3RzdHJhcCB0aGUgYXBwXG5WdWUuY29tcG9uZW50KCduYXYtY29tcG9uZW50JywgcmVxdWlyZSgnLi9jb21waWxlZC9uYXYudnVlJykpXG5WdWUuY29tcG9uZW50KCdmb290ZXItY29tcG9uZW50JywgcmVxdWlyZSgnLi9jb21waWxlZC9mb290ZXIudnVlJykpXG5jb25zdCBBcHAgPSBWdWUuZXh0ZW5kKHJlcXVpcmUoJy4vY29tcGlsZWQvYXBwLnZ1ZScpKVxucm91dGVyLnN0YXJ0KEFwcCwgJyNhcHAnKVxud2luZG93LnJvdXRlciA9IHJvdXRlclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7XG5cbiAgICB0aGlzLiRvbigndXNlckhhc0xvZ2dlZE91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZGVzdHJveUxvZ2luKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRvbigndXNlckhhc0xvZ2dlZEluJywgZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHRoaXMuc2V0TG9naW4odXNlcik7XG4gICAgfSk7XG5cbiAgICAvLyBUaGUgYXBwIGhhcyBqdXN0IGJlZW4gaW5pdGlhbGl6ZWQsIGNoZWNrIGlmIHdlIGNhbiBnZXQgdGhlIHVzZXIgZGF0YSB3aXRoIGFuIGFscmVhZHkgZXhpc3RpbmcgdG9rZW5cbiAgICB2YXIgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnand0LXRva2VuJyk7XG4gICAgaWYgKHRva2VuICE9PSBudWxsICYmIHRva2VuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgY2xpZW50KHsgcGF0aDogJy91c2Vycy9tZScgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgLy8gVXNlciBoYXMgc3VjY2Vzc2Z1bGx5IGxvZ2dlZCBpbiB1c2luZyB0aGUgdG9rZW4gZnJvbSBzdG9yYWdlXG4gICAgICAgIHRoYXQuc2V0TG9naW4ocmVzcG9uc2UuZW50aXR5LnVzZXIpO1xuICAgICAgICAvLyBicm9hZGNhc3QgYW4gZXZlbnQgdGVsbGluZyBvdXIgY2hpbGRyZW4gdGhhdCB0aGUgZGF0YSBpcyByZWFkeSBhbmQgdmlld3MgY2FuIGJlIHJlbmRlcmVkXG4gICAgICAgIHRoYXQuJGJyb2FkY2FzdCgnZGF0YS1sb2FkZWQnKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAvLyBMb2dpbiB3aXRoIG91ciB0b2tlbiBmYWlsZWQsIGRvIHNvbWUgY2xlYW51cCBhbmQgcmVkaXJlY3QgaWYgd2UncmUgb24gYW4gYXV0aGVudGljYXRlZCByb3V0ZVxuICAgICAgICB0aGF0LmRlc3Ryb3lMb2dpbigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXI6IG51bGwsXG4gICAgICB0b2tlbjogbnVsbCxcbiAgICAgIGF1dGhlbnRpY2F0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG5cbiAgICBzZXRMb2dpbjogZnVuY3Rpb24gc2V0TG9naW4odXNlcikge1xuICAgICAgLy8gU2F2ZSBsb2dpbiBpbmZvIGluIG91ciBkYXRhIGFuZCBzZXQgaGVhZGVyIGluIGNhc2UgaXQncyBub3Qgc2V0IGFscmVhZHlcbiAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgICB0aGlzLmF1dGhlbnRpY2F0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy50b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdqd3QtdG9rZW4nKTtcbiAgICB9LFxuXG4gICAgZGVzdHJveUxvZ2luOiBmdW5jdGlvbiBkZXN0cm95TG9naW4odXNlcikge1xuICAgICAgLy8gQ2xlYW51cCB3aGVuIHRva2VuIHdhcyBpbnZhbGlkIG91ciB1c2VyIGhhcyBsb2dnZWQgb3V0XG4gICAgICB0aGlzLnVzZXIgPSBudWxsO1xuICAgICAgdGhpcy50b2tlbiA9IG51bGw7XG4gICAgICB0aGlzLmF1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdqd3QtdG9rZW4nKTtcbiAgICAgIGlmICh0aGlzLiRyb3V0ZS5hdXRoKSB0aGlzLiRyb3V0ZS5yb3V0ZXIuZ28oJy9hdXRoL2xvZ2luJyk7XG4gICAgfVxuICB9XG5cbn07XG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIlxcbjxyb3V0ZXItdmlldz48L3JvdXRlci12aWV3PlwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9sdmEvU2l0ZXMvYWx0ZXJuYXRpdmV0L3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvYXBwLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmtzOiB7XG4gICAgICAgIGZhY2Vib29rOiAnYWx0ZXJuYXRpdmV0LnBhcnR5JyxcbiAgICAgICAgdHdpdHRlcjogJ0FsdGVybmF0aXZldF9ubycsXG4gICAgICAgIGdpdGh1YjogJ3BhcnRpYWx0ZXJuYXRpdmV0J1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIlxcbjxkaXYgc3R5bGU9XFxcIm1hcmdpbi10b3A6IDEyNXB4O1xcXCI+XFxuXFx0PCEtLSBQdXNoIEZvb3RlciAtLT5cXG48L2Rpdj5cXG48Zm9vdGVyIGNsYXNzPVxcXCJmb290ZXJcXFwiPlxcblxcdDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCIgc3R5bGU9XFxcImNvbG9yOiAjNzc3O1xcXCI+XFxuXFx0XFx0PCEtLSBDb21wYW55IEluZm9ybWF0aW9uIC0tPlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcInB1bGwtbGVmdFxcXCIgc3R5bGU9XFxcInBhZGRpbmctdG9wOiAyOHB4O1xcXCI+XFxuXFx0XFx0XFx0QWx0ZXJuYXRpdmV0XFxuXFx0XFx0PC9kaXY+XFxuXFx0XFx0PCEtLSBTb2NpYWwgSWNvbnMgLS0+XFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwicHVsbC1yaWdodCBmb290ZXItc29jaWFsLWljb25zXFxcIj5cXG5cXHRcXHRcXHQ8YSBocmVmPVxcXCJodHRwOi8vZmFjZWJvb2suY29tL3t7IGxpbmtzLmZhY2Vib29rIH19XFxcIj5cXG5cXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtYnRuIGZhLWZhY2Vib29rLXNxdWFyZVxcXCI+PC9pPlxcblxcdFxcdFxcdDwvYT5cXG5cXHRcXHRcXHQ8YSBocmVmPVxcXCJodHRwOi8vdHdpdHRlci5jb20ve3sgbGlua3MudHdpdHRlciB9fVxcXCI+XFxuXFx0XFx0XFx0XFx0PGkgY2xhc3M9XFxcImZhIGZhLWJ0biBmYS10d2l0dGVyLXNxdWFyZVxcXCI+PC9pPlxcblxcdFxcdFxcdDwvYT5cXG5cXHRcXHRcXHQ8IS0tXFxuXFx0XFx0XFx0PGEgaHJlZj1cXFwiaHR0cDovL2dpdGh1Yi5jb20ve3sgbGlua3MuZ2l0aHViIH19XFxcIj5cXG5cXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtZ2l0aHViLXNxdWFyZVxcXCI+PC9pPlxcblxcdFxcdFxcdDwvYT5cXG5cXHRcXHRcXHQtLT5cXG5cXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeFxcXCI+PC9kaXY+XFxuXFx0PC9kaXY+XFxuPC9mb290ZXI+XFxuXCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL2x2YS9TaXRlcy9hbHRlcm5hdGl2ZXQvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9mb290ZXIudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmF2VGl0bGU6ICdBbHRlcm5hdGl2ZXQnXG4gICAgfTtcbiAgfVxufTtcbjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPCEtLSBOYXZpZ2F0aW9uIC0tPlxcbjxuYXYgY2xhc3M9XFxcIm5hdmJhciBuYXZiYXItZGVmYXVsdFxcXCI+XFxuXFx0PGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJuYXZiYXItaGVhZGVyXFxcIj5cXG5cXHRcXHRcXHQ8IS0tIENvbGxhcHNlZCBIYW1idXJnZXIgLS0+XFxuXFx0XFx0XFx0PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJuYXZiYXItdG9nZ2xlIGNvbGxhcHNlZFxcXCIgZGF0YS10b2dnbGU9XFxcImNvbGxhcHNlXFxcIiBkYXRhLXRhcmdldD1cXFwiI2JzLWV4YW1wbGUtbmF2YmFyLWNvbGxhcHNlLTFcXFwiPlxcblxcdFxcdFxcdFxcdDxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5Ta3J1IG5hdmlnYXNqb24gYXYvcMOlPC9zcGFuPlxcblxcdFxcdFxcdFxcdDxzcGFuIGNsYXNzPVxcXCJpY29uLWJhclxcXCI+PC9zcGFuPlxcblxcdFxcdFxcdFxcdDxzcGFuIGNsYXNzPVxcXCJpY29uLWJhclxcXCI+PC9zcGFuPlxcblxcdFxcdFxcdFxcdDxzcGFuIGNsYXNzPVxcXCJpY29uLWJhclxcXCI+PC9zcGFuPlxcblxcdFxcdFxcdDwvYnV0dG9uPlxcblxcdFxcdFxcdDwhLS0gQnJhbmRpbmcgSW1hZ2UgLS0+XFxuXFx0XFx0XFx0PGEgY2xhc3M9XFxcIm5hdmJhci1icmFuZFxcXCIgdi1saW5rPVxcXCJ7IHBhdGg6ICcvJyB9XFxcIiBzdHlsZT1cXFwicGFkZGluZy10b3A6IDE5cHg7XFxcIj5cXG5cXHRcXHRcXHRcXHQ8c3BhbiBjbGFzcz1cXFwic3Itb25seVxcXCI+e3sgbmF2VGl0bGUgfX08L3NwYW4+XFxuXFx0XFx0XFx0PC9hPlxcblxcdFxcdDwvZGl2PlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbGxhcHNlIG5hdmJhci1jb2xsYXBzZVxcXCIgaWQ9XFxcImJzLWV4YW1wbGUtbmF2YmFyLWNvbGxhcHNlLTFcXFwiPlxcblxcdFxcdFxcdDx1bCBjbGFzcz1cXFwibmF2IG5hdmJhci1uYXZcXFwiPlxcblxcdFxcdFxcdFxcdDwhLS08bGk+PGEgdi1saW5rPVxcXCJ7IHBhdGg6ICcvaG9tZScgfVxcXCI+SGplbTwvYT48L2xpPi0tPlxcblxcdFxcdFxcdFxcdDwhLS08bGk+PGEgdi1saW5rPVxcXCJ7IHBhdGg6ICcvZG9ncycgfVxcXCIgdi1pZj1cXFwiJHJvb3QuYXV0aGVudGljYXRlZFxcXCI+SHVuZGVyPC9hPjwvbGk+LS0+XFxuXFx0XFx0XFx0PC91bD5cXG5cXHRcXHRcXHQ8IS0tIFJpZ2h0IFNpZGUgT2YgTmF2YmFyIC0tPlxcblxcdFxcdFxcdDx1bCBjbGFzcz1cXFwibmF2IG5hdmJhci1uYXYgbmF2YmFyLXJpZ2h0XFxcIj5cXG5cXHRcXHRcXHRcXHQ8bGk+PGEgdi1saW5rPVxcXCJ7IHBhdGg6ICcvbWFuaWZlc3QnIH1cXFwiPk1hbmlmZXN0PC9hPjwvbGk+XFxuXFx0XFx0XFx0XFx0PGxpPjxhIHYtbGluaz1cXFwieyBwYXRoOiAnL29tJyB9XFxcIj5PbSBvc3M8L2E+PC9saT5cXG5cXHRcXHRcXHRcXHQ8bGk+PGEgdi1saW5rPVxcXCJ7IHBhdGg6ICcvc3BvcnNtYWwnIH1cXFwiPlNww7hyc23DpWwgb2cgc3ZhcjwvYT48L2xpPlxcblxcdFxcdFxcdFxcdDwhLS08bGk+PGEgaHJlZj1cXFwiaHR0cDovL3dpa2kuYWx0ZXJuYXRpdmV0LnBhcnR5XFxcIj5XaWtpPC9hPjwvbGk+LS0+XFxuXFx0XFx0XFx0XFx0PCEtLSBMb2dpbiAvIFJlZ2lzdHJhdGlvbiBMaW5rcyBmb3IgdW5hdXRoZW50aWNhdGVkIHVzZXJzIC0tPlxcblxcdFxcdFxcdFxcdDxsaSB2LWlmPVxcXCIgISAkcm9vdC5hdXRoZW50aWNhdGVkXFxcIj48YSBjbGFzcz1cXFwiYXV0aFxcXCIgdi1saW5rPVxcXCJ7IHBhdGg6ICcvbG9naW4nIH1cXFwiPkxvZ2cgaW5uPC9hPjwvbGk+XFxuXFx0XFx0XFx0XFx0PGxpIHYtaWY9XFxcIiAhICRyb290LmF1dGhlbnRpY2F0ZWRcXFwiPjxhIGNsYXNzPVxcXCJhdXRoIG91dGxpbmVcXFwiIHYtbGluaz1cXFwieyBwYXRoOiAnL3JlZ2lzdGVyJyB9XFxcIj5CbGkgbWVkbGVtPC9hPjwvbGk+XFxuXFx0XFx0XFx0XFx0PCEtLSBBdXRoZW50aWNhdGVkIFJpZ2h0IERyb3Bkb3duIC0tPlxcblxcdFxcdFxcdFxcdDxsaSBjbGFzcz1cXFwiZHJvcGRvd25cXFwiIHYtaWY9XFxcIiRyb290LmF1dGhlbnRpY2F0ZWRcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJkcm9wZG93bi10b2dnbGVcXFwiIGRhdGEtdG9nZ2xlPVxcXCJkcm9wZG93blxcXCIgcm9sZT1cXFwiYnV0dG9uXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJmYWxzZVxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0e3sgJHJvb3QudXNlci5uYW1lIH19IDxzcGFuIGNsYXNzPVxcXCJjYXJldFxcXCI+PC9zcGFuPlxcblxcdFxcdFxcdFxcdFxcdDwvYT5cXG5cXG5cXHRcXHRcXHRcXHRcXHQ8dWwgY2xhc3M9XFxcImRyb3Bkb3duLW1lbnVcXFwiIHJvbGU9XFxcIm1lbnVcXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdDwhLS0gU2V0dGluZ3MgLS0+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PGxpIGNsYXNzPVxcXCJkcm9wZG93bi1oZWFkZXJcXFwiPklubnN0aWxsaW5nZXI8L2xpPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxsaT5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8YSB2LWxpbms9XFxcInsgcGF0aDogJy9hdXRoL3Byb2ZpbGUnIH1cXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1idG4gZmEtZncgZmEtdXNlclxcXCI+PC9pPk1pbiBwcm9maWxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2E+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9saT5cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8IS0tIExvZ291dCAtLT5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8bGkgY2xhc3M9XFxcImRpdmlkZXJcXFwiPjwvbGk+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PGxpPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxhIHYtbGluaz1cXFwieyBwYXRoOiAnL2F1dGgvbG9nb3V0JyB9XFxcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtYnRuIGZhLWZ3IGZhLXNpZ24tb3V0XFxcIj48L2k+TG9nZyB1dFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvYT5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L2xpPlxcblxcdFxcdFxcdFxcdFxcdDwvdWw+XFxuXFx0XFx0XFx0XFx0PC9saT5cXG5cXHRcXHRcXHQ8L3VsPlxcblxcdFxcdDwvZGl2PlxcblxcdDwvZGl2PlxcbjwvbmF2PlwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9sdmEvU2l0ZXMvYWx0ZXJuYXRpdmV0L3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvbmF2LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsInZhciBfX3Z1ZWlmeV9zdHlsZV9fID0gcmVxdWlyZShcInZ1ZWlmeS1pbnNlcnQtY3NzXCIpLmluc2VydChcIlxcbi50aXRsZSB7XFxuICAgIGNvbG9yOiAjOTk5O1xcbiAgICBmb250LXdlaWdodDogMjAwO1xcbiAgICBmb250LXNpemU6IDQwcHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDQwcHg7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgbWFyZ2luLXRvcDogMjAlO1xcbn1cXG4udGl0bGUgYSB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBtYXJnaW4tdG9wOiAyMHB4O1xcbn1cXG4udGl0bGUgYTpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XCIpXG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImNvbnRhaW5lci1mbHVpZFxcXCI+XFxuXFx0PGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtM1xcXCI+PC9kaXY+XFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLW1kLTYgdGl0bGVcXFwiPlxcblxcdFxcdFxcdEJla2xhZ2VyLCB2aSBmYW50IGlra2Ugc2lkYSBkdSBzZXIgZXR0ZXIgOiAoPGJyPlxcblxcdFxcdFxcdDxhIGhyZWY9XFxcIi9cXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jYXJldC1sZWZ0XFxcIj48L2k+IEfDpSB0aWxiYWtlIHRpbCBmb3JzaWRhPC9hPlxcblxcdFxcdDwvZGl2PlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbC1tZC0zXFxcIj48L2Rpdj5cXG5cXHQ8L2Rpdj5cXG48L2Rpdj5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvbHZhL1NpdGVzL2FsdGVybmF0aXZldC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzLzQwNC52dWVcIlxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKCkge1xuICAgIHJlcXVpcmUoXCJ2dWVpZnktaW5zZXJ0LWNzc1wiKS5jYWNoZVtcIlxcbi50aXRsZSB7XFxuICAgIGNvbG9yOiAjOTk5O1xcbiAgICBmb250LXdlaWdodDogMjAwO1xcbiAgICBmb250LXNpemU6IDQwcHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDQwcHg7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgbWFyZ2luLXRvcDogMjAlO1xcbn1cXG4udGl0bGUgYSB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBtYXJnaW4tdG9wOiAyMHB4O1xcbn1cXG4udGl0bGUgYTpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XCJdID0gZmFsc2VcbiAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKF9fdnVlaWZ5X3N0eWxlX18pXG4gIH0pXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPG5hdi1jb21wb25lbnQ+PC9uYXYtY29tcG9uZW50PlxcbjxkaXYgY2xhc3M9XFxcImNvbnRhaW5lciBhcHAtc2NyZWVuXFxcIj5cXG5cXHQ8IS0tIFRhYnMgLS0+XFxuXFx0PGRpdiBjbGFzcz1cXFwiY29sLW1kLTNcXFwiPlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcInBhbmVsIHBhbmVsLWRlZmF1bHQgcGFuZWwtZmx1c2hcXFwiPlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInBhbmVsLWhlYWRpbmdcXFwiPlxcblxcdFxcdFxcdFxcdE1pbmUgc2lkZXJcXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJhcHAtdGFic1xcXCI+XFxuXFx0XFx0XFx0XFx0XFx0PHVsIGNsYXNzPVxcXCJuYXYgYXBwLXRhYnMtc3RhY2tlZFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PGxpIHYtaWY9XFxcIiEgJHJvb3QuYXV0aGVudGljYXRlZFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGEgdi1saW5rPVxcXCJ7IHBhdGg6ICcvYXV0aC9sb2dpbicgfVxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGkgY2xhc3M9XFxcImZhIGZhLWJ0biBmYS1mdyBmYS1zaWduLWluXFxcIj48L2k+Jm5ic3A7TG9nZyBpbm5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2E+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9saT5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8bGkgdi1pZj1cXFwiISAkcm9vdC5hdXRoZW50aWNhdGVkXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8YSB2LWxpbms9XFxcInsgcGF0aDogJy9hdXRoL3JlZ2lzdGVyJyB9XFxcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtYnRuIGZhLWZ3IGZhLWNoZXZyb24tY2lyY2xlLXVwXFxcIj48L2k+Jm5ic3A7QmxpIG1lZGxlbVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvYT5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L2xpPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxsaSB2LWlmPVxcXCIkcm9vdC5hdXRoZW50aWNhdGVkXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8YSB2LWxpbms9XFxcInsgcGF0aDogJy9hdXRoL3Byb2ZpbGUnIH1cXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1idG4gZmEtZncgZmEtdXNlclxcXCI+PC9pPiZuYnNwO01pbiBwcm9maWxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2E+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9saT5cXG5cXHRcXHRcXHRcXHRcXHQ8L3VsPlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdDwvZGl2PlxcblxcdDwvZGl2PlxcblxcdDwhLS0gVGFiIFBhbmVzIC0tPlxcblxcdDxkaXYgY2xhc3M9XFxcImNvbC1tZC05XFxcIj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJ0YWItY29udGVudFxcXCI+XFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwidGFiLXBhbmVcXFwiPlxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInBhbmVsIHBhbmVsLWRlZmF1bHRcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxyb3V0ZXItdmlldz48L3JvdXRlci12aWV3PlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdDwvZGl2PjwhLS0gRW5kIHRhYiBwYW5lbCAtLT5cXG5cXHRcXHQ8L2Rpdj48IS0tIEVuZCB0YWIgY29udGVudCAtLT5cXG5cXHQ8L2Rpdj48IS0tIEVuZCB0YWIgcGFuZXMgY29sLW1kLTkgLS0+XFxuPC9kaXY+PCEtLSBFbmQgY29udGFpbmVyIC0tPlxcbjxmb290ZXItY29tcG9uZW50PjwvZm9vdGVyLWNvbXBvbmVudD5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvbHZhL1NpdGVzL2FsdGVybmF0aXZldC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL2F1dGgudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICByb3V0ZToge1xuICAgIGFjdGl2YXRlOiBmdW5jdGlvbiBhY3RpdmF0ZSh0cmFuc2l0aW9uKSB7XG4gICAgICB0aGlzLiRyb290LmF1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuJHJvb3QudXNlciA9IG51bGw7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlcicpO1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2p3dC10b2tlbicpO1xuICAgICAgdHJhbnNpdGlvbi5yZWRpcmVjdCgnLycpO1xuICAgIH1cbiAgfVxuXG59O1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvbHZhL1NpdGVzL2FsdGVybmF0aXZldC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL2F1dGgvbG9nb3V0LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZ1xcXCI+XFxuXFx0TWluIHByb2ZpbFxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiPlxcblxcdDwhLS0gPGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5XFxcIiB2LW9uPVxcXCJjbGljazogZmV0Y2hcXFwiPkZldGNoPC9idXR0b24+IC0tPlxcblxcdDx0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtYm9yZGVyZWRcXFwiIHYtaWY9XFxcIiRyb290LnVzZXJcXFwiPlxcblxcdFxcdDx0Ym9keT48dHI+XFxuXFx0XFx0XFx0PHRoPiM8L3RoPlxcblxcdFxcdFxcdDx0aD5OYXZuPC90aD5cXG5cXHRcXHRcXHQ8dGg+RS1wb3N0PC90aD5cXG5cXHRcXHQ8L3RyPlxcblxcdFxcdDx0cj5cXG5cXHRcXHRcXHQ8dGQ+e3sgJHJvb3QudXNlci5pZCB9fTwvdGQ+XFxuXFx0XFx0XFx0PHRkPnt7ICRyb290LnVzZXIubmFtZSB9fTwvdGQ+XFxuXFx0XFx0XFx0PHRkPnt7ICRyb290LnVzZXIuZW1haWwgfX08L3RkPlxcblxcdFxcdDwvdHI+XFxuXFx0PC90Ym9keT48L3RhYmxlPlxcbjwvZGl2PlwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9sdmEvU2l0ZXMvYWx0ZXJuYXRpdmV0L3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvYXV0aC9wcm9maWxlLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPG5hdi1jb21wb25lbnQ+PC9uYXYtY29tcG9uZW50PlxcbjxkaXYgY2xhc3M9XFxcImNvbnRhaW5lciBhcHAtc2NyZWVuXFxcIj5cXG5cXHQ8IS0tIFRhYnMgLS0+XFxuXFx0PGRpdiBjbGFzcz1cXFwiY29sLW1kLTNcXFwiPlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcInBhbmVsIHBhbmVsLWRlZmF1bHQgcGFuZWwtZmx1c2hcXFwiPlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInBhbmVsLWhlYWRpbmdcXFwiPlxcblxcdFxcdFxcdFxcdEh1bmRlciFcXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJhcHAtdGFic1xcXCI+XFxuXFx0XFx0XFx0XFx0XFx0PHVsIGNsYXNzPVxcXCJuYXYgYXBwLXRhYnMtc3RhY2tlZFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PGxpPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxhIHYtbGluaz1cXFwieyBwYXRoOiAnL2RvZ3MnIH1cXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1idG4gZmEtZncgZmEtbGlzdFxcXCI+PC9pPiZuYnNwO0xpc3RlIG92ZXIgaHVuZGVyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9hPlxcblxcdFxcdFxcdFxcdFxcdFxcdDwvbGk+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxuXFx0XFx0XFx0XFx0XFx0XFx0PGxpPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxhIHYtbGluaz1cXFwieyBwYXRoOiAnL2RvZ3MvY3JlYXRlJyB9XFxcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtYnRuIGZhLWZ3IGZhLWhlYXJ0XFxcIj48L2k+Jm5ic3A7T3BwcmV0dCBueVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvYT5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L2xpPlxcblxcdFxcdFxcdFxcdFxcdDwvdWw+XFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0PC9kaXY+XFxuXFx0PC9kaXY+XFxuXFx0PCEtLSBUYWIgUGFuZXMgLS0+XFxuXFx0PGRpdiBjbGFzcz1cXFwiY29sLW1kLTlcXFwiPlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcInRhYi1jb250ZW50XFxcIj5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJ0YWItcGFuZVxcXCI+XFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwicGFuZWwgcGFuZWwtZGVmYXVsdFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0PHJvdXRlci12aWV3Pjwvcm91dGVyLXZpZXc+XFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0PC9kaXY+PCEtLSBFbmQgdGFiIHBhbmVsIC0tPlxcblxcdFxcdDwvZGl2PjwhLS0gRW5kIHRhYiBjb250ZW50IC0tPlxcblxcdDwvZGl2PjwhLS0gRW5kIHRhYiBwYW5lcyBjb2wtbWQtOSAtLT5cXG48L2Rpdj48IS0tIEVuZCBjb250YWluZXIgLS0+XFxuPGZvb3Rlci1jb21wb25lbnQ+PC9mb290ZXItY29tcG9uZW50PlxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9sdmEvU2l0ZXMvYWx0ZXJuYXRpdmV0L3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvZG9ncy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkb2c6IHtcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIGFnZTogJydcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlczogW11cbiAgICB9O1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBjcmVhdGVEb2c6IGZ1bmN0aW9uIGNyZWF0ZURvZyhlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICBjbGllbnQoeyBwYXRoOiAnZG9ncycsIGVudGl0eTogdGhpcy5kb2cgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UsIHN0YXR1cykge1xuICAgICAgICB0aGF0LmRvZy5uYW1lID0gJyc7XG4gICAgICAgIHRoYXQuZG9nLmFnZSA9ICcnO1xuICAgICAgICB0aGF0Lm1lc3NhZ2VzID0gW3sgdHlwZTogJ3N1Y2Nlc3MnLCBtZXNzYWdlOiAnV29vZiB3b29mISBZb3VyIGRvZyB3YXMgY3JlYXRlZCcgfV07XG4gICAgICAgIFZ1ZS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25hbWVJbnB1dCcpLmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlc3BvbnNlLCBzdGF0dXMpIHtcbiAgICAgICAgdGhhdC5tZXNzYWdlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcmVzcG9uc2UuZW50aXR5KSB7XG4gICAgICAgICAgdGhhdC5tZXNzYWdlcy5wdXNoKHsgdHlwZTogJ2RhbmdlcicsIG1lc3NhZ2U6IHJlc3BvbnNlLmVudGl0eVtrZXldIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWhlYWRpbmdcXFwiPlxcblxcdE1ha2UgYSBkb2chXFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFxuXFx0PGRpdiBpZD1cXFwiYWxlcnRzXFxcIiB2LWlmPVxcXCJtZXNzYWdlcy5sZW5ndGggPiAwXFxcIj5cXG5cXHRcXHQ8ZGl2IHYtZm9yPVxcXCJtZXNzYWdlIGluIG1lc3NhZ2VzXFxcIiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQte3sgbWVzc2FnZS50eXBlIH19IGFsZXJ0LWRpc21pc3NpYmxlXFxcIiByb2xlPVxcXCJhbGVydFxcXCI+XFxuXFx0XFx0XFx0e3sgbWVzc2FnZS5tZXNzYWdlIH19XFxuXFx0XFx0PC9kaXY+XFxuXFx0PC9kaXY+XFxuXFx0PGZvcm0gY2xhc3M9XFxcImZvcm0taG9yaXpvbnRhbFxcXCIgcm9sZT1cXFwiZm9ybVxcXCIgdi1vbjpzdWJtaXQ9XFxcImNyZWF0ZURvZ1xcXCI+XFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuXFx0XFx0XFx0PGxhYmVsIGZvcj1cXFwibmFtZVxcXCIgY2xhc3M9XFxcImNvbC1zbS0yIGNvbC1zbS1vZmZzZXQtMSBjb250cm9sLWxhYmVsXFxcIj5OYW1lIHlvdXIgZG9nPC9sYWJlbD5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtc20tNVxcXCI+XFxuXFx0XFx0XFx0XFx0PGlucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIHJlcXVpcmVkPVxcXCJyZXF1aXJlZFxcXCIgbmFtZT1cXFwibmFtZVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgdi1tb2RlbD1cXFwiZG9nLm5hbWVcXFwiIGlkPVxcXCJuYW1lSW5wdXRcXFwiPlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdDwvZGl2PlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcblxcdFxcdFxcdDxsYWJlbCBmb3I9XFxcImFnZVxcXCIgY2xhc3M9XFxcImNvbC1zbS0yIGNvbC1zbS1vZmZzZXQtMSBjb250cm9sLWxhYmVsXFxcIj5XaGF0J3MgdGhlIGFnZT88L2xhYmVsPlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbC1zbS01XFxcIj5cXG5cXHRcXHRcXHRcXHQ8aW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgcmVxdWlyZWQ9XFxcInJlcXVpcmVkXFxcIiBuYW1lPVxcXCJhZ2VcXFwiIHR5cGU9XFxcInRleHRcXFwiIHYtbW9kZWw9XFxcImRvZy5hZ2VcXFwiPlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdDwvZGl2PlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbC1zbS00IGNvbC1zbS1vZmZzZXQtM1xcXCI+XFxuXFx0XFx0XFx0XFx0PGJ1dHRvbiB0eXBlPVxcXCJzdWJtaXRcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnlcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1idG4gZmEtc2F2ZVxcXCI+PC9pPk1ha2UgdGhlIGRvZyE8L2J1dHRvbj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXHQ8L2Zvcm0+XFxuPC9kaXY+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL2x2YS9TaXRlcy9hbHRlcm5hdGl2ZXQvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9kb2dzL2NyZWF0ZS52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvZ3M6IFtdLFxuICAgICAgbWVzc2FnZXM6IFtdXG4gICAgfTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgLy8gTGV0J3MgZmV0Y2ggc29tZSBkb2dzXG4gICAgZmV0Y2g6IGZ1bmN0aW9uIGZldGNoKHN1Y2Nlc3NIYW5kbGVyKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICBjbGllbnQoeyBwYXRoOiAnL2RvZ3MnIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIExvb2sgbWEhIFB1cHBpZXMhXG4gICAgICAgIHRoYXQuJHNldCgnZG9ncycsIHJlc3BvbnNlLmVudGl0eS5kYXRhKTtcbiAgICAgICAgc3VjY2Vzc0hhbmRsZXIocmVzcG9uc2UuZW50aXR5LmRhdGEpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlc3BvbnNlLCBzdGF0dXMpIHtcbiAgICAgICAgaWYgKF8uY29udGFpbnMoWzQwMSwgNTAwXSwgc3RhdHVzKSkge1xuICAgICAgICAgIHRoYXQuJGRpc3BhdGNoKCd1c2VySGFzTG9nZ2VkT3V0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBkZWxldGVEb2c6IGZ1bmN0aW9uIGRlbGV0ZURvZyhpbmRleCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgY2xpZW50KHsgcGF0aDogJy9kb2dzLycgKyB0aGlzLmRvZ3NbaW5kZXhdLmlkLCBtZXRob2Q6ICdERUxFVEUnIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHRoYXQuZG9ncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGF0Lm1lc3NhZ2VzID0gW3sgdHlwZTogJ3N1Y2Nlc3MnLCBtZXNzYWdlOiAnR3JlYXQsIGRvZyBwdXJnZWQuJyB9XTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB0aGF0Lm1lc3NhZ2VzLnB1c2goeyB0eXBlOiAnZGFuZ2VyJywgbWVzc2FnZTogJ1RoZXJlIHdhcyBhIHByb2JsZW0gcmVtb3ZpbmcgdGhlIGRvZycgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSxcblxuICByb3V0ZToge1xuICAgIC8vIE9vaCwgb29oLCBhcmUgdGhlcmUgYW55IG5ldyBwdXBwaWVzIHlldD9cbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKHRyYW5zaXRpb24pIHtcbiAgICAgIHRoaXMuZmV0Y2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5uZXh0KHsgZG9nczogZGF0YSB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG59O1xuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIj5cXG5cXHRMaXN0IG9mIGRvZ3NcXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIiB2LWlmPVxcXCIkbG9hZGluZ1JvdXRlRGF0YVxcXCI+XFxuXFx0TG9hZGluZyBkYXRhIHt7IGxvYWRpbmdSb3V0ZURhdGEgfX1cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIiB2LWlmPVxcXCJtZXNzYWdlcy5sZW5ndGggPiAwXFxcIj5cXG5cXHQ8ZGl2IHYtZm9yPVxcXCJtZXNzYWdlIGluIG1lc3NhZ2VzXFxcIiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQte3sgbWVzc2FnZS50eXBlIH19IGFsZXJ0LWRpc21pc3NpYmxlXFxcIiByb2xlPVxcXCJhbGVydFxcXCI+XFxuXFx0XFx0e3sgbWVzc2FnZS5tZXNzYWdlIH19XFxuXFx0PC9kaXY+XFxuPC9kaXY+XFxuXFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCIgdi1pZj1cXFwiZG9ncy5sZW5ndGggPT0gMFxcXCI+XFxuXFx0WW91IGhhdmUgbm8gZG9ncyFcXG48L2Rpdj5cXG5cXG48dGFibGUgY2xhc3M9XFxcInRhYmxlXFxcIiB2LWlmPVxcXCIgISAkbG9hZGluZ1JvdXRlRGF0YSAmYW1wOyZhbXA7IGRvZ3MubGVuZ3RoID4gMFxcXCI+XFxuXFx0PHRoZWFkPlxcblxcdFxcdDx0cj5cXG5cXHRcXHRcXHQ8dGg+SUQ8L3RoPlxcblxcdFxcdFxcdDx0aD5OYW1lPC90aD5cXG5cXHRcXHRcXHQ8dGg+QWdlPC90aD5cXG5cXHRcXHRcXHQ8dGggd2lkdGg9XFxcIjEyMHB4XFxcIj5BY3Rpb25zPC90aD5cXG5cXHRcXHQ8L3RyPlxcblxcdDwvdGhlYWQ+XFxuXFx0PHRib2R5PlxcblxcdFxcdDx0ciB2LWZvcj1cXFwiZG9nIGluIGRvZ3NcXFwiPlxcblxcdFxcdFxcdDx0ZD57eyBkb2cuaWQgfX08L3RkPlxcblxcdFxcdFxcdDx0ZD57eyBkb2cubmFtZSB9fTwvdGQ+XFxuXFx0XFx0XFx0PHRkPnt7IGRvZy5hZ2UgfX08L3RkPlxcblxcdFxcdFxcdDx0ZD5cXG5cXHRcXHRcXHRcXHQ8YSBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi14c1xcXCIgdi1saW5rPVxcXCJ7IHBhdGg6ICcvZG9ncy8nK2RvZy5pZCB9XFxcIj5FZGl0PC9hPlxcblxcdFxcdFxcdFxcdDxhIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnkgYnRuLXhzXFxcIiB2LW9uOmNsaWNrPVxcXCJkZWxldGVEb2coJGluZGV4KVxcXCI+RGVsZXRlPC9hPlxcblxcdFxcdFxcdDwvdGQ+XFxuXFx0XFx0PC90cj5cXG5cXHQ8L3Rib2R5PlxcbjwvdGFibGU+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL2x2YS9TaXRlcy9hbHRlcm5hdGl2ZXQvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9kb2dzL2luZGV4LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZG9nOiB7XG4gICAgICAgIGlkOiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICBhZ2U6IG51bGxcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlczogW11cbiAgICB9O1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICAvLyBMZXQncyBmZXRjaCB0aGUgZG9nXG4gICAgZmV0Y2g6IGZ1bmN0aW9uIGZldGNoKGlkLCBzdWNjZXNzSGFuZGxlcikge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgY2xpZW50KHsgcGF0aDogJy9kb2dzLycgKyBpZCB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB0aGF0LiRzZXQoJ2RvZycsIHJlc3BvbnNlLmVudGl0eS5kYXRhKTtcbiAgICAgICAgc3VjY2Vzc0hhbmRsZXIocmVzcG9uc2UuZW50aXR5LmRhdGEpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlc3BvbnNlLCBzdGF0dXMsIHJlcXVlc3QpIHtcbiAgICAgICAgLy8gR28gdGVsbCB5b3VyIHBhcmVudHMgdGhhdCB5b3UndmUgbWVzc2VkIHVwIHNvbWVob3dcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgc2VsZi4kZGlzcGF0Y2goJ3VzZXJIYXNMb2dnZWRPdXQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB1cGRhdGVEb2c6IGZ1bmN0aW9uIHVwZGF0ZURvZyhlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBjbGllbnQoeyBwYXRoOiAnL2RvZ3MvJyArIHRoaXMuZG9nLmlkLCBlbnRpdHk6IHRoaXMuZG9nLCBtZXRob2Q6ICdQVVQnIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHNlbGYubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgc2VsZi5tZXNzYWdlcy5wdXNoKHsgdHlwZTogJ3N1Y2Nlc3MnLCBtZXNzYWdlOiAnV29vZiB3b29mISBZb3VyIGRvZyB3YXMgdXBkYXRlZCcgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgc2VsZi5tZXNzYWdlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcmVzcG9uc2UuZW50aXR5KSB7XG4gICAgICAgICAgc2VsZi5tZXNzYWdlcy5wdXNoKHsgdHlwZTogJ2RhbmdlcicsIG1lc3NhZ2U6IHJlc3BvbnNlLmVudGl0eVtrZXldIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSxcblxuICByb3V0ZToge1xuICAgIC8vIE9vaCwgb29oLCBhcmUgdGhlcmUgYW55IG5ldyBwdXBwaWVzIHlldD9cbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKHRyYW5zaXRpb24pIHtcbiAgICAgIHRoaXMuZmV0Y2godGhpcy4kcm91dGUucGFyYW1zLmlkLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0cmFuc2l0aW9uLm5leHQoeyBkb2c6IGRhdGEgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWhlYWRpbmdcXFwiPlxcblxcdEVkaXQgZG9nXFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFxuXFx0PGRpdiBpZD1cXFwiYWxlcnRzXFxcIiB2LWlmPVxcXCJtZXNzYWdlcy5sZW5ndGggPiAwXFxcIj5cXG5cXHRcXHQ8ZGl2IHYtZm9yPVxcXCJtZXNzYWdlIGluIG1lc3NhZ2VzXFxcIiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQte3sgbWVzc2FnZS50eXBlIH19IGFsZXJ0LWRpc21pc3NpYmxlXFxcIiByb2xlPVxcXCJhbGVydFxcXCI+XFxuXFx0XFx0XFx0e3sgbWVzc2FnZS5tZXNzYWdlIH19XFxuXFx0XFx0PC9kaXY+XFxuXFx0PC9kaXY+XFxuXFx0PGZvcm0gY2xhc3M9XFxcImZvcm0taG9yaXpvbnRhbFxcXCIgcm9sZT1cXFwiZm9ybVxcXCIgdi1vbjpzdWJtaXQ9XFxcInVwZGF0ZURvZ1xcXCI+XFxuXFx0PGZpZWxkc2V0IGRpc2FibGVkPVxcXCJcXFwiPlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcblxcdFxcdFxcdDxsYWJlbCBmb3I9XFxcIm5hbWVcXFwiIGNsYXNzPVxcXCJjb2wtc20tMiBjb2wtc20tb2Zmc2V0LTEgY29udHJvbC1sYWJlbFxcXCI+RG9nIElEPC9sYWJlbD5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtc20tNVxcXCI+XFxuXFx0XFx0XFx0XFx0PGlucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIHJlcXVpcmVkPVxcXCJyZXF1aXJlZFxcXCIgbmFtZT1cXFwibmFtZVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgdi1tb2RlbD1cXFwiZG9nLmlkXFxcIj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXHQ8L2ZpZWxkc2V0PlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcblxcdFxcdFxcdDxsYWJlbCBmb3I9XFxcIm5hbWVcXFwiIGNsYXNzPVxcXCJjb2wtc20tMiBjb2wtc20tb2Zmc2V0LTEgY29udHJvbC1sYWJlbFxcXCI+TmFtZSB5b3VyIGRvZzwvbGFiZWw+XFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLXNtLTVcXFwiPlxcblxcdFxcdFxcdFxcdDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiByZXF1aXJlZD1cXFwicmVxdWlyZWRcXFwiIG5hbWU9XFxcIm5hbWVcXFwiIHR5cGU9XFxcInRleHRcXFwiIHYtbW9kZWw9XFxcImRvZy5uYW1lXFxcIj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHRcXHQ8bGFiZWwgZm9yPVxcXCJhZ2VcXFwiIGNsYXNzPVxcXCJjb2wtc20tMiBjb2wtc20tb2Zmc2V0LTEgY29udHJvbC1sYWJlbFxcXCI+V2hhdCdzIHRoZSBhZ2U/PC9sYWJlbD5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtc20tNVxcXCI+XFxuXFx0XFx0XFx0XFx0PGlucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIHJlcXVpcmVkPVxcXCJyZXF1aXJlZFxcXCIgbmFtZT1cXFwiYWdlXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiB2LW1vZGVsPVxcXCJkb2cuYWdlXFxcIj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtc20tNCBjb2wtc20tb2Zmc2V0LTNcXFwiPlxcblxcdFxcdFxcdFxcdDxidXR0b24gdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5XFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtYnRuIGZhLXNhdmVcXFwiPjwvaT5VcGRhdGUgdGhlIGRvZyE8L2J1dHRvbj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXHQ8L2Zvcm0+XFxuPC9kaXY+XFxuXCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL2x2YS9TaXRlcy9hbHRlcm5hdGl2ZXQvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9kb2dzL3Nob3cudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48bmF2LWNvbXBvbmVudD48L25hdi1jb21wb25lbnQ+XFxuPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTEyXFxcIj5cXG4gICAgICAgIDxwPlxcbiAgICAgICAgICAgIEZvcnNpZGVcXG4gICAgICAgIDwvcD5cXG4gICAgPC9kaXY+PCEtLSBFbmQgdGFiIHBhbmVzIGNvbC1tZC05IC0tPlxcbjwvZGl2PjwhLS0gRW5kIGNvbnRhaW5lciAtLT5cXG48Zm9vdGVyLWNvbXBvbmVudD48L2Zvb3Rlci1jb21wb25lbnQ+XFxuXCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL2x2YS9TaXRlcy9hbHRlcm5hdGl2ZXQvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9ob21lLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXNlcjoge1xuICAgICAgICBlbWFpbDogbnVsbCxcbiAgICAgICAgcGFzc3dvcmQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlczogW11cbiAgICB9O1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBhdHRlbXB0OiBmdW5jdGlvbiBhdHRlbXB0KGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIGNsaWVudCh7IHBhdGg6ICdsb2dpbicsIGVudGl0eTogdGhpcy51c2VyIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHRoYXQuJGRpc3BhdGNoKCd1c2VySGFzRmV0Y2hlZFRva2VuJywgcmVzcG9uc2UudG9rZW4pO1xuICAgICAgICB0aGF0LmdldFVzZXJEYXRhKCk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdGhhdC5tZXNzYWdlcyA9IFtdO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICYmIHJlc3BvbnNlLnN0YXR1cy5jb2RlID09PSA0MDEpIHRoYXQubWVzc2FnZXMucHVzaCh7IHR5cGU6ICdkYW5nZXInLCBtZXNzYWdlOiAnQmVrbGFnZXIsIGJydWtlcm5hdm4gZWxsZXIgcGFzc29yZCBlciBmZWlsLicgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0VXNlckRhdGE6IGZ1bmN0aW9uIGdldFVzZXJEYXRhKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgY2xpZW50KHsgcGF0aDogJy91c2Vycy9tZScgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdGhhdC4kZGlzcGF0Y2goJ3VzZXJIYXNMb2dnZWRJbicsIHJlc3BvbnNlLmVudGl0eS51c2VyKTtcbiAgICAgICAgdGhhdC4kcm91dGUucm91dGVyLmdvKCcvYXV0aC9wcm9maWxlJyk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJvdXRlOiB7XG4gICAgYWN0aXZhdGU6IGZ1bmN0aW9uIGFjdGl2YXRlKHRyYW5zaXRpb24pIHtcbiAgICAgIHRoaXMuJGRpc3BhdGNoKCd1c2VySGFzTG9nZ2VkT3V0Jyk7XG4gICAgICB0cmFuc2l0aW9uLm5leHQoKTtcbiAgICB9XG4gIH1cbn07XG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIlxcbjxuYXYtY29tcG9uZW50PjwvbmF2LWNvbXBvbmVudD5cXG48ZGl2IGNsYXNzPVxcXCJjb250YWluZXIgYXBwLXNjcmVlblxcXCI+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0xMlxcXCI+XFxuICAgICAgICA8Zm9ybSBjbGFzcz1cXFwiZm9ybS1ob3Jpem9udGFsXFxcIiByb2xlPVxcXCJmb3JtXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGlkPVxcXCJhbGVydHNcXFwiIHYtaWY9XFxcIm1lc3NhZ2VzLmxlbmd0aCA+IDBcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IHYtZm9yPVxcXCJtZXNzYWdlIGluIG1lc3NhZ2VzXFxcIiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQte3sgbWVzc2FnZS50eXBlIH19IGFsZXJ0LWRpc21pc3NpYmxlXFxcIiByb2xlPVxcXCJhbGVydFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICB7eyBtZXNzYWdlLm1lc3NhZ2UgfX1cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwiY29sLW1kLTQgY29udHJvbC1sYWJlbFxcXCI+RS1wb3N0PC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTZcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcImVtYWlsXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiB2LW1vZGVsPVxcXCJ1c2VyLmVtYWlsXFxcIj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwiY29sLW1kLTQgY29udHJvbC1sYWJlbFxcXCI+UGFzc29yZDwvbGFiZWw+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC02XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJwYXNzd29yZFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdi1tb2RlbD1cXFwidXNlci5wYXNzd29yZFxcXCI+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNiBjb2wtbWQtb2Zmc2V0LTRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJzdWJtaXRcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnlcXFwiIHYtb246Y2xpY2s9XFxcImF0dGVtcHRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1idG4gZmEtc2lnbi1pblxcXCI+PC9pPkxvZ2cgaW5uXFxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiIHYtbGluaz1cXFwieyBwYXRoOiAnL3JlZ2lzdGVyJyB9XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICBPcHByZXR0IGJydWtlclxcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgdi1saW5rPVxcXCJ7IHBhdGg6ICcvYXV0aC9mb3Jnb3QnIH1cXFwiPkdsZW10IHBhc3NvcmRldD88L2E+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9mb3JtPlxcbiAgICA8L2Rpdj5cXG48L2Rpdj48IS0tIEVuZCBjb250YWluZXIgLS0+XFxuPGZvb3Rlci1jb21wb25lbnQ+PC9mb290ZXItY29tcG9uZW50PlxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9sdmEvU2l0ZXMvYWx0ZXJuYXRpdmV0L3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvbG9naW4udnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwidmFyIF9fdnVlaWZ5X3N0eWxlX18gPSByZXF1aXJlKFwidnVlaWZ5LWluc2VydC1jc3NcIikuaW5zZXJ0KFwiXFxuLm1hbmlmZXN0IHtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG4ubWFuaWZlc3QgaDIge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiAxZW07XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBmb250LXNpemU6IDIuNGVtO1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcbn1cXG5cXG4ubWFuaWZlc3QgaGVhZGVyIGgyIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogLjVlbTtcXG59XFxuXFxuLm1hbmlmZXN0IHAge1xcbiAgICBmb250LXNpemU6IDEuM2VtO1xcbiAgICBtYXJnaW4tYm90dG9tOiAxLjRlbTtcXG59XFxuXFxuLm1hbmlmZXN0IHAgc3Bhbi5sZWFkIHtcXG4gICAgZm9udC1zaXplOiAxZW07XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcbn1cIilcbjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPG5hdi1jb21wb25lbnQ+PC9uYXYtY29tcG9uZW50PlxcbjxkaXYgY2xhc3M9XFxcImNvbnRhaW5lciBhcHAtc2NyZWVuIG1hbmlmZXN0XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTFcXFwiPlxcblxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTlcXFwiPlxcbiAgICAgICAgPGhlYWRlcj5cXG4gICAgICAgICAgICA8aDI+TWFuaWZlc3Q8L2gyPlxcbiAgICAgICAgICAgIDxwPkRldCBlciBhbGx0aWQgZXQgYWx0ZXJuYXRpdiE8L3A+XFxuICAgICAgICA8L2hlYWRlcj5cXG4gICAgICAgIDxwPjxzcGFuIGNsYXNzPVxcXCJsZWFkXFxcIj5BbHRlcm5hdGl2ZXQgZXIgZW4gcG9saXRpc2sgaWTDqTwvc3Bhbj48YnI+b20gcGVyc29ubGlnIGZyaWhldCwgc29zaWFsIHZlcmRpZ2hldCBvZyBsZXZlbmRlLCBiw6ZyZWtyYWZ0aWdlIGZlbGxlc3NrYXAuIEV0IGjDpXAuIEVuIGRyw7htLiBFbiBsZW5nc2VsIGV0dGVyIG1lbmluZywgYmV0eWRuaW5nIG9nIG1lZG1lbm5lc2tlbGlnZSByZWxhc2pvbmVyLiBBbHRlcm5hdGl2ZXQgZXIgZXQgc3ZhciBww6UgZGV0IHNvbSBza2plciBpIHZlcmRlbiBpIGRhZy4gUnVuZHQgb3NzLiBNZWQgb3NzLjwvcD5cXG4gICAgICAgIDxwPjxzcGFuIGNsYXNzPVxcXCJsZWFkXFxcIj5BbHRlcm5hdGl2ZXQgZXIgZXQgb3Bwcm9wPC9zcGFuPjxicj5tb3Qga3luaXNtZW4sIG1hbmdlbGVuIHDDpSByYXVzaGV0IG9nIGV0IHNhbWZ1bm4gc29tIHNwYXJrZXIgbmVkb3Zlci48L3A+XFxuICAgICAgICA8cD48c3BhbiBjbGFzcz1cXFwibGVhZFxcXCI+QWx0ZXJuYXRpdmV0IGVyIGdsZWRlLjwvc3Bhbj48YnI+VXRlbiBodW1vciBpbmdlbiBrcmVhdGl2aXRldC4gVXRlbiBrcmVhdGl2aXRldCBpbmdlbiBnb2RlIGlkw6llci4gVXRlbiBnb2RlIGlkw6llciBpbmdlbiBza2FwZXJrcmFmdC4gVXRlbiBza2FwZXJrcmFmdCBpbnRldCByZXN1bHRhdC48L3A+XFxuICAgICAgICA8cD48c3BhbiBjbGFzcz1cXFwibGVhZFxcXCI+QWx0ZXJuYXRpdmV0IGVyIGVuIHBvc2l0aXYgbW90a3JhZnQuPC9zcGFuPjxicj5FbiBseXN0IHRpbCDDpSBrb21tZSBtZWQgcmVlbGxlIG9nIHNlcmnDuHNlIHN2YXIgcMOlIG1pbGrDuC0gb2cgcmVzc3Vyc2tyaXNlbiBzb20gam9yZGVuIGJlZmlubmVyIHNlZyBpLiBFbiBrcmlzZSBzb20gZm9yIGh2ZXIgZGFnIGZvcnZlcnJlciB2w6VyZSBlZ25lLCB2w6VyZSBiYXJucyBvZyB2w6VyZSBiYXJuZWJhcm5zIG11bGlnaGV0ZXIgZm9yIGV0IGdvZHQsIHJpa3Qgb2cgbWVuaW5nc2Z5bHQgbGl2LjwvcD5cXG4gICAgICAgIDxwPjxzcGFuIGNsYXNzPVxcXCJsZWFkXFxcIj5BbHRlcm5hdGl2ZXQgZXIgbnlzZ2plcnJpZ2hldDwvc3Bhbj48YnI+cMOlIGh2b3JkYW4gdmkgdXR2aWtsZXIgYnlnZGVuZSwgYnllbmUgb2cgbmFzam9uZW5lIHbDpXJlLiBWaSB2aWwgc2VsdiB0YSB2YXJlIHDDpSDDuGtvbm9taWVuIG9nIGRlIGRlbW9rcmF0aXNrZSBiZXNsdXRuaW5nZW5lIHDDpSBhcmJlaWRzcGxhc3NlbmUgb2cgaSBsb2thbHNhbWZ1bm5lbmUgZGVyIHZpIGxldmVyIHbDpXJlIGxpdi4gVmkgbWlzdGVyIGxpa2V2ZWwgaWtrZSBkZXQgZ2xvYmFsZSB1dHN5bmV0IG9nIGFuc3ZhcmV0IGZvciDDpSBmaW5uZSBmZWxsZXMgbMO4c25pbmdlciBtZWQgYsOlZGUgdsOlcmUgbmFib2VyIG9nIG1lZCBkZSBzb20gYm9yIHDDpSBkZW4gYW5kcmUgc2lkZW4gYXYga2xvZGVuLjwvcD5cXG4gICAgICAgIDxwPjxzcGFuIGNsYXNzPVxcXCJsZWFkXFxcIj5BbHRlcm5hdGl2ZXQgZXIgc2FtYXJiZWlkLjwvc3Bhbj48YnI+VmkgdmV0IGF0IHByaXZhdGUgdmlya3NvbWhldGVyIGlra2Uga2FuIGzDuHNlIHByb2JsZW1lbmUgYWxlbmUuIERldCBrYW4gaGVsbGVyIGlra2UgZGUgb2ZmZW50bGlnZSBpbnN0aXR1c2pvbmVuZSBlbGxlciBvcmdhbmlzYXNqb25zbGl2ZXQgZ2rDuHJlLiBEZXJmb3Igc2thbCB2aSBvcHBmaW5uZSBoZWx0IG55ZSBrb2JsaW5nZXIgb2cgc2FtYXJiZWlkc21vZGVsbGVyLCBkZXIgdmkgYnJ1a2VyIGRldCBiZXN0ZSBmcmEgZGV0IHByaXZhdGUsIGRldCBvZmZlbnRsaWdlIG9nIG9yZ2FuaXNhc2pvbnNsaXZldC48L3A+XFxuICAgICAgICA8cD48c3BhbiBjbGFzcz1cXFwibGVhZFxcXCI+QWx0ZXJuYXRpdmV0IGVyIMOlcGVuaGV0Ljwvc3Bhbj48YnI+VmkgdmlsIHByw7h2ZSBueWUgaWTDqWVyIG9nIHNrYXBlIGzDuHNuaW5nZXIgc29tIHZpcmtlci4gQWx0ZXJuYXRpdmV0IGVyIG9nc8OlIHN0cmViZW4gZXR0ZXIgw6UgZm9yc3TDpSBrb21wbGVrc2Ugc2FtbWVuaGVuZ2VyIG9nIG1vdHN0w6UgZnJpc3RlbHNlbiDDpSBiZW55dHRlIGZvcmVua2xlZGUgYXJndW1lbnRlciBvZyBiZWhhZ2VsaWdlIGlsbHVzam9uZXIuPC9wPlxcbiAgICAgICAgPHA+PHNwYW4gY2xhc3M9XFxcImxlYWRcXFwiPkFsdGVybmF0aXZldCBlciBtb3Q8L3NwYW4+PGJyPnRpbCDDpSBzZSBwcm9ibGVtZW5lIGkgw7h5bmVuZS4gTWVuIG9nc8OlIG1vdCB0aWwgw6UgbcO4dGUgZnJhbXRpZGEgdmkgaGFyIHNhbW1lbi48L3A+XFxuICAgICAgICA8cD48c3BhbiBjbGFzcz1cXFwibGVhZFxcXCI+QWx0ZXJuYXRpdmV0IGVyIGFsbGVyZWRlIHZpcmtlbGlnaGV0Ljwvc3Bhbj48YnI+UnVuZHQgb20gcMOlIGtsb2RlbiB2w6VyIGJsaXIgZGV0IGkgdsOlciB0aWQgc2thcHQgaGVsdCBueWUgaW5zdGl0dXNqb25zdHlwZXIsIG9yZ2FuaXNhc2pvbnNmb3JtZXIgb2cgc29zaWFsZSBuZXR0dmVyay4gT20gZGV0IHNramVyIGkgT3NsbywgS8O4YmVuaGF2biwgU2VvdWwsIER1cmJhbiBlbGxlciBSaW8gYmV0eXIgaWtrZSBzw6UgbXllIGh2ZXIgZm9yIHNlZywgbWVuIHRpbHNhbW1lbiB1dGdqw7hyIGRlIGVuIGxldmVkeWt0aWcgZ2xvYmFsIGVuZHJpbmdzYsO4bGdlLjwvcD5cXG4gICAgICAgIDxwPjxzcGFuIGNsYXNzPVxcXCJsZWFkXFxcIj5BbHRlcm5hdGl2ZXQgZXIgZm9yIGRlZzwvc3Bhbj48YnI+c29tIG1lcmtlciBhdCBub2UgZXIgaSBiZXZlZ2Vsc2UuIFNvbSBoYXIgZW4gZm9ybmVtbWVsc2UgYXYgYXQgbm9lIG55dHQgZXIgaSBmZXJkIG1lZCDDpSBhdmzDuHNlIGRldCBnYW1sZS4gRW4gYW5uZW4gbcOldGUgw6Ugc2UgcMOlIGRlbW9rcmF0aSwgdmVrc3QsIGFyYmVpZHNsaXYsIGFuc3ZhciBvZyBsaXZza3ZhbGl0ZXQuPGJyPlxcbiAgICAgICAgICAgIERldCBlciBBbHRlcm5hdGl2ZXQuPC9wPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTJcXFwiPlxcblxcbiAgICA8L2Rpdj5cXG48L2Rpdj48IS0tIEVuZCBjb250YWluZXIgLS0+XFxuPGZvb3Rlci1jb21wb25lbnQ+PC9mb290ZXItY29tcG9uZW50PlxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9sdmEvU2l0ZXMvYWx0ZXJuYXRpdmV0L3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvbWFuaWZlc3QudnVlXCJcbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICByZXF1aXJlKFwidnVlaWZ5LWluc2VydC1jc3NcIikuY2FjaGVbXCJcXG4ubWFuaWZlc3Qge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbi5tYW5pZmVzdCBoMiB7XFxuICAgIG1hcmdpbi10b3A6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IDFlbTtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIGZvbnQtc2l6ZTogMi40ZW07XFxuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxufVxcblxcbi5tYW5pZmVzdCBoZWFkZXIgaDIge1xcbiAgICBtYXJnaW4tYm90dG9tOiAuNWVtO1xcbn1cXG5cXG4ubWFuaWZlc3QgcCB7XFxuICAgIGZvbnQtc2l6ZTogMS4zZW07XFxuICAgIG1hcmdpbi1ib3R0b206IDEuNGVtO1xcbn1cXG5cXG4ubWFuaWZlc3QgcCBzcGFuLmxlYWQge1xcbiAgICBmb250LXNpemU6IDFlbTtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxufVwiXSA9IGZhbHNlXG4gICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChfX3Z1ZWlmeV9zdHlsZV9fKVxuICB9KVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCI7KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIlxcbjxuYXYtY29tcG9uZW50PjwvbmF2LWNvbXBvbmVudD5cXG48ZGl2IGNsYXNzPVxcXCJjb250YWluZXIgYXBwLXNjcmVlblxcXCI+XFxuXFx0PCEtLSBUYWJzIC0tPlxcblxcdDxkaXYgY2xhc3M9XFxcImNvbC1tZC0zXFxcIj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJwYW5lbCBwYW5lbC1kZWZhdWx0IHBhbmVsLWZsdXNoXFxcIj5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIj5cXG5cXHRcXHRcXHRcXHRPbSBvc3NcXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJhcHAtdGFic1xcXCI+XFxuXFx0XFx0XFx0XFx0XFx0PHVsIGNsYXNzPVxcXCJuYXYgYXBwLXRhYnMtc3RhY2tlZFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PGxpPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxhIHYtbGluaz1cXFwieyBwYXRoOiAnL29tL29tJyB9XFxcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtYnRuIGZhLWZ3IGZhLWluZm9cXFwiPjwvaT4mbmJzcDtBbHRlcm5hdGl2ZXRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2E+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9saT5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8bGk+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGEgdi1saW5rPVxcXCJ7IHBhdGg6ICcvb20va29udGFrdCcgfVxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGkgY2xhc3M9XFxcImZhIGZhLWJ0biBmYS1mdyBmYS1lbnZlbG9wZVxcXCI+PC9pPiZuYnNwO0tvbnRha3RcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2E+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9saT5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8bGk+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGEgdi1saW5rPVxcXCJ7IHBhdGg6ICcvb20vZm9saycgfVxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGkgY2xhc3M9XFxcImZhIGZhLWJ0biBmYS1mdyBmYS11c2Vyc1xcXCI+PC9pPiZuYnNwO0ZvbGtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2E+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9saT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIHYtbGluaz1cXFwieyBwYXRoOiAnL29tL29yZ2FuaXNhc2pvbicgfVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtYnRuIGZhLWZ3IGZhLWNsb3VkXFxcIj48L2k+Jm5ic3A7T3JnYW5pc2Fzam9uXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxcblxcdFxcdFxcdFxcdFxcdDwvdWw+XFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0PC9kaXY+XFxuXFx0PC9kaXY+XFxuXFx0PCEtLSBUYWIgUGFuZXMgLS0+XFxuXFx0PGRpdiBjbGFzcz1cXFwiY29sLW1kLTlcXFwiPlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcInRhYi1jb250ZW50XFxcIj5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJ0YWItcGFuZVxcXCI+XFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwicGFuZWwgcGFuZWwtZGVmYXVsdFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0PHJvdXRlci12aWV3Pjwvcm91dGVyLXZpZXc+XFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0PC9kaXY+PCEtLSBFbmQgdGFiIHBhbmVsIC0tPlxcblxcdFxcdDwvZGl2PjwhLS0gRW5kIHRhYiBjb250ZW50IC0tPlxcblxcdDwvZGl2PjwhLS0gRW5kIHRhYiBwYW5lcyBjb2wtbWQtOSAtLT5cXG48L2Rpdj48IS0tIEVuZCBjb250YWluZXIgLS0+XFxuPGZvb3Rlci1jb21wb25lbnQ+PC9mb290ZXItY29tcG9uZW50PlxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9sdmEvU2l0ZXMvYWx0ZXJuYXRpdmV0L3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvb20udnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIj5cXG4gICAgRm9sa1xcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiPlxcbiAgICA8cCBjbGFzcz1cXFwibGVhZFxcXCI+XFxuICAgICAgICBIZXIgZXIgbm9lbiBhdiBtZWRsZW1tZW5lIGkgQWx0ZXJuYXRpdmV0LlxcbiAgICA8L3A+XFxuPC9kaXY+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL2x2YS9TaXRlcy9hbHRlcm5hdGl2ZXQvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9vbS9mb2xrLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPCEtLVxcblxcdEB0b2RvIExhZyDCq2F2dGFsIGVuIGRhdGXCuy1rbmFwcCBww6Uga29udGFrdHBlcnNvbmVyXFxuLS0+XFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZ1xcXCI+XFxuXFx0S29udGFrdFxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiPlxcblxcdDxwIGNsYXNzPVxcXCJsZWFkXFxcIj5cXG5cXHRcXHRUYSBrb250YWt0IG1lZCBvc3Mgb20gZHUgbHVyZXIgcMOlIG5vZSBvbSBBbHRlcm5hdGl2ZXQsIGVudGVuIGRldCBnamVsZGVyIHBvbGl0aWtrdXR2aWtsaW5nZW4sIG9yZ2FuaXNhc2pvbmVuLFxcblxcdFxcdG5ldHRwbGF0dGZvcm1lbmUsIG1lZGxlbXNrYXBldCBkaXR0IGVsbGVyIG5vZSBoZWx0IGFubmV0IDogKVxcblxcdDwvcD5cXG5cXHQ8aDM+TWVkbGVtc3NlcnZpY2U8L2gzPlxcblxcdDxwPlxcblxcdFxcdFNww7hyc23DpWwgb20gbWVkbGVtc2thcDo8YnI+XFxuXFx0XFx0PGEgaHJlZj1cXFwibWFpbHRvOm1lZGxlbUBhbHRlcm5hdGl2ZXQucGFydHlcXFwiPm1lZGxlbUBhbHRlcm5hdGl2ZXQucGFydHk8L2E+PGJyPlxcblxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1waG9uZVxcXCI+PC9pPiA5MzIgOTAgNTY3XFxuXFx0PC9wPlxcblxcdDxoMz5Lb250YWt0cGVyc29uZXI8L2gzPlxcblxcdDxwPlxcblxcdFxcdDxzdHJvbmc+PGEgaHJlZj1cXFwibWFpbHRvOmthc2JzY2hqQGdtYWlsLmNvbVxcXCI+S2F5IEFzYmrDuHJuIEtudXRzZW4gU2NoasO4cmxpZW48L2E+PC9zdHJvbmc+PGJyPlxcblxcdFxcdExlZGVyPGJyPlxcblxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1waG9uZVxcXCI+PC9pPiA5NzQgNzIgNzAwXFxuXFx0PC9wPlxcblxcdDxwPlxcblxcdFxcdDxzdHJvbmc+PGEgaHJlZj1cXFwibWFpbHRvOm1hcmlhbm5lLmdyb3R0ZUBhbHRlcm5hdGl2ZXQucGFydHlcXFwiPk1hcmlhbm5lIEdyw7h0dGU8L2E+PC9zdHJvbmc+PGJyPlxcblxcdFxcdExlZGVyPGJyPlxcblxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1waG9uZVxcXCI+PC9pPiA5ODggMTEgMTg4XFxuXFx0PC9wPlxcblxcdDxwPlxcblxcdFxcdDxzdHJvbmc+PGEgaHJlZj1cXFwibWFpbHRvOm1vaGFtZWRhbGlAaG90bWFpbC5ub1xcXCI+TW9oYW1lZCBBbGkgUmFzaGlkPC9hPjwvc3Ryb25nPjxicj5cXG5cXHRcXHRNZWRsZW1zLSBvZyBmcml2aWxsaWdrb250YWt0PGJyPlxcblxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1waG9uZVxcXCI+PC9pPiA5MzIgOTAgNTY3XFxuXFx0PC9wPlxcblxcdDxwPlxcblxcdFxcdDxzdHJvbmc+PGEgaHJlZj1cXFwibWFpbHRvOmxlb0BhbHRlcm5hdGl2ZXQucGFydHlcXFwiPkxlbyBWYWxlbjwvYT48L3N0cm9uZz48YnI+XFxuXFx0XFx0S29tbXVuaWthc2pvbiBvZyBuZXR0cGxhdHRmb3JtZXI8YnI+XFxuXFx0XFx0PGkgY2xhc3M9XFxcImZhIGZhLXBob25lXFxcIj48L2k+IDQ2NiA2NSAzMzMgKDA3OjAwLTA4OjMwIG9nIDE3OjMwLTIxOjAwKVxcblxcdDwvcD5cXG5cXHQ8aDM+UG9zdGFkcmVzc2U8L2gzPlxcblxcdDxwPlxcblxcdFxcdFRpbmcgc29tIG3DpSBzZW5kZXMgcMOlIHBvc3QgKGJsLiBhLiBlcmtsw6ZyaW5nZXIgb20gcmVnaXN0cmVyaW5nIGF2IEFsdGVybmF0aXZldCBpIHBhcnRpcmVnaXN0ZXJldCk8YnI+a2FuIHNlbmRlcyB0aWw6PGJyPlxcblxcdFxcdDwvcD48YWRkcmVzcz5cXG5cXHRcXHRcXHRBbHRlcm5hdGl2ZXQ8YnI+XFxuXFx0XFx0XFx0Yy9vIExlbyBWYWxlbjxicj5cXG5cXHRcXHRcXHRUdXJiaW52ZWllbiAxPGJyPlxcblxcdFxcdFxcdDAxOTUmbmJzcDsmbmJzcDtPU0xPXFxuXFx0XFx0PC9hZGRyZXNzPlxcblxcdDxwPjwvcD5cXG5cXHQ8aDM+QmFuayBvZyByZWdpc3RyZTwvaDM+XFxuXFx0PHA+XFxuXFx0XFx0T3JnYW5pc2Fzam9uc251bW1lcjogPGEgaHJlZj1cXFwiaHR0cHM6Ly93Mi5icnJlZy5uby9lbmhldC9zb2svZGV0YWxqLmpzcD9vcmducj05MTY0ODM1MTFcXFwiPjkxNiA0ODMgNTExPC9hPjxicj5cXG5cXHRcXHRCYW5ra29udG86IDEyNTQuNjIuMjk5MzdcXG5cXHQ8L3A+XFxuPC9kaXY+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL2x2YS9TaXRlcy9hbHRlcm5hdGl2ZXQvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9vbS9rb250YWt0LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZ1xcXCI+XFxuXFx0QWx0ZXJuYXRpdmV0XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFxuXFx0PHAgY2xhc3M9XFxcImxlYWRcXFwiPlxcblxcdFxcdEFsdGVybmF0aXZldCBoYXIgdGlsIGZvcm3DpWwgw6Ugc2thcGUgZW4gbnkgcG9saXRpc2sga3VsdHVyIHNvbSBnasO4ciBzYW1mdW5uZXQgaSBzdGFuZCB0aWwgw6UgbcO4dGVcXG5cXHRcXHRrcmlzZW5lIHZpIHN0w6VyIG92ZXJmb3IuXFxuXFx0PC9wPlxcblxcdDxwPlxcblxcdFxcdERldCBza2FsIHZpIGdqw7hyZSBtZWQgbW90LCDDpXBlbmhldCwgaHVtb3IsIGVtcGF0aSwgcmF1c2hldCBvZyB5ZG15a2hldC5cXG5cXHQ8L3A+XFxuPC9kaXY+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL2x2YS9TaXRlcy9hbHRlcm5hdGl2ZXQvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9vbS9vbS52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCI7KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWhlYWRpbmdcXFwiPlxcbiAgICBPcmdhbmlzYXNqb25cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIj5cXG4gICAgPHAgY2xhc3M9XFxcImxlYWRcXFwiPlxcbiAgICAgICAgQWx0ZXJuYXRpdmV0IGJsZSBzdGlmdGV0IDE0LiBkZXNlbWJlciAyMDE1IHNvbSBlbiBwb2xpdGlzayBvcmdhbmlzYXNqb24gZm9yIMOlIG3DuHRlIGtyaXNlbmVcXG4gICAgICAgIHNhbWZ1bm5ldCBzdMOlciBvdmVyZm9yLiBEZXQgc2thbCB2aSBnasO4cmUgbWVkIGtqZXJuZXZlcmRpZW5lIG1vdCwgw6VwZW5oZXQsIGh1bW9yLCBlbXBhdGksIHJhdXNoZXQgb2cgeWRteWtoZXQuXFxuICAgIDwvcD5cXG5cXG4gICAgPHA+XFxuICAgICAgICBBbHRlcm5hdGl2ZXRzIDxhIGhyZWY9XFxcIi8jIS9tYW5pZmVzdFxcXCI+bWFuaWZlc3Q8L2E+LFxcbiAgICAgICAga2plcm5ldmVyZGllbmUgb2cgPGEgaHJlZj1cXFwiaHR0cDovL3d3dy5mbi5uby9UZW1hL0ZOcy1iYWVyZWtyYWZ0c21hYWxcXFwiPkZOcyBiw6ZyZWtyYWZ0c23DpWw8L2E+IGRhbm5lciBncnVubmxhZ2V0XFxuICAgICAgICBmb3IgQWx0ZXJuYXRpdmV0cyBwb2xpdGlra3V0dmlrbGluZy4gQWx0ZXJuYXRpdmV0cyBvcmdhbmlzZXJpbmcgZXIgZmFzdHNhdHQgaSA8YSBocmVmPVxcXCJodHRwczovL2Rva3VtZW50ZXIuYWx0ZXJuYXRpdmV0LmlvL1ZlZHRla3Rlci5wZGZcXFwiPnZlZHRla3RlbmU8L2E+LlxcbiAgICA8L3A+XFxuXFxuICAgIDxoMz5MYW5kc23DuHRldDwvaDM+XFxuICAgIDxwPlxcbiAgICAgICAgTGFuZHNtw7h0ZXQgZXIgQWx0ZXJuYXRpdmV0cyBow7h5ZXN0ZSBteW5kaWdoZXQgb2cgdHJlZmZlciBiZXNsdXRuaW5nZXIga29udGludWVybGlnIGdqZW5ub20gcGFydGlldHMgbmV0dGJhc2VydGUgcGxhdHRmb3JtZXIuXFxuICAgICAgICBBbGxlIG1lZGxlbW1lciBoYXIgZm9yc2xhZ3NyZXR0LCB0YWxlcmV0dCBvZyBzdGVtbWVyZXR0IGkgbGFuZHNtw7h0ZXQuXFxuICAgIDwvcD5cXG4gICAgPHA+XFxuICAgICAgICBJIHRpbGxlZ2cgdGlsIGzDuHBlbmRlIHNha2VyLCBza2FsIGxhbmRzbcO4dGV0IMOlcmxpZyBiZWhhbmRsZSBwYXJ0aWV0cyDDpXJzbWVsZGluZywgcmVnbnNrYXAgb2cgYnVkc2pldHQsXFxuICAgICAgICB2ZWxnZSBob3ZlZHN0eXJlIG9nIHJldmlzb3IsIG9nIGJlaGFuZGxlIGVuZHJpbmdlciBhdiB2ZWR0ZWt0ZW5lLlxcbiAgICA8L3A+XFxuICAgIDxoMz5Ib3ZlZHN0eXJldDwvaDM+XFxuICAgIDxwPlxcbiAgICAgICAgSG92ZWRzdHlyZXQgZXIgQWx0ZXJuYXRpdmV0cyB1dMO4dmVuZGUgb3JnYW4sIG9nIGhhciBhbnN2YXIgZm9yIMOlIGl2ZXJrc2V0dGUgbGFuZHNtw7h0ZXRzIHZlZHRhay5cXG4gICAgPC9wPlxcbiAgICA8cD5cXG4gICAgICAgIEhvdmVkc3R5cmV0IGVyIHBlciBpZGFnIGV0IG1pZGxlcnRpZGlnIHN0eXJlIChpbnRlcmltc3R5cmUpIHNvbSBibGUgdmFsZ3QgdmVkIHN0aWZ0aW5nZW4gYXYgQWx0ZXJuYXRpdmV0Ljxicj5cXG4gICAgICAgIERldCBza2FsIHZlbGdlcyBueXR0IHN0eXJlIGlubmVuIDMxLiBtYXJzIDIwMTYuXFxuICAgIDwvcD5cXG4gICAgPHA+XFxuICAgICAgICA8c3Ryb25nPkhvdmVkc3R5cmV0cyBzYW1tZW5zZXRuaW5nOjwvc3Ryb25nPlxcbiAgICA8L3A+XFxuICAgIDx1bD5cXG4gICAgICAgIDxsaT5NYXJpYW5uZSBHcsO4dHRlIChsZWRlcik8L2xpPlxcbiAgICAgICAgPGxpPktheSBBc2Jqw7hybiBLbnV0c2VuIFNjaGrDuHJsaWVuIChsZWRlcik8L2xpPlxcbiAgICAgICAgPGxpPk9sYSBCcmFhZGxhbmQ8L2xpPlxcbiAgICAgICAgPGxpPkluZ3JpZCBLdmFtbWUgRnJlZHJpa3NlbjwvbGk+XFxuICAgICAgICA8bGk+TW9uYSBOZXNqZTwvbGk+XFxuICAgICAgICA8bGk+TWFyaSBNYWHDuCBOaWxzc2VuPC9saT5cXG4gICAgICAgIDxsaT5Nb2hhbWVkIEFsaSBSYXNoaWQ8L2xpPlxcbiAgICAgICAgPGxpPkxlbyBWYWxlbjwvbGk+XFxuICAgIDwvdWw+XFxuXFxuICAgIDxoMz5Mb2thbGxhZzwvaDM+XFxuICAgIDxwPkxva2FsbGFnZW5lIHV0Zm9ybWVyIGtvbW11bmUtIG9nIGJ5ZGVsc3BvbGl0aWtrZW4uPC9wPlxcbiAgICA8cD5EZXIgQWx0ZXJuYXRpdmV0IG9wcG7DpXIgcmVwcmVzZW50YXNqb24gaSBkZSBmb2xrZXZhbGd0ZSBvcmdhbmVuZSwgaGFyIGxva2FsbGFnZXQgYW5zdmFyIGZvciDDpSBmw7hsZ2Ugb3BwIHJlcHJlc2VudGFudGVyIGkga29tbXVuZXN0eXJlciwgYnlkZWxzdXR2dmFsZyBvZyBhbmRyZSBwb2xpdGlzayB1dG5ldm50ZSB2ZXJ2LjwvcD5cXG4gICAgPHA+QWx0ZXJuYXRpdmV0IGhhciBsb2thbGxhZyB1bmRlciBldGFibGVyaW5nIGkgR2FtbGUgT3NsbywgU3RhdmFuZ2VyLCBCb2TDuCBvZyBTw7hyLVZhcmFuZ2VyLjwvcD5cXG5cXG4gICAgPGgzPkZ5bGtlc2xhZzwvaDM+XFxuICAgIDxwPkZ5bGtlc2xhZ2VuZSBrb29yZGluZXJlciBsb2thbGxhZ2VuZSBvZyB1dGZvcm1lciBmeWxrZXNwb2xpdGlra2VuLjwvcD5cXG4gICAgPHA+RGVyIEFsdGVybmF0aXZldCBvcHBuw6VyIHJlcHJlc2VudGFzam9uIGkgZGUgZm9sa2V2YWxndGUgb3JnYW5lbmUsIGhhciBmeWxrZXNsYWdldCBhbnN2YXIgZm9yIMOlIGbDuGxnZSBvcHAgcmVwcmVzZW50YW50ZXIgaSBmeWxrZXN0aW5nZXQgb2cgZnlsa2V0cyByZXByZXNlbnRhbnRlciBpIFN0b3J0aW5nZXQuPC9wPlxcbiAgICA8cD5BbHRlcm5hdGl2ZXQgaGFyIGZ5bGtlc2xhZyB1bmRlciBldGFibGVyaW5nIGkgT3NsbywgUm9nYWxhbmQgb2cgTm9yZGxhbmQuPC9wPlxcbjwvZGl2PlxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9sdmEvU2l0ZXMvYWx0ZXJuYXRpdmV0L3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvb20vb3JnYW5pc2Fzam9uLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyIHBsYWNlaG9sZGVyXFxcIj5cXG4gICAgPGltZyBzcmM9XFxcIi9pbWFnZXMvYWx0ZXJuYXRpdmV0LXBsYWNlaG9sZGVyLnBuZ1xcXCIgYWx0PVxcXCJBbHRlcm5hdGl2ZXRcXFwiIHdpZHRoPVxcXCIyNTBcXFwiPlxcbiAgICA8cD5cXG4gICAgICAgIEFsdGVybmF0aXZldCBlciBlbiBwbGF0dGZvcm0gZm9yIMOlIHNrYXBlIGVuIG55IGludm9sdmVyZW5kZSBwb2xpdGlzayBrdWx0dXIuPGJyPlxcbiAgICAgICAgRGV0IHNrYWwgdmkgZ2rDuHJlIG1lZCBtb3QsIMOlcGVuaGV0LCBodW1vciwgZW1wYXRpLCByYXVzaGV0IG9nIHlkbXlraGV0LlxcbiAgICA8L3A+XFxuICAgIDxwIGNsYXNzPVxcXCJhZGRpdGlvbmFsXFxcIj5cXG4gICAgICAgIElubnRpbCB2aWRlcmUgc2tqZXIgZGV0IG1lc3RlIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZhY2Vib29rLmNvbS9ncm91cHMvNTI4MTE0Mzk0MDEwMDQzL1xcXCI+cMOlIGZhY2Vib29rPC9hPi48YnI+XFxuICAgICAgICBBbGxlIGVyIHZlbGtvbW1lbiBpIGdydXBwYSwgaW5nZW4gZm9ycGxpa3RlbHNlci5cXG4gICAgPC9wPlxcbiAgICA8cCBjbGFzcz1cXFwiYWRkaXRpb25hbFxcXCI+XFxuICAgICAgICBEdSBrYW4gb2dzw6Uga29udGFrdGUgb3NzIDxhIGhyZWY9XFxcIm1haWx0bzpwb3N0QGFsdGVybmF0aXZldC5pb1xcXCI+cMOlIGVwb3N0PC9hPiBlbGxlciB0ZWxlZm9uOlxcbiAgICAgICAgS2F5IEFzYmrDuHJuIFNjaGrDuHJsaWVuLCA5NzQgNzIgNzAwLiBNYXJpYW5uZSBHcsO4dHRlLCA5ODggMTEgMTg4Ljxicj5cXG4gICAgICAgIE1hcmkgTWFhw7ggTmlsc3NlbiwgOTEwIDAwIDUzMy4gTW9oYW1lZCBBbGkgUmFzaGlkLCA5MzIgOTAgNTY3LiBMZW8gVmFsZW4sIDQ2NiA2NSA1MzMuXFxuICAgIDwvcD5cXG4gICAgPHA+XFxuICAgICAgICA8Yj48YSBocmVmPVxcXCJodHRwczovL2Rva3VtZW50ZXIuYWx0ZXJuYXRpdmV0LmlvL01hbmlmZXN0LnBkZlxcXCI+QWx0ZXJuYXRpdmV0cyBtYW5pZmVzdCA8aSBjbGFzcz1cXFwiZmEgZmEtY2FyZXQtcmlnaHRcXFwiPjwvaT48L2E+PC9iPlxcbiAgICA8L3A+XFxuPC9kaXY+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL2x2YS9TaXRlcy9hbHRlcm5hdGl2ZXQvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9wbGFjZWhvbGRlci52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXI6IHtcbiAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgYmlydGhfZGF0ZTogbnVsbCxcbiAgICAgICAgcG9zdGFsX2NvZGU6IG51bGwsXG4gICAgICAgIGVtYWlsOiBudWxsLFxuICAgICAgICBwYXNzd29yZDogbnVsbCxcbiAgICAgICAgcGFzc3dvcmRfY29uZmlybWF0aW9uOiBudWxsXG4gICAgICB9LFxuICAgICAgbWVzc2FnZXM6IFtdXG4gICAgfTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgcmVnaXN0ZXJVc2VyOiBmdW5jdGlvbiByZWdpc3RlclVzZXIoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICBjbGllbnQoeyBwYXRoOiAnL3JlZ2lzdGVyJywgZW50aXR5OiB0aGlzLnVzZXIgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdGhhdC5nZXRVc2VyRGF0YSgpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlc3BvbnNlLCBzdGF0dXMpIHtcbiAgICAgICAgdGhhdC5tZXNzYWdlcyA9IFtdO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICYmIHJlc3BvbnNlLnN0YXR1cy5jb2RlID09PSA0MjIpIHtcbiAgICAgICAgICB0aGF0Lm1lc3NhZ2VzID0gW107XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHJlc3BvbnNlLmVudGl0eSkge1xuICAgICAgICAgICAgdGhhdC5tZXNzYWdlcy5wdXNoKHsgdHlwZTogJ2RhbmdlcicsIG1lc3NhZ2U6IHJlc3BvbnNlLmVudGl0eVtrZXldIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGdldFVzZXJEYXRhOiBmdW5jdGlvbiBnZXRVc2VyRGF0YSgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIGNsaWVudCh7IHBhdGg6ICcvdXNlcnMvbWUnIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHRoYXQuJGRpc3BhdGNoKCd1c2VySGFzTG9nZ2VkSW4nLCByZXNwb25zZS5lbnRpdHkudXNlcik7XG4gICAgICAgIHRoYXQuJHJvdXRlLnJvdXRlci5nbygnL2F1dGgvcHJvZmlsZScpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48bmF2LWNvbXBvbmVudD48L25hdi1jb21wb25lbnQ+XFxuPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyIGFwcC1zY3JlZW5cXFwiPlxcblxcblxcdDxmb3JtIGNsYXNzPVxcXCJmb3JtLWhvcml6b250YWxcXFwiIHJvbGU9XFxcImZvcm1cXFwiIHYtb246c3VibWl0PVxcXCJyZWdpc3RlclVzZXJcXFwiPlxcblxcblxcdFxcdDxkaXYgaWQ9XFxcImFsZXJ0c1xcXCIgdi1pZj1cXFwibWVzc2FnZXMubGVuZ3RoID4gMFxcXCI+XFxuXFx0XFx0XFx0PGRpdiB2LWZvcj1cXFwibWVzc2FnZSBpbiBtZXNzYWdlc1xcXCIgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LXt7IG1lc3NhZ2UudHlwZSB9fSBhbGVydC1kaXNtaXNzaWJsZVxcXCIgcm9sZT1cXFwiYWxlcnRcXFwiPlxcblxcdFxcdFxcdFxcdHt7IG1lc3NhZ2UubWVzc2FnZSB9fVxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdDwvZGl2PlxcblxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcblxcdFxcdFxcdDxsYWJlbCBjbGFzcz1cXFwiY29sLW1kLTQgY29udHJvbC1sYWJlbFxcXCI+Rm9ybmF2biBvZyBldHRlcm5hdm48L2xhYmVsPlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbC1tZC02XFxcIj5cXG5cXHRcXHRcXHRcXHQ8aW5wdXQgdHlwZT1cXFwibmFtZVxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdi1tb2RlbD1cXFwidXNlci5uYW1lXFxcIj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHRcXHQ8bGFiZWwgY2xhc3M9XFxcImNvbC1tZC00IGNvbnRyb2wtbGFiZWxcXFwiPkbDuGRzZWxzZGF0bzwvbGFiZWw+XFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLW1kLTZcXFwiPlxcblxcdFxcdFxcdFxcdDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiB2LW1vZGVsPVxcXCJ1c2VyLmJpcnRoX2RhdGVcXFwiPlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdDwvZGl2PlxcblxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcblxcdFxcdFxcdDxsYWJlbCBjbGFzcz1cXFwiY29sLW1kLTQgY29udHJvbC1sYWJlbFxcXCI+UG9zdG51bW1lcjwvbGFiZWw+XFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLW1kLTZcXFwiPlxcblxcdFxcdFxcdFxcdDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiB2LW1vZGVsPVxcXCJ1c2VyLnBvc3RhbF9jb2RlXFxcIj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHRcXHQ8bGFiZWwgY2xhc3M9XFxcImNvbC1tZC00IGNvbnRyb2wtbGFiZWxcXFwiPkUtcG9zdDwvbGFiZWw+XFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLW1kLTZcXFwiPlxcblxcdFxcdFxcdFxcdDxpbnB1dCB0eXBlPVxcXCJlbWFpbFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdi1tb2RlbD1cXFwidXNlci5lbWFpbFxcXCI+XFxuXFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0PC9kaXY+XFxuXFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuXFx0XFx0XFx0PGxhYmVsIGNsYXNzPVxcXCJjb2wtbWQtNCBjb250cm9sLWxhYmVsXFxcIj5QYXNzb3JkPC9sYWJlbD5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNlxcXCI+XFxuXFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XFxcInBhc3N3b3JkXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiB2LW1vZGVsPVxcXCJ1c2VyLnBhc3N3b3JkXFxcIj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHRcXHQ8bGFiZWwgY2xhc3M9XFxcImNvbC1tZC00IGNvbnRyb2wtbGFiZWxcXFwiPkJla3JlZnQgcGFzc29yZDwvbGFiZWw+XFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLW1kLTZcXFwiPlxcblxcdFxcdFxcdFxcdDxpbnB1dCB0eXBlPVxcXCJwYXNzd29yZFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdi1tb2RlbD1cXFwidXNlci5wYXNzd29yZF9jb25maXJtYXRpb25cXFwiPlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdDwvZGl2PlxcblxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbC1tZC02IGNvbC1tZC1vZmZzZXQtNFxcXCI+XFxuXFx0XFx0XFx0XFx0PGJ1dHRvbiB0eXBlPVxcXCJzdWJtaXRcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnlcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1idG4gZmEtc2lnbi1pblxcXCI+PC9pPiBTZW5kIGlubm1lbGRpbmdcXG5cXHRcXHRcXHRcXHQ8L2J1dHRvbj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXHQ8L2Zvcm0+XFxuXFxuPC9kaXY+PCEtLSBFbmQgY29udGFpbmVyIC0tPlxcbjxmb290ZXItY29tcG9uZW50PjwvZm9vdGVyLWNvbXBvbmVudD5cXG5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvbHZhL1NpdGVzL2FsdGVybmF0aXZldC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL3JlZ2lzdGVyLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPG5hdi1jb21wb25lbnQ+PC9uYXYtY29tcG9uZW50PlxcblxcbjxkaXYgY2xhc3M9XFxcImNvbnRhaW5lciBhcHAtc2NyZWVuXFxcIj5cXG5cXHQ8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcInRhYi1jb250ZW50XFxcIj5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJ0YWItcGFuZVxcXCI+XFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwicGFuZWwgcGFuZWwtZGVmYXVsdFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZ1xcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0VGVybXMgb2Ygc2VydmljZVxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdDwhLS0gUHJvZmlsZSBTZWxlY3Rpb24gbm90aWNlIHBhbmVsIC0tPlxcblxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiPlxcbjxwcmU+VGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuXFxuQ29weXJpZ2h0IChjKSAyMDE1IFlvdXJuYW1lXFxuXFxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsXFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcblxcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxcbmNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuXFxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxcblNPRlRXQVJFLlxcbjwvcHJlPlxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdDwvZGl2PjwhLS0gRW5kIHRhYiBwYW5lbCAtLT5cXG5cXHRcXHQ8L2Rpdj48IS0tIEVuZCB0YWIgY29udGVudCAtLT5cXG5cXHQ8L2Rpdj48IS0tIEVuZCB0YWIgcGFuZXMgY29sLW1kLTkgLS0+XFxuPC9kaXY+PCEtLSBFbmQgY29udGFpbmVyIC0tPlxcblxcbjxmb290ZXItY29tcG9uZW50PjwvZm9vdGVyLWNvbXBvbmVudD5cXG5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvbHZhL1NpdGVzL2FsdGVybmF0aXZldC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL3Rlcm1zLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsInZhciBjb25maWcgPSB7XG4gIGVudjogJ2RldmVsb3BtZW50JyxcbiAgYXBpOiB7XG4gICAgYmFzZV91cmw6ICdodHRwOi8vYXBpLmRldmVsb3BtZW50LmFsdGVybmF0aXZldC5pbycsXG4gICAgZGVmYXVsdFJlcXVlc3Q6IHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ1gtUmVxdWVzdGVkLVdpdGgnOiAncmVzdC5qcycsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNvY2lhbDoge1xuICAgIGZhY2Vib29rOiAnJyxcbiAgICB0d2l0dGVyOiAnJyxcbiAgICBnaXRodWI6ICcnXG4gIH0sXG4gIGRlYnVnOiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uZmlnXG4iLCJ2YXIgZW52ID0gcHJvY2Vzcy5lbnYuQVBQX0VOViB8fCAnZGV2ZWxvcG1lbnQnXG5cbnZhciBjb25maWcgPSB7XG4gIGRldmVsb3BtZW50OiByZXF1aXJlKCcuL2RldmVsb3BtZW50LmNvbmZpZycpLFxuICBwcm9kdWN0aW9uOiByZXF1aXJlKCcuL3Byb2R1Y3Rpb24uY29uZmlnJyksXG4gIHN0YWdpbmc6IHJlcXVpcmUoJy4vc3RhZ2luZy5jb25maWcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmZpZ1tlbnZdXG4iLCJ2YXIgY29uZmlnID0ge1xuICBlbnY6ICdwcm9kdWN0aW9uJyxcbiAgYXBpOiB7XG4gICAgYmFzZV91cmw6ICdodHRwczovL2FwaS5hbHRlcm5hdGl2ZXQuaW8nLFxuICAgIGRlZmF1bHRSZXF1ZXN0OiB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdYLVJlcXVlc3RlZC1XaXRoJzogJ3Jlc3QuanMnLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzb2NpYWw6IHtcbiAgICBmYWNlYm9vazogJycsXG4gICAgdHdpdHRlcjogJycsXG4gICAgZ2l0aHViOiAnJ1xuICB9LFxuICBkZWJ1ZzogZmFsc2Vcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25maWdcbiIsInZhciBjb25maWcgPSB7XG4gIGVudjogJ3N0YWdpbmcnLFxuICBhcGk6IHtcbiAgICBiYXNlX3VybDogJ2h0dHBzOi8vYXBpLnN0YWdpbmcuYWx0ZXJuYXRpdmV0LmlvJyxcbiAgICBkZWZhdWx0UmVxdWVzdDoge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdyZXN0LmpzJyxcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc29jaWFsOiB7XG4gICAgZmFjZWJvb2s6ICcnLFxuICAgIHR3aXR0ZXI6ICcnLFxuICAgIGdpdGh1YjogJydcbiAgfSxcbiAgZGVidWc6IHRydWVcbn1cbm1vZHVsZS5leHBvcnRzID0gY29uZmlnXG4iLCIoZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0XHR2YXIgaW50ZXJjZXB0b3I7XG5cblx0XHRpbnRlcmNlcHRvciA9IHJlcXVpcmUoJ3Jlc3QvaW50ZXJjZXB0b3InKTtcblxuXHRcdC8qKlxuXHRcdCAqIEF1dGhlbnRpY2F0ZXMgdGhlIHJlcXVlc3QgdXNpbmcgSldUIEF1dGhlbnRpY2F0aW9uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0NsaWVudH0gW2NsaWVudF0gY2xpZW50IHRvIHdyYXBcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7Q2xpZW50fVxuXHRcdCAqL1xuXHRcdHJldHVybiBpbnRlcmNlcHRvcih7XG5cdFx0XHRyZXF1ZXN0OiBmdW5jdGlvbiAocmVxdWVzdCwgY29uZmlnKSB7XG5cdFx0XHRcdHZhciB0b2tlbiwgaGVhZGVycztcblxuXHRcdFx0XHR0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdqd3QtdG9rZW4nKTtcblx0XHRcdFx0aGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycyB8fCAocmVxdWVzdC5oZWFkZXJzID0ge30pO1xuXG5cdFx0XHRcdGlmICggdG9rZW4gIT09IG51bGwgJiYgdG9rZW4gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0aGVhZGVycy5BdXRob3JpemF0aW9uID0gdG9rZW47XG5cdFx0XHRcdH1cblxuXHRcdCAgICBcdHJldHVybiByZXF1ZXN0O1xuXHRcdFx0fSxcblx0XHRcdHJlc3BvbnNlOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyAmJiByZXNwb25zZS5zdGF0dXMuY29kZSA9PSA0MDEpIHtcblx0XHRcdFx0XHRsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnand0LXRva2VuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3BvbnNlLmhlYWRlcnMgJiYgcmVzcG9uc2UuaGVhZGVycy5BdXRob3JpemF0aW9uKSB7XG5cdFx0XHRcdFx0bG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2p3dC10b2tlbicsIHJlc3BvbnNlLmhlYWRlcnMuQXV0aG9yaXphdGlvbilcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzcG9uc2UuZW50aXR5ICYmIHJlc3BvbnNlLmVudGl0eS50b2tlbiAmJiByZXNwb25zZS5lbnRpdHkudG9rZW4ubGVuZ3RoID4gMTApIHtcblx0XHRcdFx0XHRsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnand0LXRva2VuJywgJ0JlYXJlciAnICsgcmVzcG9uc2UuZW50aXR5LnRva2VuKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICBjb25maWdSb3V0ZXI6IGZ1bmN0aW9uIChyb3V0ZXIpIHtcblxuICAgIHJvdXRlci5tYXAoe1xuICAgICAgJy9hdXRoJzoge1xuICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvYXV0aC52dWUnKSxcbiAgICAgICAgc3ViUm91dGVzOiB7XG4gICAgICAgICAgJy9wcm9maWxlJzoge1xuICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL2F1dGgvcHJvZmlsZS52dWUnKSxcbiAgICAgICAgICAgIGF1dGg6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgICcvbG9nb3V0Jzoge1xuICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL2F1dGgvbG9nb3V0LnZ1ZScpLFxuICAgICAgICAgICAgYXV0aDogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICcvb20nOiB7XG4gICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9vbS52dWUnKSxcbiAgICAgICAgc3ViUm91dGVzOiB7XG4gICAgICAgICAgJy8nOiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvb20vb20udnVlJylcbiAgICAgICAgICB9LFxuICAgICAgICAgICAgJy9vbSc6IHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvb20vb20udnVlJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgJy9rb250YWt0Jzoge1xuICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL29tL2tvbnRha3QudnVlJylcbiAgICAgICAgICB9LFxuICAgICAgICAgICcvZm9sayc6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9vbS9mb2xrLnZ1ZScpXG4gICAgICAgICAgfSxcbiAgICAgICAgICAgICcvb3JnYW5pc2Fzam9uJzoge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9vbS9vcmdhbmlzYXNqb24udnVlJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnL2RvZ3MnOiB7XG4gICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9kb2dzLnZ1ZScpLFxuICAgICAgICBhdXRoOiB0cnVlLFxuICAgICAgICBzdWJSb3V0ZXM6IHtcbiAgICAgICAgICAnLyc6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9kb2dzL2luZGV4LnZ1ZScpXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnLzppZCc6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9kb2dzL3Nob3cudnVlJylcbiAgICAgICAgICB9LFxuICAgICAgICAgICcvY3JlYXRlJzoge1xuICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL2RvZ3MvY3JlYXRlLnZ1ZScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJy9sb2dpbic6IHtcbiAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL2xvZ2luLnZ1ZScpLFxuICAgICAgICBndWVzdDogdHJ1ZVxuICAgICAgfSxcbiAgICAgICAgJy9yZWdpc3Rlcic6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9yZWdpc3Rlci52dWUnKSxcbiAgICAgICAgICAgIGd1ZXN0OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAnL21hbmlmZXN0Jzoge1xuICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvbWFuaWZlc3QudnVlJylcbiAgICAgIH0sXG4gICAgICAnL3Rlcm1zJzoge1xuICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvdGVybXMudnVlJylcbiAgICAgIH0sXG4gICAgICAnL3BsYWNlaG9sZGVyJzoge1xuICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvcGxhY2Vob2xkZXIudnVlJylcbiAgICAgIH0sXG4gICAgICAnL2hvbWUnOiB7XG4gICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9ob21lLnZ1ZScpXG4gICAgICB9LFxuICAgICAgJyonOiB7XG4gICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy80MDQudnVlJylcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcm91dGVyLmFsaWFzKHtcbiAgICAgICcnOiAnL2hvbWUnLFxuICAgICAgJy9hdXRoJzogJy9sb2dpbidcbiAgICB9KVxuXG4gICAgcm91dGVyLmJlZm9yZUVhY2goZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcblxuICAgICAgdmFyIHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2p3dC10b2tlbicpXG4gICAgICBpZiAodHJhbnNpdGlvbi50by5hdXRoKSB7XG4gICAgICAgIGlmICghdG9rZW4gfHwgdG9rZW4gPT09IG51bGwpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uLnJlZGlyZWN0KCcvYXV0aC9sb2dpbicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2l0aW9uLnRvLmd1ZXN0KSB7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIHRyYW5zaXRpb24ucmVkaXJlY3QoJy8nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmFuc2l0aW9uLm5leHQoKVxuICAgIH0pXG4gIH1cbn1cbiJdfQ==\n"],"file":"app.js","sourceRoot":"/source/"}